# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/title-page.md "Suggest an edit")

_By the Cairo Community and its [contributors](https://github.com/cairo-book/cairo-book.github.io). Special thanks to [StarkWare](https://starkware.co/) through [OnlyDust](https://www.onlydust.xyz/), and [Voyager](https://voyager.online/) for supporting the creation of this book._

This version of the text assumes youâ€™re using [Cairo](https://github.com/starkware-libs/cairo) [version 2.9.2](https://github.com/starkware-libs/cairo/releases) and [Starknet Foundry](https://foundry-rs.github.io/starknet-foundry/index.html) [version 0.35.1](https://github.com/foundry-rs/starknet-foundry/releases). See the [Installation](https://book.cairo-lang.org/ch01-01-installation.html) section of Chapter 1 to install or update Cairo and Starknet Foundry.

While reading this book, if you want to experiment with Cairo code and see how it compiles into Sierra (Intermediate Representation) and CASM (Cairo Assembly), you can use the [cairovm.codes](https://cairovm.codes/) playground.

This book is open source. Find a typo or want to contribute? Check out the book's [GitHub repository](https://github.com/cairo-book/cairo-book).

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1847517231.1738497919&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=471535605)

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-000.md "Suggest an edit")

The following sections contain reference material you may find useful in your
Starknet journey.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=2049401094.1738497918&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1409534474)

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-00.md "Suggest an edit")

Bagian-bagian berikut berisi materi referensi yang mungkin berguna dalam perjalanan Anda dengan Cairo.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1035045392.1738497922&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1765393643)

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-01-keywords.md "Suggest an edit")

The following list contains keywords that are reserved for current or future use by the Cairo language.

There are three keyword categories:

- strict
- loose
- reserved

There is a fourth category, which are functions from the core library. While their names are not reserved, they are not recommended to be used as names of any items to follow good practices.

* * *

These keywords can only be used in their correct contexts. They cannot be used as names of any items.

- `as` \- Rename import
- `break` \- Exit a loop immediately
- `const` \- Define constant items
- `continue` \- Continue to the next loop iteration
- `else` \- Fallback for `if` and `if let` control flow constructs
- `enum` \- Define an enumeration
- `extern` \- Function defined at the compiler level that can be compiled to CASM
- `false` \- Boolean false literal
- `fn` \- Define a function
- `if` \- Branch based on the result of a conditional expression
- `impl` \- Implement inherent or trait functionality
- `implicits` \- Special kind of function parameters that are required to perform certain actions
- `let` \- Bind a variable
- `loop` \- Loop unconditionally
- `match` \- Match a value to patterns
- `mod` \- Define a module
- `mut` \- Denote variable mutability
- `nopanic` \- Functions marked with this notation mean that the function will never panic.
- `of` \- Implement a trait
- `pub` \- Denote public visibility in items, such as struct and struct fields, enums, consts, traits and impl blocks, or modules
- `ref` \- Parameter passed implicitly returned at the end of a function
- `return` \- Return from function
- `struct` \- Define a structure
- `trait` \- Define a trait
- `true` \- Boolean true literal
- `type` \- Define a type alias
- `use` \- Bring symbols into scope
- `while` \- loop conditionally based on the result of an expression

* * *

These keywords are associated with a specific behaviour, but can also be used to define items.

- `self` \- Method subject
- `super` \- Parent module of the current module

* * *

These keywords aren't used yet, but they are reserved for future use. For now, it is possible to use them to define items, although it is highly recommended not to do so. The reasoning behind this recommendation is to make current programs forward compatible with future versions of Cairo by forbidding them to use these keywords.

- `Self`
- `do`
- `dyn`
- `for`
- `hint`
- `in`
- `macro`
- `move`
- `static_assert`
- `static`
- `try`
- `typeof`
- `unsafe`
- `where`
- `with`
- `yield`

* * *

Cairoç¼–ç¨‹è¯­è¨€æä¾›äº†ï¿½ï¿½ï¿½ä¸ªå…·æœ‰ç‰¹æ®Šç”¨é€”çš„å‡½æ•°ã€‚æˆ‘ä»¬ä¸ä¼šåœ¨æœ¬ä¹¦ä¸­ä»‹ç»æ‰€æœ‰è¿™äº›å‡½æ•°ï¼Œä½†ä¸å»ºè®®ä½¿ç”¨è¿™äº›å‡½æ•°çš„åç§°ä½œä¸ºä»»ä½•é¡¹çš„æ ‡è¯†ç¬¦ã€‚

- `assert` \- This function checks a boolean expression, and if it evaluates to false, it triggers the panic function.
- `panic` \- This function acknowledges the occurrence of an error and terminates the program.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=762301612.1738497923&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1864634516)

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/tr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-00.md "Suggest an edit")

The following sections contain reference material you may find useful in your Cairo journey.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1763538673.1738497925&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=415021571)

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch00-01-foreword.md "Suggest an edit")

Zero-knowledge proofs have emerged as a transformative technology in the blockchain space, offering solutions for both privacy and scalability challenges. Among these, STARKs (Scalable Transparent ARguments of Knowledge) stand out as a particularly powerful innovation. Unlike traditional proof systems, STARKs rely solely on collision-resistant hash functions, making them post-quantum secure and eliminating the need for trusted setups.

However, writing general-purpose programs that can generate cryptographic proofs has historically been a significant challenge. Developers needed deep expertise in cryptography and complex mathematical concepts to create verifiable computations, making it impractical for mainstream adoption.

This is where Cairo comes in. As a general-purpose programming language designed specifically for creating provable programs, Cairo abstracts away the underlying cryptographic complexities while maintaining the full power of STARKs. Strongly inspired by Rust, Cairo has been built to help you create provable programs without requiring specific knowledge of its underlying architecture, allowing you to focus on the program logic itself.

Blockchain developers that want to deploy contracts on Starknet will use the Cairo programming language to code their smart contracts. This allows the Starknet OS to generate execution traces for transactions to be proved by a prover, which is then verified on Ethereum L1 prior to updating the state root of Starknet.

However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one computer and verified on other machines. Powered by a Rust VM, and a next-generation prover, the execution and proof generation of Cairo programs is blazingly fast - making Cairo the best tool for building provable applications.

This book is designed for developers with a basic understanding of programming concepts. It is a friendly and approachable text intended to help you level up your knowledge of Cairo, but also help you develop your programming skills in general. So, dive in and get ready to learn all there is to know about Cairo!

This book would not have been possible without the help of the Cairo community. We would like to thank every contributor for their contributions to this book!

We would like to thank the Rust community for the [Rust Book](https://doc.rust-lang.org/book/), which has been a great source of inspiration for this book. Many examples and explanations have been adapted from the Rust Book to fit the Cairo programming language, as the two languages share many similarities.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=904879626.1738497928&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102308675~102482432~102528644~102539968~102546754&z=865770492)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=835974556.1738497927&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565~102558063&z=1102122507)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-03-functions.md "Suggest an edit")

Las funciones son frecuentes en el cÃ³digo de Cairo. Ya has visto una de las funciones mÃ¡s importantes del lenguaje: la funciÃ³n `main`, que es el punto de entrada de muchos programas. TambiÃ©n has visto la palabra clave `fn`, que te permite declarar nuevas funciones.

El cÃ³digo de Cairo utiliza el estilo _snake case_ como convenciÃ³n para los nombres de funciones y variables, en el cual todas las letras estÃ¡n en minÃºscula y los guiones bajos separan las palabras. AquÃ­ hay un programa que contiene un ejemplo de definiciÃ³n de funciÃ³n:

```cairo hljs

fn another_function() {
    println!("Another function.");
}

fn main() {
    println!("Hello, world!");
    another_function();
}

```

Definimos una funciÃ³n en Cairo introduciendo `fn` seguido de un nombre de funciÃ³n y un conjunto de parÃ©ntesis. Las llaves indican al compilador dÃ³nde empieza y termina el cuerpo de la funciÃ³n.

Podemos llamar a cualquier funciÃ³n que hayamos definido introduciendo su nombre seguido de parÃ©ntesis. Dado que `otra_funcion` estÃ¡ definida en el programa, puede ser llamada desde dentro de la funciÃ³n `main`. Tenga en cuenta que hemos definido `otra_funcion` _antes_ de la funciÃ³n `main` en el cÃ³digo fuente; tambiÃ©n podrÃ­amos haberla definido despuÃ©s tambiÃ©n. A Cairo no le importa dÃ³nde definas tus funciones, sÃ³lo que estÃ©n definidas en algÃºn lugar en un Ã¡mbito que pueda ser visto por quien las llame.

Empecemos un nuevo proyecto con Scarb llamado _functions_ para explorar las funciones mÃ¡s a fondo. Coloque el ejemplo `another_function` en _src/lib.cairo_ y ejecÃºtelo. Usted DeberÃ­a ver la siguiente salida:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_15_functions
Hello, world!
Another function.
Run completed successfully, returning []

```

The lines execute in the order in which they appear in the `main` function. First the `Hello, world!` message prints, and then `another_function` is called and its message is printed.

Podemos definir funciones para que tengan _parameters_, que son variables especiales que forman parte de la firma de una funciÃ³n. Cuando una funciÃ³n tiene parÃ¡metros, puedes proporcionarle valores concretos para esos parÃ¡metros. TÃ©cnicamente, los valores valores concretos se llaman _arguments_, pero en la conversaciÃ³n informal, la gente tiende a usar las palabras _parameters_ y _arguments_ indistintamente para las variables en la definiciÃ³n de una funciÃ³n o los valores concretos que se pasan cuando se llama a una funciÃ³n.

En esta versiÃ³n de `another_function` aÃ±adimos un parÃ¡metro:

```cairo hljs

fn main() {
    another_function(5);
}

fn another_function(x: felt252) {
    println!("The value of x is: {}", x);
}

```

Intente ejecutar este programa; deberÃ­a obtener la siguiente salida:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_16_single_param
The value of x is: 5
Run completed successfully, returning []

```

La declaraciÃ³n de `another_function` tiene un parÃ¡metro llamado x. El tipo de `x` se especifica cÃ³mo `felt252`. Cuando pasamos 5 a `another_function`, la macro `println!` coloca 5 donde estaba el par de llaves que contenÃ­an a `x` en el formato string.

En las firmas de funciÃ³n, _must_ declarar el tipo de cada parÃ¡metro. Esta es una decisiÃ³n deliberada en el diseÃ±o de Cairo: requerir anotaciones de tipo en las significa que el compilador casi nunca necesita usarlas en otra parte del cÃ³digo el cÃ³digo para averiguar a quÃ© tipo se refiere. El compilador tambiÃ©n puede dar mensajes de error mÃ¡s Ãºtiles si sabe quÃ© tipos espera la funciÃ³n.

Cuando defina mÃºltiples parÃ¡metros, separe las declaraciones de parÃ¡metros con comas, asÃ­:

```cairo hljs

fn main() {
    print_labeled_measurement(5, "h");
}

fn print_labeled_measurement(value: u128, unit_label: ByteArray) {
    println!("The measurement is: {value}{unit_label}");
}

```

Este ejemplo crea una funciÃ³n llamada `print_labeled_measurement` con dos parÃ¡metros. El primer parÃ¡metro se llama `value` y es un `u128`. El segundo se llama `unit_label` y es de tipo `ByteArray`, el tipo interno de Cairo para representar literales de string. La funciÃ³n luego imprime texto que contiene tanto el valor como la etiqueta de unidad `unit_label`.

Letâ€™s try running this code. Replace the program currently in your _functions_ projectâ€™s _src/lib.cairo_ file with the preceding example and run it using `scarb cairo-run`:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)
    Finished `dev` profile target(s) in 5 seconds
     Running no_listing_17_multiple_params
The measurement is: 5h
Run completed successfully, returning []

```

Dado que llamamos a la funciÃ³n con `5` como el valor para valor y `"h"` como el valor para `unit_label`, la salida del programa contiene esos valores.

En Cairo, los parÃ¡metros con nombre permiten especificar los nombres de los argumentos cuando se llama a una funciÃ³n. Esto hace que las llamadas a funciones sean mÃ¡s legibles y autodescriptivas. Si quieres usar parÃ¡metros con nombre, necesitas especificar el nombre del parÃ¡metro y el valor que quieres pasarle. La sintaxis es `parameter_name: value`. Si pasas una variable que tiene el mismo nombre que el parÃ¡metro, puedes escribir simplemente `:parameter_name` en lugar de `parameter_name: variable_name`.

AquÃ­ un ejemplo:

```cairo hljs

fn foo(x: u8, y: u8) {}

fn main() {
    let first_arg = 3;
    let second_arg = 4;
    foo(x: first_arg, y: second_arg);
    let x = 1;
    let y = 2;
    foo(:x, :y)
}

```

Los cuerpos de las funciones estÃ¡n compuestos por una serie de sentencias que terminan opcionalmente en una expresiÃ³n. Hasta ahora, las funciones que hemos cubierto no han incluido una expresiÃ³n final, pero ya has visto una expresiÃ³n como parte de una sentencia. Como Cairo es un lenguaje basado en expresiones, esta es una distinciÃ³n importante que debemos entender. Otros lenguajes no tienen las mismas distinciones, asÃ­ que veamos quÃ© son las sentencias y expresiones y cÃ³mo sus diferencias afectan los cuerpos de las funciones.

- **Declaraciones** son instrucciones que realizan alguna acciÃ³n y no devuelven un valor.
- **Expresiones** se evalÃºan a un valor resultante. Veamos algunos ejemplos.

De hecho, ya hemos utilizado declaraciones y expresiones. Crear una variable y asignarle un valor con la palabra clave `let` es una declaraciÃ³n. En el Listado 2-1, `let y = 6;` es una declaraciÃ³n.

```cairo hljs

fn main() {
    let y = 6;
}

```

Listing 2-1: A `main` function declaration containing one statement

Las definiciones de funciones tambiÃ©n son sentencias; todo el ejemplo anterior es una sentencia en sÃ­ misma.

Las declaraciones no devuelven valores. Por lo tanto, no se puede asignar una sentencia `let` a otra variable, como intenta hacer el siguiente cÃ³digo; se producirÃ¡ un error:

```cairo noplayground hljs

fn main() {
    let x = (let y = 6);
}

```

Cuando ejecutes este programa, el error que obtendrÃ¡s se verÃ¡ asÃ­:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_18_statements_dont_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml)
error: Missing token TerminalRParen.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
    let x = (let y = 6);
                      ^

error: Skipped tokens. Expected: statement.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
    let x = (let y = 6);
                      ^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:9
    let x = (let y = 6);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:18
    let x = (let y = 6);
                 ^

error: could not compile `no_listing_18_statements_dont_return_values` due to previous error
error: `scarb metadata` exited with error

```

La declaraciÃ³n `let y = 6` no devuelve un valor, por lo que no hay nada a lo que `x` pueda enlazar. Esto es diferente de lo que sucede en otros lenguajes, como C y Ruby, donde la asignaciÃ³n devuelve el valor de la asignaciÃ³n. En esos lenguajes, puedes escribir `x = y = 6` y tanto `x` como `y` tendrÃ¡n el valor `6`; esto no es asÃ­ en Cairo.

Expressions evaluate to a value and make up most of the rest of the code that youâ€™ll write in Cairo. Consider a math operation, such as `5 + 6`, which is an expression that evaluates to the value `11`. Expressions can be part of statements: in Listing 2-1, the `6` in the statement `let y = 6;` is an expression that evaluates to the value `6`.

Calling a function is an expression since it always evaluates to a value: the function's explicit return value, if specified, or the 'unit' type `()` otherwise.

A new scope block created with curly brackets is an expression, for example:

```cairo hljs

fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}

```

Esta expresiÃ³n:

```cairo noplayground hljs

    let y = {
        let x = 3;
        x + 1
    };

```

Este bloque de cÃ³digo, en este caso, se evalÃºa como 4. Ese valor se asigna a y como parte de la declaraciÃ³n let. Ten en cuenta que la lÃ­nea x + 1 no tiene un punto y coma al final, lo que es diferente a la mayorÃ­a de las lÃ­neas que has visto hasta ahora. Las expresiones no incluyen un punto y coma al final. Si agregas un punto y coma al final de una expresiÃ³n, la conviertes en una declaraciÃ³n, y en ese caso no se devolverÃ¡ ningÃºn valor. Tenlo en cuenta mientras exploras los valores de retorno de las funciones y las expresiones a continuaciÃ³n.

Las funciones pueden devolver valores al cÃ³digo que las llama. No nombramos los valores de retorno, pero debemos declarar su tipo despuÃ©s de una flecha ( `->`). En Cairo, el valor de retorno de la funciÃ³n es sinÃ³nimo del valor de la Ãºltima expresiÃ³n en el bloque del cuerpo de una funciÃ³n. Puede salir temprano de una funciÃ³n usando la palabra clave `return` y especificando un valor, pero la mayorÃ­a de las funciones devuelven la Ãºltima expresiÃ³n implÃ­citamente. AquÃ­ hay un ejemplo de una funciÃ³n que devuelve un valor:

```cairo hljs

fn five() -> u32 {
    5
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}

```

No hay llamadas a funciones ni declaraciones `let` en la funciÃ³n `five`, solo el nÃºmero `5` por sÃ­ mismo. Esa es una funciÃ³n perfectamente vÃ¡lida en Cairo. Observa que se especifica el tipo de retorno de la funciÃ³n como `-> u32`. Intenta ejecutar este cÃ³digo; la salida deberÃ­a verse asÃ­:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_20_function_return_values
The value of x is: 5
Run completed successfully, returning []

```

El `5` en `five` es el valor de retorno de la funciÃ³n, por eso el tipo de retorno es `u32`. Vamos a examinar esto con mÃ¡s detalle. Hay dos partes importantes: en primer lugar, la lÃ­nea `let x = five();` muestra que estamos usando el valor de retorno de una funciÃ³n para inicializar una variable. Debido a que la funciÃ³n `five` devuelve un `5`, esa lÃ­nea es lo mismo que:

```cairo noplayground hljs

let x = 5;

```

Segundo, la funciÃ³n `five` no tiene parÃ¡metros y define el tipo del valor de retorno, pero el cuerpo de la funciÃ³n es un solitario `5` sin punto y coma porque es una expresiÃ³n cuyo valor queremos devolver. Veamos otro ejemplo:

```cairo hljs

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -> u32 {
    x + 1
}

```

Al ejecutar este cÃ³digo se imprimirÃ¡ `x = 6`. Pero si agregamos un punto y coma al final de la lÃ­nea que contiene `x + 1`, cambiÃ¡ndola de una expresiÃ³n a una declaraciÃ³n, obtendremos un error:

```cairo does_not_compile hljs

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -> u32 {
    x + 1;
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)
error: Unexpected return type. Expected: "core::integer::u32", found: "()".
 --> listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:9:28
fn plus_one(x: u32) -> u32 {
                           ^

error: could not compile `no_listing_22_function_return_invalid` due to previous error
error: `scarb metadata` exited with error

```

El mensaje principal de error, `Unexpected return type`, revela el problema principal con este cÃ³digo. La definiciÃ³n de la funciÃ³n `plus_one` indica que devolverÃ¡ un `u32`, pero las sentencias no se evalÃºan a un valor, lo cual se expresa por `()`, el tipo unit. Por lo tanto, no se devuelve nada, lo que contradice la definiciÃ³n de la funciÃ³n y resulta en un error.

Start

ðŸ’¬

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-08-system-calls.md "Suggest an edit")

This chapter is based on the Starknet documentation available at [Starknet Docs](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/).

Writing smart contracts requires various associated operations, such as calling another contract or accessing the contractâ€™s storage, that standalone programs do not require.

The Starknet contract language supports these operations by using system calls. System calls enable a contract to require services from the Starknet OS. You can use system calls in a function to get information that depends on the broader state of Starknet, which would otherwise be inaccessible, rather than local variables that appear in the functionâ€™s scope.

Here is a list of the system calls available in Cairo 1.0:

- [get\_block\_hash](https://book.cairo-lang.org/appendix-08-system-calls.html#get_block_hash)
- [get\_execution\_info](https://book.cairo-lang.org/appendix-08-system-calls.html#get_execution_info)
- [call\_contract](https://book.cairo-lang.org/appendix-08-system-calls.html#call_contract)
- [deploy](https://book.cairo-lang.org/appendix-08-system-calls.html#deploy)
- [emit\_event](https://book.cairo-lang.org/appendix-08-system-calls.html#emit_event)
- [library\_call](https://book.cairo-lang.org/appendix-08-system-calls.html#library_call)
- [send\_message\_to\_L1](https://book.cairo-lang.org/appendix-08-system-calls.html#send_message_to_l1)
- [get\_class\_hash\_at](https://book.cairo-lang.org/appendix-08-system-calls.html#get_class_hash_at)
- [replace\_class](https://book.cairo-lang.org/appendix-08-system-calls.html#replace_class)
- [storage\_read](https://book.cairo-lang.org/appendix-08-system-calls.html#storage_read)
- [storage\_write](https://book.cairo-lang.org/appendix-08-system-calls.html#storage_write)
- [keccak](https://book.cairo-lang.org/appendix-08-system-calls.html#keccak)
- [sha256\_process\_block](https://book.cairo-lang.org/appendix-08-system-calls.html#sha256_process_block)

```cairo noplayground hljs

pub extern fn get_block_hash_syscall(
    block_number: u64,
) -> SyscallResult<felt252> implicits(GasBuiltin, System) nopanic;

```

Gets the hash of a specific Starknet block within the range of `[first_v0_12_0_block, current_block - 10]`.

Returns the hash of the given block.

- `Block number out of range`: `block_number` is greater than _`current_block`_ `- 10`.
- `0`: `block_number` is less than the first block number of v0.12.0.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/0c882679fdb24a818cad19f2c18decbf6ef66153/corelib/src/starknet/syscalls.cairo#L37)

```cairo noplayground hljs

pub extern fn get_execution_info_syscall() -> SyscallResult<
    Box<starknet::info::ExecutionInfo>,
> implicits(GasBuiltin, System) nopanic;

```

Gets information about the original transaction.

In Cairo 1.0, all block/transaction/execution context getters are batched into this single system call.

None.

Returns a [struct](https://github.com/starkware-libs/cairo/blob/efbf69d4e93a60faa6e1363fd0152b8fcedbb00a/corelib/src/starknet/info.cairo#L8) containing the execution info.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L35)

```cairo noplayground hljs

pub extern fn call_contract_syscall(
    address: ContractAddress, entry_point_selector: felt252, calldata: Span<felt252>,
) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;

```

Calls a given contract. This system call expects the address of the called contract, a selector for a function within that contract, and call arguments.

> **Note:**
>
> An internal call canâ€™t return Err(\_) as this is not handled by the sequencer and the Starknet OS.
>
> If call\_contract\_syscall fails, this canâ€™t be caught and will therefore result in the entire transaction being reverted.

- _`address`_: The address of the contract you want to call.
- _`entry_point_selector`_: A selector for a function within that contract, can be computed with the `selector!` macro.
- _`calldata`_: The calldata array.

The call response, of type `SyscallResult<Span<felt252>>`.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L10)

> **Note:**
> This is considered a lower-level syntax for calling contracts.
> If the interface of the called contract is available, then you can use a more straightforward syntax.

```cairo noplayground hljs

pub extern fn deploy_syscall(
    class_hash: ClassHash,
    contract_address_salt: felt252,
    calldata: Span<felt252>,
    deploy_from_zero: bool,
) -> SyscallResult<(ContractAddress, Span<felt252>)> implicits(GasBuiltin, System) nopanic;

```

Deploys a new instance of a previously declared class.

- _`class_hash`_: The class hash of the contract to be deployed.
- _`contract_address_salt`_: The salt, an arbitrary value provided by the sender. It is used in the computation of the contractâ€™s address.
- _`calldata`_: The constructorâ€™s calldata. An array of felts.
- _`deploy_from_zero`_: A flag used for the contract address computation. If not set, the caller address will be used as the new contractâ€™s deployer address, otherwise 0 is used.

A tuple wrapped with SyscallResult where:

- The first element is the address of the deployed contract, of type `ContractAddress`.

- The second element is the response array from the contractâ€™s constructor, of type `Span::<felt252>`.


- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/4821865770ac9e57442aef6f0ce82edc7020a4d6/corelib/src/starknet/syscalls.cairo#L22)

```cairo noplayground hljs

pub extern fn emit_event_syscall(
    keys: Span<felt252>, data: Span<felt252>,
) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;

```

Emits an event with a given set of keys and data.

For more information and a higher-level syntax for emitting events, see [Starknet events](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/starknet-events/).

- _`keys`_: The eventâ€™s keys. These are analogous to Ethereumâ€™s event topics, you can use the starknet\_getEvents method to filter by these keys.

- _`data`_: The eventâ€™s data.


None.

The following example emits an event with two keys, the strings `status` and `deposit` and three data elements: `1`, `2`, and `3`.

```cairo noplayground hljs

let keys = ArrayTrait::new();
keys.append('key');
keys.append('deposit');
let values = ArrayTrait::new();
values.append(1);
values.append(2);
values.append(3);
emit_event_syscall(keys, values).unwrap_syscall();

```

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L30)

```cairo noplayground hljs

pub extern fn library_call_syscall(
    class_hash: ClassHash, function_selector: felt252, calldata: Span<felt252>,
) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;

```

Calls the requested function in any previously declared class. The class is only used for its logic.

This system call replaces the known delegate call functionality from Ethereum, with the important difference that there is only one contract involved.

- _`class_hash`_: The hash of the class you want to use.

- _`function_selector`_: A selector for a function within that class, can be computed with the `selector!` macro.

- _`calldata`_: The calldata.


The call response, of type `SyscallResult<Span<felt252>>`.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L43)

```cairo noplayground hljs

pub extern fn send_message_to_l1_syscall(
    to_address: felt252, payload: Span<felt252>,
) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;

```

Sends a message to L1.

This system call includes the message parameters as part of the proofâ€™s output and exposes these parameters to the `StarknetCore` contract on L1 once the state update, including the transaction, is received.

For more information, see Starknetâ€™s [messaging mechanism](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/messaging-mechanism/).

- _`to_address`_: The recipientâ€™s L1 address.

- _`payload`_: The array containing the message payload.


None.

The following example sends a message whose content is `(1,2)` to the L1 contract whose address is `3423542542364363`.

```cairo noplayground hljs

let payload = ArrayTrait::new();
payload.append(1);
payload.append(2);
send_message_to_l1_syscall(payload).unwrap_syscall();

```

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L51)

```cairo noplayground hljs

pub extern fn get_class_hash_at_syscall(
    contract_address: ContractAddress,
) -> SyscallResult<ClassHash> implicits(GasBuiltin, System) nopanic;

```

Gets the class hash of the contract at the given address.

- _`contract_address`_: The address of the deployed contract.

The class hash of the contract's originating code.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L99)

```cairo noplayground hljs

pub extern fn replace_class_syscall(
    class_hash: ClassHash,
) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;

```

Once `replace_class` is called, the class of the calling contract (i.e. the contract whose address is returned by `get_contract_address` at the time the syscall is called) will be replaced by the class whose hash is given by the class\_hash argument.

> **Note:**
>
> After calling `replace_class`, the code currently executing from the old class will finish running.
>
> The new class will be used from the next transaction onwards or if the contract is called via the `call_contract` syscall in the same transaction (after the replacement).

- _`class_hash`_: The hash of the class you want to use as a replacement.

None.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L77)

```cairo noplayground hljs

pub extern fn storage_read_syscall(
    address_domain: u32, address: StorageAddress,
) -> SyscallResult<felt252> implicits(GasBuiltin, System) nopanic;

```

Gets the value of a key in the storage of the calling contract.

This system call provides direct access to any possible key in storage, in contrast with `var.read()`, which enables you to read storage variables that are defined explicitly in the contract.

For information on accessing storage by using the storage variables, see [storage variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables).

- _`address_domain`_: The domain of the key, used to separate between different data availability modes. This separation is used in Starknet to offer different data availability modes. Currently, only the onchain mode (where all updates go to L1), indicated by domain `0`, is supported. Other address domains which will be introduced in the future will behave differently in terms of publication (in particular, they will not be posted on L1, creating a tradeoff between cost and security).

- _`address`_: The requested storage address.


The value of the key, of type `SyscallResult<felt252>`.

```cairo noplayground hljs

use starknet::storage_access::storage_base_address_from_felt252;

...

let storage_address = storage_base_address_from_felt252(3534535754756246375475423547453)
storage_read_syscall(0, storage_address).unwrap_syscall()

```

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L60)

```cairo noplayground hljs

pub extern fn storage_write_syscall(
    address_domain: u32, address: StorageAddress, value: felt252,
) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;

```

Sets the value of a key in the storage of the calling contract.

This system call provides direct access to any possible key in storage, in contrast with `var.write()`, which enables you to write to storage variables that are defined explicitly in the contract.

For information on accessing storage by using the storage variables, see [storage variables](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-storage/#storage_variables).

- _`address_domain`_: The domain of the key, used to separate between different data availability modes. This separation is used in Starknet to offer different data availability modes. Currently, only the onchain mode (where all updates go to L1), indicated by domain `0`, is supported. Other address domains which will be introduced in the future will behave differently in terms of publication (in particular, they will not be posted on L1, creating a tradeoff between cost and security).

- _`address`_: The requested storage address.

- _`value`_: The value to write to the key.


None.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/cca08c898f0eb3e58797674f20994df0ba641983/corelib/src/starknet/syscalls.cairo#L70)

```cairo noplayground hljs

pub extern fn keccak_syscall(
    input: Span<u64>,
) -> SyscallResult<u256> implicits(GasBuiltin, System) nopanic;

```

Computes the Keccak-256 hash of a given input.

- _`input`_: A `Span<u64>` Keccak-256 input.

Returns the hash result as a `u256`.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/67c6eff9c276d11bd1cc903d7a3981d8d0eb2fa2/corelib/src/starknet/syscalls.cairo#L107)

```cairo noplayground hljs

pub extern fn sha256_process_block_syscall(
    state: core::sha256::Sha256StateHandle, input: Box<[u32; 16]>
) -> SyscallResult<core::sha256::Sha256StateHandle> implicits(GasBuiltin, System) nopanic;

```

Computes the next SHA-256 state of the input with the given state.

This syscall computes the next SHA-256 state by combining the current `state` with a 512-bit block of `input` data.

- _`state`_: The current SHA-256 state.
- _`input`_: The value to be processed into SHA-256.

Returns a new SHA-256 state of the `input` data.

- [syscalls.cairo](https://github.com/starkware-libs/cairo/blob/3540731e5b0e78f2f5b1a51d3611418121c19e54/corelib/src/starknet/syscalls.cairo#L106)

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1773269761.1738497929&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=1794822189)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch204-02-01-pedersen.md "Suggest an edit")

The _Pedersen_ builtin is dedicated to computing the pedersen hash
of two felts. Its use in Cairo is explained on section 11.4 [Working with Hashes](https://book.cairo-lang.org/ch12-04-hash.html).

The Pedersen builtin has its own segment during a Cairo VM run.
It follows a deduction property, organized by _triplets of cells_,
two input and one output.

- The input cells must store felts, relocatable are forbidden.
It makes sense as you cannot compute the hash of a pointer
(unless you allow dereferencing pointers from the builtin...)
- The output cell is deduced from the input cells.
Once an instruction tries reading the cell, the Pedersen hash
of the two related input cells is computed and written to
the cell.

Let's take a look at two snapshots of a Pedersen segment,
during the execution of a dummy program by the Cairo VM.

In the first snapshot, the first triplet has its three cells
storing felts and the second one only has its two input cells
storing felts.

It means that the Pedersen hash of 15 and 35 has been computed,
because the cell `3:2` has been read.
The cell `3:5` is still empty while its two input cells are filled
with 93 and 5. It means that even if the input cells have been written to,
the output cell `3:5` has not been read yet, so
the Pedersen hash of 93 and 5 has not been computed yet.

![valid pedersen builtin segment](https://book.cairo-lang.org/pedersen-builtin-valid.png)

Snapshot 1 - Pedersen builtin segment with valid inputs

On the second snapshot, both triplets of cells would throw
an error if their output cell was read.

Why is there an error when trying to read `3:2`?

This is because one of the input cells is empty.
It's hard to compute a hash of something missing.

Why is there an error when trying to read `3:5`?

If you look closely to the related input cells `3:3` and `3:4`,
you'll notice that the value asserted in `3:4` is a _relocatable_,
a pointer to the cell `1:7`. Recall that the Pedersen builtin
cannot hash a relocatable value, hence the error.

The error arises when the output cell is read. In the second case,
it could have been caught earlier if the input cells were validated
as being felts only.

![Invalid pedersen builtin segment](https://book.cairo-lang.org/pedersen-builtin-error.png)

Snapshot 2 - Pedersen builtin segment with invalid inputs

These implementation references of the Pedersen builtin might not be exhaustive.

- [TypeScript Pedersen Builtin](https://github.com/kkrt-labs/cairo-vm-ts/blob/58fd07d81cff4a4bb45c30ab99976ba66f0576ad/src/builtins/pedersen.ts#L4)
- [Python Pedersen Builtin](https://github.com/starkware-libs/cairo-lang/blob/0e4dab8a6065d80d1c726394f5d9d23cb451706a/src/starkware/cairo/lang/builtins/hash/hash_builtin_runner.py)
- [Rust Pedersen Builtin](https://github.com/lambdaclass/cairo-vm/blob/41476335884bf600b62995f0c005be7d384eaec5/vm/src/vm/runners/builtin_runner/hash.rs)
- [Go Pedersen Builtin](https://github.com/NethermindEth/cairo-vm-go/blob/dc02d614497f5e59818313e02d2d2f321941cbfa/pkg/vm/builtins/pedersen.go)
- [Zig Pedersen Builtin](https://github.com/keep-starknet-strange/ziggy-starkdust/blob/55d83e61968336f6be93486d7acf8530ba868d7e/src/vm/builtins/builtin_runner/hash.zig)

If you're interested about the Pedersen hash and its use,
take a look at those references:

- StarkNet, [Hash Functions - Pedersen Hash](https://docs.starknet.io/architecture-and-concepts/cryptography/hash-functions/#pedersen-hash)
- nccgroup, [Breaking Pedersen Hashes in Practice](https://research.nccgroup.com/2023/03/22/breaking-pedersen-hashes-in-practice/), 2023, March 22
- Ryan S., [Pedersen Hash Function Overview](https://rya-sge.github.io/access-denied/2024/05/07/pedersen-hash-function/), 2024, May 07

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1830666656.1738497929&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1791620003)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-01-installation.md "Suggest an edit")

Cairo can be installed by simply downloading [Scarb](https://docs.swmansion.com/scarb/docs). Scarb bundles the Cairo compiler and the Cairo language server together in an easy-to-install package so that you can start writing Cairo code right away.

Scarb is also Cairo's package manager and is heavily inspired by [Cargo](https://doc.rust-lang.org/cargo/), Rustâ€™s build system and package manager.

Scarb handles a lot of tasks for you, such as building your code (either pure Cairo or Starknet contracts), downloading the libraries your code depends on, building those libraries, and provides LSP support for the VSCode Cairo 1 extension.

As you write more complex Cairo programs, you might add dependencies, and if you start a project using Scarb, managing external code and dependencies will be a lot easier to do.

[Starknet Foundry](https://foundry-rs.github.io/starknet-foundry/index.html) is a toolchain for Cairo programs and Starknet smart contract development. It supports many features, including writing and running tests with advanced features, deploying contracts, interacting with the Starknet network, and more.

Let's start by installing Scarb and Starknet Foundry.

Scarb requires a Git executable to be available in the `PATH` environment variable.

To install Scarb, please refer to the [installation instructions](https://docs.swmansion.com/scarb/download). We strongly recommend that you install Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a CLI tool that can manage multiple language runtime versions on a per-project basis. This will ensure that the version of Scarb you use to work on a project always matches the one defined in the project settings, avoiding problems related to version mismatches.

Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-started.html) to install all prerequisites.

Once you have asdf installed locally, you can download Scarb plugin with the following command:

```bash hljs

asdf plugin add scarb

```

This will allow you to download specific versions:

```bash hljs

asdf install scarb 2.9.2

```

and set a global version:

```bash hljs

asdf global scarb 2.9.2

```

Otherwise, you can simply run the following command in your terminal, and follow the onscreen instructions. This will install the latest stable release of Scarb.

```bash hljs

curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh

```

In both cases, you can verify installation by running the following command in a new terminal session, it should print both Scarb and Cairo language versions, e.g:

```bash hljs

$ scarb --version
scarb 2.9.2 (5070ff374 2024-12-11)
cairo: 2.9.2 (https://crates.io/crates/cairo-lang-compiler/2.9.2)
sierra: 1.6.0

```

To install Starknet Foundry, please refer to the [installation instructions](https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html). We also recommend that you install it via asdf.

Once installed, you can run the following command to see the version:

```bash hljs

$ snforge --version
snforge 0.35.1

```

We'll describe Starknet Foundry in more detail in [Chapter 10](https://book.cairo-lang.org/ch10-01-how-to-write-tests.html) for Cairo programs testing and in [Chapter 18](https://book.cairo-lang.org/ch104-02-testing-smart-contracts.html#testing-smart-contracts-with-starknet-foundry) when discussing Starknet smart contract testing and security in the second part of the book.

Cairo has a VSCode extension that provides syntax highlighting, code completion, and other useful features. You can install it from the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1).
Once installed, go into the extension settings, and make sure to tick the `Enable Language Server` and `Enable Scarb` options.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1312880021.1738497931&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102325445~102482432~102528644~102539968~102546754&z=1260634068)

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1807144117.1738497931&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1116960367)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/tr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-04-hash.md "Suggest an edit")

At its essence, hashing is a process of converting input data (often called a message) of any length into a fixed-size value, typically referred to as a "hash." This transformation is deterministic, meaning that the same input will always produce the same hash value. Hash functions are a fundamental component in various fields, including data storage, cryptography and data integrity verification. They are very often used when developing smart contracts, especially when working with [Merkle trees](https://en.wikipedia.org/wiki/Merkle_tree#Uses).

In this chapter, we will present the two hash functions implemented natively in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when and how to use them, and see examples with Cairo programs.

Cairo Ã§ekirdek kitaplÄ±ÄŸÄ± iki hash fonksiyonu saÄŸlar: Pedersen ve Poseidon.

Pedersen hash functions are cryptographic algorithms that rely on [elliptic curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography). These functions perform operations on points along an elliptic curve â€” essentially, doing math with the locations of these points â€” which are easy to do in one direction and hard to undo. This one-way difficulty is based on the Elliptic Curve Discrete Logarithm Problem (ECDLP), which is a problem so hard to solve that it ensures the security of the hash function. The difficulty of reversing these operations is what makes the Pedersen hash function secure and reliable for cryptographic purposes.

Poseidon is a family of hash functions designed to be very efficient as algebraic circuits. Its design is particularly efficient for Zero-Knowledge proof systems, including STARKs (so, Cairo). Poseidon uses a method called a 'sponge construction,' which soaks up data and transforms it securely using a process known as the Hades permutation. Cairo's version of Poseidon is based on a three-element state permutation with [specific parameters](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt).

Pedersen, Starknet'te kullanÄ±lan ilk hash fonksiyonuydu ve hala depolama alanÄ±ndaki deÄŸiÅŸkenlerin adreslerini hesaplamak iÃ§in kullanÄ±lmaktadÄ±r (Ã¶rneÄŸin, `LegacyMap` Starknet'te bir depolama eÅŸlemesinin anahtarlarÄ±nÄ± hashlemek iÃ§in Pedersen kullanÄ±r). Ancak, Poseidon STARK kanÄ±t sistemiyle Ã§alÄ±ÅŸÄ±rken Pedersen'den daha ucuz ve daha hÄ±zlÄ± olduÄŸundan, ÅŸimdi Kahire programlarÄ±nda kullanÄ±lmasÄ± Ã¶nerilen hash fonksiyonudur.

The core library makes it easy to work with hashes. The `Hash` trait is implemented for all types that can be converted to `felt252`, including `felt252` itself. For more complex types like structs, deriving `Hash` allows them to be hashed easily using the hash function of your choice - given that all of the struct's fields are themselves hashable. You cannot derive the `Hash` trait on a struct that contains un-hashable values, such as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable.

The `Hash` trait is accompanied by the `HashStateTrait` and `HashStateExTrait` that define the basic methods to work with hashes. They allow you to initialize a hash state that will contain the temporary values of the hash after each application of the hash function, update the hash state and finalize it when the computation is completed. `HashStateTrait` and `HashStateExTrait` are defined as follows:

```cairo noplayground hljs

/// A trait for hash state accumulators.
trait HashStateTrait<S> {
    fn update(self: S, value: felt252) -> S;
    fn finalize(self: S) -> felt252;
}

/// Extension trait for hash state accumulators.
trait HashStateExTrait<S, T> {
    /// Updates the hash state with the given value.
    fn update_with(self: S, value: T) -> S;
}

/// A trait for values that can be hashed.
trait Hash<T, S, +HashStateTrait<S>> {
    /// Updates the hash state with the given value.
    fn update_state(state: S, value: T) -> S;
}

```

Kodunuzda hash'leri kullanmak iÃ§in, ilgili Ã¶zellikleri ve fonksiyonlarÄ± Ã¶nce iÃ§e aktarmanÄ±z gerekir. AÅŸaÄŸÄ±daki Ã¶rnekte, hem Pedersen hem de Poseidon hash fonksiyonlarÄ±nÄ± kullanarak bir yapÄ±yÄ± nasÄ±l hashleyeceÄŸimizi gÃ¶stereceÄŸiz.

Ä°lk adÄ±m, hangi hash fonksiyonuyla Ã§alÄ±ÅŸmak istediÄŸimize baÄŸlÄ± olarak ya `PoseidonTrait::new() -> HashState` ya da `PedersenTrait::new(base: felt252) -> HashState` ile hash'i baÅŸlatmaktÄ±r. Daha sonra hash durumu, gerektiÄŸi kadar `update(self: HashState, value: felt252) -> HashState` veya `update_with(self: S, value: T) -> S` fonksiyonlarÄ± ile gÃ¼ncellenebilir. Sonra `finalize(self: HashState) -> felt252` fonksiyonu hash durumu Ã¼zerinde Ã§aÄŸrÄ±lÄ±r ve hash deÄŸeri bir `felt252` olarak dÃ¶ndÃ¼rÃ¼lÃ¼r.

```cairo hljs

use core::poseidon::PoseidonTrait;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop, Hash)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

fn main() -> felt252 {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();
    hash
}

```

Pedersen, bir temel durumla baÅŸladÄ±ÄŸÄ± iÃ§in Poseidon'dan farklÄ±dÄ±r. Bu temel durum `felt252` tÃ¼rÃ¼nde olmalÄ±dÄ±r, bu da bizi ya `update_with` metodunu kullanarak yapÄ±yÄ± keyfi bir temel durumla hashlemeye ya da yapÄ±yÄ± bir diziye seri hale getirip tÃ¼m alanlarÄ±nÄ± dÃ¶ngÃ¼ye alÄ±p elemanlarÄ±nÄ± birlikte hashlemeye zorlar.

Here is a short example of Pedersen hashing:

```cairo hljs hide-boring

use core::pedersen::PedersenTrait;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop, Hash, Serde, Copy)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

fn main() -> (felt252, felt252) {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    // hash1 is the result of hashing a struct with a base state of 0
    let hash1 = PedersenTrait::new(0).update_with(struct_to_hash).finalize();

    let mut serialized_struct: Array<felt252> = ArrayTrait::new();
    Serde::serialize(@struct_to_hash, ref serialized_struct);
    let first_element = serialized_struct.pop_front().unwrap();
    let mut state = PedersenTrait::new(first_element);

    while let Option::Some(value) = serialized_struct.pop_front() {
        state = state.update(value);
    };

    // hash2 is the result of hashing only the fields of the struct
    let hash2 = state.finalize();

    (hash1, hash2)
}

```

Let us look at an example of hashing a struct that contains a `Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a `Span<felt252>` you can use the built-in function `poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` by calling `poseidon_hash_span` on its span.

First, let us import the following traits and function:

```cairo noplayground hljs

use core::poseidon::PoseidonTrait;
use core::poseidon::poseidon_hash_span;
use core::hash::{HashStateTrait, HashStateExTrait};

```

Now we define the struct. As you might have noticed, we didn't derive the `Hash` trait. If you attempt to derive the `Hash` trait for this struct, it will result in an error because the structure contains a field that is not hashable.

```cairo noplayground hljs

#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array<felt252>,
}

```

In this example, we initialized a `HashState` ( `hash`), updated it and then called the function `finalize()` on the `HashState` to get the computed hash `hash_felt252`. We used `poseidon_hash_span` on the `Span` of the `Array<felt252>` to compute its hash.

```cairo hljs hide-boring

use core::poseidon::PoseidonTrait;
use core::poseidon::poseidon_hash_span;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array<felt252>,
}

fn main() {
    let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };

    let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);
    let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();
}

```

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch05-03-method-syntax.md "Suggest an edit")

_Methods_ are similar to functions: we declare them with the `fn` keyword and a name, they can have parameters and a return value, and they contain some code thatâ€™s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an enum which we cover in [Chapter 6](https://book.cairo-lang.org/ch06-01-enums.html)), and their first parameter is always `self`, which represents the instance of the type the method is being called on.

Letâ€™s change the `area` function that has a `Rectangle` instance as a parameter and instead make an `area` method defined on the `Rectangle` struct, as shown in Listing 5-11

```cairo noplayground hljs

#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

trait RectangleTrait {
    fn area(self: @Rectangle) -> u64;
}

impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -> u64 {
        (*self.width) * (*self.height)
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}

```

Listing 5-11: Defining an `area` method on the `Rectangle` struct.

To define the function within the context of `Rectangle`, we start an `impl` (implementation) block for a trait `RectangleTrait` that defines the methods that can be called on a `Rectangle` instance. As impl blocks can only be defined for traits and not types, we need to define this trait first - but it's not meant to be used for anything else.

Everything within this `impl` block will be associated with the `Rectangle` type. Then we move the `area` function within the `impl` curly brackets and change the first (and in this case, only) parameter to be `self` in the signature and everywhere within the body. In `main`, where we called the `area` function and passed `rect1` as an argument, we can instead use _method syntax_ to call the `area` method on our `Rectangle` instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.

In the signature for `area`, we use `self: @Rectangle` instead of `rectangle: @Rectangle`.
Methods must have a parameter named `self`, for their first parameter, and the type of `self` indicates the type that method can be called on. Methods can take ownership of `self`, but `self` can also be passed by snapshot or by reference, just like any other parameter.

> There is no direct link between a type and a trait. Only the type of the `self` parameter of a method defines the type from which this method can be called. That means, it is technically possible to define methods on multiple types in a same trait (mixing `Rectangle` and `Circle` methods, for example). But **this is not a recommended practice** as it can lead to confusion.

The main reason for using methods instead of functions, in addition to providing method syntax, is for organization. Weâ€™ve put all the things we can do with an instance of a type in one `impl` block rather than making future users of our code search for capabilities of `Rectangle` in various places in the library we provide.

If you are familiar with Rust, you may find Cairo's approach confusing because methods cannot be defined directly on types. Instead, you must define a [trait](https://book.cairo-lang.org/ch08-02-traits-in-cairo.html) and an implementation of this trait associated with the type for which the method is intended.
However, defining a trait and then implementing it to define methods on a specific type is verbose, and unnecessary: the trait itself will not be reused.

So, to avoid defining useless traits, Cairo provides the `#[generate_trait]` attribute to add above a trait implementation, which tells the compiler to generate the corresponding trait definition for you, and let's you focus on the implementation only. Both approaches are equivalent, but it's considered a best practice to not explicitly define traits in this case.

The previous example can also be written as follows:

```cairo hljs

#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -> u64 {
        (*self.width) * (*self.height)
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("Area is {}", rect1.area());
}

```

Let's use this `#[generate_trait]` in the following chapters to make our code cleaner.

As the `area` method does not modify the calling instance, `self` is declared as a snapshot of a `Rectangle` instance with the `@` snapshot operator. But, of course, we can also define some methods receiving a mutable reference of this instance, to be able to modify it.

Let's write a new method `scale` which resizes a rectangle of a `factor` given as parameter:

```cairo hljs

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -> u64 {
        (*self.width) * (*self.height)
    }
    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }
}

fn main() {
    let mut rect2 = Rectangle { width: 10, height: 20 };
    rect2.scale(2);
    println!("The new size is (width: {}, height: {})", rect2.width, rect2.height);
}

```

It is also possible to define a method which takes ownership of the instance by using just `self` as the first parameter but it is rare. This technique is usually used when the method transforms `self` into something else and you want to prevent the caller from using the original instance after the transformation.

Look at the [Understanding Ownership](https://book.cairo-lang.org/ch04-00-understanding-ownership.html) chapter for more details about these important notions.

Letâ€™s practice using methods by implementing another method on the `Rectangle` struct. This time we want to write the method `can_hold` which accepts another instance of `Rectangle` and returns `true` if this rectangle can fit completely within self; otherwise, it should return false.

```cairo hljs

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -> u64 {
        *self.width * *self.height
    }

    fn scale(ref self: Rectangle, factor: u64) {
        self.width *= factor;
        self.height *= factor;
    }

    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {
        *self.width > *other.width && *self.height > *other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(@rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(@rect3));
}

```

Here, we expect that `rect1` can hold `rect2` but not `rect3`.

We call _associated functions_ all functions that are defined inside an `impl` block that are associated to a specific type. While this is not enforced by the compiler, it is a good practice to keep associated functions related to the same type in the same `impl` block - for example, all functions related to `Rectangle` will be grouped in the same `impl` block for `RectangleTrait`.

Methods are a special kind of associated function, but we can also define associated functions that donâ€™t have `self` as their first parameter (and thus are not methods) because they donâ€™t need an instance of the type to work with, but are still associated with that type.

Associated functions that arenâ€™t methods are often used for constructors that
will return a new instance of the type. These are often called `new`, but
`new` isnâ€™t a special name and isnâ€™t built into the language. For example, we
could choose to provide an associated function named `square` that would have
one dimension parameter and use that as both width and height, thus making it
easier to create a square `Rectangle` rather than having to specify the same
value twice:

Let's create the function `new` which creates a `Rectangle` from a `width` and a `height`, `square` which creates a square `Rectangle` from a `size` and `avg` which computes the average of two `Rectangle` instances:

```cairo hljs

#[generate_trait]
impl RectangleImpl of RectangleTrait {
    fn area(self: @Rectangle) -> u64 {
        (*self.width) * (*self.height)
    }

    fn new(width: u64, height: u64) -> Rectangle {
        Rectangle { width, height }
    }

    fn square(size: u64) -> Rectangle {
        Rectangle { width: size, height: size }
    }

    fn avg(lhs: @Rectangle, rhs: @Rectangle) -> Rectangle {
        Rectangle {
            width: ((*lhs.width) + (*rhs.width)) / 2, height: ((*lhs.height) + (*rhs.height)) / 2,
        }
    }
}

fn main() {
    let rect1 = RectangleTrait::new(30, 50);
    let rect2 = RectangleTrait::square(10);

    println!(
        "The average Rectangle of {:?} and {:?} is {:?}",
        @rect1,
        @rect2,
        RectangleTrait::avg(@rect1, @rect2),
    );
}

```

To call the `square` associated function, we use the `::` syntax with the struct name;
`let sq = RectangleTrait::square(3);` is an example. This function is namespaced by
the trait: the `::` syntax is used for both associated functions and
namespaces created by modules. Weâ€™ll discuss modules in [Chapter\\
7](https://book.cairo-lang.org/ch07-02-defining-modules-to-control-scope.html).

Note that the `avg` function could also be written as a method with `self` as the first rectangle. In this case, instead of using the method with `RectangleTrait::avg(@rect1, @rect2)`, it would be called with `rect1.avg(rect2)`.

Each struct is allowed to have multiple `trait` and `impl` blocks. For example,
the following code is equivalent to the code shown in the _Methods with several parameters_ section, which has each method in its own `trait` and `impl` blocks.

```cairo hljs

#[generate_trait]
impl RectangleCalcImpl of RectangleCalc {
    fn area(self: @Rectangle) -> u64 {
        (*self.width) * (*self.height)
    }
}

#[generate_trait]
impl RectangleCmpImpl of RectangleCmp {
    fn can_hold(self: @Rectangle, other: @Rectangle) -> bool {
        *self.width > *other.width && *self.height > *other.height
    }
}

```

Thereâ€™s no strong reason to separate these methods into multiple `trait` and `impl`
blocks here, but this is valid syntax.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1216379904.1738497932&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566~102558063&z=1721705689)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-05-macros.md "Suggest an edit")

The Cairo language has some plugins that allow developers to simplify their code. They are called `inline_macros` and are a way of writing code that generates other code.

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¼€å‘äººå‘˜å¯èƒ½éœ€è¦å£°æ˜Žä¸€ä¸ªå¸¸é‡ï¼Œè¯¥å¸¸é‡æ˜¯æ•´æ•°è®¡ç®—çš„ç»“æžœã€‚ä¸ºäº†åœ¨ç¼–è¯‘æ—¶è®¡ç®—å¸¸é‡è¡¨è¾¾å¼å¹¶ä½¿ç”¨å…¶ç»“æžœï¼Œéœ€è¦ä½¿ç”¨ `consteval_int!` å®ã€‚

ä¸‹é¢æ˜¯ `consteval_int!` çš„ç¤ºä¾‹ï¼š

```cairo noplayground hljs

const a: felt252 = consteval_int!(2 * 2 * 2);

```

ç¼–è¯‘å™¨å°†è§£é‡Šä¸º `const a: felt252 = 8`

`selector!("function_name")` macro generates the entry point selector for the given function name.

Please refer to the [Printing](https://book.cairo-lang.org/zh-cn/ch12-08-printing.html) page.

Please refer to the [Arrays](https://book.cairo-lang.org/zh-cn/ch03-01-arrays.html) page.

See [Unrecoverable Errors with panic](https://book.cairo-lang.org/zh-cn/ch09-01-unrecoverable-errors-with-panic.html#panic-macro) page.

See [How to Write Tests](https://book.cairo-lang.org/zh-cn/ch10-01-how-to-write-tests.html) page.

See [Printing](https://book.cairo-lang.org/zh-cn/ch12-08-printing.html#formatting) page.

See [Printing](https://book.cairo-lang.org/zh-cn/ch12-08-printing.html#printing-custom-data-types) page.

Please refer to the [Composability and Components](https://book.cairo-lang.org/zh-cn/ch103-02-00-composability-and-components.html) chapter.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1063909736.1738497932&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=2033704982)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1887858272.1738497933&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=1046084048)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-03-functions.md "Suggest an edit")

Functions are prevalent in Cairo code. Youâ€™ve already seen one of the most
important functions in the language: the `main` function, which is the entry
point of many programs. Youâ€™ve also seen the `fn` keyword, which allows you to
declare new functions.

Cairo code uses _snake case_ as the conventional style for function and variable
names, in which all letters are lowercase and underscores separate words.
Hereâ€™s a program that contains an example function definition:

```cairo hljs

fn another_function() {
    println!("Another function.");
}

fn main() {
    println!("Hello, world!");
    another_function();
}

```

We define a function in Cairo by entering `fn` followed by a function name and a
set of parentheses. The curly brackets tell the compiler where the function
body begins and ends.

We can call any function weâ€™ve defined by entering its name followed by a set
of parentheses. Because `another_function` is defined in the program, it can be
called from inside the `main` function. Note that we defined `another_function` _before_ the `main` function in the source code; we could have defined it after
as well. Cairo doesnâ€™t care where you define your functions, only that theyâ€™re
defined somewhere in a scope that can be seen by the caller.

Letâ€™s start a new project with Scarb named _functions_ to explore functions
further. Place the `another_function` example in _src/lib.cairo_ and run it. You
should see the following output:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_15_functions
Hello, world!
Another function.
Run completed successfully, returning []

```

The lines execute in the order in which they appear in the `main` function.
First the `Hello, world!` message prints, and then `another_function` is called
and its message is printed.

We can define functions to have _parameters_, which are special variables that
are part of a functionâ€™s signature. When a function has parameters, you can
provide it with concrete values for those parameters. Technically, the concrete
values are called _arguments_, but in casual conversation, people tend to use
the words _parameter_ and _argument_ interchangeably for either the variables
in a functionâ€™s definition or the concrete values passed in when you call a
function.

In this version of `another_function` we add a parameter:

```cairo hljs

fn main() {
    another_function(5);
}

fn another_function(x: felt252) {
    println!("The value of x is: {}", x);
}

```

Try running this program; you should get the following output:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_16_single_param
The value of x is: 5
Run completed successfully, returning []

```

The declaration of `another_function` has one parameter named `x`. The type of
`x` is specified as `felt252`. When we pass `5` in to `another_function`, the
`println!` macro puts `5` where the pair of curly brackets containing `x` was in the format string.

In function signatures, you _must_ declare the type of each parameter. This is
a deliberate decision in Cairoâ€™s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what type you mean. The compiler is also able to give
more helpful error messages if it knows what types the function expects.

When defining multiple parameters, separate the parameter declarations with
commas, like this:

```cairo hljs

fn main() {
    print_labeled_measurement(5, "h");
}

fn print_labeled_measurement(value: u128, unit_label: ByteArray) {
    println!("The measurement is: {value}{unit_label}");
}

```

This example creates a function named `print_labeled_measurement` with two
parameters. The first parameter is named `value` and is a `u128`. The second is
named `unit_label` and is of type `ByteArray` \- Cairo's internal type to represent string literals. The function then prints text containing both the `value` and the `unit_label`.

Letâ€™s try running this code. Replace the program currently in your _functions_
projectâ€™s _src/lib.cairo_ file with the preceding example and run it using `scarb cairo-run`:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)
    Finished `dev` profile target(s) in 5 seconds
     Running no_listing_17_multiple_params
The measurement is: 5h
Run completed successfully, returning []

```

Because we called the function with `5` as the value for value and `"h"` as the value for `unit_label`, the program output contains those values.

In Cairo, named parameters allow you to specify the names of arguments when you call a function. This makes the function calls more readable and self-descriptive.
If you want to use named parameters, you need to specify the name of the parameter and the value you want to pass to it. The syntax is `parameter_name: value`. If you pass a variable that has the same name as the parameter, you can simply write `:parameter_name` instead of `parameter_name: variable_name`.

Here is an example:

```cairo hljs

fn foo(x: u8, y: u8) {}

fn main() {
    let first_arg = 3;
    let second_arg = 4;
    foo(x: first_arg, y: second_arg);
    let x = 1;
    let y = 2;
    foo(:x, :y)
}

```

Function bodies are made up of a series of statements optionally ending in an
expression. So far, the functions weâ€™ve covered havenâ€™t included an ending
expression, but you have seen an expression as part of a statement. Because
Cairo is an expression-based language, this is an important distinction to
understand. Other languages donâ€™t have the same distinctions, so letâ€™s look at
what statements and expressions are and how their differences affect the bodies
of functions.

- **Statements** are instructions that perform some action and do not return
a value.
- **Expressions** evaluate to a resultant value. Letâ€™s look at some examples.

Weâ€™ve actually already used statements and expressions. Creating a variable and
assigning a value to it with the `let` keyword is a statement. In Listing 2-1,
`let y = 6;` is a statement.

```cairo hljs

fn main() {
    let y = 6;
}

```

Listing 2-1: A `main` function declaration containing one statement

Function definitions are also statements; the entire preceding example is a statement in itself.

Statements do not return values. Therefore, you canâ€™t assign a `let` statement
to another variable, as the following code tries to do; youâ€™ll get an error:

```cairo noplayground hljs

fn main() {
    let x = (let y = 6);
}

```

When you run this program, the error youâ€™ll get looks like this:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_18_statements_dont_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml)
error: Missing token TerminalRParen.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
    let x = (let y = 6);
                      ^

error: Skipped tokens. Expected: statement.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
    let x = (let y = 6);
                      ^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:9
    let x = (let y = 6);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:18
    let x = (let y = 6);
                 ^

error: could not compile `no_listing_18_statements_dont_return_values` due to previous error
error: `scarb metadata` exited with error

```

The `let y = 6` statement does not return a value, so there isnâ€™t anything for
`x` to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write `x = y = 6` and have both `x` and `y` have the value
`6`; that is not the case in Cairo.

Expressions evaluate to a value and make up most of the rest of the code that
youâ€™ll write in Cairo. Consider a math operation, such as `5 + 6`, which is an
expression that evaluates to the value `11`. Expressions can be part of
statements: in Listing 2-1, the `6` in the statement `let y = 6;` is an
expression that evaluates to the value `6`.

Calling a function is an expression since it always evaluates to a value: the function's explicit return value, if specified, or the 'unit' type `()` otherwise.

A new scope block created with curly brackets is an expression, for example:

```cairo hljs

fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}

```

This expression:

```cairo noplayground hljs

    let y = {
        let x = 3;
        x + 1
    };

```

is a block that, in this case, evaluates to `4`. That value gets bound to `y`
as part of the `let` statement. Note that the `x + 1` line doesnâ€™t have a
semicolon at the end, which is unlike most of the lines youâ€™ve seen so far.
Expressions do not include ending semicolons. If you add a semicolon to the end
of an expression, you turn it into a statement, and it will then not return a
value. Keep this in mind as you explore function return values and expressions
next.

Functions can return values to the code that calls them. We donâ€™t name return
values, but we must declare their type after an arrow ( `->`). In Cairo, the
return value of the function is synonymous with the value of the final
expression in the block of the body of a function. You can return early from a
function by using the `return` keyword and specifying a value, but most
functions return the last expression implicitly. Hereâ€™s an example of a
function that returns a value:

```cairo hljs

fn five() -> u32 {
    5
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}

```

There are no function calls, or even `let` statements in the `five`
functionâ€”just the number `5` by itself. Thatâ€™s a perfectly valid function in
Cairo. Note that the functionâ€™s return type is specified too, as `-> u32`. Try
running this code; the output should look like this:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_20_function_return_values
The value of x is: 5
Run completed successfully, returning []

```

The `5` in `five` is the functionâ€™s return value, which is why the return type
is `u32`. Letâ€™s examine this in more detail. There are two important bits:
first, the line `let x = five();` shows that weâ€™re using the return value of a
function to initialize a variable. Because the function `five` returns a `5`,
that line is the same as the following:

```cairo noplayground hljs

let x = 5;

```

Second, the `five` function has no parameters and defines the type of the
return value, but the body of the function is a lonely `5` with no semicolon
because itâ€™s an expression whose value we want to return.
Letâ€™s look at another example:

```cairo hljs

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -> u32 {
    x + 1
}

```

Running this code will print `x = 6`. But if we place a
semicolon at the end of the line containing `x + 1`, changing it from an
expression to a statement, weâ€™ll get an error:

```cairo does_not_compile hljs

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -> u32 {
    x + 1;
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)
error: Unexpected return type. Expected: "core::integer::u32", found: "()".
 --> listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:9:28
fn plus_one(x: u32) -> u32 {
                           ^

error: could not compile `no_listing_22_function_return_invalid` due to previous error
error: `scarb metadata` exited with error

```

The main error message, `Unexpected return type`, reveals the core issue with this
code. The definition of the function `plus_one` says that it will return an
`u32`, but statements donâ€™t evaluate to a value, which is expressed by `()`,
the unit type. Therefore, nothing is returned, which contradicts the function
definition and results in an error.

Start

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=656321864.1738497933&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=1901084790)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/tr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch06-01-enums.md "Suggest an edit")

Enumlar, "enumerasyonlar" iÃ§in kÄ±sa, sabit bir adlandÄ±rÄ±lmÄ±ÅŸ deÄŸer kÃ¼mesinden oluÅŸan Ã¶zel bir veri tipi tanÄ±mlamanÄ±n bir yoludur. Enumlar, her biri belirgin ve belirli bir anlama sahip olan iliÅŸkili deÄŸerlerin bir koleksiyonunu temsil etmek iÃ§in yararlÄ±dÄ±r.

Ä°ÅŸte basit bir enum Ã¶rneÄŸi:

```cairo noplayground hljs

#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}

```

In this example, we've defined an enum called `Direction` with four variants: `North`, `East`, `South`, and `West`. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the `Direction` type. In this particular example, variants don't have any associated value. One variant can be instantiated using this syntax:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}

fn main() {
    let direction = Direction::North;
}

```

Now let's imagine that our variants have associated values, that store the exact degree of the direction. We can define a new `Direction` enum:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}

fn main() {
    let direction = Direction::North(10);
}

```

and instantiate it as follows:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}

fn main() {
    let direction = Direction::North(10);
}

```

In this code, each variant is associated with a `u128` value, representing the direction in degrees. In the next example, we will see that it is also possible to associate different data types with each variant.

It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a direction. You can learn more about it in the [Match Control Flow Construct](https://book.cairo-lang.org/tr/ch06-02-the-match-control-flow-construct.html) section.

Enums can also be used to store more interesting custom data associated with each variant. For example:

```cairo noplayground hljs

#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}

```

In this example, the `Message` enum has three variants: `Quit`, `Echo`, and `Move`, all with different types:

- `Quit` herhangi bir iliÅŸkilendirilmiÅŸ deÄŸere sahip deÄŸildir.
- `Echo` is a single `felt252`.
- `Move` is a tuple of two `u128` values.

You could even use a Struct or another enum you defined inside one of your enum variants.

Cairo'da, Ã¶zel enumlarÄ±nÄ±z iÃ§in trait'leri tanÄ±mlayabilir ve bunlarÄ± uygulayabilirsiniz. Bu, enumunuzla iliÅŸkilendirilmiÅŸ metodlarÄ± ve davranÄ±ÅŸlarÄ± tanÄ±mlamanÄ±za olanak tanÄ±r. Ä°ÅŸte Ã¶nceki `Message` enumu iÃ§in bir trait tanÄ±mlayÄ±p bunu uygulama Ã¶rneÄŸi:

```cairo noplayground hljs

trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit => { println!("quitting") },
            Message::Echo(value) => { println!("echoing {}", value) },
            Message::Move((x, y)) => { println!("moving from {} to {}", x, y) },
        }
    }
}

```

In this example, we implemented the `Processing` trait for `Message`. Here is how it could be used to process a `Quit` message:

```cairo hljs hide-boring

#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}

trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit => { println!("quitting") },
            Message::Echo(value) => { println!("echoing {}", value) },
            Message::Move((x, y)) => { println!("moving from {} to {}", x, y) },
        }
    }
}
fn main() {
    let msg: Message = Message::Quit;
    msg.process(); // prints "quitting"
}

```

The `Option` enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: `Some: T` and `None`. `Some: T` indicates that there's a value of type `T`, while `None` represents the absence of a value.

```cairo noplayground hljs

enum Option<T> {
    Some: T,
    None,
}

```

`Option` enumu yararlÄ±dÄ±r Ã§Ã¼nkÃ¼ bir deÄŸerin yokluÄŸunun aÃ§Ä±kÃ§a temsil edilmesine izin verir, kodunuzu daha ifade edilebilir ve hakkÄ±nda dÃ¼ÅŸÃ¼nmesi daha kolay hale getirir. `Option` kullanmak, baÅŸlatÄ±lmamÄ±ÅŸ veya beklenmedik `null` deÄŸerleri nedeniyle oluÅŸan hatalarÄ± Ã¶nlemeye de yardÄ±mcÄ± olabilir.

To give you an example, here is a function which returns the index of the first element of an array with a given value, or `None` if the element is not present.

YukarÄ±daki fonksiyon iÃ§in iki yaklaÅŸÄ±mÄ± gÃ¶steriyoruz:

- Recursive approach with `find_value_recursive`.
- Iterative approach with `find_value_iterative`.

```cairo noplayground hljs

fn find_value_recursive(mut arr: Span<felt252>, value: felt252, index: usize) -> Option<usize> {
    match arr.pop_front() {
        Option::Some(index_value) => { if (*index_value == value) {
            return Option::Some(index);
        } },
        Option::None => { return Option::None; },
    };

    find_value_recursive(arr, value, index + 1)
}

fn find_value_iterative(mut arr: Span<felt252>, value: felt252) -> Option<usize> {
    let mut result = Option::None;
    let mut index = 0;

    while let Option::Some(array_value) = arr.pop_front() {
        if (*array_value == value) {
            result = Option::Some(index);
            break;
        };

        index += 1;
    };

    result
}

```

Enums can be useful in many situations, especially when using the `match` flow construct that we just used. We will describe it in the next section.

Other enums are used very often, such as the `Result` enum, allowing to handle errors gracefully. We will explain the `Result` enum in detail in the ["Error Handling"](https://book.cairo-lang.org/tr/ch09-02-recoverable-errors.html#the-result-enum) chapter.

Start

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1726210381.1738497934&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1368488224)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch09-02-recoverable-errors.md "Suggest an edit")

Kebanyakan kesalahan tidak serius sehingga memerlukan program untuk berhenti sepenuhnya. Terkadang, ketika sebuah fungsi gagal, itu karena alasan yang dapat Anda terjemahkan dan tanggapi dengan mudah. Sebagai contoh, jika Anda mencoba untuk menambahkan dua bilangan bulat besar dan operasinya melebihi kapasitas maksimum yang dapat direpresentasikan sehingga terjadi overflow, Anda mungkin ingin mengembalikan kesalahan atau hasil yang dibungkus daripada menyebabkan perilaku yang tidak terdefinisi atau menghentikan proses.

Recall from [Generic data types](https://book.cairo-lang.org/id/ch08-01-generic-data-types.html#enums) section in Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and `Err`, as follows:

```cairo noplayground hljs

enum Result<T, E> {
    Ok: T,
    Err: E,
}

```

Enum `Result<T, E>` memiliki dua tipe generik, `T` dan `E`, dan dua variasi: `Ok` yang menyimpan nilai tipe `T` dan `Err` yang menyimpan nilai tipe `E`. Definisi ini membuatnya nyaman untuk menggunakan enum `Result` di mana pun kita memiliki operasi yang mungkin berhasil (dengan mengembalikan nilai tipe `T`) atau gagal (dengan mengembalikan nilai tipe `E`).

Trait `ResultTrait` menyediakan metode-metode untuk bekerja dengan enum `Result<T, E>`, seperti membuka nilai-nilai, memeriksa apakah `Result` adalah `Ok` atau `Err`, dan melakukan panic dengan pesan kustom. Implementasi `ResultTraitImpl` mendefinisikan logika dari metode-metode ini.

```cairo noplayground hljs

trait ResultTrait<T, E> {
    fn expect<+Drop<E>>(self: Result<T, E>, err: felt252) -> T;

    fn unwrap<+Drop<E>>(self: Result<T, E>) -> T;

    fn expect_err<+Drop<T>>(self: Result<T, E>, err: felt252) -> E;

    fn unwrap_err<+Drop<T>>(self: Result<T, E>) -> E;

    fn is_ok(self: @Result<T, E>) -> bool;

    fn is_err(self: @Result<T, E>) -> bool;
}

```

Metode `expect` dan `unwrap` mirip dalam hal keduanya mencoba mengekstrak nilai tipe `T` dari sebuah `Result<T, E>` saat berada dalam varian `Ok`. Jika `Result` adalah `Ok(x)`, kedua metode mengembalikan nilai `x`. Namun, perbedaan utama antara kedua metode tersebut terletak pada perilaku mereka saat `Result` berada dalam varian `Err`. Metode `expect` memungkinkan Anda untuk memberikan pesan kesalahan kustom (sebagai nilai `felt252`) yang akan digunakan saat terjadi panic, memberikan lebih banyak kontrol dan konteks atas panic tersebut. Di sisi lain, metode `unwrap` akan panic dengan pesan kesalahan default, memberikan informasi yang lebih sedikit tentang penyebab dari panic.

The `expect_err` and `unwrap_err` methods have the exact opposite behavior. If the `Result` is `Err(x)`, both methods return the value `x`. However, the key difference between the two methods is in case of `Result::Ok()`. The `expect_err` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap_err` method panics with a default error message, providing less information about the cause of the panic.

A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the first four methods signatures. This syntax represents generic type constraints in the Cairo language, as seen in the previous chapter. These constraints indicate that the associated functions require an implementation of the `Drop` trait for the generic types `T` and `E`, respectively.

Akhirnya, metode `is_ok` dan `is_err` adalah fungsi utilitas yang disediakan oleh trait `ResultTrait` untuk memeriksa varian dari nilai enumerasi `Result`.

- `is_ok` mengambil gambaran (snapshot) dari nilai `Result<T, E>` dan mengembalikan `true` jika `Result` merupakan varian `Ok`, yang berarti operasi berhasil. Jika `Result` merupakan varian `Err`, maka mengembalikan `false`.
- `is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Err` variant, meaning the operation encountered an error. If the `Result` is the `Ok` variant, it returns `false`.

These methods are helpful when you want to check the success or failure of an operation without consuming the `Result` value, allowing you to perform additional operations or make decisions based on the variant without unwrapping it.

Anda dapat menemukan implementasi dari `ResultTrait` [di sini](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20).

It is always easier to understand with examples. Have a look at this function signature:

```cairo noplayground hljs

fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;

```

It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, u128>` where the `Ok` variant holds the sum if the addition does not overflow, and the `Err` variant holds the overflowed value if the addition does overflow.

Sekarang, kita dapat menggunakan fungsi ini di tempat lain. Misalnya:

```cairo noplayground hljs

fn u128_checked_add(a: u128, b: u128) -> Option<u128> {
    match u128_overflowing_add(a, b) {
        Result::Ok(r) => Option::Some(r),
        Result::Err(r) => Option::None,
    }
}

```

Here, it accepts two `u128` integers, `a` and `b`, and returns an `Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to determine the success or failure of the addition operation. The `match` expression checks the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it returns `Option::None` to indicate that the operation has failed due to overflow. The function does not panic in case of an overflow.

Let's take another example:

```cairo noplayground hljs

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

```

In this example, the `parse_u8` function takes a `felt252` and tries to convert it into a `u8` integer using the `try_into` method. If successful, it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid integer')`.

Dua kasus uji kita adalah:

```cairo noplayground hljs hide-boring

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_felt252_to_u8() {
        let number: felt252 = 5;
        // should not panic
        let res = parse_u8(number).unwrap();
    }

    #[test]
    #[should_panic]
    fn test_felt252_to_u8_panic() {
        let number: felt252 = 256;
        // should panic
        let res = parse_u8(number).unwrap();
    }
}

```

Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in more detail its meaning in the next [Testing Cairo Programs](https://book.cairo-lang.org/id/ch10-01-how-to-write-tests.html) chapter.

`#[test]` attribute means the function is a test function, and `#[should_panic]` attribute means this test will pass if the test execution panics.

The first one tests a valid conversion from `felt252` to `u8`, expecting the `unwrap` method not to panic. The second test function attempts to convert a value that is out of the `u8` range, expecting the `unwrap` method to panic with the error message `Invalid integer`.

Operator terakhir yang akan kita bahas adalah operator `?`. Operator `?` digunakan untuk penanganan kesalahan yang lebih idiomatik dan ringkas. Ketika Anda menggunakan operator `?` pada tipe `Result` atau `Option`, itu akan melakukan hal berikut:

- Jika nilainya adalah `Result::Ok(x)` atau `Option::Some(x)`, maka akan mengembalikan nilai dalamnya, yaitu `x`, secara langsung.
- Jika nilainya adalah `Result::Err(e)` atau `Option::None`, maka akan menyebarkan kesalahan atau `None` dengan segera mengembalikan dari fungsi tersebut.

Operator `?` berguna ketika Anda ingin menangani kesalahan secara implisit dan membiarkan fungsi pemanggil menanganinya.

Berikut adalah contohnya:

```cairo noplayground hljs

fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {
    let input_to_u8: u8 = parse_u8(input)?;
    // DO SOMETHING
    let res = input_to_u8 - 1;
    Result::Ok(res)
}

```

We can see that `do_something_with_parse_u8` function takes a `felt252` value as input and calls `parse_u8` function. The `?` operator is used to propagate the error, if any, or unwrap the successful value.

Dan dengan sedikit kasus uji:

```cairo noplayground hljs hide-boring

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {
    let input_to_u8: u8 = parse_u8(input)?;
    // DO SOMETHING
    let res = input_to_u8 - 1;
    Result::Ok(res)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_function_2() {
        let number: felt252 = 258;
        match do_something_with_parse_u8(number) {
            Result::Ok(value) => println!("Result: {}", value),
            Result::Err(e) => println!("Error: {}", e),
        }
    }
}

```

The console will print the error `Invalid Integer`.

We saw that recoverable errors can be handled in Cairo using the `Result` enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is generic, with types `T` and `E` representing the successful and error values, respectively. The `ResultTrait` provides methods for working with `Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or `Err`, and panicking with custom messages.

Untuk menangani kesalahan yang dapat dipulihkan, sebuah fungsi dapat mengembalikan tipe `Result` dan menggunakan pola pencocokan untuk menangani keberhasilan atau kegagalan suatu operasi. Operator `?` dapat digunakan untuk menangani kesalahan secara implisit dengan menyebarkan kesalahan atau membuka nilai yang berhasil. Ini memungkinkan penanganan kesalahan yang lebih ringkas dan jelas, di mana pemanggil bertanggung jawab untuk mengelola kesalahan yang dihasilkan oleh fungsi yang dipanggil.

Start

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1806769045.1738497935&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=36958123)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/fr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-05-control-flow.md "Suggest an edit")

The ability to run some code depending on whether a condition is true and to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Cairo code are if expressions and loops.

An if expression allows you to branch your code depending on conditions. You provide a condition and then state, â€œIf this condition is met, run this block of code. If the condition is not met, do not run this block of code.â€

Create a new project called _branches_ in your _cairo\_projects_ directory to explore the `if` expression. In the _src/lib.cairo_ file, input the following:

```cairo hljs

fn main() {
    let number = 3;

    if number == 5 {
        println!("condition was true and number = {}", number);
    } else {
        println!("condition was false and number = {}", number);
    }
}

```

All `if` expressions start with the keyword `if`, followed by a condition. In this case, the condition checks whether or not the variable `number` has a value equal to 5. We place the block of code to execute if the condition is `true` immediately after the condition inside curly brackets.

Optionally, we can also include an `else` expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to `false`. If you donâ€™t provide an `else` expression and the condition is `false`, the program will just skip the `if` block and move on to the next bit of code.

Try running this code; you should see the following output:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_24_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_24_if
condition was false and number = 3
Run completed successfully, returning []

```

Letâ€™s try changing the value of `number` to a value that makes the condition `true` to see what happens:

```cairo noplayground hljs

    let number = 5;

```

```shell hljs

$ scarb cairo-run
condition was true and number = 5
Run completed successfully, returning []

```

Itâ€™s also worth noting that the condition in this code must be a `bool`. If the condition isnâ€™t a `bool`, weâ€™ll get an error. For example, try running the following code:

```cairo hljs

fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}

```

The `if` condition evaluates to a value of 3 this time, and Cairo throws an error:

```shell hljs

$ scarb build
   Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)
error: Mismatched types. The type `core::bool` cannot be created from a numeric literal.
 --> listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:4:18
    let number = 3;
                 ^

error: could not compile `no_listing_28_bis_if_not_bool` due to previous error

```

The error indicates that Cairo inferred the type of `number` to be a `bool` based on its later use as a condition of the `if` statement. It tries to create a `bool` from the value `3`, but Cairo doesn't support instantiating a `bool` from a numeric literal anyway - you can only use `true` or `false` to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will not automatically try to convert non-Boolean types to a Boolean. If we want the `if` code block to run only when a number is not equal to 0, for example, we can change the if expression to the following:

```cairo hljs

fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}

```

Running this code will print `number was something other than zero`.

You can use multiple conditions by combining `if` and `else` in an `else if` expression. For example:

```cairo hljs

fn main() {
    let number = 3;

    if number == 12 {
        println!("number is 12");
    } else if number == 3 {
        println!("number is 3");
    } else if number - 2 == 1 {
        println!("number minus 2 is 1");
    } else {
        println!("number not found");
    }
}

```

This program has four possible paths it can take. After running it, you should see the following output:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_25_else_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_25_else_if
number is 3
Run completed successfully, returning []

```

When this program executes, it checks each `if` expression in turn and executes the first body for which the condition evaluates to `true`. Note that even though `number - 2 == 1` is `true`, we donâ€™t see the output `number minus 2 is 1` nor do we see the `number not found` text from the `else` block. Thatâ€™s because Cairo only executes the block for the first true condition, and once it finds one, it doesnâ€™t even check the rest. Using too many `else if` expressions can clutter your code, so if you have more than one, you might want to refactor your code. [Chapter 6](https://book.cairo-lang.org/fr/ch06-02-the-match-control-flow-construct.html) describes a powerful Cairo branching construct called `match` for these cases.

Because `if` is an expression, we can use it on the right side of a `let` statement to assign the outcome to a variable.

```cairo hljs

fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    if number == 5 {
        println!("condition was true and number is {}", number);
    }
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_26_if_let v0.1.0 (listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_26_if_let
condition was true and number is 5
Run completed successfully, returning []

```

The `number` variable will be bound to a value based on the outcome of the `if` expression, which will be 5 here.

Itâ€™s often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, which will run through the code inside the loop body to the end and then start immediately back at the beginning. To experiment with loops, letâ€™s create a new project called _loops_.

Cairo has three kinds of loops: `loop`, `while`, and `for`. Letâ€™s try each one.

The `loop` keyword tells Cairo to execute a block of code over and over again forever or until you explicitly tell it to stop.

As an example, change the _src/lib.cairo_ file in your _loops_ directory to look like this:

```cairo hljs

fn main() {
    loop {
        println!("again!");
    }
}

```

When we run this program, weâ€™ll see `again!` printed over and over continuously until either the program runs out of gas or we stop the program manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a program that is stuck in a continual loop. Give it a try:

```shell hljs

$ scarb cairo-run --available-gas=20000000
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished release target(s) in 0 seconds
     Running loops
again!
again!
again!
^Cagain!

```

The symbol `^C` represents where you pressed ctrl-c. You may or may not see the word `again!` printed after the ^C, depending on where the code was in the loop when it received the interrupt signal.

> Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a mechanism that limits the amount of computation that can be done in a program. By setting a value to the `--available-gas` flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurement that expresses the computation cost of an instruction. When the gas meter runs out, the program will stop. In the previous case, we set the gas limit high enough for the program to run for quite some time.

> It is particularly important in the context of smart contracts deployed on Starknet, as it prevents from running infinite loops on the network. If you're writing a program that needs to run a loop, you will need to execute it with the `--available-gas` flag set to a value that is large enough to run the program.

Now, try running the same program again, but this time with the `--available-gas` flag set to `200000` instead of `2000000000000`. You will see the program only prints `again!` 3 times before it stops, as it ran out of gas to keep executing the loop.

Fortunately, Cairo also provides a way to break out of a loop using code. You can place the `break` keyword within the loop to tell the program when to stop executing the loop.

```cairo hljs

fn main() {
    let mut i: usize = 0;
    loop {
        if i > 10 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}

```

The `continue` keyword tells the program to go to the next iteration of the loop and to skip the rest of the code in this iteration. Let's add a `continue` statement to our loop to skip the `println!` statement when `i` is equal to `5`.

```cairo hljs

fn main() {
    let mut i: usize = 0;
    loop {
        if i > 10 {
            break;
        }
        if i == 5 {
            i += 1;
            continue;
        }
        println!("i = {}", i);
        i += 1;
    }
}

```

Executing this program will not print the value of `i` when it is equal to `5`.

One of the uses of a `loop` is to retry an operation you know might fail, such as checking whether an operation has succeeded. You might also need to pass the result of that operation out of the loop to the rest of your code. To do this, you can add the value you want returned after the `break` expression you use to stop the loop; that value will be returned out of the loop so you can use it, as shown here:

```cairo hljs

fn main() {
    let mut counter = 0;

    let result = loop {
        if counter == 10 {
            break counter * 2;
        }
        counter += 1;
    };

    println!("The result is {}", result);
}

```

Before the loop, we declare a variable named `counter` and initialize it to `0`. Then we declare a variable named `result` to hold the value returned from the loop. On every iteration of the loop, we check whether the `counter` is equal to `10`, and then add `1` to the `counter` variable. When the condition is met, we use the `break` keyword with the value `counter * 2`. After the loop, we use a semicolon to end the statement that assigns the value to `result`. Finally, we print the value in `result`, which in this case is `20`.

A program will often need to evaluate a condition within a loop. While the condition is `true`, the loop runs. When the condition ceases to be `true`, the program calls `break`, stopping the loop. Itâ€™s possible to implement behavior like this using a combination of `loop`, `if`, `else`, and `break`; you could try that now in a program, if youâ€™d like. However, this pattern is so common that Cairo has a built-in language construct for it, called a `while` loop.

In Listing 2-2, we use `while` to loop the program three times, counting down each time after printing the value of `number`, and then, after the loop, print a message and exit.

```cairo hljs

fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    };

    println!("LIFTOFF!!!");
}

```

Listing 2-2: Using a `while` loop to run code while a condition holds `true`.

This construct eliminates a lot of nesting that would be necessary if you used `loop`, `if`, `else`, and `break`, and itâ€™s clearer. While a condition evaluates to `true`, the code runs; otherwise, it exits the loop.

You can also use the while construct to loop over the elements of a collection, such as an array. For example, the loop in Listing 2-3 prints each element in the array `a`.

```cairo hljs

fn main() {
    let a = [10, 20, 30, 40, 50].span();
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}

```

Listing 2-3: Looping through each element of a collection using a `while` loop

Here, the code counts up through the elements in the array. It starts at index `0`, and then loops until it reaches the final index in the array (that is, when `index < 5` is no longer `true`). Running this code will print every element in the array:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_45_iter_loop_while v0.1.0 (listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_45_iter_loop_while
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
Run completed successfully, returning []

```

All five array values appear in the terminal, as expected. Even though `index` will reach a value of `5` at some point, the loop stops executing before trying to fetch a sixth value from the array.

However, this approach is error prone; we could cause the program to panic if the index value or test condition is incorrect. For example, if you changed the definition of the `a` array to have four elements but forgot to update the condition to `while index < 4`, the code would panic. Itâ€™s also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.

As a more concise alternative, you can use a `for` loop and execute some code for each item in a collection. A `for` loop looks like the code in Listing 2-4.

```cairo hljs

fn main() {
    let a = [10, 20, 30, 40, 50].span();

    for element in a {
        println!("the value is: {element}");
    }
}

```

Listing 2-4: Looping through each element of a collection using a `for` loop

When we run this code, weâ€™ll see the same output as in Listing 2-3. More importantly, weâ€™ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.

Using the `for` loop, you wouldnâ€™t need to remember to change any other code if you changed the number of values in the array, as you would with the method used in Listing 2-3.

The safety and conciseness of `for` loops make them the most commonly used loop construct in Cairo. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a while loop in Listing 2-2. Another way to run code a certain number of times would be to use a `Range`, provided by the core library, which generates all numbers in sequence starting from one number and ending before another number.

Hereâ€™s how you can use a `Range` to count from 1 to 3:

```cairo hljs

fn main() {
    for number in 1..4_u8 {
        println!("{number}!");
    };
    println!("Go!!!");
}

```

This code is a bit nicer, isnâ€™t it?

Loops and recursive functions are two common ways to repeat a block of code multiple times. The `loop` keyword is used to create an infinite loop that can be broken by using the `break` keyword.

```cairo hljs

fn main() -> felt252 {
    let mut x: felt252 = 0;
    loop {
        if x == 2 {
            break;
        } else {
            x += 1;
        }
    };
    x
}

```

Loops can be transformed into recursive functions by calling the function within itself. Here is an example of a recursive function that mimics the behavior of the `loop` example above.

```cairo hljs

fn main() -> felt252 {
    recursive_function(0)
}

fn recursive_function(mut x: felt252) -> felt252 {
    if x == 2 {
        x
    } else {
        recursive_function(x + 1)
    }
}

```

In both cases, the code block will run indefinitely until the condition `x == 2` is met, at which point the value of x will be displayed.

In Cairo, loops and recursions are not only conceptually equivalent: they are also compiled down to similar low-level representations. To understand this, we can compile both examples to Sierra, and analyze the Sierra Code generated by the Cairo compiler for both examples. Add the following in your `Scarb.toml` file:

```toml hljs ini

[lib]
sierra-text = true

```

Then, run `scarb build` to compile both examples. You will find the Sierra code generated by for both examples is extremely similar, as the loop is compiled to a recursive function in the Sierra statements.

> Note: For our example, our findings came from understanding the **statements** section in Sierra that shows the execution traces of the two programs. If you are curious to learn more about Sierra, check out [Exploring Sierra](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5).

Start

You made it! This was a sizable chapter: you learned about variables, data types, functions, comments, `if` expressions and loops! To practice with the concepts discussed in this chapter, try building programs to do the following:

- Generate the _n_-th Fibonacci number.
- Compute the factorial of a number _n_.

Now, weâ€™ll review the common collection types in Cairo in the next chapter.

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-01-installation.md "Suggest an edit")

Cairo puede instalarse simplemente descargando [Scarb](https://docs.swmansion.com/scarb/docs). Scarb incluye el compilador Cairo y el servidor de lenguaje Cairo en un paquete fÃ¡cil de instalar para que puedas empezar a escribir cÃ³digo Cairo inmediatamente.

Scarb es el gestor de paquetes de Cairo y estÃ¡ fuertemente inspirado en [Cargo](https://doc.rust-lang.org/cargo/), el sistema de construcciÃ³n y gestor de paquetes de Rust.

Scarb se encarga de muchas tareas por ti, como construir tu cÃ³digo (ya sea en Cairo puro o contratos Starknet), descargar las librerias necesarias para tu cÃ³digo, construir esas librerias y proporcionar soporte LSP (Language Server Protocol) para la extensiÃ³n de Cairo 1 en VSCode.

A medida que escribas programas Cairo mÃ¡s complejos, es posible que aÃ±adas dependencias, y si comienzas un proyecto utilizando Scarb, gestionar elcÃ³digo externo y las dependencias serÃ¡ mucho mÃ¡s fÃ¡cil de hacer.

[Starknet Foundry](https://foundry-rs.github.io/starknet-foundry/index.html) is a toolchain for Cairo programs and Starknet smart contract development. It supports many features, including writing and running tests with advanced features, deploying contracts, interacting with the Starknet network, and more.

Let's start by installing Scarb and Starknet Foundry.

Scarb requiere un ejecutable Git disponible en la variable de entorno `PATH`.

To install Scarb, please refer to the [installation instructions](https://docs.swmansion.com/scarb/download). We strongly recommend that you install Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a CLI tool that can manage multiple language runtime versions on a per-project basis. This will ensure that the version of Scarb you use to work on a project always matches the one defined in the project settings, avoiding problems related to version mismatches.

Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-started.html) to install all prerequisites.

Once you have asdf installed locally, you can download Scarb plugin with the following command:

```bash hljs

asdf plugin add scarb

```

This will allow you to download specific versions:

```bash hljs

asdf install scarb 2.9.2

```

and set a global version:

```bash hljs

asdf global scarb 2.9.2

```

Otherwise, you can simply run the following command in your terminal, and follow the onscreen instructions. This will install the latest stable release of Scarb.

```bash hljs

curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh

```

In both cases, you can verify installation by running the following command in a new terminal session, it should print both Scarb and Cairo language versions, e.g:

```bash hljs

$ scarb --version
scarb 2.9.2 (5070ff374 2024-12-11)
cairo: 2.9.2 (https://crates.io/crates/cairo-lang-compiler/2.9.2)
sierra: 1.6.0

```

To install Starknet Foundry, please refer to the [installation instructions](https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html). We also recommend that you install it via asdf.

Once installed, you can run the following command to see the version:

```bash hljs

$ snforge --version
snforge 0.35.1

```

We'll describe Starknet Foundry in more detail in [Chapter 10](https://book.cairo-lang.org/es/ch10-01-how-to-write-tests.html) for Cairo programs testing and in [Chapter 18](https://book.cairo-lang.org/es/ch104-02-testing-smart-contracts.html#testing-smart-contracts-with-starknet-foundry) when discussing Starknet smart contract testing and security in the second part of the book.

Cairo tiene una extensiÃ³n VSCode que proporciona resaltado de sintaxis, cairo1). Una vez instalada, ve a la configuraciÃ³n de la extensiÃ³n, y asegÃºrate de marcar las opciones `Enable Language Server` y `Enable Scarb` options."

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1485452039.1738497936&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=2009994758)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch11-00-functional-features.md "Suggest an edit")

Cairoâ€™s design has taken strong inspiration from Rust, which itself has taken inspiration from many
existing languages and techniques, and one significant influence is _functional programming_.
Programming in a functional style often includes using functions as values by passing them in
arguments, returning them from other functions, assigning them to variables for later execution, and
so forth.

In this chapter, we wonâ€™t debate the issue of what functional programming is or
isnâ€™t but will instead discuss some features of Cairo that are similar to
features in Rust and many languages often referred to as functional.

More specifically, weâ€™ll cover:

- _Closures_, a function-like construct you can store in a variable
- _Iterators_, a way of processing a series of elements -->


Weâ€™ve already covered some other Cairo features, such as pattern matching and
enums, that are also influenced by the Rust and the functional style. Because mastering
closures and iterators is an important part of writing idiomatic, fast Cairo
code, weâ€™ll devote this entire chapter to them.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1139260188.1738497937&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1145652876)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1173687184.1738497938&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015666~102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=1526172820)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-01-keywords.md "Suggest an edit")

The following list contains keywords that are reserved for current or future use by the Cairo language.

There are three keyword categories:

- strict
- loose
- reserved

There is a fourth category, which are functions from the core library. While their names are not reserved,
they are not recommended to be used as names of any items to follow good practices.

* * *

These keywords can only be used in their correct contexts.
They cannot be used as names of any items.

- `as` \- Rename import
- `break` \- Exit a loop immediately
- `const` \- Define constant items
- `continue` \- Continue to the next loop iteration
- `else` \- Fallback for `if` and `if let` control flow constructs
- `enum` \- Define an enumeration
- `extern` \- Function defined at the compiler level that can be compiled to CASM
- `false` \- Boolean false literal
- `fn` \- Define a function
- `if` \- Branch based on the result of a conditional expression
- `impl` \- Implement inherent or trait functionality
- `implicits` \- Special kind of function parameters that are required to perform certain actions
- `let` \- Bind a variable
- `loop` \- Loop unconditionally
- `match` \- Match a value to patterns
- `mod` \- Define a module
- `mut` \- Denote variable mutability
- `nopanic` \- Functions marked with this notation mean that the function will never panic.
- `of` \- Implement a trait
- `pub` \- Denote public visibility in items, such as struct and struct fields, enums, consts, traits and impl blocks, or modules
- `ref` \- Parameter passed implicitly returned at the end of a function
- `return` \- Return from function
- `struct` \- Define a structure
- `trait` \- Define a trait
- `true` \- Boolean true literal
- `type` \- Define a type alias
- `use` \- Bring symbols into scope
- `while` \- loop conditionally based on the result of an expression

* * *

These keywords are associated with a specific behaviour, but can also be used to define items.

- `self` \- Method subject
- `super` \- Parent module of the current module

* * *

These keywords aren't used yet, but they are reserved for future use.
For now, it is possible to use them to define items, although it is highly recommended not to do so.
The reasoning behind this recommendation is to make current programs forward compatible with future versions of
Cairo by forbidding them to use these keywords.

- `Self`
- `do`
- `dyn`
- `for`
- `hint`
- `in`
- `macro`
- `move`
- `static_assert`
- `static`
- `try`
- `typeof`
- `unsafe`
- `where`
- `with`
- `yield`

* * *

The Cairo programming language provides several specific functions that serve a special purpose. We will not cover all of them in this book, but using the names of these functions as names of other items is not recommended.

- `assert` \- This function checks a boolean expression, and if it evaluates to false, it triggers the panic function.
- `panic` \- This function acknowledges the occurrence of an error and terminates the program.

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-03-derivable-traits.md "Suggest an edit")

In various places in the book, weâ€™ve discussed the `derive` attribute, which you can apply to a struct or enum definition. The `derive` attribute generates code to implement a default trait on the type youâ€™ve annotated with the `derive` syntax.

In this appendix, we provide a comprehensive reference detailing all the traits in the standard library compatible with the `derive` attribute.

These traits listed here are the only ones defined by the core library that can be implemented on your types using `derive`. Other traits defined in the standard library donâ€™t have sensible default behavior, so itâ€™s up to you to implement them in a way that makes sense for what youâ€™re trying to accomplish.

When moving out of scope, variables need to be moved first. This is where the `Drop` trait intervenes. You can find more details about its usage [here](https://book.cairo-lang.org/ch04-01-what-is-ownership.html#no-op-destruction-the-drop-trait).

Moreover, Dictionaries need to be squashed before going out of scope. Calling the `squash` method on each of them manually can quickly become redundant. `Destruct` trait allows Dictionaries to be automatically squashed when they get out of scope. You can also find more information about `Destruct` [here](https://book.cairo-lang.org/ch04-01-what-is-ownership.html#destruction-with-a-side-effect-the-destruct-trait).

The `Clone` trait provides the functionality to explicitly create a deep copy of a value.

Deriving `Clone` implements the `clone` method, which, in turn, calls clone on each of the type's components. This means all the fields or values in the type must also implement `Clone` to derive `Clone`.

Here is a simple example:

```cairo hljs

#[derive(Clone, Drop)]
struct A {
    item: felt252,
}

fn main() {
    let first_struct = A { item: 2 };
    let second_struct = first_struct.clone();
    assert!(second_struct.item == 2, "Not equal");
}

```

The `Copy` trait allows for the duplication of values. You can derive `Copy` on any type whose parts all implement `Copy`.

Example:

```cairo hljs

#[derive(Copy, Drop)]
struct A {
    item: felt252,
}

fn main() {
    let first_struct = A { item: 2 };
    let second_struct = first_struct;
    // Copy Trait prevents first_struct from moving into second_struct
    assert!(second_struct.item == 2, "Not equal");
    assert!(first_struct.item == 2, "Not Equal");
}

```

The `Debug` trait enables debug formatting in format strings, which you indicate by adding `:?` within `{}` placeholders.

It allows you to print instances of a type for debugging purposes, so you and other programmers using this type can inspect an instance at a particular point in a programâ€™s execution.

For example, if you want to print the value of a variable of type `Point`, you can do it as follows:

```cairo hljs

#[derive(Copy, Drop, Debug)]
struct Point {
    x: u8,
    y: u8,
}

fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{:?}", p);
}

```

```shell hljs

scarb cairo-run
Point { x: 1, y: 3 }

```

The `Debug` trait is required, for example, when using the `assert_xx!` macros in tests. These macros print the values of instances given as arguments if the equality or comparison assertion fails so programmers can see why the two instances werenâ€™t equal.

The `Default` trait allows creation of a default value of a type. The most common default value is zero. All primitive types in the standard library implement `Default`.

If you want to derive `Default` on a composite type, each of its elements must already implement `Default`. If you have an [`enum`](https://book.cairo-lang.org/ch06-01-enums.html) type, you must declare its default value by using the `#[default]` attribute on one of its variants.

An example:

```cairo hljs

#[derive(Default, Drop)]
struct A {
    item1: felt252,
    item2: u64,
}

#[derive(Default, Drop, PartialEq)]
enum CaseWithDefault {
    A: felt252,
    B: u128,
    #[default]
    C: u64,
}

fn main() {
    let defaulted: A = Default::default();
    assert!(defaulted.item1 == 0_felt252, "item1 mismatch");
    assert!(defaulted.item2 == 0_u64, "item2 mismatch");

    let default_case: CaseWithDefault = Default::default();
    assert!(default_case == CaseWithDefault::C(0_u64), "case mismatch");
}

```

The `PartialEq` trait allows for comparison between instances of a type for equality, thereby enabling the `==` and `!=` operators.

When `PartialEq` is derived on structs, two instances are equal only if all their fields are equal; they are not equal if any field is different. When derived for enums, each variant is equal to itself and not equal to the other variants.

You can write your own implementation of the `PartialEq` trait for your type, if you can't derive it or if you want to implement your custom rules. In the following example, we write an implementation for `PartialEq` in which we consider that two rectangles are equal if they have the same area:

```cairo hljs

#[derive(Copy, Drop)]
struct Rectangle {
    width: u64,
    height: u64,
}

impl PartialEqImpl of PartialEq<Rectangle> {
    fn eq(lhs: @Rectangle, rhs: @Rectangle) -> bool {
        (*lhs.width) * (*lhs.height) == (*rhs.width) * (*rhs.height)
    }

    fn ne(lhs: @Rectangle, rhs: @Rectangle) -> bool {
        (*lhs.width) * (*lhs.height) != (*rhs.width) * (*rhs.height)
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 50, height: 30 };

    println!("Are rect1 and rect2 equal? {}", rect1 == rect2);
}

```

The `PartialEq` trait is required when using the `assert_eq!` macro in tests, which needs to be able to compare two instances of a type for equality.

Here is an example:

```cairo hljs

#[derive(PartialEq, Drop)]
struct A {
    item: felt252,
}

fn main() {
    let first_struct = A { item: 2 };
    let second_struct = A { item: 2 };
    assert!(first_struct == second_struct, "Structs are different");
}

```

`Serde` provides trait implementations for `serialize` and `deserialize` functions for data structures defined in your crate. It allows you to transform your structure into an array (or the opposite).

> **[Serialization](https://en.wikipedia.org/wiki/Serialization)** is a process of transforming data structures into a format that can be easily stored or transmitted. Let's say you are running a program and would like to persist its state to be able to resume it later. To do this, you could take each of the objects your program is using and save their information, for example in a file. This is a simplified version of serialization. Now if you want to resume your program with this saved state, you would perform **deserialization**, which means loading the state of the objects from the saved source.

For example:

```cairo hljs

#[derive(Serde, Drop)]
struct A {
    item_one: felt252,
    item_two: felt252,
}

fn main() {
    let first_struct = A { item_one: 2, item_two: 99 };
    let mut output_array = array![];
    first_struct.serialize(ref output_array);
    panic(output_array);
}

```

If you run the `main` function, the output will be:

```shell hljs

Run panicked with [2, 99 ('c'), ].

```

We can see here that our struct `A` has been serialized into the output array. Note that the `serialize` function takes as argument a snapshot of the type you want to convert into an array. This is why deriving `Drop` for `A` is required here, as the `main` function keeps ownership of the `first_struct` struct.

Also, we can use the `deserialize` function to convert the serialized array back into our `A` struct.

Here is an example:

```cairo hljs

#[derive(Serde, Drop)]
struct A {
    item_one: felt252,
    item_two: felt252,
}

fn main() {
    let first_struct = A { item_one: 2, item_two: 99 };
    let mut output_array = array![];
    first_struct.serialize(ref output_array);
    let mut span_array = output_array.span();
    let deserialized_struct: A = Serde::<A>::deserialize(ref span_array).unwrap();
}

```

Here we are converting a serialized array span back to the struct `A`. `deserialize` returns an `Option` so we need to unwrap it. When using `deserialize` we also need to specify the type we want to deserialize into.

It is possible to derive the `Hash` trait on structs and enums. This allows them to be hashed easily using any available hash function. For a struct or an enum to derive the `Hash` attribute, all fields or variants need to be hashable themselves.

You can refer to the [Hashes section](https://book.cairo-lang.org/ch12-04-hash.html) to get more information about how to hash complex data types.

The `starknet::Store` trait is relevant only when building on [Starknet](https://book.cairo-lang.org/ch100-00-introduction-to-smart-contracts.html). It allows for a type to be used in smart contract storage by automatically implementing the necessary read and write functions.

You can find detailed information about the inner workings of Starknet storage in the [Contract storage section](https://book.cairo-lang.org/ch101-01-00-contract-storage.html).

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=556620155.1738497938&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565~102558063&z=132494889)

DisconnectedChatÃ—

SendProcessing math: 100%

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch103-05-01-price-feeds.md "Suggest an edit")

Price feeds enabled by an oracle serve as a bridge between real-world data feed and the blockchain. They provide real time pricing data that is aggregated from multiple trusted external sources ( e.g. crypto exchanges, financial data providers, etc. ) to the blockchain network.

For the example in this book section, we will use Pragma Oracle to read the price feed for `ETH/USD` asset pair and also showcase a mini application that utilizes this feed.

[Pragma Oracle](https://www.pragma.build/) is a leading zero knowledge oracle that provides access to off-chain data on Starknet blockchain in a verifiable way.

To get started with integrating Pragma on your Cairo smart contract for price feed data, edit your project's `Scarb.toml` file to include the path to use Pragma.

```toml hljs ini

[dependencies]
pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib" }

```

After adding the required dependencies for your project, you'll need to define a contract interface that includes the required pragma price feed entry point.

```cairo noplayground hljs

#[starknet::interface]
pub trait IPriceFeedExample<TContractState> {
    fn buy_item(ref self: TContractState);
    fn get_asset_price(self: @TContractState, asset_id: felt252) -> u128;
}

```

Of the two public functions exposed in the `IPriceFeedExample`, the one necessary to interact with the pragma price feed oracle is the `get_asset_price` function, a view function that takes in the `asset_id` argument and returns a `u128` value.

```cairo noplayground hljs

    use pragma_lib::abi::{IPragmaABIDispatcher, IPragmaABIDispatcherTrait};
    use pragma_lib::types::{DataType, PragmaPricesResponse};

```

The snippet above shows the necessary imports you need to add to your contract module in order to interact with the Pragma oracle.

```cairo noplayground hljs

        fn get_asset_price(self: @ContractState, asset_id: felt252) -> u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }

```

The `get_asset_price` function is responsible for retrieving the price of the asset specified by the `asset_id` argument from Pragma Oracle. The `get_data_median` method is called from the `IPragmaDispatcher` instance by passing the `DataType::SpotEntry(asset_id)` as an argument and its output is assigned to a variable named `output` of type `PragmaPricesResponse`. Finally, the function returns the price of the requested asset as a `u128`.

```cairo noplayground hljs

#[starknet::contract]
mod PriceFeedExample {
    use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use super::{ContractAddress, IPriceFeedExample};
    use pragma_lib::abi::{IPragmaABIDispatcher, IPragmaABIDispatcherTrait};
    use pragma_lib::types::{DataType, PragmaPricesResponse};
    use openzeppelin::token::erc20::interface::{ERC20ABIDispatcher, ERC20ABIDispatcherTrait};
    use core::starknet::contract_address::contract_address_const;
    use core::starknet::get_caller_address;

    const ETH_USD: felt252 = 19514442401534788;
    const EIGHT_DECIMAL_FACTOR: u256 = 100000000;

    #[storage]
    struct Storage {
        pragma_contract: ContractAddress,
        product_price_in_usd: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, pragma_contract: ContractAddress) {
        self.pragma_contract.write(pragma_contract);
        self.product_price_in_usd.write(100);
    }

    #[abi(embed_v0)]
    impl PriceFeedExampleImpl of IPriceFeedExample<ContractState> {
        fn buy_item(ref self: ContractState) {
            let caller_address = get_caller_address();
            let eth_price = self.get_asset_price(ETH_USD).into();
            let product_price = self.product_price_in_usd.read();

            // Calculate the amount of ETH needed
            let eth_needed = product_price * EIGHT_DECIMAL_FACTOR / eth_price;

            let eth_dispatcher = ERC20ABIDispatcher {
                contract_address: contract_address_const::<
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
                >() // ETH Contract Address
            };

            // Transfer the ETH to the caller
            eth_dispatcher
                .transfer_from(
                    caller_address,
                    contract_address_const::<
                        0x0237726d12d3c7581156e141c1b132f2db9acf788296a0e6e4e9d0ef27d092a2,
                    >(),
                    eth_needed,
                );
        }

        fn get_asset_price(self: @ContractState, asset_id: felt252) -> u128 {
            // Retrieve the oracle dispatcher
            let oracle_dispatcher = IPragmaABIDispatcher {
                contract_address: self.pragma_contract.read(),
            };

            // Call the Oracle contract, for a spot entry
            let output: PragmaPricesResponse = oracle_dispatcher
                .get_data_median(DataType::SpotEntry(asset_id));

            return output.price;
        }
    }
}

```

> **Note**: Pragma returns the value of different token pairs using the decimal factor of 6 or 8. You can convert the value to the required decimal factor by dividing the value by 10n, where `n` is the decimal factor.

The code above is an example implementation of an applications consuming a price feed from the Pragma oracle. The contract imports necessary modules and interfaces, including the `IPragmaABIDispatcher` for interacting with the Pragma oracle contract and the `ERC20ABIDispatcher` for interacting with the ETH ERC20 token contract.

The contract has a `const` that stores the token pair ID of `ETH/USD`, and a `Storage` struct that holds two fields `pragma_contract` and `product_price_in_usd`. The constructor function initializes the `pragma_contract` address and sets the `product_price_in_usd` to 100.

The `buy_item` function is the main entry point for a user to purchase an item. It retrieves the caller's address. It calls the `get_asset_price` function to get the current price of ETH in USD using the `ETH_USD` asset ID. It calculates the amount of ETH needed to buy the product based on the product price in USD at the corresponding ETH price. It then checks if the caller has enough ETH by calling the `balance_of` method on the ERC20 ETH contract. If the caller has enough ETH, it calls the `transfer_from` method of the `eth_dispatcher` instance to transfer the required amount of ETH from the caller to another contract address.

The `get_asset_price` function is the entry point to interact with the Pragma oracle and has been explained in the section above.

You can get a detailed guide on consuming data using Pragma price feeds on their [documentation](https://docs.pragma.build/Resources/Starknet/data-feeds/consuming-data).

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1308418843.1738497939&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=2001403983)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-05-macros.md "Suggest an edit")

The Cairo language has some plugins that allow developers to simplify their code. They are called `inline_macros` and are a way of writing code that generates other code.

Dalam beberapa situasi, seorang pengembang mungkin perlu mendeklarasikan konstanta yang merupakan hasil dari perhitungan bilangan bulat. Untuk menghitung ekspresi konstan dan menggunakan hasilnya pada saat kompilasi, diperlukan untuk menggunakan macro `consteval_int!`.

Berikut adalah contoh dari `consteval_int!`:

```cairo noplayground hljs

const a: felt252 = consteval_int!(2 * 2 * 2);

```

Ini akan diinterpretasikan sebagai `const a: felt252 = 8;` oleh kompiler.

`selector!("function_name")` macro generates the entry point selector for the given function name.

Please refer to the [Printing](https://book.cairo-lang.org/id/ch12-08-printing.html) page.

Please refer to the [Arrays](https://book.cairo-lang.org/id/ch03-01-arrays.html) page.

See [Unrecoverable Errors with panic](https://book.cairo-lang.org/id/ch09-01-unrecoverable-errors-with-panic.html#panic-macro) page.

See [How to Write Tests](https://book.cairo-lang.org/id/ch10-01-how-to-write-tests.html) page.

See [Printing](https://book.cairo-lang.org/id/ch12-08-printing.html#formatting) page.

See [Printing](https://book.cairo-lang.org/id/ch12-08-printing.html#printing-custom-data-types) page.

Please refer to the [Composability and Components](https://book.cairo-lang.org/id/ch103-02-00-composability-and-components.html) chapter.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=226258267.1738497940&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102525910~102528644~102539968~102546754~102556565~102558063&z=350471944)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-01-arrays.md "Suggest an edit")

Un array es una colecciÃ³n de elementos del mismo tipo. Puedes crear y utilizar mÃ©todos de array mediante el uso del rasgo `ArrayTrait` de la libreria principal.

An important thing to note is that arrays have limited modification options. Arrays are, in fact, queues whose values can't be modified. This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it. You can only append items to the end of an array and remove items from the front.

Creating an array is done with the `ArrayTrait::new()` call. Here's an example of creating an array and appending 3 elements to it:

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

Cuando sea necesario, puedes pasar el tipo esperado de elementos dentro del array al instanciarlo de esta manera, o definir explÃ­citamente el tipo del mismo.

```cairo noplayground hljs

let mut arr = ArrayTrait::<u128>::new();

```

```cairo noplayground hljs

let mut arr:Array<u128> = ArrayTrait::new();

```

Para aÃ±adir un elemento al final de un array, puedes utilizar el mÃ©todo `append()`:

```cairo hljs hide-boring

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

You can only remove elements from the front of an array by using the `pop_front()` method. This method returns an `Option` that can be unwrapped, containing the removed element, or `Option::None` if the array is empty.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    println!("The first value is {}", first_value);
}

```

The above code will print `The first value is 10` as we remove the first element that was added.

En Cairo, la memoria es inmutable, lo que significa que no es posible modificar los elementos de un array una vez que han sido aÃ±adidos. SÃ³lo se pueden aÃ±adir elementos al final de un array y eliminar elementos de la parte frontal de un array. Estas operaciones no requieren mutaciÃ³n de memoria, ya que implican actualizar punteros en lugar de modificar directamente las celdas de memoria.

Para acceder a los elementos de un array, puedes utilizar los mÃ©todos `get()` o `at()` que devuelven diferentes tipos. Utilizar `arr.at(index)` es equivalente a utilizar el operador de subÃ­ndice `arr[index]`.

The `get` function returns an `Option<Box<@T>>`, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the ["References and Snapshots"](https://book.cairo-lang.org/es/ch04-02-references-and-snapshots.html#snapshots) chapter.

He aquÃ­ un ejemplo con el mÃ©todo `get()`:

```cairo hljs

fn main() -> u128 {
    let mut arr = ArrayTrait::<u128>::new();
    arr.append(100);
    let index_to_access =
        1; // Change this value to see different results, what would happen if the index doesn't exist?
    match arr.get(index_to_access) {
        Option::Some(x) => {
            *x
                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
            // It basically means "transform what get(idx) returned into a real value"
        },
        Option::None => { panic!("out of bounds") },
    }
}

```

The `at` function, and its equivalent the subscripting operator, on the other hand, directly return a snapshot to the element at the specified index using the `unbox()` operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use `at` when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    // using the `at()` method
    let first = *a.at(0);
    assert!(first == 0);
    // using the subscripting operator
    let second = *a[1];
    assert!(second == 1);
}

```

En este ejemplo, la variable llamada `first` obtendrÃ¡ el valor `0` porque es el valor del Ã­ndice `0` del array. La variable llamada `second` obtendrÃ¡ el valor `1` del Ã­ndice `1` del array.

En resumen, usa `at` cuando quieras que el programa entre en pÃ¡nico ante intentos de acceso fuera de los lÃ­mites, y usa `get` cuando prefieras manejar estos casos con gracia sin entrar en pÃ¡nico.

To determine the number of elements in an array, use the `len()` method. The return value is of type `usize`.

Si quieres comprobar si un array estÃ¡ vacÃ­o o no, puedes utilizar el mÃ©todo `is_empty()`, que devuelve `true` si el array estÃ¡ vacÃ­o y `false` en caso contrario.

A veces, necesitamos crear arrays con valores que ya se conocen en tiempo de compilaciÃ³n. La forma bÃ¡sica de hacerlo es redundante. Primero declararÃ­as el array y luego aÃ±adirÃ­as cada valor uno por uno. `array!` es una forma mÃ¡s sencilla de realizar esta tarea al combinar los dos pasos. En tiempo de compilaciÃ³n, el compilador expandirÃ¡ la macro para generar el cÃ³digo que aÃ±ade los elementos de forma secuencial

Sin `array!`:

```cairo hljs

    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr.append(4);
    arr.append(5);

```

Con `array!`:

```cairo hljs

    let arr = array![1, 2, 3, 4, 5];

```

If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type that can hold multiple types. Enums will be explained in more detail in the ["Enums and Pattern Matching"](https://book.cairo-lang.org/es/ch06-00-enums-and-pattern-matching.html) chapter.

```cairo hljs

#[derive(Copy, Drop)]
enum Data {
    Integer: u128,
    Felt: felt252,
    Tuple: (u32, u32),
}

fn main() {
    let mut messages: Array<Data> = array![];
    messages.append(Data::Integer(100));
    messages.append(Data::Felt('hello world'));
    messages.append(Data::Tuple((10, 30)));
}

```

`Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations, as introduced in ["References and Snapshots"](https://book.cairo-lang.org/es/ch04-02-references-and-snapshots.html).

All methods provided by `Array` can also be used with `Span`, except for the `append()` method.

Para crear un `Span` de un `Array`, llama al mÃ©todo `span()`:

```cairo hljs hide-boring

fn main() {
    let mut array: Array<u8> = ArrayTrait::new();
    array.span();
}

```

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=753619300.1738497942&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102308675~102482433~102528644~102539968~102546754~102556565&z=809385843)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch103-02-02-component-dependencies.md "Suggest an edit")

Working with components becomes more complex when we try to use one component inside another. As mentioned earlier, a component can only be embedded within a contract, meaning that it's not possible to embed a component within another component. However, this doesn't mean that we can't use one component inside another. In this section, we will see how to use a component as a dependency of another component.

Consider a component called `OwnableCounter` whose purpose is to create a counter that can only be incremented by its owner. This component can be embedded in any contract, so that any contract that uses it will have a counter that can only be incremented by its owner.

The first way to implement this is to create a single component that contains both counter and ownership features from within a single component. However, this approach is not recommended: our goal is to minimize the amount of code duplication and take advantage of component reusability. Instead, we can create a new component that _depends_ on the `Ownable` component for the ownership features, and internally defines the logic for the counter.

Listing 17-1 shows the complete implementation, which we'll break down right after:

```cairo noplayground hljs

use core::starknet::ContractAddress;

#[starknet::interface]
trait IOwnableCounter<TContractState> {
    fn get_counter(self: @TContractState) -> u32;
    fn increment(ref self: TContractState);
    fn transfer_ownership(ref self: TContractState, new_owner: ContractAddress);
}

#[starknet::component]
mod OwnableCounterComponent {
    use listing_03_component_dep::owner::{ownable_component, ownable_component::InternalImpl};
    use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};
    use core::starknet::ContractAddress;

    #[storage]
    pub struct Storage {
        value: u32,
    }

    #[embeddable_as(OwnableCounterImpl)]
    impl OwnableCounter<
        TContractState,
        +HasComponent<TContractState>,
        +Drop<TContractState>,
        impl Owner: ownable_component::HasComponent<TContractState>,
    > of super::IOwnableCounter<ComponentState<TContractState>> {
        fn get_counter(self: @ComponentState<TContractState>) -> u32 {
            self.value.read()
        }

        fn increment(ref self: ComponentState<TContractState>) {
            let ownable_comp = get_dep_component!(@self, Owner);
            ownable_comp.assert_only_owner();
            self.value.write(self.value.read() + 1);
        }

        fn transfer_ownership(
            ref self: ComponentState<TContractState>, new_owner: ContractAddress,
        ) {
            let mut ownable_comp = get_dep_component_mut!(ref self, Owner);
            ownable_comp._transfer_ownership(new_owner);
        }
    }
}

```

Listing 17-1: An OwnableCounter Component

```cairo noplayground hljs

    impl OwnableCounter<
        TContractState,
        +HasComponent<TContractState>,
        +Drop<TContractState>,
        impl Owner: ownable_component::HasComponent<TContractState>,
    > of super::IOwnableCounter<ComponentState<TContractState>> {

```

In [chapter 8](https://book.cairo-lang.org/ch08-02-traits-in-cairo.html), we introduced trait bounds, which are used to specify that a generic type must implement a certain trait. In the same way, we can specify that a component depends on another component by restricting the `impl` block to be available only for contracts that contain the required component.
In our case, this is done by adding a restriction `impl Owner: ownable_component::HasComponent<TContractState>`, which indicates that this `impl` block is only available for contracts that contain an implementation of the `ownable_component::HasComponent` trait. This essentially means that the \`TContractState' type has access to the ownable component. See [Components under the hood](https://book.cairo-lang.org/ch103-02-01-under-the-hood.html#inside-components-generic-impls) for more information.

Although most of the trait bounds were defined using [anonymous parameters](https://book.cairo-lang.org/ch08-01-generic-data-types.html#anonymous-generic-implementation-parameter--operator), the dependency on the `Ownable` component is defined using a named parameter (here, `Owner`). We will need to use this explicit name when accessing the `Ownable` component within the `impl` block.

While this mechanism is verbose and may not be easy to approach at first, it is a powerful leverage of the trait system in Cairo. The inner workings of this mechanism are abstracted away from the user, and all you need to know is that when you embed a component in a contract, all other components in the same contract can access it.

Now that we have made our `impl` depend on the `Ownable` component, we can access its functions, storage, and events within the implementation block. To bring the `Ownable` component into scope, we have two choices, depending on whether we intend to mutate the state of the `Ownable` component or not.
If we want to access the state of the `Ownable` component without mutating it, we use the `get_dep_component!` macro. If we want to mutate the state of the `Ownable` component (for example, change the current owner), we use the `get_dep_component_mut!` macro.
Both macros take two arguments: the first is `self`, either as a snapshot or by reference depending on mutability, representing the state of the component using the dependency, and the second is the component to access.

```cairo noplayground hljs

        fn increment(ref self: ComponentState<TContractState>) {
            let ownable_comp = get_dep_component!(@self, Owner);
            ownable_comp.assert_only_owner();
            self.value.write(self.value.read() + 1);
        }

```

In this function, we want to make sure that only the owner can call the `increment` function. We need to use
the `assert_only_owner` function from the `Ownable` component. We'll use the `get_dep_component!` macro which will return a snapshot of the requested component state, and call `assert_only_owner` on it, as a method of that component.

For the `transfer_ownership` function, we want to mutate that state to change the current owner. We need to use the `get_dep_component_mut!` macro, which will return the requested component state as a mutable reference, and call `transfer_ownership` on it.

```cairo noplayground hljs

        fn transfer_ownership(
            ref self: ComponentState<TContractState>, new_owner: ContractAddress,
        ) {
            let mut ownable_comp = get_dep_component_mut!(ref self, Owner);
            ownable_comp._transfer_ownership(new_owner);
        }

```

It works exactly the same as `get_dep_component!` except that we need to pass the state as a `ref` so we can
mutate it to transfer the ownership.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1073767125.1738497943&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102558064&z=1063584943)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1292725663.1738497944&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=993688670)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-05-control-flow.md "Suggest an edit")

The ability to run some code depending on whether a condition is true and to run some code repeatedly while a condition is true are basic building blocks in most programming languages. The most common constructs that let you control the flow of execution of Cairo code are if expressions and loops.

An if expression allows you to branch your code depending on conditions. You provide a condition and then state, â€œIf this condition is met, run this block of code. If the condition is not met, do not run this block of code.â€

Create a new project called _branches_ in your _cairo\_projects_ directory to explore the `if` expression. In the _src/lib.cairo_ file, input the following:

```cairo hljs

fn main() {
    let number = 3;

    if number == 5 {
        println!("condition was true and number = {}", number);
    } else {
        println!("condition was false and number = {}", number);
    }
}

```

All `if` expressions start with the keyword `if`, followed by a condition. In this case, the condition checks whether or not the variable `number` has a value equal to 5. We place the block of code to execute if the condition is `true` immediately after the condition inside curly brackets.

Optionally, we can also include an `else` expression, which we chose to do here, to give the program an alternative block of code to execute should the condition evaluate to `false`. If you donâ€™t provide an `else` expression and the condition is `false`, the program will just skip the `if` block and move on to the next bit of code.

Try running this code; you should see the following output:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_24_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_24_if
condition was false and number = 3
Run completed successfully, returning []

```

Letâ€™s try changing the value of `number` to a value that makes the condition `true` to see what happens:

```cairo noplayground hljs

    let number = 5;

```

```shell hljs

$ scarb cairo-run
condition was true and number = 5
Run completed successfully, returning []

```

Itâ€™s also worth noting that the condition in this code must be a `bool`. If the condition isnâ€™t a `bool`, weâ€™ll get an error. For example, try running the following code:

```cairo hljs

fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}

```

The `if` condition evaluates to a value of 3 this time, and Cairo throws an error:

```shell hljs

$ scarb build
   Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)
error: Mismatched types. The type `core::bool` cannot be created from a numeric literal.
 --> listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:4:18
    let number = 3;
                 ^

error: could not compile `no_listing_28_bis_if_not_bool` due to previous error

```

The error indicates that Cairo inferred the type of `number` to be a `bool`
based on its later use as a condition of the `if` statement. It tries to create
a `bool` from the value `3`, but Cairo doesn't support instantiating a `bool`
from a numeric literal anyway - you can only use `true` or `false` to create a
`bool`. Unlike languages such as Ruby and JavaScript, Cairo will not
automatically try to convert non-Boolean types to a Boolean. If we want the `if`
code block to run only when a number is not equal to 0, for example, we can
change the if expression to the following:

```cairo hljs

fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}

```

Running this code will print `number was something other than zero`.

You can use multiple conditions by combining `if` and `else` in an `else if` expression. For example:

```cairo hljs

fn main() {
    let number = 3;

    if number == 12 {
        println!("number is 12");
    } else if number == 3 {
        println!("number is 3");
    } else if number - 2 == 1 {
        println!("number minus 2 is 1");
    } else {
        println!("number not found");
    }
}

```

This program has four possible paths it can take. After running it, you should see the following output:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_25_else_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_25_else_if
number is 3
Run completed successfully, returning []

```

When this program executes, it checks each `if` expression in turn and executes the first body for which the condition evaluates to `true`. Note that even though `number - 2 == 1` is `true`, we donâ€™t see the output `number minus 2 is 1` nor do we see the `number not found` text from the `else` block. Thatâ€™s because Cairo only executes the block for the first true condition, and once it finds one, it doesnâ€™t even check the rest. Using too many `else if` expressions can clutter your code, so if you have more than one, you might want to refactor your code. [Chapter 6](https://book.cairo-lang.org/ch06-02-the-match-control-flow-construct.html) describes a powerful Cairo branching construct called `match` for these cases.

Because `if` is an expression, we can use it on the right side of a `let` statement to assign the outcome to a variable.

```cairo hljs

fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    if number == 5 {
        println!("condition was true and number is {}", number);
    }
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_26_if_let v0.1.0 (listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_26_if_let
condition was true and number is 5
Run completed successfully, returning []

```

The `number` variable will be bound to a value based on the outcome of the `if` expression, which will be 5 here.

Itâ€™s often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, which will run through the code inside the loop body to the end and then start immediately back at the beginning. To experiment with loops, letâ€™s create a new project called _loops_.

Cairo has three kinds of loops: `loop`, `while`, and `for`. Letâ€™s try each one.

The `loop` keyword tells Cairo to execute a block of code over and over again forever or until you explicitly tell it to stop.

As an example, change the _src/lib.cairo_ file in your _loops_ directory to look like this:

```cairo hljs

fn main() {
    loop {
        println!("again!");
    }
}

```

When we run this program, weâ€™ll see `again!` printed over and over continuously until either the program runs out of gas or we stop the program manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a program that is stuck in a continual loop. Give it a try:

```shell hljs

$ scarb cairo-run --available-gas=20000000
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished release target(s) in 0 seconds
     Running loops
again!
again!
again!
^Cagain!

```

The symbol `^C` represents where you pressed ctrl-c. You may or may not see the word `again!` printed after the ^C, depending on where the code was in the loop when it received the interrupt signal.

> Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a mechanism that limits the amount of computation that can be done in a program. By setting a value to the `--available-gas` flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurement that expresses the computation cost of an instruction. When the gas meter runs out, the program will stop. In the previous case, we set the gas limit high enough for the program to run for quite some time.

> It is particularly important in the context of smart contracts deployed on Starknet, as it prevents from running infinite loops on the network.
> If you're writing a program that needs to run a loop, you will need to execute it with the `--available-gas` flag set to a value that is large enough to run the program.

Now, try running the same program again, but this time with the `--available-gas` flag set to `200000` instead of `2000000000000`. You will see the program only prints `again!` 3 times before it stops, as it ran out of gas to keep executing the loop.

Fortunately, Cairo also provides a way to break out of a loop using code. You can place the `break` keyword within the loop to tell the program when to stop executing the loop.

```cairo hljs

fn main() {
    let mut i: usize = 0;
    loop {
        if i > 10 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}

```

The `continue` keyword tells the program to go to the next iteration of the loop and to skip the rest of the code in this iteration.
Let's add a `continue` statement to our loop to skip the `println!` statement when `i` is equal to `5`.

```cairo hljs

fn main() {
    let mut i: usize = 0;
    loop {
        if i > 10 {
            break;
        }
        if i == 5 {
            i += 1;
            continue;
        }
        println!("i = {}", i);
        i += 1;
    }
}

```

Executing this program will not print the value of `i` when it is equal to `5`.

One of the uses of a `loop` is to retry an operation you know might fail, such
as checking whether an operation has succeeded. You might also need to pass
the result of that operation out of the loop to the rest of your code. To do
this, you can add the value you want returned after the `break` expression you
use to stop the loop; that value will be returned out of the loop so you can
use it, as shown here:

```cairo hljs

fn main() {
    let mut counter = 0;

    let result = loop {
        if counter == 10 {
            break counter * 2;
        }
        counter += 1;
    };

    println!("The result is {}", result);
}

```

Before the loop, we declare a variable named `counter` and initialize it to
`0`. Then we declare a variable named `result` to hold the value returned from
the loop. On every iteration of the loop, we check whether the `counter` is equal to `10`, and then add `1` to the `counter` variable.
When the condition is met, we use the `break` keyword with the value `counter * 2`. After the loop, we use a
semicolon to end the statement that assigns the value to `result`. Finally, we
print the value in `result`, which in this case is `20`.

A program will often need to evaluate a condition within a loop.
While the condition is `true`, the loop runs.
When the condition ceases to be `true`, the program calls `break`, stopping the loop.
Itâ€™s possible to implement behavior like this using a combination of `loop`, `if`, `else`, and `break`; you could try that now in a program, if youâ€™d like.
However, this pattern is so common that Cairo has a built-in language construct for it, called a `while` loop.

In Listing 2-2, we use `while` to loop the program three times, counting down each time after printing the value of `number`, and then, after the loop, print a message and exit.

```cairo hljs

fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    };

    println!("LIFTOFF!!!");
}

```

Listing 2-2: Using a `while` loop to run code while a condition holds `true`.

This construct eliminates a lot of nesting that would be necessary if you used `loop`, `if`, `else`, and `break`, and itâ€™s clearer.
While a condition evaluates to `true`, the code runs; otherwise, it exits the loop.

You can also use the while construct to loop over the elements of a collection, such as an array. For example, the loop in Listing 2-3 prints each element in the array `a`.

```cairo hljs

fn main() {
    let a = [10, 20, 30, 40, 50].span();
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}

```

Listing 2-3: Looping through each element of a collection using a `while` loop

Here, the code counts up through the elements in the array. It starts at index `0`, and then loops until it reaches the final index in the array (that is, when `index < 5` is no longer `true`). Running this code will print every element in the array:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_45_iter_loop_while v0.1.0 (listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_45_iter_loop_while
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
Run completed successfully, returning []

```

All five array values appear in the terminal, as expected. Even though `index` will reach a value of `5` at some point, the loop stops executing before trying to fetch a sixth value from the array.

However, this approach is error prone; we could cause the program to panic if the index value or test condition is incorrect. For example, if you changed the definition of the `a` array to have four elements but forgot to update the condition to `while index < 4`, the code would panic. Itâ€™s also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.

As a more concise alternative, you can use a `for` loop and execute some code for each item in a collection. A `for` loop looks like the code in Listing 2-4.

```cairo hljs

fn main() {
    let a = [10, 20, 30, 40, 50].span();

    for element in a {
        println!("the value is: {element}");
    }
}

```

Listing 2-4: Looping through each element of a collection using a `for` loop

When we run this code, weâ€™ll see the same output as in Listing 2-3. More importantly, weâ€™ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.

Using the `for` loop, you wouldnâ€™t need to remember to change any other code if you changed the number of values in the array, as you would with the method used in Listing 2-3.

The safety and conciseness of `for` loops make them the most commonly used loop construct in Cairo. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a while loop in Listing 2-2. Another way to run code a certain number of times would be to use a `Range`, provided by the core library, which generates all numbers in sequence starting from one number and ending before another number.

Hereâ€™s how you can use a `Range` to count from 1 to 3:

```cairo hljs

fn main() {
    for number in 1..4_u8 {
        println!("{number}!");
    };
    println!("Go!!!");
}

```

This code is a bit nicer, isnâ€™t it?

Loops and recursive functions are two common ways to repeat a block of code multiple times. The `loop` keyword is used to create an infinite loop that can be broken by using the `break` keyword.

```cairo hljs

fn main() -> felt252 {
    let mut x: felt252 = 0;
    loop {
        if x == 2 {
            break;
        } else {
            x += 1;
        }
    };
    x
}

```

Loops can be transformed into recursive functions by calling the function within itself. Here is an example of a recursive function that mimics the behavior of the `loop` example above.

```cairo hljs

fn main() -> felt252 {
    recursive_function(0)
}

fn recursive_function(mut x: felt252) -> felt252 {
    if x == 2 {
        x
    } else {
        recursive_function(x + 1)
    }
}

```

In both cases, the code block will run indefinitely until the condition `x == 2` is met, at which point the value of x will be displayed.

In Cairo, loops and recursions are not only conceptually equivalent: they are also compiled down to similar low-level representations. To understand this, we can compile both examples to Sierra, and analyze the Sierra Code generated by the Cairo compiler for both examples. Add the following in your `Scarb.toml` file:

```toml hljs ini

[lib]
sierra-text = true

```

Then, run `scarb build` to compile both examples. You will find the Sierra code generated by for both examples is extremely similar, as the loop is compiled to a recursive function in the Sierra statements.

> Note: For our example, our findings came from understanding the **statements** section in Sierra that shows the execution traces of the two programs. If you are curious to learn more about Sierra, check out [Exploring Sierra](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5).

Start

You made it! This was a sizable chapter: you learned about variables, data types, functions, comments,
`if` expressions and loops! To practice with the concepts discussed in this chapter,
try building programs to do the following:

- Generate the _n_-th Fibonacci number.
- Compute the factorial of a number _n_.

Now, weâ€™ll review the common collection types in Cairo in the next chapter.

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/tr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-00-getting-started.md "Suggest an edit")

Cairo yolculuÄŸunuza baÅŸlayalÄ±m! Ã–ÄŸrenilecek Ã§ok ÅŸey var, ama her yolculuk bir yerden baÅŸlar. Bu bÃ¶lÃ¼mde, ÅŸunlarÄ± tartÄ±ÅŸacaÄŸÄ±z:

- Linux, macOS ve Windows Ã¼zerinde Cairo'nun derleme araÃ§ zinciri ve paket yÃ¶neticisi olan Scarb'Ä± kurma.
- Installing Starknet Foundry, which is the default test runnner when creating a Cairo project.
- `Hello, world!` yazdÄ±ran bir program yazma.
- Bir proje oluÅŸturmak ve bir programÄ± Ã§alÄ±ÅŸtÄ±rmak iÃ§in temel Scarb komutlarÄ±nÄ± kullanma.

If you have any questions about Starknet or Cairo, you can ask them in the [Starknet Discord server](https://discord.gg/starknet-community). The community is friendly and always willing to help.

Starknet proposes its own AI agent designed to assist with Cairo and Starknet-related questions. This AI agent is trained on the Cairo book and the Starknet documentation, using Retrieval-Augmented Generation (RAG) to efficiently retrieve information and provide accurate assistance.

You can find the Starknet Agent on the [Starknet Agent](https://agent.starknet.id/) website.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=335446388.1738497946&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1476506319)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch00-01-foreword.md "Suggest an edit")

Zero-knowledge proofs have emerged as a transformative technology in the blockchain space, offering solutions for both privacy and scalability challenges. Among these, STARKs (Scalable Transparent ARguments of Knowledge) stand out as a particularly powerful innovation. Unlike traditional proof systems, STARKs rely solely on collision-resistant hash functions, making them post-quantum secure and eliminating the need for trusted setups.

However, writing general-purpose programs that can generate cryptographic proofs has historically been a significant challenge. Developers needed deep expertise in cryptography and complex mathematical concepts to create verifiable computations, making it impractical for mainstream adoption.

This is where Cairo comes in. As a general-purpose programming language designed specifically for creating provable programs, Cairo abstracts away the underlying cryptographic complexities while maintaining the full power of STARKs. Strongly inspired by Rust, Cairo has been built to help you create provable programs without requiring specific knowledge of its underlying architecture, allowing you to focus on the program logic itself.

Los desarrolladores de blockchain que desean implementar contratos en Starknet utilizarÃ¡n el lenguaje de programaciÃ³n Cairo para codificar sus contratos inteligentes. Esto permite al sistema operativo Starknet generar trazas de ejecuciÃ³n para transacciones que deben ser demostradas por un probador, que luego se verifica en Ethereum L1 antes de actualizar la raÃ­z del estado de Starknet.

However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one computer and verified on other machines. Powered by a Rust VM, and a next-generation prover, the execution and proof generation of Cairo programs is blazingly fast - making Cairo the best tool for building provable applications.

Este libro estÃ¡ diseÃ±ado para desarrolladores con una comprensiÃ³n bÃ¡sica de los conceptos de programaciÃ³n. Es un texto amigable y accesible destinado a ayudarte a mejorar tus conocimientos de Cairo, pero tambiÃ©n a ayudarte a desarrollar tus habilidades de programaciÃ³n en general. Â¡AsÃ­ que sumÃ©rgete y prepÃ¡rate para aprender todo lo que hay que saber sobre Cairo!

This book would not have been possible without the help of the Cairo community. We would like to thank every contributor for their contributions to this book!

We would like to thank the Rust community for the [Rust Book](https://doc.rust-lang.org/book/), which has been a great source of inspiration for this book. Many examples and explanations have been adapted from the Rust Book to fit the Cairo programming language, as the two languages share many similarities.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=698844428.1738497947&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1413154399)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch103-05-02-randomness.md "Suggest an edit")

Since all blockchains are fundamentally deterministic and most are public ledgers, generating truly unpredictatable randomness on-chain presents a challenge. This randomness is crucial for fair outcomes in gaming, lotteries, and unique generation of NFTs. To address this, verifiable random functions (VRFs) provided by oracles offer a solution. VRFs guarantee that the randomness can't be predicted or tampered with, ensuring trust and transparency in these applications.

VRFs use a secret key and a nonce (a unique input) to generate an output that appears random. While technically 'pseudo-random', it's practically impossible for another party to predict the outcome without knowing the secret key.

VRFs produce not only the random number but also a proof that anyone can use to independently verify that the result was generated correctly according to the function's parameters.

[Pragma](https://www.pragma.build/), an oracle on Starknet provides a solution for generating random numbers using VRFs.
Let's dive into how to use Pragma VRF to generate a random number in a simple dice game contract.

Edit your cairo project's `Scarb.toml` file to include the path to use Pragma.

```toml hljs ini

[dependencies]
pragma_lib = { git = "https://github.com/astraly-labs/pragma-lib" }

```

```cairo noplayground hljs

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait IPragmaVRF<TContractState> {
    fn get_last_random_number(self: @TContractState) -> felt252;
    fn request_randomness_from_pragma(
        ref self: TContractState,
        seed: u64,
        callback_address: ContractAddress,
        callback_fee_limit: u128,
        publish_delay: u64,
        num_words: u64,
        calldata: Array<felt252>,
    );
    fn receive_random_words(
        ref self: TContractState,
        requester_address: ContractAddress,
        request_id: u64,
        random_words: Span<felt252>,
        calldata: Array<felt252>,
    );
    fn withdraw_extra_fee_fund(ref self: TContractState, receiver: ContractAddress);
}

#[starknet::interface]
pub trait IDiceGame<TContractState> {
    fn guess(ref self: TContractState, guess: u8);
    fn toggle_play_window(ref self: TContractState);
    fn get_game_window(self: @TContractState) -> bool;
    fn process_game_winners(ref self: TContractState);
}

```

Listing 17-5 shows a contract interfaces for Pragma VRF and a simple dice game.

The function `request_randomness_from_pragma` initiates a request for verifiable randomness from the Pragma oracle. It does this by emitting an event that triggers the following actions off-chain:

1. **Randomness generation**: The oracle generates random values and a corresponding proof.
2. **On-chain submission**: The oracle submits the generated randomness and proof back to the blockchain via the `receive_random_words` callback function.

1. `seed`: A value used to initialize the randomness generation process. This should be unique to ensure unpredictable results.
2. `callback_address`: The contract address where the `receive_random_words` function will be called to deliver the generated randomness. It is typically the address of your deployed contract implementing Pragma VRF.
3. `callback_fee_limit`: The maximum amount of gas you're willing to spend on executing the `receive_random_words` callback function.
4. `publish_delay`: The minimum delay (in blocks) between requesting randomness and the oracle fulfilling the request.
5. `num_words`: The number of random values (each represented as a `felt252`) you want to receive in a single callback.
6. `calldata`: Additional data you want to pass to the `receive_random_words` callback function.

1. `requester_address`: The contract address that initiated the randomness request.
2. `request_id`: A unique identifier assigned to the randomness request.
3. `random_words`: An array (span) of the generated random values (represented as `felt252`).
4. `calldata`: Additional data passed along with the initial randomness request.

This dice game contract allows players to guess a number between 1 & 6 during an active game window. The contract owner then has the ability to toggle the game window to disable new guesses from players. To determine the winning number, the contract owner calls the `request_randomness_from_pragma` function to request a random number from the Pragma VRF oracle. Once the random number is received through the `receive_random_words` callback function, it is stored in the `last_random_number` storage variable. Each player has to call `process_game_winners` function to determine if they have won or lost. The `last_random_number` generated is then reduced to a number between 1 & 6, and compared to the guesses of the players stored in the `user_guesses` mapping, which leads to the emission of an event `GameWinner` or `GameLost`.

```cairo noplayground hljs

#[starknet::contract]
mod DiceGame {
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };
    use core::starknet::{
        ContractAddress, contract_address_const, get_block_number, get_caller_address,
        get_contract_address,
    };
    use pragma_lib::abi::{IRandomnessDispatcher, IRandomnessDispatcherTrait};
    use openzeppelin::token::erc20::interface::{ERC20ABIDispatcher, ERC20ABIDispatcherTrait};
    use openzeppelin::access::ownable::OwnableComponent;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl<ContractState>;
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        user_guesses: Map<ContractAddress, u8>,
        pragma_vrf_contract_address: ContractAddress,
        game_window: bool,
        min_block_number_storage: u64,
        last_random_number: felt252,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        GameWinner: ResultAnnouncement,
        GameLost: ResultAnnouncement,
        #[flat]
        OwnableEvent: OwnableComponent::Event,
    }

    #[derive(Drop, starknet::Event)]
    struct ResultAnnouncement {
        caller: ContractAddress,
        guess: u8,
        random_number: u256,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        pragma_vrf_contract_address: ContractAddress,
        owner: ContractAddress,
    ) {
        self.ownable.initializer(owner);
        self.pragma_vrf_contract_address.write(pragma_vrf_contract_address);
        self.game_window.write(true);
    }

    #[abi(embed_v0)]
    impl DiceGame of super::IDiceGame<ContractState> {
        fn guess(ref self: ContractState, guess: u8) {
            assert(self.game_window.read(), 'GAME_INACTIVE');
            assert(guess >= 1 && guess <= 6, 'INVALID_GUESS');

            let caller = get_caller_address();
            self.user_guesses.entry(caller).write(guess);
        }

        fn toggle_play_window(ref self: ContractState) {
            self.ownable.assert_only_owner();

            let current: bool = self.game_window.read();
            self.game_window.write(!current);
        }

        fn get_game_window(self: @ContractState) -> bool {
            self.game_window.read()
        }

        fn process_game_winners(ref self: ContractState) {
            assert(!self.game_window.read(), 'GAME_ACTIVE');
            assert(self.last_random_number.read() != 0, 'NO_RANDOM_NUMBER_YET');

            let caller = get_caller_address();
            let user_guess: u8 = self.user_guesses.entry(caller).read();
            let reduced_random_number: u256 = self.last_random_number.read().into() % 6 + 1;

            if user_guess == reduced_random_number.try_into().unwrap() {
                self
                    .emit(
                        Event::GameWinner(
                            ResultAnnouncement {
                                caller: caller,
                                guess: user_guess,
                                random_number: reduced_random_number,
                            },
                        ),
                    );
            } else {
                self
                    .emit(
                        Event::GameLost(
                            ResultAnnouncement {
                                caller: caller,
                                guess: user_guess,
                                random_number: reduced_random_number,
                            },
                        ),
                    );
            }
        }
    }

    #[abi(embed_v0)]
    impl PragmaVRFOracle of super::IPragmaVRF<ContractState> {
        fn get_last_random_number(self: @ContractState) -> felt252 {
            let last_random = self.last_random_number.read();
            last_random
        }

        fn request_randomness_from_pragma(
            ref self: ContractState,
            seed: u64,
            callback_address: ContractAddress,
            callback_fee_limit: u128,
            publish_delay: u64,
            num_words: u64,
            calldata: Array<felt252>,
        ) {
            self.ownable.assert_only_owner();

            let randomness_contract_address = self.pragma_vrf_contract_address.read();
            let randomness_dispatcher = IRandomnessDispatcher {
                contract_address: randomness_contract_address,
            };

            // Approve the randomness contract to transfer the callback fee
            // You would need to send some ETH to this contract first to cover the fees
            let eth_dispatcher = ERC20ABIDispatcher {
                contract_address: contract_address_const::<
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
                >() // ETH Contract Address
            };
            eth_dispatcher
                .approve(
                    randomness_contract_address,
                    (callback_fee_limit + callback_fee_limit / 5).into(),
                );

            // Request the randomness
            randomness_dispatcher
                .request_random(
                    seed, callback_address, callback_fee_limit, publish_delay, num_words, calldata,
                );

            let current_block_number = get_block_number();
            self.min_block_number_storage.write(current_block_number + publish_delay);
        }

        fn receive_random_words(
            ref self: ContractState,
            requester_address: ContractAddress,
            request_id: u64,
            random_words: Span<felt252>,
            calldata: Array<felt252>,
        ) {
            // Have to make sure that the caller is the Pragma Randomness Oracle contract
            let caller_address = get_caller_address();
            assert(
                caller_address == self.pragma_vrf_contract_address.read(),
                'caller not randomness contract',
            );
            // and that the current block is within publish_delay of the request block
            let current_block_number = get_block_number();
            let min_block_number = self.min_block_number_storage.read();
            assert(min_block_number <= current_block_number, 'block number issue');

            let random_word = *random_words.at(0);
            self.last_random_number.write(random_word);
        }

        fn withdraw_extra_fee_fund(ref self: ContractState, receiver: ContractAddress) {
            self.ownable.assert_only_owner();
            let eth_dispatcher = ERC20ABIDispatcher {
                contract_address: contract_address_const::<
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7,
                >() // ETH Contract Address
            };
            let balance = eth_dispatcher.balance_of(get_contract_address());
            eth_dispatcher.transfer(receiver, balance);
        }
    }
}

```

Listing 17-6: Simple Dice Game Contract using Pragma VRF.

After deploying your contract that includes Pragma VRF functionalities, ensure it holds sufficient ETH to cover the expenses related to requesting random values. Pragma VRF requires payment for both generating the random numbers and executing the callback function defined in your contract.

For more information, please refer to the [Pragma](https://docs.pragma.build/Resources/Starknet/randomness/randomness) docs.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=973044607.1738497949&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1525064236)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-01-arrays.md "Suggest an edit")

An array is a collection of elements of the same type. You can create and use array methods by using the `ArrayTrait` trait from the core library.

An important thing to note is that arrays have limited modification options. Arrays are, in fact, queues whose values can't be modified.
This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it. You can only append items to the end of an array and remove items from the front.

Creating an array is done with the `ArrayTrait::new()` call. Here's an example of creating an array and appending 3 elements to it:

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

When required, you can pass the expected type of items inside the array when instantiating the array like this, or explicitly define the type of the variable.

```cairo noplayground hljs

let mut arr = ArrayTrait::<u128>::new();

```

```cairo noplayground hljs

let mut arr:Array<u128> = ArrayTrait::new();

```

To add an element to the end of an array, you can use the `append()` method:

```cairo hljs hide-boring

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

You can only remove elements from the front of an array by using the `pop_front()` method.
This method returns an `Option` that can be unwrapped, containing the removed element, or `Option::None` if the array is empty.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    println!("The first value is {}", first_value);
}

```

The above code will print `The first value is 10` as we remove the first element that was added.

In Cairo, memory is immutable, which means that it is not possible to modify the elements of an array once they've been added. You can only add elements to the end of an array and remove elements from the front of an array. These operations do not require memory mutation, as they involve updating pointers rather than directly modifying the memory cells.

To access array elements, you can use `get()` or `at()` array methods that return different types. Using `arr.at(index)` is equivalent to using the subscripting operator `arr[index]`.

The `get` function returns an `Option<Box<@T>>`, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the ["References and Snapshots"](https://book.cairo-lang.org/ch04-02-references-and-snapshots.html#snapshots) chapter.

Here is an example with the `get()` method:

```cairo hljs

fn main() -> u128 {
    let mut arr = ArrayTrait::<u128>::new();
    arr.append(100);
    let index_to_access =
        1; // Change this value to see different results, what would happen if the index doesn't exist?
    match arr.get(index_to_access) {
        Option::Some(x) => {
            *x
                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
            // It basically means "transform what get(idx) returned into a real value"
        },
        Option::None => { panic!("out of bounds") },
    }
}

```

The `at` function, and its equivalent the subscripting operator, on the other hand, directly return a snapshot to the element at the specified index using the `unbox()` operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use `at` when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    // using the `at()` method
    let first = *a.at(0);
    assert!(first == 0);
    // using the subscripting operator
    let second = *a[1];
    assert!(second == 1);
}

```

In this example, the variable named `first` will get the value `0` because that
is the value at index `0` in the array. The variable named `second` will get
the value `1` from index `1` in the array.

In summary, use `at` when you want to panic on out-of-bounds access attempts, and use `get` when you prefer to handle such cases gracefully without panicking.

To determine the number of elements in an array, use the `len()` method. The return value is of type `usize`.

If you want to check if an array is empty or not, you can use the `is_empty()` method, which returns `true` if the array is empty and `false` otherwise.

Sometimes, we need to create arrays with values that are already known at compile time. The basic way of doing that is redundant. You would first declare the array and then append each value one by one. `array!` is a simpler way of doing this task by combining the two steps.
At compile-time, the compiler will expand the macro to generate the code that appends the items sequentially.

Without `array!`:

```cairo hljs

    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr.append(4);
    arr.append(5);

```

With `array!`:

```cairo hljs

    let arr = array![1, 2, 3, 4, 5];

```

If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type that can hold multiple types. Enums will be explained in more detail in the ["Enums and Pattern Matching"](https://book.cairo-lang.org/ch06-00-enums-and-pattern-matching.html) chapter.

```cairo hljs

#[derive(Copy, Drop)]
enum Data {
    Integer: u128,
    Felt: felt252,
    Tuple: (u32, u32),
}

fn main() {
    let mut messages: Array<Data> = array![];
    messages.append(Data::Integer(100));
    messages.append(Data::Felt('hello world'));
    messages.append(Data::Tuple((10, 30)));
}

```

`Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations, as introduced in ["References and Snapshots"](https://book.cairo-lang.org/ch04-02-references-and-snapshots.html).

All methods provided by `Array` can also be used with `Span`, except for the `append()` method.

To create a `Span` of an `Array`, call the `span()` method:

```cairo hljs hide-boring

fn main() {
    let mut array: Array<u8> = ArrayTrait::new();
    array.span();
}

```

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1901229498.1738497940&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102558064&z=2074379101)

ðŸ’¬

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-04-hash.md "Suggest an edit")

At its essence, hashing is a process of converting input data (often called a message) of any length into a fixed-size value, typically referred to as a "hash." This transformation is deterministic, meaning that the same input will always produce the same hash value. Hash functions are a fundamental component in various fields, including data storage, cryptography and data integrity verification. They are very often used when developing smart contracts, especially when working with [Merkle trees](https://en.wikipedia.org/wiki/Merkle_tree#Uses).

In this chapter, we will present the two hash functions implemented natively in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when and how to use them, and see examples with Cairo programs.

Cairo æ ¸å¿ƒåº“æä¾›äº†ä¸¤ç§å“ˆå¸Œå‡½æ•°ï¼šPedersen å’Œ Poseidonã€‚

Pedersen hash functions are cryptographic algorithms that rely on [elliptic curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography). These functions perform operations on points along an elliptic curve â€” essentially, doing math with the locations of these points â€” which are easy to do in one direction and hard to undo. This one-way difficulty is based on the Elliptic Curve Discrete Logarithm Problem (ECDLP), which is a problem so hard to solve that it ensures the security of the hash function. The difficulty of reversing these operations is what makes the Pedersen hash function secure and reliable for cryptographic purposes.

Poseidon is a family of hash functions designed to be very efficient as algebraic circuits. Its design is particularly efficient for Zero-Knowledge proof systems, including STARKs (so, Cairo). Poseidon uses a method called a 'sponge construction,' which soaks up data and transforms it securely using a process known as the Hades permutation. Cairo's version of Poseidon is based on a three-element state permutation with [specific parameters](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt).

Pedersen æ˜¯ Starknet ä¸Šæœ€åˆä½¿ç”¨çš„å“ˆå¸Œå‡½æ•°ï¼ŒçŽ°åœ¨ä»ç”¨äºŽè®¡ç®—å­˜å‚¨ä¸­å˜é‡çš„åœ°å€ï¼ˆä¾‹å¦‚ï¼Œ `LegacyMap` ä½¿ç”¨ Pedersen å¯¹ Starknet ä¸Šå­˜å‚¨æ˜ å°„çš„é”®è¿›è¡Œå“ˆå¸Œï¼‰ã€‚ç„¶è€Œï¼Œç”±äºŽ Poseidon åœ¨å¤„ç† STARK è¯æ˜Žç³»ç»Ÿæ—¶æ¯” Pedersen æ›´ä¾¿å®œï¼Œæ›´å¿«ï¼Œå› æ­¤çŽ°åœ¨å®ƒå·²æˆä¸º Cairo ç¨‹åºä¸­æŽ¨èä½¿ç”¨çš„å“ˆå¸Œå‡½æ•°ã€‚

The core library makes it easy to work with hashes. The `Hash` trait is implemented for all types that can be converted to `felt252`, including `felt252` itself. For more complex types like structs, deriving `Hash` allows them to be hashed easily using the hash function of your choice - given that all of the struct's fields are themselves hashable. You cannot derive the `Hash` trait on a struct that contains un-hashable values, such as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable.

The `Hash` trait is accompanied by the `HashStateTrait` and `HashStateExTrait` that define the basic methods to work with hashes. They allow you to initialize a hash state that will contain the temporary values of the hash after each application of the hash function, update the hash state and finalize it when the computation is completed. `HashStateTrait` and `HashStateExTrait` are defined as follows:

```cairo noplayground hljs

/// A trait for hash state accumulators.
trait HashStateTrait<S> {
    fn update(self: S, value: felt252) -> S;
    fn finalize(self: S) -> felt252;
}

/// Extension trait for hash state accumulators.
trait HashStateExTrait<S, T> {
    /// Updates the hash state with the given value.
    fn update_with(self: S, value: T) -> S;
}

/// A trait for values that can be hashed.
trait Hash<T, S, +HashStateTrait<S>> {
    /// Updates the hash state with the given value.
    fn update_state(state: S, value: T) -> S;
}

```

è¦åœ¨ä»£ç ä¸­ä½¿ç”¨å“ˆå¸Œï¼Œæ‚¨å¿…é¡»é¦–å…ˆå¯¼å…¥ç›¸å…³çš„traitå’Œå‡½æ•°ã€‚åœ¨ä»¥ä¸‹ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ Pedersen å’Œ Poseidon å“ˆå¸Œå‡½æ•°å¯¹ç»“æž„ä½“è¿›è¡Œå“ˆå¸Œå¤„ç†ã€‚

é¦–å…ˆï¼Œéœ€è¦æ ¹æ®æˆ‘ä»¬æƒ³è¦ä½¿ç”¨çš„å“ˆå¸Œå‡½æ•°ï¼Œä½¿ç”¨ `PoseidonTrait::new() -> HashState` æˆ– `PedersenTrait::new(base: felt252) -> HashState` åˆå§‹åŒ–å“ˆå¸ŒçŠ¶æ€ã€‚ç„¶åŽï¼Œå¯ä»¥ä½¿ç”¨ `update(self: HashState, value: felt252) -> HashState` æˆ– `update_with(self: S, value: T) -> S` å‡½æ•°å¤šæ¬¡æ›´æ–°å“ˆå¸ŒçŠ¶æ€ï¼Œå…·ä½“æ›´æ–°æ¬¡æ•°å–å†³äºŽéœ€è¦ã€‚æœ€åŽï¼Œä½¿ç”¨ `finalize(self: HashState) -> felt252` å‡½æ•°å®Œæˆå“ˆå¸Œè®¡ç®—å¹¶è¿”å›žå“ˆå¸Œå€¼ã€‚

```cairo hljs

use core::poseidon::PoseidonTrait;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop, Hash)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

fn main() -> felt252 {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();
    hash
}

```

Pedersen is different from Poseidon, as it starts with a base state. This base state must be of `felt252` type, which forces us to either hash the struct with an arbitrary base state using the `update_with` method, or serialize the struct into an array to loop through all of its fields and hash its elements together.

Here is a short example of Pedersen hashing:

```cairo hljs hide-boring

use core::pedersen::PedersenTrait;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop, Hash, Serde, Copy)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

fn main() -> (felt252, felt252) {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    // hash1 is the result of hashing a struct with a base state of 0
    let hash1 = PedersenTrait::new(0).update_with(struct_to_hash).finalize();

    let mut serialized_struct: Array<felt252> = ArrayTrait::new();
    Serde::serialize(@struct_to_hash, ref serialized_struct);
    let first_element = serialized_struct.pop_front().unwrap();
    let mut state = PedersenTrait::new(first_element);

    while let Option::Some(value) = serialized_struct.pop_front() {
        state = state.update(value);
    };

    // hash2 is the result of hashing only the fields of the struct
    let hash2 = state.finalize();

    (hash1, hash2)
}

```

Let us look at an example of hashing a struct that contains a `Span<felt252>`. To hash a `Span<felt252>` or a struct that contains a `Span<felt252>` you can use the built-in function `poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` by calling `poseidon_hash_span` on its span.

First, let us import the following traits and function:

```cairo noplayground hljs

use core::poseidon::PoseidonTrait;
use core::poseidon::poseidon_hash_span;
use core::hash::{HashStateTrait, HashStateExTrait};

```

Now we define the struct. As you might have noticed, we didn't derive the `Hash` trait. If you attempt to derive the `Hash` trait for this struct, it will result in an error because the structure contains a field that is not hashable.

```cairo noplayground hljs

#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array<felt252>,
}

```

In this example, we initialized a `HashState` ( `hash`), updated it and then called the function `finalize()` on the `HashState` to get the computed hash `hash_felt252`. We used `poseidon_hash_span` on the `Span` of the `Array<felt252>` to compute its hash.

```cairo hljs hide-boring

use core::poseidon::PoseidonTrait;
use core::poseidon::poseidon_hash_span;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array<felt252>,
}

fn main() {
    let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };

    let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);
    let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();
}

```

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=693326675.1738497959&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1536463335)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch00-00-introduction.md "Suggest an edit")

Cairo is a programming language designed to leverage the power of mathematical proofs for computational integrity. Just as C.S. Lewis defined integrity as "doing the right thing, even when no one is watching," Cairo enables programs to prove they've done the right computation, even when executed on untrusted machines.

The language is built on STARK technology, a modern evolution of PCP (Probabilistically Checkable Proofs) that transforms computational claims into constraint systems. While Cairo's ultimate purpose is to generate these mathematical proofs that can be verified efficiently and with absolute certainty.

Cairo enables a paradigm shift in how we think about trusted computation. Its primary application today is Starknet, a Layer 2 scaling solution for Ethereum that addresses one of blockchain's fundamental challenges: scalability without sacrificing security.

In the traditional blockchain model, every participant must verify every computation. Starknet changes this by using Cairo's proof system: computations are executed off-chain by a prover who generates a STARK proof, which is then verified by an Ethereum smart contract. This verification requires significantly less computational power than re-executing the computations, enabling massive scalability while maintaining security.

However, Cairo's potential extends beyond blockchain. Any scenario where computational integrity needs to be verified efficiently can benefit from Cairo's verifiable computation capabilities.

This book caters to three main audiences, each with their own learning path:

1. **General-Purpose Developers**: If you're interested in Cairo for its verifiable computation capabilities outside of blockchain, you'll want to focus on chapters 1-12. These chapters cover the core language features and programming concepts without diving deep into smart contract specifics.

2. **New Smart Contract Developers**: If you're new to both Cairo and smart contracts, we recommend reading the book front to back. This will give you a solid foundation in both the language fundamentals and smart contract development principles.

3. **Experienced Smart Contract Developers**: If you're already familiar with smart contract development in other languages, or Rust, you might want to follow this focused path:
   - Chapters 1-3 for Cairo basics
   - Chapter 8 for Cairo's trait and generics system
   - Skip to Chapter 15 for smart contract development
   - Reference other chapters as needed

Regardless of your background, this book assumes basic programming knowledge such as variables, functions, and common data structures. While prior experience with Rust can be helpful (as Cairo shares many similarities), it's not required.

- Cairo CPU Architecture: [https://eprint.iacr.org/2021/1063](https://eprint.iacr.org/2021/1063)
- Cairo, Sierra and Casm: [https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5)
- State of non determinism: [https://twitter.com/PapiniShahar/status/1638203716535713798](https://twitter.com/PapiniShahar/status/1638203716535713798)

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1751805854.1738497960&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=752226764)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-03-operator-overloading.md "Suggest an edit")

Operator overloading is a feature in some programming languages that allows the redefinition of standard operators, such as addition ( `+`), subtraction ( `-`), multiplication ( `*`), and division ( `/`), to work with user-defined types. This can make the syntax of the code more intuitive, by enabling operations on user-defined types to be expressed in the same way as operations on primitive types.

In Cairo, operator overloading is achieved through the implementation of specific traits. Each operator has an associated trait, and overloading that operator involves providing an implementation of that trait for a custom type.
However, it's essential to use operator overloading judiciously. Misuse can lead to confusion, making the code more difficult to maintain, for example when there is no semantic meaning to the operator being overloaded.

Consider an example where two `Potions` need to be combined. `Potions` have two data fields, mana and health. Combining two `Potions` should add their respective fields.

```cairo hljs

struct Potion {
    health: felt252,
    mana: felt252,
}

impl PotionAdd of Add<Potion> {
    fn add(lhs: Potion, rhs: Potion) -> Potion {
        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana }
    }
}

fn main() {
    let health_potion: Potion = Potion { health: 100, mana: 0 };
    let mana_potion: Potion = Potion { health: 0, mana: 100 };
    let super_potion: Potion = health_potion + mana_potion;
    // Both potions were combined with the `+` operator.
    assert(super_potion.health == 100, '');
    assert(super_potion.mana == 100, '');
}

```

In the code above, we're implementing the `Add` trait for the `Potion` type. The add function takes two arguments: `lhs` and `rhs` (left and right-hand side). The function body returns a new `Potion` instance, its field values being a combination of `lhs` and `rhs`.

As illustrated in the example, overloading an operator requires specification of the concrete type being overloaded. The overloaded generic trait is `Add<T>`, and we define a concrete implementation for the type `Potion` with `Add<Potion>`.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1863971281.1738497961&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1372683710)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch11-01-closures.md "Suggest an edit")

Closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which theyâ€™re defined. Weâ€™ll demonstrate how these closure features allow for code reuse and behavior customization.

> Note: Closures were introduced in Cairo 2.9 and are still under development.
> Some new features will be introduced in future versions of Cairo, so this page will evolve accordingly.

When writing Cairo programs, you'll often need to pass behavior as a parameter to another function. Closures provide a way to define this behavior inline, without creating a separate named function. They are particularly valuable when working with collections, error handling, and any scenario where you want to customize how a function behaves using a function as a parameter.

Consider a simple example where we want to process numbers differently based on some condition. Instead of writing multiple functions, we can use closures to define the behavior where we need it:

```cairo hljs hide-boring

#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn map<T, +Drop<T>, F, +Drop<F>, impl func: core::ops::Fn<F, (T,)>, +Drop<func::Output>>(
        self: Array<T>, f: F,
    ) -> Array<func::Output> {
        let mut output: Array<func::Output> = array![];
        for elem in self {
            output.append(f(elem));
        };
        output
    }
}

#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter<
        T,
        +Copy<T>,
        +Drop<T>,
        F,
        +Drop<F>,
        impl func: core::ops::Fn<F, (T,)>[Output: bool],
        +Drop<func::Output>,
    >(
        self: Array<T>, f: F,
    ) -> Array<T> {
        let mut output: Array<T> = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        };
        output
    }
}

fn main() {
    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));

    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));

    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);

    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
}

```

The closure's arguments go between the pipes ( `|`). Note that we don't have to specify the types of arguments and of the return value (see `double` closure), they will be inferred from the closure usage, as it is done for any variables.
Of course, if you use a closure with different types, you will get a `Type annotations needed` error, telling you that you have to choose and specify the closure argument types.

The body is an expression, on a single line without `{}` like `double` or on several lines with `{}` like `sum`.

One of the interests of closures is that they can include bindings from their enclosing scope.

In the following example, `my_closure` use a binding to `x` to compute `x + value * 3`.

```cairo hljs hide-boring

#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn map<T, +Drop<T>, F, +Drop<F>, impl func: core::ops::Fn<F, (T,)>, +Drop<func::Output>>(
        self: Array<T>, f: F,
    ) -> Array<func::Output> {
        let mut output: Array<func::Output> = array![];
        for elem in self {
            output.append(f(elem));
        };
        output
    }
}

#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter<
        T,
        +Copy<T>,
        +Drop<T>,
        F,
        +Drop<F>,
        impl func: core::ops::Fn<F, (T,)>[Output: bool],
        +Drop<func::Output>,
    >(
        self: Array<T>, f: F,
    ) -> Array<T> {
        let mut output: Array<T> = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        };
        output
    }
}

fn main() {
    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));

    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));

    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);

    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
}

```

> Note that, at the moment, closures are still not allowed to capture mutable variables, but this will be supported in future Cairo versions.

There are more differences between functions and closures. Closures donâ€™t
usually require you to annotate the types of the parameters or the return value
like `fn` functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, arenâ€™t used
in an exposed interface like this: theyâ€™re stored in variables and used without
naming them and exposing them to users of our library.

Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how itâ€™s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).

As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 11-1. In this example, weâ€™re defining a closure and storing it
in a variable rather than defining the closure in the spot we pass it as an
argument as we did in Listing 13-1.

```cairo hljs hide-boring

fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num: u32| -> u32 {
        num
    };

    if intensity < 25 {
        println!("Today, do {} pushups!", expensive_closure(intensity));
        println!("Next, do {} situps!", expensive_closure(intensity));
    } else {
        if random_number == 3 {
            println!("Take a break today! Remember to stay hydrated!");
        } else {
            println!("Today, run for {} minutes!", expensive_closure(intensity));
        }
    }
}

fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(simulated_user_specified_value, simulated_random_number);
}

```

Listing 11-1: Adding optional type annotations of the parameter and return value types in the closure

With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. Weâ€™ve added some spaces
to line up the relevant parts. This illustrates how closure syntax is similar
to function syntax except for the use of pipes and the amount of syntax that is
optional:

```cairo ignore hljs

fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;

```

The first line shows a function definition, and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when theyâ€™re called. The
`add_one_v3` and `add_one_v4` lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to `let array = array![];` needing either type annotations or values of
some type to be inserted into the `array` for Cairo to be able to infer the type.

For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing 11-2 shows
the definition of a short closure that just returns the value it receives as a
parameter. This closure isnâ€™t very useful except for the purposes of this
example. Note that we havenâ€™t added any type annotations to the definition.
Because there are no type annotations, we can call the closure with any type,
which weâ€™ve done here with `u64` the first time. If we then try to call
`example_closure` with a `u32`, weâ€™ll get an error.

```cairo noplayground hljs hide-boring

//TAG: does_not_compile
fn main() {
    let example_closure = |x| x;

    let s = example_closure(5_u64);
    let n = example_closure(5_u32);
}

```

Listing 11-2: Attempting to call a closure whose types are inferred with two different types

The compiler gives us this error:

```hljs

$ scarb build
   Compiling listing_closure_different_types v0.1.0 (listings/ch11-functional-features/listing_closure_different_types/Scarb.toml)
warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:6:9
    let s = example_closure(5_u64);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:7:9
    let n = example_closure(5_u32);
        ^

error: Type annotations needed. Failed to infer ?7.
 --> listings/ch11-functional-features/listing_closure_different_types/src/lib.cairo:7:13
    let n = example_closure(5_u32);
            ^********************^

error: could not compile `listing_closure_different_types` due to previous error

```

The first time we call `example_closure` with the `u64` value, the compiler
infers the type of `x` and the return type of the closure to be `u64`. Those
types are then locked into the closure in `example_closure`, and we get a type
error when we next try to use a different type with the same closure.

Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved _into_ the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved _out of_ the closure). A closure body can do any of the
following: move a captured value out of the closure, neither move nor mutate the value, or capture
nothing from the environment to begin with.

The way a closure captures and handles values from the environment affects
which traits the closure implements, and traits are how functions and structs
can specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these `Fn` traits, in an additive fashion,
depending on how the closureâ€™s body handles the values:

1. `FnOnce` applies to closures that can be called once. All closures implement
at least this trait, because all closures can be called. A closure that
moves captured values out of its body will only implement `FnOnce` and none
of the other `Fn` traits, because it can only be called once.

2. `Fn` applies to closures that donâ€™t move captured values out of their body
and that donâ€™t mutate captured values, as well as closures that capture
nothing from their environment. These closures can be called more than once
without mutating their environment, which is important in cases such as
calling a closure multiple times concurrently.


Letâ€™s look at the definition of the `unwrap_or_else` method on `OptionTrait<T>` that
we used in Listing 13-1:

```cairo ignore hljs

pub impl OptionTraitImpl<T> of OptionTrait<T> {
    #[inline]
    fn unwrap_or_else<F, +Drop<F>, impl func: core::ops::FnOnce<F, ()>[Output: T], +Drop<func::Output>>(
        self: Option<T>, f: F,
    ) -> T {
        match self {
            Option::Some(x) => x,
            Option::None => f(),
        }
    }
}

```

Recall that `T` is the generic type representing the type of the value in the
`Some` variant of an `Option`. That type `T` is also the return type of the
`unwrap_or_else` function: code that calls `unwrap_or_else` on an
`Option<ByteArray>`, for example, will get a `ByteArray`.

Next, notice that the `unwrap_or_else` function has the additional generic type
parameter `F`. The `F` type is the type of the parameter named `f`, which is
the closure we provide when calling `unwrap_or_else`.

The trait bound specified on the generic type `F` is `impl func: core::ops::FnOnce<F, ()>[Output: T]`,
which means `F` must be able to be called once, take no arguments (the unit type `()` is used), and return a `T` as output.
Using `FnOnce` in the trait bound expresses the constraint that
`unwrap_or_else` is only going to call `f` at most one time. In the body of
`unwrap_or_else`, we can see that if the `Option` is `Some`, `f` wonâ€™t be
called. If the `Option` is `None`, `f` will be called once. Because all
closures implement `FnOnce`, `unwrap_or_else` accepts all two kinds of
closures and is as flexible as it can be.

The `Fn` traits are important when defining or using functions or types that
make use of closures. In the next section, weâ€™ll discuss iterators. Many
iterator methods take closure arguments, so keep these closure details in mind
as we continue!

Under the hood, closures are implemented through `FnOnce` and `Fn` traits. `FnOnce` is implemented for closures that may consume captured variables, where `Fn` is implemented for closures that capture only copyable variables.

Another great interest of closures is that, like any type of variables, you can pass them as function arguments. This mechanism is massively used in functional programming, through classic functions like `map`, `filter` or `reduce`.

Here is a potential implementation of `map` to apply a same function to all the items of an array:

```cairo noplayground hljs hide-boring

#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn map<T, +Drop<T>, F, +Drop<F>, impl func: core::ops::Fn<F, (T,)>, +Drop<func::Output>>(
        self: Array<T>, f: F,
    ) -> Array<func::Output> {
        let mut output: Array<func::Output> = array![];
        for elem in self {
            output.append(f(elem));
        };
        output
    }
}

#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter<
        T,
        +Copy<T>,
        +Drop<T>,
        F,
        +Drop<F>,
        impl func: core::ops::Fn<F, (T,)>[Output: bool],
        +Drop<func::Output>,
    >(
        self: Array<T>, f: F,
    ) -> Array<T> {
        let mut output: Array<T> = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        };
        output
    }
}

fn main() {
    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));

    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));

    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);

    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
}

```

> Note that, due to a bug in inlining analysis, this analysis process should be disabled using `#[inline(never)]`.

In this implementation, you'll notice that, while `T` is the element type of the input array `self`, the element type of the output array is defined by the output type of the `f` closure (the associated type `func::Output` from the `Fn` trait).

This means that your `f` closure can return the same type of elements like as for `_double` in the following code, or any other type of elements like as for `_another`:

```cairo hljs hide-boring

#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn map<T, +Drop<T>, F, +Drop<F>, impl func: core::ops::Fn<F, (T,)>, +Drop<func::Output>>(
        self: Array<T>, f: F,
    ) -> Array<func::Output> {
        let mut output: Array<func::Output> = array![];
        for elem in self {
            output.append(f(elem));
        };
        output
    }
}

#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter<
        T,
        +Copy<T>,
        +Drop<T>,
        F,
        +Drop<F>,
        impl func: core::ops::Fn<F, (T,)>[Output: bool],
        +Drop<func::Output>,
    >(
        self: Array<T>, f: F,
    ) -> Array<T> {
        let mut output: Array<T> = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        };
        output
    }
}

fn main() {
    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));

    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));

    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);

    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
}

```

> Currently, Cairo 2.9 provides an experimental feature allowing you to specify the associated type of trait, using `experimental-features = ["associated_item_constraints"]` in your `Scarb.toml`.

Let's say we want to implement the `filter` function for arrays, to filter out elements which do not match a criteria.
This criteria will be provided through a closure which takes an element as input, and return `true` if the element has to be kept,
`false` otherwise. That means, we need to specify that the closure must return a `boolean`.

```cairo noplayground hljs hide-boring

#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn map<T, +Drop<T>, F, +Drop<F>, impl func: core::ops::Fn<F, (T,)>, +Drop<func::Output>>(
        self: Array<T>, f: F,
    ) -> Array<func::Output> {
        let mut output: Array<func::Output> = array![];
        for elem in self {
            output.append(f(elem));
        };
        output
    }
}

#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter<
        T,
        +Copy<T>,
        +Drop<T>,
        F,
        +Drop<F>,
        impl func: core::ops::Fn<F, (T,)>[Output: bool],
        +Drop<func::Output>,
    >(
        self: Array<T>, f: F,
    ) -> Array<T> {
        let mut output: Array<T> = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        };
        output
    }
}

fn main() {
    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));

    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));

    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);

    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
}

```

```cairo hljs hide-boring

#[generate_trait]
impl ArrayExt of ArrayExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn map<T, +Drop<T>, F, +Drop<F>, impl func: core::ops::Fn<F, (T,)>, +Drop<func::Output>>(
        self: Array<T>, f: F,
    ) -> Array<func::Output> {
        let mut output: Array<func::Output> = array![];
        for elem in self {
            output.append(f(elem));
        };
        output
    }
}

#[generate_trait]
impl ArrayFilterExt of ArrayFilterExtTrait {
    // Needed in Cairo 2.9.2 because of a bug in inlining analysis.
    #[inline(never)]
    fn filter<
        T,
        +Copy<T>,
        +Drop<T>,
        F,
        +Drop<F>,
        impl func: core::ops::Fn<F, (T,)>[Output: bool],
        +Drop<func::Output>,
    >(
        self: Array<T>, f: F,
    ) -> Array<T> {
        let mut output: Array<T> = array![];
        for elem in self {
            if f(elem) {
                output.append(elem);
            }
        };
        output
    }
}

fn main() {
    let double = |value| value * 2;
    println!("Double of 2 is {}", double(2_u8));
    println!("Double of 4 is {}", double(4_u8));

    // This won't work because `value` type has been inferred as `u8`.
    //println!("Double of 6 is {}", double(6_u16));

    let sum = |x: u32, y: u32, z: u16| {
        x + y + z.into()
    };
    println!("Result: {}", sum(1, 2, 3));

    let x = 8;
    let my_closure = |value| {
        x * (value + 3)
    };

    println!("my_closure(1) = {}", my_closure(1));

    let double = array![1, 2, 3].map(|item: u32| item * 2);
    let another = array![1, 2, 3].map(|item: u32| {
        let x: u64 = item.into();
        x * x
    });

    println!("double: {:?}", double);
    println!("another: {:?}", another);

    let even = array![3, 4, 5, 6].filter(|item: u32| item % 2 == 0);
    println!("even: {:?}", even);
}

```

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1814817926.1738497962&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566~102558064&z=1518762472)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-05-macros.md "Suggest an edit")

The Cairo language has some plugins that allow developers to simplify their code. They are called `inline_macros` and are a way of writing code that generates other code.

In some situations, a developer might need to declare a constant that is the result of a computation of integers. To compute a constant expression and use its result at compile time, it is required to use the `consteval_int!` macro.

Here is an example of `consteval_int!`:

```cairo noplayground hljs

const a: felt252 = consteval_int!(2 * 2 * 2);

```

This will be interpreted as `const a: felt252 = 8;` by the compiler.

`selector!("function_name")` macro generates the entry point selector for the given function name.

Please refer to the [Printing](https://book.cairo-lang.org/ch12-08-printing.html) page.

Please refer to the [Arrays](https://book.cairo-lang.org/ch03-01-arrays.html) page.

See [Unrecoverable Errors with panic](https://book.cairo-lang.org/ch09-01-unrecoverable-errors-with-panic.html#panic-macro) page.

See [How to Write Tests](https://book.cairo-lang.org/ch10-01-how-to-write-tests.html) page.

See [Printing](https://book.cairo-lang.org/ch12-08-printing.html#formatting) page.

See [Printing](https://book.cairo-lang.org/ch12-08-printing.html#printing-custom-data-types) page.

Please refer to the [Composability and Components](https://book.cairo-lang.org/ch103-02-00-composability-and-components.html) chapter.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1022037162.1738497963&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=101509157~102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1366670210)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch101-03-contract-events.md "Suggest an edit")

Events are a way for smart contracts to inform the outside world of any changes that occur during their execution. They play a critical role in the integration of smart contracts into real-world applications.

Technically speaking, an event is a custom data structure emitted by a smart contract during its execution and stored in the corresponding transaction receipt, allowing any external tool to parse and index it.

The events of a smart contract are defined in an enum annotated with the attribute `#[event]`. This enum must be named `Event`.

```cairo noplayground hljs hide-boring

#[starknet::interface]
pub trait IEventExample<TContractState> {
    fn add_book(ref self: TContractState, id: u32, title: felt252, author: felt252);
    fn change_book_title(ref self: TContractState, id: u32, new_title: felt252);
    fn change_book_author(ref self: TContractState, id: u32, new_author: felt252);
    fn remove_book(ref self: TContractState, id: u32);
}

#[starknet::contract]
mod EventExample {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        BookAdded: BookAdded,
        #[flat]
        FieldUpdated: FieldUpdated,
        BookRemoved: BookRemoved,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookAdded {
        pub id: u32,
        pub title: felt252,
        #[key]
        pub author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub enum FieldUpdated {
        Title: UpdatedTitleData,
        Author: UpdatedAuthorData,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedTitleData {
        #[key]
        pub id: u32,
        pub new_title: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedAuthorData {
        #[key]
        pub id: u32,
        pub new_author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookRemoved {
        pub id: u32,
    }

    #[abi(embed_v0)]
    impl EventExampleImpl of super::IEventExample<ContractState> {
        fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
            // ... logic to add a book in the contract storage ...
            self.emit(BookAdded { id, title, author });
        }

        fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
            self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
        }

        fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
            self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
        }

        fn remove_book(ref self: ContractState, id: u32) {
            self.emit(BookRemoved { id });
        }

    }
}

```

Each variant, like `BookAdded` or `FieldUpdated` represents an event that can be emitted by the contract. The variant data represents the data associated to an event. It can be any `struct` or `enum` that implements the `starknet::Event` trait.
This can be simply achieved by adding a `#[derive(starknet::Event)]` attribute on top of your type definition.

Each event data field can be annotated with the attribute `#[key]`. Key fields are then stored separately than data fields to be used by external tools to easily filter events on these keys.

Let's look at the full event definition of this example to add, update and remove books:

```cairo noplayground hljs hide-boring

#[starknet::interface]
pub trait IEventExample<TContractState> {
    fn add_book(ref self: TContractState, id: u32, title: felt252, author: felt252);
    fn change_book_title(ref self: TContractState, id: u32, new_title: felt252);
    fn change_book_author(ref self: TContractState, id: u32, new_author: felt252);
    fn remove_book(ref self: TContractState, id: u32);
}

#[starknet::contract]
mod EventExample {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        BookAdded: BookAdded,
        #[flat]
        FieldUpdated: FieldUpdated,
        BookRemoved: BookRemoved,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookAdded {
        pub id: u32,
        pub title: felt252,
        #[key]
        pub author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub enum FieldUpdated {
        Title: UpdatedTitleData,
        Author: UpdatedAuthorData,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedTitleData {
        #[key]
        pub id: u32,
        pub new_title: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedAuthorData {
        #[key]
        pub id: u32,
        pub new_author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookRemoved {
        pub id: u32,
    }

    #[abi(embed_v0)]
    impl EventExampleImpl of super::IEventExample<ContractState> {
        fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
            // ... logic to add a book in the contract storage ...
            self.emit(BookAdded { id, title, author });
        }

        fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
            self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
        }

        fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
            self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
        }

        fn remove_book(ref self: ContractState, id: u32) {
            self.emit(BookRemoved { id });
        }

    }
}

```

In this example:

- There are 3 events: `BookAdded`, `FieldUpdated` and `BookRemoved`,
- `BookAdded` and `BookRemoved` events use a simple `struct` to store their data while the `FieldUpdated` event uses an `enum` of structs,
- In the `BookAdded` event, the `author` field is a key field and will be used outside of the smart contract to filter `BookAdded` events by `author`, while `id` and `title` are data fields.

> The **variant** and its associated data structure can be named differently, although it's common practice to use the same name. The **variant name** is used internally as the **first event key** to represent the name of the event and to help filter events, while the **variant data name** is used in the smart contract to **build the event** before it is emitted.

Sometimes you may have a complex event structure with some nested enums like the `FieldUpdated` event in the previous example. In this case, you can flatten this structure using the `#[flat]` attribute, which means that the inner variant name is used as the event name instead of the variant name of the annotated enum.
In the previous example, because the `FieldUpdated` variant is annotated with `#[flat]`, when you emit a `FieldUpdated::Title` event, its name will be `Title` instead of `FieldUpdated`.
If you have more than 2 nested enums, you can use the `#[flat]` attribute on multiple levels.

Once you have defined your list of events, you want to emit them in your smart contracts. This can be simply achieved by calling `self.emit()` with an event data structure in parameter.

```cairo noplayground hljs hide-boring

#[starknet::interface]
pub trait IEventExample<TContractState> {
    fn add_book(ref self: TContractState, id: u32, title: felt252, author: felt252);
    fn change_book_title(ref self: TContractState, id: u32, new_title: felt252);
    fn change_book_author(ref self: TContractState, id: u32, new_author: felt252);
    fn remove_book(ref self: TContractState, id: u32);
}

#[starknet::contract]
mod EventExample {
    #[storage]
    struct Storage {}

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        BookAdded: BookAdded,
        #[flat]
        FieldUpdated: FieldUpdated,
        BookRemoved: BookRemoved,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookAdded {
        pub id: u32,
        pub title: felt252,
        #[key]
        pub author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub enum FieldUpdated {
        Title: UpdatedTitleData,
        Author: UpdatedAuthorData,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedTitleData {
        #[key]
        pub id: u32,
        pub new_title: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UpdatedAuthorData {
        #[key]
        pub id: u32,
        pub new_author: felt252,
    }

    #[derive(Drop, starknet::Event)]
    pub struct BookRemoved {
        pub id: u32,
    }

    #[abi(embed_v0)]
    impl EventExampleImpl of super::IEventExample<ContractState> {
        fn add_book(ref self: ContractState, id: u32, title: felt252, author: felt252) {
            // ... logic to add a book in the contract storage ...
            self.emit(BookAdded { id, title, author });
        }

        fn change_book_title(ref self: ContractState, id: u32, new_title: felt252) {
            self.emit(FieldUpdated::Title(UpdatedTitleData { id, new_title }));
        }

        fn change_book_author(ref self: ContractState, id: u32, new_author: felt252) {
            self.emit(FieldUpdated::Author(UpdatedAuthorData { id, new_author }));
        }

        fn remove_book(ref self: ContractState, id: u32) {
            self.emit(BookRemoved { id });
        }

    }
}

```

To have a better understanding of what happens under the hood, let's see two examples of emitted events and how they are stored in the transaction receipt:

In this example, we send a transaction invoking the `add_book` function with `id` = 42, `title` = 'Misery' and `author` = 'S. King'.

If you read the "events" section of the transaction receipt, you will get something like:

```json hljs

"events": [\
    {\
      "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",\
      "keys": [\
        "0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc",\
        "0x532e204b696e67"\
      ],\
      "data": [\
        "0x2a",\
        "0x4d6973657279"\
      ]\
    }\
  ]

```

In this receipt:

- `from_address` is the address of your smart contract,
- `keys` contains the key fields of the emitted `BookAdded` event, serialized in an array of `felt252`.

  - The first key `0x2d00090ebd741d3a4883f2218bd731a3aaa913083e84fcf363af3db06f235bc` is the selector of the event name, which is the variant name in the `Event` enum, so `selector!("BookAdded")`,
  - The second key `0x532e204b696e67 = 'S. King'` is the `author` field of your event as it has been defined using the `#[key]` attribute,
- `data` contains the data fields of the emitted `BookAdded` event, serialized in an array of `felt252`. The first item `0x2a = 42` is the `id` data field and `0x4d6973657279 = 'Misery'` is the `title` data field.

Now we want to change the author name of the book, so we send a transaction invoking `change_book_author` with `id` = `42` and `new_author` = 'Stephen King'.

This `change_book_author` call emits a `FieldUpdated` event with the event data `FieldUpdated::Author(UpdatedAuthorData { id: 42, title: author: 'Stephen King' })`. If you read the "events" section of the transaction receipt, you will get something like:

```json hljs

"events": [\
    {\
      "from_address": "0x27d07155a12554d4fd785d0b6d80c03e433313df03bb57939ec8fb0652dbe79",\
      "keys": [\
        "0x1b90a4a3fc9e1658a4afcd28ad839182217a69668000c6104560d6db882b0e1",\
        "0x2a"\
      ],\
      "data": [\
        "0x5374657068656e204b696e67"\
      ]\
    }\
  ]

```

As the `FieldUpdated` variant in `Event` enum has been annotated with the `#[flat]` attribute, this is the inner variant `Author` that is used as event name, instead of `FieldUpdated`. So:

- the first key is `selector!("Author")`,
- the second key is the `id` field, annotated with `#[key]`,
- the data field is `0x5374657068656e204b696e67 = 'Stephen King'`.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1100133388.1738497965&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=304520434)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-02-hello-world.md "Suggest an edit")

Now that youâ€™ve installed Cairo through Scarb, itâ€™s time to write your first Cairo program.
Itâ€™s traditional when learning a new language to write a little program that
prints the text `Hello, world!` to the screen, so weâ€™ll do the same here!

> Note: This book assumes basic familiarity with the command line. Cairo makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. The Cairo team has developed
> a VSCode extension for the Cairo language that you can use to get the features from
> the language server and code highlighting. See [Appendix F](https://book.cairo-lang.org/appendix-06-useful-development-tools.html)
> for more details.

Youâ€™ll start by making a directory to store your Cairo code. It doesnâ€™t matter
to Cairo where your code lives, but for the exercises and projects in this book,
we suggest making a _cairo\_projects_ directory in your home directory and keeping all
your projects there.

Open a terminal and enter the following commands to make a _cairo\_projects_ directory.

For Linux, macOS, and PowerShell on Windows, enter this:

```shell hljs

mkdir ~/cairo_projects
cd ~/cairo_projects

```

For Windows CMD, enter this:

```cmd hljs

> mkdir "%USERPROFILE%\cairo_projects"
> cd /d "%USERPROFILE%\cairo_projects"

```

> Note: From now on, for each example shown in the book, we assume that
> you will be working from a Scarb project directory. If you are not using Scarb, and try to run the examples from a different directory, you might need to adjust the commands accordingly or create a Scarb project.

Letâ€™s create a new project using Scarb.

Navigate to your _cairo\_projects_ directory (or wherever you decided to store your code). Then run the following:

```bash hljs

scarb new hello_world

```

Scarb will ask you about the dependencies you want to add.
You will be given two options :

```text hljs plaintext

? Which test runner do you want to set up? â€º
â¯ Starknet Foundry (default)
  Cairo Test

```

In general, we'll prefer using the first one `â¯ Starknet Foundry (default)`.

This creates a new directory and project called _hello\_world_. Weâ€™ve named our project _hello\_world_, and Scarb creates its files in a directory of the same name.

Go into the _hello\_world_ directory with the command `cd hello_world`. Youâ€™ll see that Scarb has generated three files and two directory for us: a _Scarb.toml_ file, a _src_ directory with a _lib.cairo_ file inside and a _tests_ directory containing a _test\_contract.cairo_ file. For now, we can remove this _tests_ directory.

It has also initialized a new Git repository along with a `.gitignore` file

> Note: Git is a common version control system. You can stop using version control system by using the `--no-vcs` flag.
> Run `scarb new --help` to see the available options.

Open _Scarb.toml_ in your text editor of choice. It should look similar to the code in Listing 1-1.

Filename: Scarb.toml

```toml hljs ini

[package]
name = "test"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.9.2"

[dev-dependencies]
snforge_std = "0.35.1"
assert_macros = "2.9.2"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# ...

```

Listing 1-1: Contents of _Scarb.toml_ generated by `scarb new`

This file is in the [TOML](https://toml.io/) (Tomâ€™s Obvious, Minimal Language) format, which is Scarbâ€™s configuration format.

The first line, `[package]`, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, weâ€™ll add other sections.

The next three lines set the configuration information Scarb needs to compile your program: the name of the package and the version of Scarb to use, and the edition of the prelude to use. The prelude is the collection of the most commonly used items that are automatically imported into every Cairo program. You can learn more about the prelude in [Appendix D](https://book.cairo-lang.org/appendix-04-cairo-prelude.html).

The `[dependencies]` section, is the start of a section for you to list any of your projectâ€™s dependencies. In Cairo, packages of code are referred to as crates. We wonâ€™t need any other crates for this project.

The `[dev-dependencies]` section is about dependencies that are required for development, but are not needed for the actual production build of the project. `snforge_std` and `assert_macros` are two examples of such dependencies. If you want to test your project without using Starknet Foundry, you can use `cairo_test`.

The `[[target.starknet-contract]]` section allows to build Starknet smart contracts. We can remove it for now.

The `[script]` section allows to define custom scripts. By default, there is one script for running tests using `snforge` with the `scarb test` command. We can also remove it for now.

Starknet Foundry also have more options, check out [Starknet Foundry documentation](https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html) for more information.

By default, using Starknet Foundry adds the `starknet` dependency and the `[[target.starknet-contract]]` section, so that you can build contracts for Starknet out of the box. We will start with only Cairo programs, so you can edit your _Scarb.toml_ file to the following:

Filename: Scarb.toml

```toml hljs ini

[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

[dependencies]

```

Listing 1-2: Contents of modified _Scarb.toml_

The other file created by Scarb is _src/lib.cairo_, let's delete all the content and put in the following content, we will explain the reason later.

```cairo noplayground hljs

mod hello_world;

```

Then create a new file called _src/hello\_world.cairo_ and put the following code in it:

Filename: src/hello\_world.cairo

```cairo hljs

fn main() {
    println!("Hello, World!");
}

```

We have just created a file called _lib.cairo_, which contains a module declaration referencing another module named `hello_world`, as well as the file _hello\_world.cairo_, containing the implementation details of the `hello_world` module.

Scarb requires your source files to be located within the _src_ directory.

The top-level project directory is reserved for _README_ files, license information, configuration files, and any other non-code-related content.
Scarb ensures a designated location for all project components, maintaining a structured organization.

If you started a project that doesnâ€™t use Scarb, you can convert it to a project that does use Scarb. Move the project code into the _src_ directory and create an appropriate _Scarb.toml_ file. You can also use `scarb init` command to generate the _src_ folder and the _Scarb.toml_ it contains.

```txt hljs plaintext

â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.cairo
â”‚   â””â”€â”€ hello_world.cairo

```

A sample Scarb project structure

From your _hello\_world_ directory, build your project by entering the following command:

```bash hljs

$ scarb build
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 8 seconds

```

This command creates a `hello_world.sierra.json` file in _target/dev_, let's ignore the `sierra` file for now.

If you have installed Cairo correctly, you should be able to run the `main` function of your program with the `scarb cairo-run` command and see the following output:

```shell hljs

$ scarb cairo-run
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 15 seconds
     Running hello_world
Hello, World!
Run completed successfully, returning []

```

Regardless of your operating system, the string `Hello, world!` should be printed to
the terminal.

If `Hello, world!` did print, congratulations! Youâ€™ve officially written a Cairo
program. That makes you a Cairo programmer â€” welcome!

Letâ€™s review this â€œHello, world!â€ program in detail. Hereâ€™s the first piece of
the puzzle:

```cairo noplayground hljs

fn main() {

}

```

These lines define a function named `main`. The `main` function is special: it
is always the first code that runs in every executable Cairo program. Here, the
first line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses `()`.

The function body is wrapped in `{}`. Cairo requires curly brackets around all
function bodies. Itâ€™s good style to place the opening curly bracket on the same
line as the function declaration, adding one space in between.

> Note: If you want to stick to a standard style across Cairo projects, you can
> use the automatic formatter tool available with `scarb fmt` to format your code in a
> particular style (more on `scarb fmt` in
> [Appendix F](https://book.cairo-lang.org/appendix-06-useful-development-tools.html)). The Cairo team has included this tool
> with the standard Cairo distribution, as `cairo-run` is, so it should already be
> installed on your computer!

The body of the `main` function holds the following code:

```cairo noplayground hljs

    println!("Hello, World!");

```

This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here.

First, Cairo style is to indent with four spaces, not a tab.

Second, `println!` calls a Cairo macro. If it had called a function instead, it would be entered as `println` (without the `!`).
Weâ€™ll discuss Cairo macros in more detail in the ["Macros"](https://book.cairo-lang.org/ch12-05-macros.html) chapter. For now, you just need to know that using a `!` means that youâ€™re calling a macro instead of a normal function and that macros donâ€™t always follow the same rules as functions.

Third, you see the `"Hello, world!"` string. We pass this string as an argument to `println!`, and the string is printed to the screen.

Fourth, we end the line with a semicolon ( `;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Cairo code
end with a semicolon.

Start

Letâ€™s recap what weâ€™ve learned so far about Scarb:

- We can install one or multiple Scarb versions, either the latest stable or a specific one, using asdf.
- We can create a project using `scarb new`.
- We can build a project using `scarb build` to generate the compiled Sierra code.
- We can execute a Cairo program using the `scarb cairo-run` command.

An additional advantage of using Scarb is that the commands are the same no matter which operating system youâ€™re working on. So, at this point, weâ€™ll no longer provide specific instructions for Linux and macOS versus Windows.

Youâ€™re already off to a great start on your Cairo journey! This is a great time to build a more substantial program to get used to reading and writing Cairo code.

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1951851504.1738497966&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565~102558063&z=927309262)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch104-02-testing-smart-contracts.md "Suggest an edit")

Testing smart contracts is a critical part of the development process. It is important to ensure that smart contracts behave as expected and that they are secure.

In a previous section of the Cairo Book, we learned how to write and structure our tests for Cairo programs. We demonstrated how these tests could be run using the `scarb` command-line tool.
While this approach is useful for testing standalone Cairo programs and functions, it lacks functionality for testing smart contracts that require control over the contract state and execution context. Therefore, in this section, we will introduce how to use Starknet Foundry, a smart contract development toolchain for Starknet, to test your Cairo contracts.

Throughout this chapter, we will be using as an example the `PizzaFactory` contract in Listing 18-1 to demonstrate how to write tests with Starknet Foundry.

```cairo noplayground hljs

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait IPizzaFactory<TContractState> {
    fn increase_pepperoni(ref self: TContractState, amount: u32);
    fn increase_pineapple(ref self: TContractState, amount: u32);
    fn get_owner(self: @TContractState) -> ContractAddress;
    fn change_owner(ref self: TContractState, new_owner: ContractAddress);
    fn make_pizza(ref self: TContractState);
    fn count_pizza(self: @TContractState) -> u32;
}

#[starknet::contract]
pub mod PizzaFactory {
    use super::IPizzaFactory;
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    pub struct Storage {
        pepperoni: u32,
        pineapple: u32,
        pub owner: ContractAddress,
        pizzas: u32,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.pepperoni.write(10);
        self.pineapple.write(10);
        self.owner.write(owner);
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        PizzaEmission: PizzaEmission,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PizzaEmission {
        pub counter: u32,
    }

    #[abi(embed_v0)]
    impl PizzaFactoryimpl of super::IPizzaFactory<ContractState> {
        fn increase_pepperoni(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pepperoni.write(self.pepperoni.read() + amount);
        }

        fn increase_pineapple(ref self: ContractState, amount: u32) {
            assert!(amount != 0, "Amount cannot be 0");
            self.pineapple.write(self.pineapple.read() + amount);
        }

        fn make_pizza(ref self: ContractState) {
            assert!(self.pepperoni.read() > 0, "Not enough pepperoni");
            assert!(self.pineapple.read() > 0, "Not enough pineapple");

            let caller: ContractAddress = get_caller_address();
            let owner: ContractAddress = self.get_owner();

            assert!(caller == owner, "Only the owner can make pizza");

            self.pepperoni.write(self.pepperoni.read() - 1);
            self.pineapple.write(self.pineapple.read() - 1);
            self.pizzas.write(self.pizzas.read() + 1);

            self.emit(PizzaEmission { counter: self.pizzas.read() });
        }

        fn get_owner(self: @ContractState) -> ContractAddress {
            self.owner.read()
        }

        fn change_owner(ref self: ContractState, new_owner: ContractAddress) {
            self.set_owner(new_owner);
        }

        fn count_pizza(self: @ContractState) -> u32 {
            self.pizzas.read()
        }
    }

    #[generate_trait]
    pub impl InternalImpl of InternalTrait {
        fn set_owner(ref self: ContractState, new_owner: ContractAddress) {
            let caller: ContractAddress = get_caller_address();
            assert!(caller == self.get_owner(), "Only the owner can set ownership");

            self.owner.write(new_owner);
        }
    }
}

```

Listing 18-1: A pizza factory that needs to be tested

The settings of your Scarb project can be configured in the `Scarb.toml` file. To use Starknet Foundry as your testing tool, you will need to add it as a dev dependency in your `Scarb.toml` file. At the time of writing, the latest version of Starknet Foundry is `v0.22.0` \- but you should use the latest version.

```toml noplayground hljs ini

[dev-dependencies]
snforge_std = { git = "https://github.com/foundry-rs/starknet-foundry.git", tag = "v0.33.0" }

[scripts]
test = "snforge test"

```

The `scarb test` command is configured to execute `scarb cairo-test` by default. In our settings, we have configured it to execute `snforge test` instead. This will allow us to run our tests using Starknet Foundry when we run the `scarb test` command.

Once your project is configured, you will need to install Starknet Foundry by following the installation guide from the [Starknet Foundry Documentation](https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html). As usual, we recommend to use `asdf` to manage versions of your development tools.

The usual command to run your tests using Starknet Foundry is `snforge test`. However, when we configured our projects, we defined that the `scarb test` command will run the `snforge test` command. Therefore, during the rest of this chapter, consider that the `scarb test` command will be using `snforge test` under the hood.

The usual testing flow of a contract is as follows:

1. Declare the class of the contract to test, identified by its name
2. Serialize the constructor calldata into an array
3. Deploy the contract and retrieve its address
4. Interact with the contract's entrypoint to test various scenarios

In Listing 18-2, we wrote a function that deploys the `PizzaFactory` contract and sets up the dispatcher for interactions.

```cairo noplayground hljs hide-boring

use crate::pizza::{
    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
};
use crate::pizza::PizzaFactory::{InternalTrait};

use core::starknet::{ContractAddress, contract_address_const};
use core::starknet::storage::StoragePointerReadAccess;

use snforge_std::{
    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
};

fn owner() -> ContractAddress {
    contract_address_const::<'owner'>()
}

fn deploy_pizza_factory() -> (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::<'owner'>();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}

#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}

#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::<'new_owner'>();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}

#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}

#[test]
fn test_set_as_new_owner_direct() {
    let mut state = PizzaFactory::contract_state_for_testing();
    let owner: ContractAddress = contract_address_const::<'owner'>();
    state.set_owner(owner);
    assert_eq!(state.owner.read(), owner);
}

```

Listing 18-2 Deploying the contract to test

Determining the behavior that your contract should respect is the first step in writing tests. In the `PizzaFactory` contract, we determined that the contract should have the following behavior:

- Upon deployment, the contract owner should be set to the address provided in the constructor, and the factory should have 10 units of pepperoni and pineapple, and no pizzas created.
- If someone tries to make a pizza and they are not the owner, the operation should fail. Otherwise, the pizza count should be incremented, and an event should be emitted.
- If someone tries to take ownership of the contract and they are not the owner, the operation should fail. Otherwise, the owner should be updated.

```cairo noplayground hljs hide-boring

use crate::pizza::{
    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
};
use crate::pizza::PizzaFactory::{InternalTrait};

use core::starknet::{ContractAddress, contract_address_const};
use core::starknet::storage::StoragePointerReadAccess;

use snforge_std::{
    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
};

fn owner() -> ContractAddress {
    contract_address_const::<'owner'>()
}

fn deploy_pizza_factory() -> (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::<'owner'>();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}

#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}

#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::<'new_owner'>();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}

#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}

#[test]
fn test_set_as_new_owner_direct() {
    let mut state = PizzaFactory::contract_state_for_testing();
    let owner: ContractAddress = contract_address_const::<'owner'>();
    state.set_owner(owner);
    assert_eq!(state.owner.read(), owner);
}

```

Listing 18-3: Testing the initial state by loading storage variables

Once our contract is deployed, we want to assert that the initial values are set as expected. If our contract has an entrypoint that returns the value of a storage variable, we can call this entrypoint. Otherwise, we can use the `load` function from `snforge` to load the value of a storage variable inside our contract, even if not exposed by an entrypoint.

The security of our factory relies on the owner being the only one able to make pizzas and transfer ownership. To test this, we can use the `start_cheat_caller_address` function to mock the caller address and assert that the contract behaves as expected.

```cairo noplayground hljs hide-boring

use crate::pizza::{
    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
};
use crate::pizza::PizzaFactory::{InternalTrait};

use core::starknet::{ContractAddress, contract_address_const};
use core::starknet::storage::StoragePointerReadAccess;

use snforge_std::{
    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
};

fn owner() -> ContractAddress {
    contract_address_const::<'owner'>()
}

fn deploy_pizza_factory() -> (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::<'owner'>();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}

#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}

#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::<'new_owner'>();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}

#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}

#[test]
fn test_set_as_new_owner_direct() {
    let mut state = PizzaFactory::contract_state_for_testing();
    let owner: ContractAddress = contract_address_const::<'owner'>();
    state.set_owner(owner);
    assert_eq!(state.owner.read(), owner);
}

```

Listing 18-4: Testing ownership of the contract by mocking the caller address

Using `start_cheat_caller_address`, we call the `change_owner` function first as the owner, and then as a different address. We assert that the operation fails when the caller is not the owner, and that the owner is updated when the caller is the owner.

When a pizza is created, the contract emits an event. To test this, we can use the `spy_events` function to capture the emitted events and assert that the event was emitted with the expected parameters. Naturally, we can also assert that the pizza count was incremented, and that only the owner can make a pizza.

```cairo noplayground hljs hide-boring

use crate::pizza::{
    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
};
use crate::pizza::PizzaFactory::{InternalTrait};

use core::starknet::{ContractAddress, contract_address_const};
use core::starknet::storage::StoragePointerReadAccess;

use snforge_std::{
    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
};

fn owner() -> ContractAddress {
    contract_address_const::<'owner'>()
}

fn deploy_pizza_factory() -> (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::<'owner'>();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}

#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}

#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::<'new_owner'>();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}

#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}

#[test]
fn test_set_as_new_owner_direct() {
    let mut state = PizzaFactory::contract_state_for_testing();
    let owner: ContractAddress = contract_address_const::<'owner'>();
    state.set_owner(owner);
    assert_eq!(state.owner.read(), owner);
}

```

Listing 18-5: Testing the events emitted when a pizza is created

All the tests we have seen so far have been using a workflow that involves deploying the contract and interacting with the contract's entrypoints. However, sometimes we may want to test the internals of the contract directly, without deploying the contract. How could this be done, if we were reasoning in purely Cairo terms?

Recall the struct `ContractState`, which is used as a parameter to all the entrypoints of a contract. To make it short, this struct contains zero-sized fields, corresponding to the storage variables of the contract. The only purpose of these fields is to allow the Cairo compiler to generate the correct code for accessing the storage variables. If we could create an instance of this struct, we could access these storage variables directly, without deploying the contract...

...and this is exactly what the `contract_state_for_testing` function does! It creates an instance of the `ContractState` struct, allowing us to call any function that takes as parameter a `ContractState` struct, without deploying the contract. To interact with the storage variables properly, we need to manually import the traits that define access to the storage variables.

```cairo noplayground hljs hide-boring

use crate::pizza::{
    IPizzaFactoryDispatcher, IPizzaFactoryDispatcherTrait, PizzaFactory,
    PizzaFactory::{Event as PizzaEvents, PizzaEmission},
};
use crate::pizza::PizzaFactory::{InternalTrait};

use core::starknet::{ContractAddress, contract_address_const};
use core::starknet::storage::StoragePointerReadAccess;

use snforge_std::{
    declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address,
    stop_cheat_caller_address, EventSpyAssertionsTrait, spy_events, load,
};

fn owner() -> ContractAddress {
    contract_address_const::<'owner'>()
}

fn deploy_pizza_factory() -> (IPizzaFactoryDispatcher, ContractAddress) {
    let contract = declare("PizzaFactory").unwrap().contract_class();

    let owner: ContractAddress = contract_address_const::<'owner'>();
    let constructor_calldata = array![owner.into()];

    let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();

    let dispatcher = IPizzaFactoryDispatcher { contract_address };

    (dispatcher, contract_address)
}

#[test]
fn test_constructor() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let pepperoni_count = load(pizza_factory_address, selector!("pepperoni"), 1);
    let pineapple_count = load(pizza_factory_address, selector!("pineapple"), 1);
    assert_eq!(pepperoni_count, array![10]);
    assert_eq!(pineapple_count, array![10]);
    assert_eq!(pizza_factory.get_owner(), owner());
}

#[test]
fn test_change_owner_should_change_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();

    let new_owner: ContractAddress = contract_address_const::<'new_owner'>();
    assert_eq!(pizza_factory.get_owner(), owner());

    start_cheat_caller_address(pizza_factory_address, owner());

    pizza_factory.change_owner(new_owner);

    assert_eq!(pizza_factory.get_owner(), new_owner);
}

#[test]
#[should_panic(expected: "Only the owner can set ownership")]
fn test_change_owner_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);
    pizza_factory.change_owner(not_owner);
    stop_cheat_caller_address(pizza_factory_address);
}

#[test]
#[should_panic(expected: "Only the owner can make pizza")]
fn test_make_pizza_should_panic_when_not_owner() {
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    let not_owner = contract_address_const::<'not_owner'>();
    start_cheat_caller_address(pizza_factory_address, not_owner);

    pizza_factory.make_pizza();
}

#[test]
fn test_make_pizza_should_increment_pizza_counter() {
    // Setup
    let (pizza_factory, pizza_factory_address) = deploy_pizza_factory();
    start_cheat_caller_address(pizza_factory_address, owner());
    let mut spy = spy_events();

    // When
    pizza_factory.make_pizza();

    // Then
    let expected_event = PizzaEvents::PizzaEmission(PizzaEmission { counter: 1 });
    assert_eq!(pizza_factory.count_pizza(), 1);
    spy.assert_emitted(@array![(pizza_factory_address, expected_event)]);
}

#[test]
fn test_set_as_new_owner_direct() {
    let mut state = PizzaFactory::contract_state_for_testing();
    let owner: ContractAddress = contract_address_const::<'owner'>();
    state.set_owner(owner);
    assert_eq!(state.owner.read(), owner);
}

```

Listing 18-6: Unit testing our contract without deployment

These imports give us access to our internal functions (notably, `set_owner`), as well as the
read/write access to the `owner` storage variable. Once we have these, we can interact with the
contract directly, changing the address of the owner by calling the `set_owner` method, accessible
through `InternalTrait`, and reading the `owner` storage variable.

> Note: Both approaches cannot be used at the same time. If you decide to deploy the contract, you interact with it using the dispatcher. If you decide to test the internal functions, you interact with the `ContractState` object directly.

```bash noplayground hljs

$ scarb test
     Running test listing_02_pizza_factory_snfoundry (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Finished `release` profile [optimized] target(s) in 0.99s
   Compiling test(listings/ch17-starknet-smart-contracts-security/listing_02_pizza_factory_snfoundry/Scarb.toml)
    Finished `dev` profile target(s) in 7 seconds

Collected 6 test(s) from listing_02_pizza_factory_snfoundry package
Running 6 test(s) from src/
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_set_as_new_owner_direct (gas: ~130)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_panic_when_not_owner (gas: ~298)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_constructor (gas: ~297)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_panic_when_not_owner (gas: ~298)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_make_pizza_should_increment_pizza_counter (gas: ~368)
[PASS] listing_02_pizza_factory_snfoundry::tests::foundry_test::test_change_owner_should_change_owner (gas: ~303)
Tests: 6 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

```

The output of the tests shows that all the tests passed successfully, along with an estimation of the gas consumed by each test.

In this chapter, we learned how to test smart contracts using Starknet Foundry. We demonstrated how to deploy a contract and interact with it using the dispatcher. We also showed how to test the contract's behavior by mocking the caller address and capturing events. Finally, we demonstrated how to test the internal functions of the contract directly, without deploying the contract.

To learn more about Starknet Foundry, refer to the [Starknet Foundry documentation](https://foundry-rs.github.io/starknet-foundry/index.html).

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=2117362038.1738497967&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102558063&z=1118409984)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1179494260.1738497968&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1827086007)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch09-02-recoverable-errors.md "Suggest an edit")

La mayorÃ­a de los errores no son lo suficientemente graves como para que el programa se detenga por completo. A veces, cuando una funciÃ³n falla, es por una razÃ³n que usted puede interpretar fÃ¡cilmente y a la que puede responder. Por ejemplo, si intenta sumar dos enteros grandes y la operaciÃ³n se desborda porque la suma excede el valor mÃ¡ximo representable, es posible que desee devolver un error o un resultado envuelto en lugar de causar un comportamiento indefinido o terminar el proceso.

Recall from [Generic data types](https://book.cairo-lang.org/es/ch08-01-generic-data-types.html#enums) section in Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and `Err`, as follows:

```cairo noplayground hljs

enum Result<T, E> {
    Ok: T,
    Err: E,
}

```

El enum `Result<T, E>` tiene dos tipos genÃ©ricos, `T` y `E`, y dos variantes: `Ok` que tiene el valor de tipo `T` y `Err` que tiene el valor de tipo `E`. Esta definiciÃ³n hace que sea conveniente usar el enum `Result` en cualquier lugar donde tengamos una operaciÃ³n que pueda tener Ã©xito (devolviendo un valor de tipo `T`) o fallar (devolviendo un valor de tipo `E`).

El rasgo `ResultTrait` proporciona mÃ©todos para trabajar con el enum `Result<T, E>`, como desenvolver valores, comprobar si el `Result` es `Ok` o `Err`, y entrar en pÃ¡nico con un mensaje personalizado. La implementaciÃ³n de `ResultTraitImpl` define la lÃ³gica de estos mÃ©todos.

```cairo noplayground hljs

trait ResultTrait<T, E> {
    fn expect<+Drop<E>>(self: Result<T, E>, err: felt252) -> T;

    fn unwrap<+Drop<E>>(self: Result<T, E>) -> T;

    fn expect_err<+Drop<T>>(self: Result<T, E>, err: felt252) -> E;

    fn unwrap_err<+Drop<T>>(self: Result<T, E>) -> E;

    fn is_ok(self: @Result<T, E>) -> bool;

    fn is_err(self: @Result<T, E>) -> bool;
}

```

Los mÃ©todos `expect` y `unwrap` se parecen en que ambos intentan extraer el valor de tipo `T` de un `Resultado<T, E>` cuando estÃ¡ en la variante `Ok`. Si el `Resultado` es `Ok(x)`, ambos mÃ©todos devuelven el valor `x`. Sin embargo, la diferencia clave entre los dos mÃ©todos radica en su comportamiento cuando el `Result` estÃ¡ en la variante `Err`. El mÃ©todo `expect` te permite proporcionar un mensaje de error personalizado (como un valor `felt252`) que se utilizarÃ¡ cuando se produzca el pÃ¡nico, dÃ¡ndote mÃ¡s control y contexto sobre el pÃ¡nico. Por otro lado, el mÃ©todo `unwrap` entra en pÃ¡nico con un mensaje de error por defecto, proporcionando menos informaciÃ³n sobre la causa del pÃ¡nico.

The `expect_err` and `unwrap_err` methods have the exact opposite behavior. If the `Result` is `Err(x)`, both methods return the value `x`. However, the key difference between the two methods is in case of `Result::Ok()`. The `expect_err` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap_err` method panics with a default error message, providing less information about the cause of the panic.

A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the first four methods signatures. This syntax represents generic type constraints in the Cairo language, as seen in the previous chapter. These constraints indicate that the associated functions require an implementation of the `Drop` trait for the generic types `T` and `E`, respectively.

Por Ãºltimo, los mÃ©todos `is_ok` y `is_err` son funciones de utilidad proporcionadas por el rasgo `ResultTrait` para comprobar la variante de un valor del enum `Result`.

- `is_ok` toma una instantÃ¡nea de un valor `Result<T, E>` y devuelve `true` si el `Result` es la variante `Ok`, lo que significa que la operaciÃ³n se ha realizado correctamente. Si el `Resultado` es la variante `Err`, devuelve `false`.
- `is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Err` variant, meaning the operation encountered an error. If the `Result` is the `Ok` variant, it returns `false`.

These methods are helpful when you want to check the success or failure of an operation without consuming the `Result` value, allowing you to perform additional operations or make decisions based on the variant without unwrapping it.

Puede encontrar la implementaciÃ³n del `ResultTrait` [aquÃ­](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20).

It is always easier to understand with examples. Have a look at this function signature:

```cairo noplayground hljs

fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;

```

It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, u128>` where the `Ok` variant holds the sum if the addition does not overflow, and the `Err` variant holds the overflowed value if the addition does overflow.

Ahora, podemos utilizar esta funciÃ³n en otros lugares. Por ejemplo:

```cairo noplayground hljs

fn u128_checked_add(a: u128, b: u128) -> Option<u128> {
    match u128_overflowing_add(a, b) {
        Result::Ok(r) => Option::Some(r),
        Result::Err(r) => Option::None,
    }
}

```

Here, it accepts two `u128` integers, `a` and `b`, and returns an `Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to determine the success or failure of the addition operation. The `match` expression checks the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it returns `Option::None` to indicate that the operation has failed due to overflow. The function does not panic in case of an overflow.

Let's take another example:

```cairo noplayground hljs

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

```

In this example, the `parse_u8` function takes a `felt252` and tries to convert it into a `u8` integer using the `try_into` method. If successful, it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid integer')`.

Nuestros dos casos de prueba son:

```cairo noplayground hljs hide-boring

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_felt252_to_u8() {
        let number: felt252 = 5;
        // should not panic
        let res = parse_u8(number).unwrap();
    }

    #[test]
    #[should_panic]
    fn test_felt252_to_u8_panic() {
        let number: felt252 = 256;
        // should panic
        let res = parse_u8(number).unwrap();
    }
}

```

Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in more detail its meaning in the next [Testing Cairo Programs](https://book.cairo-lang.org/es/ch10-01-how-to-write-tests.html) chapter.

`#[test]` attribute means the function is a test function, and `#[should_panic]` attribute means this test will pass if the test execution panics.

The first one tests a valid conversion from `felt252` to `u8`, expecting the `unwrap` method not to panic. The second test function attempts to convert a value that is out of the `u8` range, expecting the `unwrap` method to panic with the error message `Invalid integer`.

El Ãºltimo operador del que hablaremos es el operador `?`. El operador `?` se utiliza para un manejo de errores mÃ¡s idiomÃ¡tico y conciso. Cuando usas el operador `?` en un tipo `Result` u `Option`, harÃ¡ lo siguiente:

- If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the inner value `x` directly.
- If the value is `Result::Err(e)` or `Option::None`, it will propagate the error or `None` by immediately returning from the function.

El operador `?` es Ãºtil cuando se desea manejar los errores implÃ­citamente y dejar que la funciÃ³n de llamada se ocupe de ellos.

AquÃ­ un ejemplo:

```cairo noplayground hljs

fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {
    let input_to_u8: u8 = parse_u8(input)?;
    // DO SOMETHING
    let res = input_to_u8 - 1;
    Result::Ok(res)
}

```

We can see that `do_something_with_parse_u8` function takes a `felt252` value as input and calls `parse_u8` function. The `?` operator is used to propagate the error, if any, or unwrap the successful value.

Y con un pequeÃ±o caso de prueba:

```cairo noplayground hljs hide-boring

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {
    let input_to_u8: u8 = parse_u8(input)?;
    // DO SOMETHING
    let res = input_to_u8 - 1;
    Result::Ok(res)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_function_2() {
        let number: felt252 = 258;
        match do_something_with_parse_u8(number) {
            Result::Ok(value) => println!("Result: {}", value),
            Result::Err(e) => println!("Error: {}", e),
        }
    }
}

```

The console will print the error `Invalid Integer`.

We saw that recoverable errors can be handled in Cairo using the `Result` enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is generic, with types `T` and `E` representing the successful and error values, respectively. The `ResultTrait` provides methods for working with `Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or `Err`, and panicking with custom messages.

Para gestionar errores recuperables, una funciÃ³n puede devolver un tipo `Result` y utilizar la concordancia de patrones para gestionar el Ã©xito o el fracaso de una operaciÃ³n. El operador `?` puede utilizarse para gestionar errores implÃ­citamente, propagando el error o desenvolviendo el valor correcto. Esto permite una gestiÃ³n de errores mÃ¡s concisa y clara, en la que el autor de la llamada es responsable de gestionar los errores generados por la funciÃ³n llamada.

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-09-deref-coercion.md "Suggest an edit")

Deref coercion simplifies the way we interact with nested or wrapped data structures by allowing an instance of one type to behave like an instance of another type. This mechanism is enabled by implementing the `Deref` trait, which allows implicit conversion (or coercion) to a different type, providing direct access to the underlying data.

> Note: For now, deref coercion allows you to access a member of a type `T` as if it was a type `K`, but will not allow you to call functions whose `self` argument is of the original type when holding an instance of the coerced type.

Deref coercion is implemented via the `Deref` and `DerefMut` traits. When a type `T` implements `Deref` or `DerefMut` to type `K`, instances of `T` can access the members of `K` directly.

The `Deref` trait in Cairo is defined as follows:

```cairo noplayground hljs hide-boring

pub trait Deref<T> {
    type Target;
    fn deref(self: T) -> Self::Target;
}

pub trait DerefMut<T> {
    type Target;
    fn deref_mut(ref self: T) -> Self::Target;
}

```

The `Target` type specifies the result of dereferencing, and the `deref` method defines how to transform `T` into `K`.

To better understand how deref coercion works, let's look at a practical example. We'll create a simple generic wrapper type around a type `T` called `Wrapper<T>`, and use it to wrap a `UserProfile` struct.

```cairo noplayground hljs hide-boring

#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper<T> {
    value: T,
}

impl DerefWrapper<T> of Deref<Wrapper<T>> {
    type Target = T;
    fn deref(self: Wrapper<T>) -> T {
        self.value
    }
}

fn main() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Access fields directly via deref coercion
    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}

```

The `Wrapper` struct wraps a single value generic of type `T`. To simplify access to the wrapped value, we implement the `Deref` trait for `Wrapper<T>`.

```cairo noplayground hljs hide-boring

#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper<T> {
    value: T,
}

impl DerefWrapper<T> of Deref<Wrapper<T>> {
    type Target = T;
    fn deref(self: Wrapper<T>) -> T {
        self.value
    }
}

fn main() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Access fields directly via deref coercion
    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}

```

This implementation is quite simple. The `deref` method returns the wrapped value, allowing instances of `Wrapper<T>` to access the members of `T` directly.

In practice, this mechanism is totally transparent. The following example demonstrates how, holding
an instance of `Wrapper<UserProfile>`, we can print the `username` and `age` fields of the underlying
`UserProfile` instance.

```cairo hljs hide-boring

#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper<T> {
    value: T,
}

impl DerefWrapper<T> of Deref<Wrapper<T>> {
    type Target = T;
    fn deref(self: Wrapper<T>) -> T {
        self.value
    }
}

fn main() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Access fields directly via deref coercion
    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}

```

While `Deref` works for both mutable and immutable variables, `DerefMut` will only be applicable to mutable variables. Contrary to what the name might suggest, `DerefMut` does not provide mutable access to the underlying data.

```cairo noplayground hljs hide-boring

//TAG: does_not_compile

use core::ops::DerefMut;

#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper<T> {
    value: T,
}

impl DerefMutWrapper<T, +Copy<T>> of DerefMut<Wrapper<T>> {
    type Target = T;
    fn deref_mut(ref self: Wrapper<T>) -> T {
        self.value
    }
}

fn error() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Uncommenting the next line will cause a compilation error
    println!("Username: {}", wrapped_profile.username);
}

fn main() {
    let mut wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };

    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}

```

If you try to use `DerefMut` with an immutable variable, the compiler would throw an error. Hereâ€™s an example:

```cairo noplayground hljs hide-boring

//TAG: does_not_compile

use core::ops::DerefMut;

#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper<T> {
    value: T,
}

impl DerefMutWrapper<T, +Copy<T>> of DerefMut<Wrapper<T>> {
    type Target = T;
    fn deref_mut(ref self: Wrapper<T>) -> T {
        self.value
    }
}

fn error() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Uncommenting the next line will cause a compilation error
    println!("Username: {}", wrapped_profile.username);
}

fn main() {
    let mut wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };

    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}

```

Compiling this code will result in the following error:

```plaintext hljs

$ scarb build
   Compiling no_listing_09_deref_coercion_example v0.1.0 (listings/ch12-advanced-features/no_listing_09_deref_mut_example/Scarb.toml)
error: Type "no_listing_09_deref_coercion_example::Wrapper::<no_listing_09_deref_coercion_example::UserProfile>" has no member "username"
 --> listings/ch12-advanced-features/no_listing_09_deref_mut_example/src/lib.cairo:32:46
    println!("Username: {}", wrapped_profile.username);
                                             ^******^

error: could not compile `no_listing_09_deref_coercion_example` due to previous error

```

For the above code to work, we need to define `wrapped_profile` as a mutable variable.

```cairo noplayground hljs hide-boring

//TAG: does_not_compile

use core::ops::DerefMut;

#[derive(Drop, Copy)]
struct UserProfile {
    username: felt252,
    email: felt252,
    age: u16,
}

#[derive(Drop, Copy)]
struct Wrapper<T> {
    value: T,
}

impl DerefMutWrapper<T, +Copy<T>> of DerefMut<Wrapper<T>> {
    type Target = T;
    fn deref_mut(ref self: Wrapper<T>) -> T {
        self.value
    }
}

fn error() {
    let wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };
    // Uncommenting the next line will cause a compilation error
    println!("Username: {}", wrapped_profile.username);
}

fn main() {
    let mut wrapped_profile = Wrapper {
        value: UserProfile { username: 'john_doe', email: 'john@example.com', age: 30 },
    };

    println!("Username: {}", wrapped_profile.username);
    println!("Current age: {}", wrapped_profile.age);
}

```

By using the `Deref` and `DerefMut` traits, we can transparently convert one type into another, simplifying the access to nested or wrapped data structures. This feature is particularly useful when working with generic types or building abstractions that require seamless access to the underlying data and can help reduce boilerplate code.
However, this functionality is quite limited, as you cannot call functions whose `self` argument is of the original type when holding an instance of the coerced type.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1555833416.1738497951&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015666~102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=589380036)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-00-advanced-features.md "Suggest an edit")

Sekarang, mari kita pelajari tentang fitur-fitur lebih lanjut yang ditawarkan oleh Cairo.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=237522247.1738497969&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=562624339)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-00-common-collections.md "Suggest an edit")

Cairo provides a set of common collection types that can be used to store and manipulate data. These collections are designed to be efficient, flexible, and easy to use. This section introduces the primary collection types available in Cairo: Arrays and Dictionaries.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1546345353.1738497970&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102325445~102482433~102528644~102539968~102546754~102558063&z=190694050)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=384770300.1738497971&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102308675~102482432~102528644~102539968~102546754~102556566&z=979636878)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-01-arrays.md "Suggest an edit")

An array is a collection of elements of the same type. You can create and use array methods by using the `ArrayTrait` trait from the core library.

An important thing to note is that arrays have limited modification options. Arrays are, in fact, queues whose values can't be modified. This has to do with the fact that once a memory slot is written to, it cannot be overwritten, but only read from it. You can only append items to the end of an array and remove items from the front.

Creating an array is done with the `ArrayTrait::new()` call. Here's an example of creating an array and appending 3 elements to it:

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

Jika diperlukan, Anda dapat menyertakan tipe item yang diharapkan di dalam array saat menginstansiasi array seperti ini, atau secara eksplisit menentukan tipe variabel.

```cairo noplayground hljs

let mut arr = ArrayTrait::<u128>::new();

```

```cairo noplayground hljs

let mut arr:Array<u128> = ArrayTrait::new();

```

Untuk menambahkan elemen ke akhir array, Anda dapat menggunakan metode `append()`:

```cairo hljs hide-boring

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

You can only remove elements from the front of an array by using the `pop_front()` method. This method returns an `Option` that can be unwrapped, containing the removed element, or `Option::None` if the array is empty.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    println!("The first value is {}", first_value);
}

```

The above code will print `The first value is 10` as we remove the first element that was added.

Dalam Cairo, memori bersifat imutabel, yang berarti bahwa tidak mungkin untuk memodifikasi elemen-elemen dari suatu array setelah mereka ditambahkan. Anda hanya dapat menambahkan elemen ke akhir array dan menghapus elemen dari depan array. Operasi-operasi ini tidak memerlukan mutasi memori, karena melibatkan pembaruan pointer daripada langsung memodifikasi sel-sel memori.

Untuk mengakses elemen-elemen array, Anda dapat menggunakan metode array `get()` atau `at()` yang mengembalikan tipe yang berbeda. Menggunakan `arr.at(indeks)` setara dengan menggunakan operator subscripting `arr[indeks]`.

The `get` function returns an `Option<Box<@T>>`, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the ["References and Snapshots"](https://book.cairo-lang.org/id/ch04-02-references-and-snapshots.html#snapshots) chapter.

Berikut adalah contoh dengan metode `get()`:

```cairo hljs

fn main() -> u128 {
    let mut arr = ArrayTrait::<u128>::new();
    arr.append(100);
    let index_to_access =
        1; // Change this value to see different results, what would happen if the index doesn't exist?
    match arr.get(index_to_access) {
        Option::Some(x) => {
            *x
                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
            // It basically means "transform what get(idx) returned into a real value"
        },
        Option::None => { panic!("out of bounds") },
    }
}

```

The `at` function, and its equivalent the subscripting operator, on the other hand, directly return a snapshot to the element at the specified index using the `unbox()` operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use `at` when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    // using the `at()` method
    let first = *a.at(0);
    assert!(first == 0);
    // using the subscripting operator
    let second = *a[1];
    assert!(second == 1);
}

```

Dalam contoh ini, variabel bernama `first` akan mendapatkan nilai `0` karena itu adalah nilai pada indeks `0` dalam array. Variabel bernama `second` akan mendapatkan nilai `1` dari indeks `1` dalam array.

Secara ringkas, gunakan `at` ketika Anda ingin program mengalami panic pada percobaan akses di luar batas, dan gunakan `get` ketika Anda lebih suka menangani kasus-kasus tersebut dengan lembut tanpa panic.

To determine the number of elements in an array, use the `len()` method. The return value is of type `usize`.

Jika Anda ingin memeriksa apakah sebuah array kosong atau tidak, Anda dapat menggunakan metode `is_empty()`, yang mengembalikan nilai `true` jika array tersebut kosong dan `false` jika tidak.

Sometimes, we need to create arrays with values that are already known at compile time. The basic way of doing that is redundant. You would first declare the array and then append each value one by one. `array!` is a simpler way of doing this task by combining the two steps. At compile-time, the compiler will expand the macro to generate the code that appends the items sequentially.

Without `array!`:

```cairo hljs

    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr.append(4);
    arr.append(5);

```

Dengan `array!`:

```cairo hljs

    let arr = array![1, 2, 3, 4, 5];

```

If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type that can hold multiple types. Enums will be explained in more detail in the ["Enums and Pattern Matching"](https://book.cairo-lang.org/id/ch06-00-enums-and-pattern-matching.html) chapter.

```cairo hljs

#[derive(Copy, Drop)]
enum Data {
    Integer: u128,
    Felt: felt252,
    Tuple: (u32, u32),
}

fn main() {
    let mut messages: Array<Data> = array![];
    messages.append(Data::Integer(100));
    messages.append(Data::Felt('hello world'));
    messages.append(Data::Tuple((10, 30)));
}

```

`Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations, as introduced in ["References and Snapshots"](https://book.cairo-lang.org/id/ch04-02-references-and-snapshots.html).

All methods provided by `Array` can also be used with `Span`, except for the `append()` method.

Untuk membuat `Span` dari sebuah `Array`, panggil metode `span()`:

```cairo hljs hide-boring

fn main() {
    let mut array: Array<u8> = ArrayTrait::new();
    array.span();
}

```

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch101-02-contract-functions.md "Suggest an edit")

In this section, we are going to be looking at the different types of functions you could encounter in Starknet smart contracts.

Functions can access the contract's state easily via the `self: ContractState` object, which abstracts away the complexity of underlying system calls ( `storage_read_syscall` and `storage_write_syscall`). The compiler provides two modifiers: `ref` and `@` to decorate `self`, which intends to distinguish view and external functions.

Let's consider the `NameRegistry` contract in Listing 15-4 that we'll be using throughout this chapter:

```cairo noplayground hljs

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry<TContractState> {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
}

#[starknet::contract]
mod NameRegistry {
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };

    #[storage]
    struct Storage {
        names: Map::<ContractAddress, felt252>,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry<ContractState> {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -> felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -> felt252 {
        self.total_names.__base_address__
    }
}

```

Listing 15-4: Our reference contract for this chapter

Constructors are a special type of function that only runs once when deploying a contract, and can be used to initialize the state of a contract.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry<TContractState> {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
}

#[starknet::contract]
mod NameRegistry {
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };

    #[storage]
    struct Storage {
        names: Map::<ContractAddress, felt252>,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry<ContractState> {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -> felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -> felt252 {
        self.total_names.__base_address__
    }
}

```

Some important rules to note:

1. A contract can't have more than one constructor.
2. The constructor function must be named `constructor`, and must be annotated with the `#[constructor]` attribute.

The `constructor` function might take arguments, which are passed when deploying the contract. In our example, we pass some value corresponding to a `Person` type as argument in order to store the `owner` information (address and name) in the contract.

Note that the `constructor` function **must** take `self` as a first argument, corresponding to the state of the contract, generally passed by reference with the `ref` keyword to be able to modify the contract's state. We will explain `self` and its type shortly.

As stated previously, public functions are accessible from outside of the contract. They are usually defined inside an implementation block annotated with the `#[abi(embed_v0)]` attribute, but might also be defined independently under the `#[external(v0)]` attribute.

The `#[abi(embed_v0)]` attribute means that all functions embedded inside it are implementations of the Starknet interface of the contract, and therefore potential entry points.

Annotating an impl block with the `#[abi(embed_v0)]` attribute only affects the visibility (i.e., public vs private/internal) of the functions it contains, but it doesn't inform us on the ability of these functions to modify the state of the contract.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry<TContractState> {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
}

#[starknet::contract]
mod NameRegistry {
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };

    #[storage]
    struct Storage {
        names: Map::<ContractAddress, felt252>,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry<ContractState> {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -> felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -> felt252 {
        self.total_names.__base_address__
    }
}

```

> Similarly to the `constructor` function, all public functions, either standalone functions annotated with the `#[external(v0)]` or functions within an impl block annotated with the `#[abi(embed_v0)]` attribute, **must** take `self` as a first argument. This is not the case for private functions.

External functions are _public_ functions where the `self: ContractState` argument is passed by reference with the `ref` keyword, which exposes both the `read` and `write` access to storage variables. This allows modifying the state of the contract via `self` directly.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry<TContractState> {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
}

#[starknet::contract]
mod NameRegistry {
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };

    #[storage]
    struct Storage {
        names: Map::<ContractAddress, felt252>,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry<ContractState> {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -> felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -> felt252 {
        self.total_names.__base_address__
    }
}

```

View functions are _public_ functions where the `self: ContractState` argument is passed as snapshot, which only allows the `read` access to storage variables, and restricts writes to storage made via `self` by causing compilation errors. The compiler will mark their _state\_mutability_ to `view`, preventing any state modification through `self` directly.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry<TContractState> {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
}

#[starknet::contract]
mod NameRegistry {
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };

    #[storage]
    struct Storage {
        names: Map::<ContractAddress, felt252>,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry<ContractState> {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -> felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -> felt252 {
        self.total_names.__base_address__
    }
}

```

However, as you may have noticed, passing `self` as a snapshot only restricts the storage write access via `self` at compile time. It does not prevent state modification via direct system calls, nor calling another contract that would modify the state.

The read-only property of view functions is not enforced on Starknet, and sending a transaction targeting a view function _could_ change the state.

In conclusion, even though external and view functions are distinguished by the Cairo compiler, **all public functions** can be called through an invoke transaction and can potentially modify the Starknet state. Moreover, all public functions can be called with the `starknet_call` RPC method, which will not create a transaction and hence will not change the state.

> **Warning:** This is different from the EVM where a `staticcall` opcode is provided, which prevents storage modifications in the current context and subcontexts. Hence developers **should not** have the assumption that calling a view function on another contract cannot modify the state.

It is also possible to define public functions outside of an implementation of a trait, using the `#[external(v0)]` attribute. Doing this will automatically generate an entry in the contract ABI, allowing these standalone public functions to be callable by anyone from outside. These functions can also be called from within the contract just like any function in Starknet contracts. The first parameter must be `self`.

Here, we define a standalone `get_contract_name` function outside of an impl block:

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry<TContractState> {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
}

#[starknet::contract]
mod NameRegistry {
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };

    #[storage]
    struct Storage {
        names: Map::<ContractAddress, felt252>,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry<ContractState> {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -> felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -> felt252 {
        self.total_names.__base_address__
    }
}

```

Functions that are not defined with the `#[external(v0)]` attribute or inside a block annotated with the `#[abi(embed_v0)]` attribute are private functions (also called internal functions). They can only be called from within the contract.

They can be grouped in a dedicated impl block (e.g., in components, to easily import internal functions all at once in the embedding contracts) or just be added as free functions inside the contract module.
Note that these 2 methods are equivalent. Just choose the one that makes your code more readable and easy to use.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
pub trait INameRegistry<TContractState> {
    fn store_name(ref self: TContractState, name: felt252);
    fn get_name(self: @TContractState, address: ContractAddress) -> felt252;
}

#[starknet::contract]
mod NameRegistry {
    use core::starknet::{ContractAddress, get_caller_address};
    use core::starknet::storage::{
        Map, StoragePathEntry, StoragePointerReadAccess, StoragePointerWriteAccess,
    };

    #[storage]
    struct Storage {
        names: Map::<ContractAddress, felt252>,
        total_names: u128,
    }

    #[derive(Drop, Serde, starknet::Store)]
    pub struct Person {
        address: ContractAddress,
        name: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: Person) {
        self.names.entry(owner.address).write(owner.name);
        self.total_names.write(1);
    }

    // Public functions inside an impl block
    #[abi(embed_v0)]
    impl NameRegistry of super::INameRegistry<ContractState> {
        fn store_name(ref self: ContractState, name: felt252) {
            let caller = get_caller_address();
            self._store_name(caller, name);
        }

        fn get_name(self: @ContractState, address: ContractAddress) -> felt252 {
            self.names.entry(address).read()
        }
    }

    // Standalone public function
    #[external(v0)]
    fn get_contract_name(self: @ContractState) -> felt252 {
        'Name Registry'
    }

    // Could be a group of functions about a same topic
    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        fn _store_name(ref self: ContractState, user: ContractAddress, name: felt252) {
            let total_names = self.total_names.read();

            self.names.entry(user).write(name);

            self.total_names.write(total_names + 1);
        }
    }

    // Free function
    fn get_total_names_storage_address(self: @ContractState) -> felt252 {
        self.total_names.__base_address__
    }
}

```

> Wait, what is this `#[generate_trait]` attribute? Where is the trait definition for this implementation? Well, the `#[generate_trait]` attribute is a special attribute that tells the compiler to generate a trait definition for the implementation block. This allows you to get rid of the boilerplate code of defining a trait with generic parameters and implementing it for the implementation block. With this attribute, we can simply define the implementation block directly, without any generic parameter, and use `self: ContractState` in our functions.

The `#[generate_trait]` attribute is mostly used to define private impl blocks. It might also be used in addition to `#[abi(per_item)]` to define the various entrypoints of a contract (see [next section](https://book.cairo-lang.org/ch101-02-contract-functions.html#4-abiper_item-attribute)).

> Note: using `#[generate_trait]` in addition to the `#[abi(embed_v0)]` attribute for a public impl block is not recommended, as it will result in a failure to generate the corresponding ABI. Public functions should only be defined in an impl block annotated with `#[generate_trait]` if this block is also annotated with the `#[abi(per_item)]` attribute.

You can also define the entrypoint type of functions individually inside an impl block using the `#[abi(per_item)]` attribute on top of your impl. It is often used with the `#[generate_trait]` attribute, as it allows you to define entrypoints without an explicit interface. In this case, the functions will not be grouped under an impl in the ABI. Note that when using `#[abi(per_item)]` attribute, public functions need to be annotated with the `#[external(v0)]` attribute - otherwise, they will not be exposed and will be considered as private functions.

Here is a short example:

```cairo noplayground hljs

#[starknet::contract]
mod ContractExample {
    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl SomeImpl of SomeTrait {
        #[constructor]
        // this is a constructor function
        fn constructor(ref self: ContractState) {}

        #[external(v0)]
        // this is a public function
        fn external_function(ref self: ContractState, arg1: felt252) {}

        #[l1_handler]
        // this is a l1_handler function
        fn handle_message(ref self: ContractState, from_address: felt252, arg: felt252) {}

        // this is an internal function
        fn internal_function(self: @ContractState) {}
    }
}

```

In the case of `#[abi(per_item)]` attribute usage without `#[generate_trait]`, it will only be possible to include `constructor`, `l1-handler` and `internal` functions in the trait implementation. Indeed, `#[abi(per_item)]` only works with a trait that is not defined as a Starknet interface. Hence, it will be mandatory to create another trait defined as interface to implement public functions.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=123865533.1738497971&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102308675~102482432~102528644~102539968~102546754&z=402512579)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-02-hello-world.md "Suggest an edit")

Ahora que has instalado Cairo, es hora de escribir tu primer programa Cairo. Es tradicional cuando se aprende un nuevo lenguaje se escriba un pequeÃ±o programa que imprima el texto `Hello, world!` en la pantalla, Â¡asÃ­ que haremos lo mismo aquÃ­!

> Note: This book assumes basic familiarity with the command line. Cairo makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. The Cairo team has developed a VSCode extension for the Cairo language that you can use to get the features from the language server and code highlighting. See [Appendix F](https://book.cairo-lang.org/es/appendix-06-useful-development-tools.html) for more details.

EmpezarÃ¡s creando un directorio para almacenar tu cÃ³digo de Cairo. A Cairo no le importa a Cairo dÃ³nde vive tu cÃ³digo, pero para los ejercicios y proyectos de este libro, sugerimos hacer un directorio _cairo\_projects_ en tu directorio home y mantener todos tus proyectos allÃ­.

Open a terminal and enter the following commands to make a _cairo\_projects_ directory.

Para Linux, macOS y PowerShell en Windows, introduce esto:

```shell hljs

mkdir ~/cairo_projects
cd ~/cairo_projects

```

Para Windows CMD, introduzca esto:

```cmd hljs

> mkdir "%USERPROFILE%\cairo_projects"
> cd /d "%USERPROFILE%\cairo_projects"

```

> Nota: De ahora en adelante, para cada ejemplo mostrado en el libro, asumimos que estarÃ¡s trabajando desde un directorio de proyecto Scarb. Si no estÃ¡s utilizando Scarb, e intentas ejecutar los ejemplos desde un directorio diferente, puede que tengas que ajustar los comandos en consecuencia o crear un proyecto Scarb.

Vamos a crear un nuevo proyecto usando Scarb.

Navigate to your _cairo\_projects_ directory (or wherever you decided to store your code). Then run the following:

```bash hljs

scarb new hello_world

```

Scarb will ask you about the dependencies you want to add. You will be given two options :

```text hljs plaintext

? Which test runner do you want to set up? â€º
â¯ Starknet Foundry (default)
  Cairo Test

```

In general, we'll prefer using the first one `â¯ Starknet Foundry (default)`.

This creates a new directory and project called _hello\_world_. Weâ€™ve named our project _hello\_world_, and Scarb creates its files in a directory of the same name.

Go into the _hello\_world_ directory with the command `cd hello_world`. Youâ€™ll see that Scarb has generated three files and two directory for us: a _Scarb.toml_ file, a _src_ directory with a _lib.cairo_ file inside and a _tests_ directory containing a _test\_contract.cairo_ file. For now, we can remove this _tests_ directory.

TambiÃ©n ha inicializado un nuevo repositorio Git junto con un archivo `.gitignore`

> Note: Git is a common version control system. You can stop using version control system by using the `--no-vcs` flag. Run `scarb new --help` to see the available options.

Open _Scarb.toml_ in your text editor of choice. It should look similar to the code in Listing 1-1.

Filename: Scarb.toml

```toml hljs ini

[package]
name = "test"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.9.2"

[dev-dependencies]
snforge_std = "0.35.1"
assert_macros = "2.9.2"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# ...

```

Listing 1-1: Contents of _Scarb.toml_ generated by `scarb new`

Este archivo se encuentra en formato [TOML](https://toml.io/) (Tomâ€™s Obvious, Minimal Language), que es el formato de configuraciÃ³n de Scarb.

La primera lÃ­nea, `[package]`, es un encabezado de secciÃ³n que indica que las siguientes sentencias estÃ¡n configurando un paquete. A medida que agreguemos mÃ¡s informaciÃ³n a este archivo, agregaremos otras secciones.

The next three lines set the configuration information Scarb needs to compile your program: the name of the package and the version of Scarb to use, and the edition of the prelude to use. The prelude is the collection of the most commonly used items that are automatically imported into every Cairo program. You can learn more about the prelude in [Appendix D](https://book.cairo-lang.org/es/appendix-04-cairo-prelude.html).

The `[dependencies]` section, is the start of a section for you to list any of your projectâ€™s dependencies. In Cairo, packages of code are referred to as crates. We wonâ€™t need any other crates for this project.

The `[dev-dependencies]` section is about dependencies that are required for development, but are not needed for the actual production build of the project. `snforge_std` and `assert_macros` are two examples of such dependencies. If you want to test your project without using Starknet Foundry, you can use `cairo_test`.

The `[[target.starknet-contract]]` section allows to build Starknet smart contracts. We can remove it for now.

The `[script]` section allows to define custom scripts. By default, there is one script for running tests using `snforge` with the `scarb test` command. We can also remove it for now.

Starknet Foundry also have more options, check out [Starknet Foundry documentation](https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html) for more information.

By default, using Starknet Foundry adds the `starknet` dependency and the `[[target.starknet-contract]]` section, so that you can build contracts for Starknet out of the box. We will start with only Cairo programs, so you can edit your _Scarb.toml_ file to the following:

Filename: Scarb.toml

```toml hljs ini

[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

[dependencies]

```

Listing 1-2: Contents of modified _Scarb.toml_

The other file created by Scarb is _src/lib.cairo_, let's delete all the content and put in the following content, we will explain the reason later.

```cairo noplayground hljs

mod hello_world;

```

Then create a new file called _src/hello\_world.cairo_ and put the following code in it:

Filename: src/hello\_world.cairo

```cairo hljs

fn main() {
    println!("Hello, World!");
}

```

We have just created a file called _lib.cairo_, which contains a module declaration referencing another module named `hello_world`, as well as the file _hello\_world.cairo_, containing the implementation details of the `hello_world` module.

Scarb requires your source files to be located within the _src_ directory.

The top-level project directory is reserved for _README_ files, license information, configuration files, and any other non-code-related content. Scarb ensures a designated location for all project components, maintaining a structured organization.

If you started a project that doesnâ€™t use Scarb, you can convert it to a project that does use Scarb. Move the project code into the _src_ directory and create an appropriate _Scarb.toml_ file. You can also use `scarb init` command to generate the _src_ folder and the _Scarb.toml_ it contains.

```txt hljs plaintext

â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.cairo
â”‚   â””â”€â”€ hello_world.cairo

```

A sample Scarb project structure

From your _hello\_world_ directory, build your project by entering the following command:

```bash hljs

$ scarb build
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 8 seconds

```

This command creates a `hello_world.sierra.json` file in _target/dev_, let's ignore the `sierra` file for now.

If you have installed Cairo correctly, you should be able to run the `main` function of your program with the `scarb cairo-run` command and see the following output:

```shell hljs

$ scarb cairo-run
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 15 seconds
     Running hello_world
Hello, World!
Run completed successfully, returning []

```

Regardless of your operating system, the string `Hello, world!` should be printed to the terminal.

If `Hello, world!` did print, congratulations! Youâ€™ve officially written a Cairo program. That makes you a Cairo programmer â€” welcome!

Revisemos este programa â€œHello, world!â€ en detalle. AquÃ­ estÃ¡ la primera pieza del rompecabezas:

```cairo noplayground hljs

fn main() {

}

```

Estas lÃ­neas definen una funciÃ³n llamada `main`. La funciÃ³n `main` es especial: siempre es el primer cÃ³digo que se ejecuta en cada programa ejecutable de Cairo. AquÃ­, la primera lÃ­nea declara una funciÃ³n llamada `main` que no tiene parÃ¡metros y devuelve nada. Si hubiera parÃ¡metros, irÃ­an dentro de los parÃ©ntesis `()`.

El cuerpo de la funciÃ³n estÃ¡ envuelto en `{}`. Cairo requiere llaves alrededor de todos los cuerpos de funciones. Es una buena prÃ¡ctica colocar la llave de apertura en la misma lÃ­nea que la declaraciÃ³n de la funciÃ³n, aÃ±adiendo un espacio en medio.

> Note: If you want to stick to a standard style across Cairo projects, you can use the automatic formatter tool available with `scarb fmt` to format your code in a particular style (more on `scarb fmt` in [Appendix F](https://book.cairo-lang.org/es/appendix-06-useful-development-tools.html)). The Cairo team has included this tool with the standard Cairo distribution, as `cairo-run` is, so it should already be installed on your computer!

El cuerpo de la funciÃ³n `main` contiene el siguiente cÃ³digo:

```cairo noplayground hljs

    println!("Hello, World!");

```

Esta lÃ­nea hace todo el trabajo en este pequeÃ±o programa: imprime texto en la pantalla. Hay cuatro detalles importantes a tener en cuenta aquÃ­.

Primero, el estilo de Cairo es identar con cuatro espacios, no con una tabulaciÃ³n.

Second, `println!` calls a Cairo macro. If it had called a function instead, it would be entered as `println` (without the `!`). Weâ€™ll discuss Cairo macros in more detail in the ["Macros"](https://book.cairo-lang.org/es/ch12-05-macros.html) chapter. For now, you just need to know that using a `!` means that youâ€™re calling a macro instead of a normal function and that macros donâ€™t always follow the same rules as functions.

En tercer lugar, ves la short string `'Hello, world!'`. Pasamos este short string como argumento a `print()`, y la cadena corta se imprime en la pantalla.

Cuarto, terminamos la lÃ­nea con un punto y coma ( `;`), que indica que esta expresiÃ³n ha terminado y la siguiente estÃ¡ lista para comenzar. La mayorÃ­a de las lÃ­neas de cÃ³digo de Cairo terminan con punto y coma.

Start

Recapitulemos lo que hemos aprendido hasta ahora sobre Scarb:

- We can install one or multiple Scarb versions, either the latest stable or a specific one, using asdf.
- Podemos crear un proyecto utilizando `scarb new`.
- Podemos construir un proyecto usando `scarb build` para generar el cÃ³digo compilado de Sierra.
- We can execute a Cairo program using the `scarb cairo-run` command.

Una ventaja adicional de usar Scarb es que los comandos son los mismos sin importar el sistema operativo en el que estemos trabajando. AsÃ­ que, en este punto, ya no proporcionaremos instrucciones especÃ­ficas para Linux y macOS frente a Windows.

Youâ€™re already off to a great start on your Cairo journey! This is a great time to build a more substantial program to get used to reading and writing Cairo code.

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=935639201.1738497972&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=202440056)

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1548741245.1738497973&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=2014442365)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch09-02-recoverable-errors.md "Suggest an edit")

Most errors arenâ€™t serious enough to require the program to stop entirely. Sometimes, when a function fails, itâ€™s for a reason that you can easily interpret and respond to. For example, if you try to add two large integers and the operation overflows because the sum exceeds the maximum representable value, you might want to return an error or a wrapped result instead of causing undefined behavior or terminating the process.

Recall from [Generic data types](https://book.cairo-lang.org/ch08-01-generic-data-types.html#enums) section in Chapter 8 that the `Result` enum is defined as having two variants, `Ok` and `Err`, as follows:

```cairo noplayground hljs

enum Result<T, E> {
    Ok: T,
    Err: E,
}

```

The `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`).

The `ResultTrait` trait provides methods for working with the `Result<T, E>` enum, such as unwrapping values, checking whether the `Result` is `Ok` or `Err`, and panicking with a custom message. The `ResultTraitImpl` implementation defines the logic of these methods.

```cairo noplayground hljs

trait ResultTrait<T, E> {
    fn expect<+Drop<E>>(self: Result<T, E>, err: felt252) -> T;

    fn unwrap<+Drop<E>>(self: Result<T, E>) -> T;

    fn expect_err<+Drop<T>>(self: Result<T, E>, err: felt252) -> E;

    fn unwrap_err<+Drop<T>>(self: Result<T, E>) -> E;

    fn is_ok(self: @Result<T, E>) -> bool;

    fn is_err(self: @Result<T, E>) -> bool;
}

```

The `expect` and `unwrap` methods are similar in that they both attempt to extract the value of type `T` from a `Result<T, E>` when it is in the `Ok` variant. If the `Result` is `Ok(x)`, both methods return the value `x`. However, the key difference between the two methods lies in their behavior when the `Result` is in the `Err` variant. The `expect` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap` method panics with a default error message, providing less information about the cause of the panic.

The `expect_err` and `unwrap_err` methods have the exact opposite behavior. If the `Result` is `Err(x)`, both methods return the value `x`. However, the key difference between the two methods is in case of `Result::Ok()`. The `expect_err` method allows you to provide a custom error message (as a `felt252` value) that will be used when panicking, giving you more control and context over the panic. On the other hand, the `unwrap_err` method panics with a default error message, providing less information about the cause of the panic.

A careful reader may have noticed the `<+Drop<T>>` and `<+Drop<E>>` in the first four methods signatures. This syntax represents generic type constraints in the Cairo language, as seen in the previous chapter. These constraints indicate that the associated functions require an implementation of the `Drop` trait for the generic types `T` and `E`, respectively.

Finally, the `is_ok` and `is_err` methods are utility functions provided by the `ResultTrait` trait to check the variant of a `Result` enum value.

- `is_ok` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Ok` variant, meaning the operation was successful. If the `Result` is the `Err` variant, it returns `false`.
- `is_err` takes a snapshot of a `Result<T, E>` value and returns `true` if the `Result` is the `Err` variant, meaning the operation encountered an error. If the `Result` is the `Ok` variant, it returns `false`.

These methods are helpful when you want to check the success or failure of an operation without consuming the `Result` value, allowing you to perform additional operations or make decisions based on the variant without unwrapping it.

You can find the implementation of the `ResultTrait` [here](https://github.com/starkware-libs/cairo/blob/main/corelib/src/result.cairo#L20).

It is always easier to understand with examples. Have a look at this function signature:

```cairo noplayground hljs

fn u128_overflowing_add(a: u128, b: u128) -> Result<u128, u128>;

```

It takes two `u128` integers, `a` and `b`, and returns a `Result<u128, u128>` where the `Ok` variant holds the sum if the addition does not overflow, and the `Err` variant holds the overflowed value if the addition does overflow.

Now, we can use this function elsewhere. For instance:

```cairo noplayground hljs

fn u128_checked_add(a: u128, b: u128) -> Option<u128> {
    match u128_overflowing_add(a, b) {
        Result::Ok(r) => Option::Some(r),
        Result::Err(r) => Option::None,
    }
}

```

Here, it accepts two `u128` integers, `a` and `b`, and returns an `Option<u128>`. It uses the `Result` returned by `u128_overflowing_add` to determine the success or failure of the addition operation. The `match` expression checks the `Result` from `u128_overflowing_add`. If the result is `Ok(r)`, it returns `Option::Some(r)` containing the sum. If the result is `Err(r)`, it returns `Option::None` to indicate that the operation has failed due to overflow. The function does not panic in case of an overflow.

Let's take another example:

```cairo noplayground hljs

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

```

In this example, the `parse_u8` function takes a `felt252` and tries to convert it into a `u8` integer using the `try_into` method. If successful, it returns `Result::Ok(value)`, otherwise it returns `Result::Err('Invalid integer')`.

Our two test cases are:

```cairo noplayground hljs hide-boring

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_felt252_to_u8() {
        let number: felt252 = 5;
        // should not panic
        let res = parse_u8(number).unwrap();
    }

    #[test]
    #[should_panic]
    fn test_felt252_to_u8_panic() {
        let number: felt252 = 256;
        // should panic
        let res = parse_u8(number).unwrap();
    }
}

```

Don't worry about the `#[cfg(test)]` attribute for now. We'll explain in more detail its meaning in the next [Testing Cairo Programs](https://book.cairo-lang.org/ch10-01-how-to-write-tests.html) chapter.

`#[test]` attribute means the function is a test function, and `#[should_panic]` attribute means this test will pass if the test execution panics.

The first one tests a valid conversion from `felt252` to `u8`, expecting the `unwrap` method not to panic. The second test function attempts to convert a value that is out of the `u8` range, expecting the `unwrap` method to panic with the error message `Invalid integer`.

The last operator we will talk about is the `?` operator. The `?` operator is used for more idiomatic and concise error handling. When you use the `?` operator on a `Result` or `Option` type, it will do the following:

- If the value is `Result::Ok(x)` or `Option::Some(x)`, it will return the inner value `x` directly.
- If the value is `Result::Err(e)` or `Option::None`, it will propagate the error or `None` by immediately returning from the function.

The `?` operator is useful when you want to handle errors implicitly and let the calling function deal with them.

Here is an example:

```cairo noplayground hljs

fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {
    let input_to_u8: u8 = parse_u8(input)?;
    // DO SOMETHING
    let res = input_to_u8 - 1;
    Result::Ok(res)
}

```

We can see that `do_something_with_parse_u8` function takes a `felt252` value as input and calls `parse_u8` function. The `?` operator is used to propagate the error, if any, or unwrap the successful value.

And with a little test case:

```cairo noplayground hljs hide-boring

fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
        Option::None => Result::Err('Invalid integer'),
    }
}

fn do_something_with_parse_u8(input: felt252) -> Result<u8, felt252> {
    let input_to_u8: u8 = parse_u8(input)?;
    // DO SOMETHING
    let res = input_to_u8 - 1;
    Result::Ok(res)
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_function_2() {
        let number: felt252 = 258;
        match do_something_with_parse_u8(number) {
            Result::Ok(value) => println!("Result: {}", value),
            Result::Err(e) => println!("Error: {}", e),
        }
    }
}

```

The console will print the error `Invalid Integer`.

We saw that recoverable errors can be handled in Cairo using the `Result` enum, which has two variants: `Ok` and `Err`. The `Result<T, E>` enum is generic, with types `T` and `E` representing the successful and error values, respectively. The `ResultTrait` provides methods for working with `Result<T, E>`, such as unwrapping values, checking if the result is `Ok` or `Err`, and panicking with custom messages.

To handle recoverable errors, a function can return a `Result` type and use pattern matching to handle the success or failure of an operation. The `?` operator can be used to implicitly handle errors by propagating the error or unwrapping the successful value. This allows for more concise and clear error handling, where the caller is responsible for managing errors raised by the called function.

Start

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=19293679.1738497973&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=243284358)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-02-dictionaries.md "Suggest an edit")

Cairoåœ¨å…¶æ ¸å¿ƒåº“ä¸­æä¾›äº†ä¸€ä¸ªç±»ä¼¼å­—å…¸çš„ç±»åž‹ã€‚ `Felt252Dict<T>` æ•°æ®ç±»åž‹è¡¨ç¤ºé”®å€¼å¯¹çš„é›†åˆï¼Œå…¶ä¸­æ¯ä¸ªé”®éƒ½æ˜¯å”¯ä¸€çš„ï¼Œå¹¶ä¸Žç›¸åº”çš„å€¼ç›¸å…³è”ã€‚è¿™ç§ç±»åž‹çš„æ•°æ®ç»“æž„åœ¨ä¸åŒçš„ç¼–ç¨‹è¯­è¨€ä¸­æœ‰ä¸åŒçš„åç§°ï¼Œå¦‚æ˜ å°„ã€å“ˆå¸Œè¡¨ã€å…³è”æ•°ç»„ç­‰ã€‚

`Felt252Dict<T>` ç±»åž‹åœ¨ä½ æƒ³ä»¥æŸç§æ–¹å¼ç»„ç»‡æ•°æ®è€Œä½¿ç”¨ `Array<T>` å’Œç´¢å¼•ä¸èƒ½æ»¡è¶³è¦æ±‚æ—¶éžå¸¸æœ‰ç”¨ã€‚Cairoå­—å…¸è¿˜å…è®¸ç¨‹åºå‘˜åœ¨å†…å­˜éžå¯å˜çš„æƒ…å†µä¸‹è½»æ¾åœ°æ¨¡æ‹Ÿå¯å˜å†…å­˜ã€‚

It is normal in other languages when creating a new dictionary to define the data types of both key and value. In Cairo, the key type is restricted to `felt252`, leaving only the possibility to specify the value data type, represented by `T` in `Felt252Dict<T>`.

`Felt252Dict<T>` çš„æ ¸å¿ƒåŠŸèƒ½åœ¨trait `Felt252DictTrait` ä¸­å®žçŽ°ï¼Œå®ƒåŒ…æ‹¬æ‰€æœ‰çš„åŸºæœ¬æ“ä½œã€‚åœ¨å…¶ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼š

1. `insert(felt252, T) -> ()` to write values to a dictionary instance and
2. `get(felt252) -> T` to read values from it.

è¿™äº›å‡½æ•°å…è®¸æˆ‘ä»¬ä½¿ç”¨å…¶ä»–è¯­è¨€ä¸€æ ·çš„æ–¹æ³•æ¥æ“ä½œå­—å…¸ã€‚åœ¨ä¸‹é¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå­—å…¸æ¥è¡¨ç¤ºä¸ªä½“åŠå…¶ä½™é¢ä¹‹é—´çš„æ˜ å°„ï¼š

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();

    balances.insert('Alex', 100);
    balances.insert('Maria', 200);

    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Balance is not 100");

    let maria_balance = balances.get('Maria');
    assert!(maria_balance == 200, "Balance is not 200");
}

```

We can create a new instance of `Felt252Dict<u64>` by using the `default` method of the `Default` trait and add two individuals, each one with their own balance, using the `insert` method. Finally, we check the balance of our users with the `get` method. These methods are defined in the `Felt252DictTrait` trait in the core library.

Throughout the book we have talked about how Cairo's memory is immutable, meaning you can only write to a memory cell once but the `Felt252Dict<T>` type represents a way to overcome this obstacle. We will explain how this is implemented later on in ["Dictionaries Underneath"](https://book.cairo-lang.org/zh-cn/ch03-02-dictionaries.html#dictionaries-underneath).

åœ¨å‰é¢ç¤ºä¾‹çš„åŸºç¡€ä¸Šï¼Œè®©æˆ‘ä»¬å±•ç¤ºä¸€ä¸ªåŒä¸€ç”¨æˆ·çš„ä½™é¢äº§ç”Ÿå˜åŒ–çš„ä»£ç ç¤ºä¾‹ï¼š

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();

    // Insert Alex with 100 balance
    balances.insert('Alex', 100);
    // Check that Alex has indeed 100 associated with him
    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Alex balance is not 100");

    // Insert Alex again, this time with 200 balance
    balances.insert('Alex', 200);
    // Check the new balance is correct
    let alex_balance_2 = balances.get('Alex');
    assert!(alex_balance_2 == 200, "Alex balance is not 200");
}

```

Notice how in this example we added the 'Alex' individual twice, each time using a different balance and each time that we checked for its balance it had the last value inserted! `Felt252Dict<T>` effectively allows us to "rewrite" the stored value for any given key.

åœ¨ç»§ç»­è§£é‡Šå­—å…¸æ˜¯å¦‚ä½•å®žçŽ°çš„ä¹‹å‰ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼Œä¸€æ—¦ä½ å®žä¾‹åŒ–äº†ä¸€ä¸ª `Felt252Dict<T>`ï¼Œå…¶æ‰€æœ‰çš„é”®å€¼éƒ½å°†è¢«åˆå§‹åŒ–ä¸º0ã€‚è¿™æ„å‘³ç€ï¼Œä¾‹å¦‚ï¼Œå¦‚æžœä½ è¯•å›¾èŽ·å–ä¸€ä¸ªä¸å­˜åœ¨çš„ç”¨æˆ·çš„ä½™é¢ï¼Œä½ å°†å¾—åˆ°0ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªé”™è¯¯æˆ–æœªå®šä¹‰çš„å€¼ã€‚è¿™ä¹Ÿæ„å‘³ç€æ— æ³•ä»Žå­—å…¸ä¸­åˆ é™¤æ•°æ®ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™æ­Œç»“æž„çº³æ—¶ä½ éœ€è¦è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ã€‚

åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»äº†è§£äº† `Felt252Dict<T>` çš„æ‰€æœ‰åŸºæœ¬ç‰¹æ€§ï¼Œä»¥åŠå®ƒæ˜¯å¦‚ä½•åœ¨å¤–éƒ¨è¡¨çŽ°ä¸Šæ¨¡ä»¿å…¶ä»–è¯­è¨€ä¸­ç›¸åº”æ•°æ®ç»“æž„çš„ã€‚Cairoçš„æ ¸å¿ƒæ˜¯ä¸€ç§éžç¡®å®šçš„å›¾çµå®Œå¤‡çš„ç¼–ç¨‹è¯­è¨€ï¼Œä¸Žå…¶ä»–ä»»ä½•æµè¡Œçš„è¯­è¨€éƒ½æœ‰å¾ˆå¤§çš„ä¸åŒï¼Œè¿™æ„å‘³ç€å­—å…¸çš„å®žçŽ°ä¹Ÿæœ‰å¾ˆå¤§çš„ä¸åŒï¼

åœ¨ä¸‹é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥ä»‹ç» `Felt252Dict<T>` çš„å†…éƒ¨æœºåˆ¶ä»¥åŠä¸ºä½¿å…¶æ­£å¸¸å·¥ä½œè€Œåšå‡ºçš„å¦¥åã€‚ä¹‹åŽï¼Œæˆ‘ä»¬å°†ä»‹ç»å¦‚ä½•å°†å­—å…¸ä¸Žå…¶ä»–æ•°æ®ç»“æž„ä¸€èµ·ä½¿ç”¨ï¼Œä»¥åŠä½¿ç”¨ `entry` æ–¹æ³•ä½œä¸ºä¸Žå­—å…¸äº¤äº’çš„å¦ä¸€ç§æ–¹å¼ã€‚

Cairoçš„éžç¡®å®šæ€§è®¾è®¡çš„é™åˆ¶ä¹‹ä¸€æ˜¯å®ƒçš„å†…å­˜ç³»ç»Ÿæ˜¯ä¸å¯å˜çš„ï¼Œå› æ­¤ä¸ºäº†æ¨¡æ‹Ÿå¯å˜æ€§ï¼Œè¯­è¨€å°† `Felt252Dict<T>` å®žçŽ°ä¸ºä¸€ä¸ªæ¡ç›®(entry)åˆ—è¡¨ã€‚æ¯ä¸ªæ¡ç›®ä»£è¡¨äº†å­—å…¸è¢«è¯»å–/æ›´æ–°/å†™å…¥çš„æ—¶é—´ã€‚ä¸€ä¸ªæ¡ç›®æœ‰ä¸‰ä¸ªå­—æ®µï¼š

1. A `key` field that identifies the key for this key-value pair of the dictionary.
2. A `previous_value` field that indicates which previous value was held at `key`.
3. A `new_value` field that indicates the new value that is held at `key`.

å¦‚æžœæˆ‘ä»¬å°è¯•ä½¿ç”¨é«˜çº§ç»“æž„æ¥å®žçŽ° `Felt252Dict<T>`ï¼Œæˆ‘ä»¬å°†åœ¨å†…éƒ¨æŠŠå®ƒå®šä¹‰ä¸º `Array<Entry<T>>` å…¶ä¸­æ¯ä¸ª `Entry<T>` éƒ½æœ‰å…³äºŽå®ƒä»£è¡¨çš„é”®å€¼å¯¹çš„ä¿¡æ¯ï¼Œä»¥åŠå®ƒæŒæœ‰çš„å‰ä¸€ä¸ªå€¼å’Œæ–°å€¼ã€‚ `Entry<T>` çš„å®šä¹‰å¦‚ä¸‹ï¼š

```cairo noplayground hljs

struct Entry<T> {
    key: felt252,
    previous_value: T,
    new_value: T,
}

```

For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be registered:

- A `get` would register an entry where there is no change in state, and previous and new values are stored with the same value.
- An `insert` would register a new `Entry<T>` where the `new_value` would be the element being inserted, and the `previous_value` the last element inserted before this. In case it is the first entry for a certain key, then the previous value will be zero.

æ¡ç›®åˆ—è¡¨çš„ä½¿ç”¨å±•ç¤ºäº†è¿™é‡Œæ²¡æœ‰ä»»ä½•å€¼çš„è¦†ç›–ï¼Œåªæ˜¯åœ¨æ¯æ¬¡ `Felt252Dict<T>` äº¤äº’ä¸­åˆ›å»ºæ–°çš„å­˜å‚¨å•å…ƒã€‚è®©æˆ‘ä»¬ä½¿ç”¨ä¸Šä¸€èŠ‚ä¸­çš„ `balances` å­—å…¸å¹¶æ’å…¥ç”¨æˆ· 'Alex' å’Œ 'Maria' æ¥å±•ç¤ºä¸€ä¸ªä¾‹å­ï¼š

```cairo hljs hide-boring

use core::dict::Felt252Dict;

struct Entry<T> {
    key: felt252,
    previous_value: T,
    new_value: T,
}

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();
    balances.insert('Alex', 100_u64);
    balances.insert('Maria', 50_u64);
    balances.insert('Alex', 200_u64);
    balances.get('Maria');
}

```

è¿™äº›æŒ‡ä»¤å°†äº§ç”Ÿä»¥ä¸‹æ¡ç›®åˆ—è¡¨ï¼š

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 100 |
| Maria | 0 | 50 |
| Alex | 100 | 200 |
| Maria | 50 | 50 |

æ³¨æ„ï¼Œç”±äºŽ'Alex'è¢«æ’å…¥äº†ä¸¤æ¬¡ï¼Œæ‰€ä»¥å®ƒå‡ºçŽ°äº†ä¸¤æ¬¡ï¼Œå¹¶ä¸”'previous'å’Œ'current'å€¼è¢«æ­£ç¡®çš„è®¾ç½®ã€‚ä»Ž'Maria'ä¸­è¯»å–çš„æ•°æ®ä¹Ÿæ˜¯ä¸€ä¸ªæ¡ç›®ï¼Œä»Žå‰å€¼åˆ°çŽ°å€¼æ²¡æœ‰å‘ç”Ÿå˜åŒ–ã€‚

è¿™ç§å®žçŽ° `Felt252Dict<T>` çš„æ–¹æ³•æ„å‘³ç€æ¯ä¸€æ¬¡è¯»/å†™æ“ä½œï¼Œéƒ½è¦æ‰«ææ•´ä¸ªæ¡ç›®åˆ—è¡¨ï¼Œå¯»æ‰¾æœ€åŽä¸€ä¸ªå…·æœ‰ç›¸åŒ `key` çš„æ¡ç›®ã€‚ä¸€æ—¦æ¡ç›®è¢«æ‰¾åˆ°ï¼Œå®ƒçš„ `new_value` å°±ä¼šè¢«æå–å‡ºæ¥ï¼Œå¹¶ä½œä¸º `previous_value` æ·»åŠ åˆ°æ–°çš„æ¡ç›®ä¸­ã€‚è¿™æ„å‘³ç€ä¸Ž `Felt252Dict<T>` äº¤äº’çš„æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¸º `O(n)`ï¼Œå…¶ä¸­ `n` æ˜¯åˆ—è¡¨ä¸­çš„æ¡ç›®æ•°ã€‚

If you pour some thought into alternate ways of implementing `Felt252Dict<T>` you'd surely find them, probably even ditching completely the need for a `previous_value` field, nonetheless, since Cairo is not your normal language this won't work. One of the purposes of Cairo is, with the STARK proof system, to generate proofs of computational integrity. This means that you need to verify that program execution is correct and inside the boundaries of Cairo restrictions. One of those boundary checks consists of "dictionary squashing" and that requires information on both previous and new values for every entry.

To verify that the proof generated by a Cairo program execution that used a `Felt252Dict<T>` is correct, we need to check that there wasn't any illegal tampering with the dictionary. This is done through a method called `squash_dict` that reviews each entry of the entry list and checks that access to the dictionary remains coherent throughout the execution.

åŽ‹ç¼©è¿‡ç¨‹å¦‚ä¸‹ï¼šç»™å®šæ‰€æœ‰å…·æœ‰ç‰¹å®šé”® `k` çš„æ¡ç›®ï¼ŒæŒ‰ç…§å®ƒä»¬è¢«æ’å…¥çš„ç›¸åŒé¡ºåºï¼ŒéªŒè¯ç¬¬iä¸ªæ¡ç›® `new_value` æ˜¯å¦ç­‰äºŽç¬¬i+1ä¸ªæ¡ç›® `previous_value`ã€‚

ä¾‹å¦‚ï¼Œç»™å®šä»¥ä¸‹æ¡ç›®åˆ—è¡¨ï¼š

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 150 |
| Maria | 0 | 100 |
| Charles | 0 | 70 |
| Maria | 100 | 250 |
| Alex | 150 | 40 |
| Alex | 40 | 300 |
| Maria | 250 | 190 |
| Alex | 300 | 90 |

åŽ‹ç¼©åŽï¼Œæ¡ç›®åˆ—è¡¨å°†ç¼©å‡ä¸ºï¼š

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 90 |
| Maria | 0 | 190 |
| Charles | 0 | 70 |

å¦‚æžœç¬¬ä¸€å¼ è¡¨ä¸­çš„ä»»ä½•å€¼å‘ç”Ÿå˜åŒ–ï¼Œåˆ™åœ¨è¿è¡ŒæœŸé—´åŽ‹ç¼©å°†ä¼šå¤±è´¥ã€‚

If you run the examples from ["Basic Use of Dictionaries"](https://book.cairo-lang.org/zh-cn/ch03-02-dictionaries.html#basic-use-of-dictionaries) section, you'd notice that there was never a call to squash dictionary, but the program compiled successfully nonetheless. What happened behind the scene was that squash was called automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` trait. This call occurred just before the `balance` dictionary went out of scope.

The `Destruct<T>` trait represents another way of removing instances out of scope apart from `Drop<T>`. The main difference between these two is that `Drop<T>` is treated as a no-op operation, meaning it does not generate new CASM while `Destruct<T>` does not have this restriction. The only type which actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these traits in [Drop and Destruct](https://book.cairo-lang.org/zh-cn/appendix-03-derivable-traits.html#drop-and-destruct) section of Appendix C.

Later in ["Dictionaries as Struct Members"](https://book.cairo-lang.org/zh-cn/ch12-01-custom-data-structures.html#dictionaries-as-struct-members) section, we will have a hands-on example where we implement the `Destruct<T>` trait for a custom type.

åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»å…¨é¢åœ°ä»‹ç»äº† `Felt252Dict<T>` çš„åŠŸèƒ½ï¼Œä»¥åŠå®ƒæ˜¯å¦‚ä½•å’Œä¸ºä»€ä¹ˆä»¥æŸç§æ–¹å¼å®žçŽ°çš„ã€‚å¦‚æžœæ‚¨è¿˜æ²¡æœ‰å®Œå…¨ç†è§£ï¼Œè¯·ä¸è¦æ‹…å¿ƒï¼Œå› ä¸ºåœ¨æœ¬èŠ‚ä¸­æˆ‘ä»¬å°†æä¾›æ›´å¤šä½¿ç”¨å­—å…¸çš„ç¤ºä¾‹ã€‚

We will start by explaining the `entry` method which is part of a dictionary basic functionality included in `Felt252DictTrait<T>` which we didn't mention at the beginning. Soon after, we will see examples of how to use `Felt252Dict<T>` with other [complex types](https://book.cairo-lang.org/zh-cn/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively) such as `Array<T>`.

In the ["Dictionaries Underneath"](https://book.cairo-lang.org/zh-cn/ch03-02-dictionaries.html#dictionaries-underneath) section, we explained how `Felt252Dict<T>` internally worked. It was a list of entries for each time the dictionary was accessed in any manner. It would first find the last entry given a certain `key` and then update it accordingly to whatever operation it was executing. The Cairo language gives us the tools to replicate this ourselves through the `entry` and `finalize` methods.

`entry` æ–¹æ³•ä½œä¸º `Felt252DictTrait<T>` çš„ä¸€éƒ¨åˆ†ï¼Œç›®çš„æ˜¯åœ¨ç»™å®šé”®çš„æƒ…å†µä¸‹åˆ›å»ºä¸€ä¸ªæ–°çš„æ¡ç›®ã€‚ä¸€æ—¦è¢«è°ƒç”¨ï¼Œè¯¥æ–¹æ³•å°†èŽ·å¾—å­—å…¸çš„æ‰€æœ‰æƒå¹¶è¿”å›žè¦æ›´æ–°çš„æ¡ç›®ã€‚æ–¹æ³•ç­¾åå¦‚ä¸‹:

```cairo noplayground hljs

fn entry(self: Felt252Dict<T>, key: felt252) -> (Felt252DictEntry<T>, T) nopanic

```

The first input parameter takes ownership of the dictionary while the second one is used to create the appropriate entry. It returns a tuple containing a `Felt252DictEntry<T>`, which is the type used by Cairo to represent dictionary entries, and a `T` representing the value held previously. The `nopanic` notation simply indicates that the function is guaranteed to never panic.

æŽ¥ä¸‹æ¥è¦åšçš„æ˜¯ç”¨æ–°å€¼æ›´æ–°æ¡ç›®ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ `finalize` æ–¹æ³•æ’å…¥æ¡ç›®å¹¶è¿”å›žå­—å…¸çš„æ‰€æœ‰æƒï¼š

```cairo noplayground hljs

fn finalize(self: Felt252DictEntry<T>, new_value: T) -> Felt252Dict<T>

```

This method receives the entry and the new value as parameters, and returns the updated dictionary.

è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä½¿ç”¨ `entry` å’Œ `finalize` çš„ä¾‹å­ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬æƒ³ä»Žå­—å…¸ä¸­å®žçŽ°æˆ‘ä»¬è‡ªå·±ç‰ˆæœ¬çš„ `get` æ–¹æ³•ã€‚æˆ‘ä»¬åº”è¯¥è¿™æ ·åšï¼š

1. Create the new entry to add using the `entry` method.
2. Insert back the entry where the `new_value` equals the `previous_value`.
3. Return the value.

å®žçŽ°æˆ‘ä»¬çš„è‡ªå®šä¹‰getå°†å¦‚ä¸‹æ‰€ç¤ºï¼š

```cairo noplayground hljs

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get<T, +Felt252DictValue<T>, +Drop<T>, +Copy<T>>(
    ref dict: Felt252Dict<T>, key: felt252,
) -> T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}

```

The `ref` keyword means that the ownership of the variable will be given back at the end of the function. This concept will be explained in more detail in the ["References and Snapshots"](https://book.cairo-lang.org/zh-cn/ch04-02-references-and-snapshots.html) section.

å®žçŽ° `insert` æ–¹æ³•å°†éµå¾ªç±»ä¼¼çš„å·¥ä½œæµç¨‹ï¼Œé™¤äº†åœ¨æœ€ç»ˆç¡®å®šæ—¶æ’å…¥ä¸€ä¸ªæ–°å€¼ã€‚å¦‚æžœæˆ‘ä»¬è¦å®žçŽ°å®ƒï¼Œå®ƒå°†çœ‹èµ·æ¥åƒä¸‹é¢è¿™æ ·ï¼š

```cairo noplayground hljs

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_insert<T, +Felt252DictValue<T>, +Destruct<T>, +Drop<T>>(
    ref dict: Felt252Dict<T>, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}

```

æœ€åŽè¦è¯´æ˜Žçš„æ˜¯ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•çš„å®žçŽ°æ–¹å¼ç±»ä¼¼äºŽ `Felt252Dict<T>` çš„ `insert` å’Œ `get` çš„å®žçŽ°æ–¹å¼ã€‚è¿™æ®µä»£ç å±•ç¤ºäº†ä¸€äº›ä½¿ç”¨ç¤ºä¾‹ï¼š

```cairo hljs hide-boring

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get<T, +Felt252DictValue<T>, +Drop<T>, +Copy<T>>(
    ref dict: Felt252Dict<T>, key: felt252,
) -> T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}

fn custom_insert<T, +Felt252DictValue<T>, +Destruct<T>, +Drop<T>>(
    ref dict: Felt252Dict<T>, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}

fn main() {
    let mut dict: Felt252Dict<u64> = Default::default();

    custom_insert(ref dict, '0', 100);

    let val = custom_get(ref dict, '0');

    assert!(val == 100, "Expecting 100");
}

```

One restriction of `Felt252Dict<T>` that we haven't talked about is the trait `Felt252DictValue<T>`. This trait defines the `zero_default` method which is the one that gets called when a value does not exist in the dictionary. This is implemented by some common data types, such as most unsigned integers, `bool` and `felt252` \- but it is not implemented for more complex types such as arrays, structs (including `u256`), and other types from the core library. This means that making a dictionary of types not natively supported is not a straightforward task, because you would need to write a couple of trait implementations in order to make the data type a valid dictionary value type. To compensate this, you can wrap your type inside a `Nullable<T>`.

`Nullable<T>` is a smart pointer type that can either point to a value or be `null` in the absence of value. It is usually used in Object Oriented Programming Languages when a reference doesn't point anywhere. The difference with `Option` is that the wrapped value is stored inside a `Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to use a dedicated `boxed_segment` memory segment for our data, and access this segment using a pointer that can only be manipulated in one place at a time. See [Smart Pointers Chapter](https://book.cairo-lang.org/zh-cn/ch12-02-smart-pointers.html) for more information.

è®©æˆ‘ä»¬æ¥ä¸¾ä¾‹è¯´æ˜Žã€‚æˆ‘ä»¬å°†å°è¯•åœ¨å­—å…¸ä¸­å­˜å‚¨ä¸€ä¸ª `Span<felt252>`ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ `Nullable<T>` å’Œ `Box<T>`ã€‚å¦å¤–ï¼Œæˆ‘ä»¬è¦å­˜å‚¨çš„æ˜¯ä¸€ä¸ª `Span<T>` è€Œä¸æ˜¯ä¸€ä¸ª `Array<T>` ï¼Œå› ä¸ºåŽè€…æ²¡æœ‰å®žçŽ° `Copy<T>` ç‰¹æ€§ï¼Œè€Œä»Žå­—å…¸ä¸­è¯»å–æ•°æ®æ˜¯éœ€è¦è¿™ä¸ªç‰¹æ€§çš„ã€‚

```cairo noplayground hljs

use core::dict::Felt252Dict;
use core::nullable::{NullableTrait, match_nullable, FromNullableResult};

fn main() {
    // Create the dictionary
    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

//...

```

åœ¨è¿™æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å­—å…¸ `d`ã€‚æˆ‘ä»¬å¸Œæœ›å®ƒä¿å­˜ä¸€ä¸ª `Nullable<Span>`ã€‚ç„¶åŽï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ•°ç»„ï¼Œå¹¶åœ¨å…¶ä¸­å¡«å…¥å€¼ã€‚

The last step is inserting the array as a span inside the dictionary. Notice that we do this using the `new` function of the `NullableTrait`.

ä¸€æ—¦å…ƒç´ å­˜åœ¨å­—å…¸ä¸­ï¼Œå¹¶ä¸”æˆ‘ä»¬æƒ³èŽ·å–å®ƒï¼Œæˆ‘ä»¬å°†éµå¾ªç›¸åŒçš„æ­¥éª¤ï¼Œä½†é¡ºåºç›¸åã€‚ä¸‹é¢çš„ä»£ç å±•ç¤ºäº†å¦‚ä½•å®žçŽ°è¿™ä¸€ç‚¹ï¼š

```cairo noplayground hljs

//...

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value found"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

```

æˆ‘ä»¬åœ¨è¿™é‡Œï¼š

1. Read the value using `get`.
2. Verified it is non-null using the `match_nullable` function.
3. Unwrapped the value inside the box and asserted it was correct.

å®Œæ•´çš„è„šæœ¬å¦‚ä¸‹ï¼š

```cairo hljs

use core::dict::Felt252Dict;
use core::nullable::{NullableTrait, match_nullable, FromNullableResult};

fn main() {
    // Create the dictionary
    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value found"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

```

In the previous section, we explored how to store and retrieve complex types inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a look at how to store an array inside a dictionary and dynamically modify its contents.

Storing arrays in dictionaries in Cairo is slightly different from storing other types. This is because arrays are more complex data structures that require special handling to avoid issues with memory copying and references.

First, let's look at how to create a dictionary and insert an array into it. This process is pretty straightforward and follows a similar pattern to inserting other types of data:

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array inserted successfully.");
}

```

However, attempting to read an array from the dictionary using the `get` method will result in a compiler error. This is because `get` tries to copy the array in memory, which is not possible for arrays (as we've already mentioned in the [previous section](https://book.cairo-lang.org/zh-cn/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively), `Array<T>` does not implement the `Copy<T>` trait):

```cairo hljs

use core::nullable::{match_nullable, FromNullableResult};
use core::dict::Felt252Dict;

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array: {:?}", get_array_entry(ref dict, 0));
}

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let val = dict.get(0); // This will cause a compiler error
    let arr = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value!"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };
    arr.span()
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)
error: Trait has no implementation in context: core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>.
 --> listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:13:20
    let val = dict.get(0); // This will cause a compiler error
                   ^*^

error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error
error: `scarb metadata` exited with error

```

To correctly read an array from the dictionary, we need to use dictionary entries. This allows us to get a reference to the array value without copying it:

```cairo noplayground hljs

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

```

> Note: We must convert the array to a `Span` before finalizing the entry, because calling `NullableTrait::new(arr)` moves the array, thus making it impossible to return it from the function.

To modify the stored array, such as appending a new value, we can use a similar approach. The following `append_value` function demonstrates this:

```cairo noplayground hljs

fn append_value(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

```

In the `append_value` function, we access the dictionary entry, dereference the array, append the new value, and finalize the entry with the updated array.

> Note: Removing an item from a stored array can be implemented in a similar manner.

Below is the complete example demonstrating the creation, insertion, reading, and modification of an array in a dictionary:

```cairo hljs

use core::nullable::NullableTrait;
use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn append_value(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Before insertion: {:?}", get_array_entry(ref dict, 0));

    append_value(ref dict, 0, 30);

    println!("After insertion: {:?}", get_array_entry(ref dict, 0));
}

```

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/fr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch00-01-foreword.md "Suggest an edit")

Zero-knowledge proofs have emerged as a transformative technology in the blockchain space, offering solutions for both privacy and scalability challenges. Among these, STARKs (Scalable Transparent ARguments of Knowledge) stand out as a particularly powerful innovation. Unlike traditional proof systems, STARKs rely solely on collision-resistant hash functions, making them post-quantum secure and eliminating the need for trusted setups.

However, writing general-purpose programs that can generate cryptographic proofs has historically been a significant challenge. Developers needed deep expertise in cryptography and complex mathematical concepts to create verifiable computations, making it impractical for mainstream adoption.

This is where Cairo comes in. As a general-purpose programming language designed specifically for creating provable programs, Cairo abstracts away the underlying cryptographic complexities while maintaining the full power of STARKs. Strongly inspired by Rust, Cairo has been built to help you create provable programs without requiring specific knowledge of its underlying architecture, allowing you to focus on the program logic itself.

Les dÃ©veloppeurs blockchain qui souhaitent dÃ©ployer des contrats sur Starknet utiliseront le langage de programmation Cairo pour Ã©crire leurs contrats intelligents. Ceci permet au Starknet OS de gÃ©nÃ©rer des traces d'exÃ©cution pour les transactions afin d'Ãªtre prouvÃ©es par un prouveur, pour ensuite Ãªtre vÃ©rifiÃ©es sur Ethereum L1 avant d'actualiser l'Ã©tat de Starknet.

However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one computer and verified on other machines. Powered by a Rust VM, and a next-generation prover, the execution and proof generation of Cairo programs is blazingly fast - making Cairo the best tool for building provable applications.

Ce livre a pour cible des dÃ©veloppeurs avec une connaissance basique de programmation. La rÃ©daction accessible et comprÃ©hensive du contenu vous aidera Ã  augmenter vos connaissances de Cairo, mais aussi vos compÃ©tences de programmation en gÃ©nÃ©ral. Lancez vous pour tout savoir sur Cairo !

This book would not have been possible without the help of the Cairo community. We would like to thank every contributor for their contributions to this book!

We would like to thank the Rust community for the [Rust Book](https://doc.rust-lang.org/book/), which has been a great source of inspiration for this book. Many examples and explanations have been adapted from the Rust Book to fit the Cairo programming language, as the two languages share many similarities.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1761025269.1738497974&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=1897961083)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=341184392.1738497975&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102308675~102482433~102528644~102539968~102546754~102556566&z=884935158)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch10-02-test-organization.md "Suggest an edit")

We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private functions. Integration tests use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.

Escribir ambos tipos de pruebas es importante para asegurarse de que las piezas de su biblioteca estÃ©n haciendo lo que se espera de ellas, tanto separadas como juntas.

El propÃ³sito de las pruebas unitarias es probar cada unidad de cÃ³digo en aislamiento del resto del cÃ³digo para identificar rÃ¡pidamente dÃ³nde el cÃ³digo funciona y dÃ³nde no lo hace como se esperaba. ColocarÃ¡ las pruebas unitarias en el directorio `src` en cada archivo con el cÃ³digo que estÃ¡n probando.

The convention is to create a module named `tests` in each file to contain the test functions and to annotate the module with `#[cfg(test)]` attribute.

The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and run the test code only when you run `scarb test`, not when you run `scarb build`. This saves compile time when you only want to build the project and saves space in the resulting compiled artifact because the tests are not included. Youâ€™ll see that because integration tests go in a different directory, they donâ€™t need the `#[cfg(test)]` annotation. However, because unit tests go in the same files as the code, youâ€™ll use `#[cfg(test)]` to specify that they shouldnâ€™t be included in the compiled result.

Recuerde que cuando creamos el nuevo proyecto `adder` en la primera secciÃ³n de este capÃ­tulo, escribimos esta primera prueba:

```cairo hljs

pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}

```

The attribute `cfg` stands for _configuration_ and tells Cairo that the following item should only be included given a certain configuration option. In this case, the configuration option is `test`, which is provided by Cairo for compiling and running tests. By using the `cfg` attribute, Cairo compiles our test code only if we actively run the tests with `scarb test`. This includes any helper functions that might be within this module, in addition to the functions annotated with `#[test]`.

Thereâ€™s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Cairo's privacy rules do allow you to test private functions. Consider the code below with the private function `internal_adder`.

Filename: src/lib.cairo

```cairo noplayground hljs

pub fn add(a: u32, b: u32) -> u32 {
    internal_adder(a, 2)
}

fn internal_adder(a: u32, b: u32) -> u32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add() {
        assert_eq!(4, internal_adder(2, 2));
    }
}

```

Listing 10-10: Testing a private function

Note that the `internal_adder` function is not marked as `pub`. Tests are just Cairo code, and the tests module is just another module. As we discussed in the ["Paths for Referring to an Item in the Module Tree"](https://book.cairo-lang.org/es/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html) section, items in child modules can use the items in their ancestor modules. In this test, we bring the `tests` moduleâ€™s parent `internal_adder` into scope with `use super::internal_adder;` and then the test can call `internal_adder`. If you donâ€™t think private functions should be tested, thereâ€™s nothing in Cairo that will compel you to do so.

Integration tests use your library in the same way any other code would. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a _tests_ directory.

We create a _tests_ directory at the top level of our project directory, next to _src_. Scarb knows to look for integration test files in this directory. We can then make as many test files as we want, and Scarb will compile each of the files as an individual crate.

Letâ€™s create an integration test. With the code in Listing 10-10 still in the _src/lib.cairo_ file, make a _tests_ directory, and create a new file named _tests/integration\_test.cairo_. Your directory structure should look like this:

```shell hljs

adder
â”œâ”€â”€ Scarb.lock
â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â””â”€â”€ lib.cairo
â””â”€â”€ tests
    â””â”€â”€ integration_tests.cairo

```

Enter the code in Listing 10-11 into the _tests/integration\_test.cairo_ file:

Filename: tests/integration\_tests.cairo

```cairo noplayground hljs

use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}

```

Listing 10-11: An integration test of a function in the `adder` crate

Each file in the `tests` directory is a separate crate, so we need to bring our library into each test crateâ€™s scope. For that reason we add `use adder::add_two` at the top of the code, which we didnâ€™t need in the unit tests.

We donâ€™t need to annotate any code in _tests/integration\_test.cairo_ with `#[cfg(test)]`. Scarb treats the tests directory specially and compiles files in this directory only when we run `scarb test`. Run `scarb test` now:

```shell hljs

$ scarb test
     Running test adder (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Blocking waiting for file lock on build directory
    Finished `release` profile [optimized] target(s) in 0.88s
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
    Finished `dev` profile target(s) in 9 seconds

Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::it_adds_two (gas: ~1)
Running 1 test(s) from src/
[PASS] adder::tests::internal (gas: ~1)
Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

```

The two sections of output include the unit tests and the integration tests. Note that if any test in a section fails, the following sections will not be run. For example, if a unit test fails, there wonâ€™t be any output for integration tests because those tests will only be run if all unit tests are passing.

The first displayed section is for the integration tests. Each integration test file has its own section, so if we add more files in the _tests_ directory, there will be more integration test sections.

The second displayed section is the same as weâ€™ve been seeing: one line for each unit test (one named add that we added just above) and then a summary line for the unit tests.

We can still run a particular integration test function by specifying the test functionâ€™s name as an argument of the option -f to `scarb test` like for instance `scarb test -f integration_tests::internal`. To run all the tests in a particular integration test file, we use the same option of `scarb test` but using only the name of the file.

Then, to run all of our integration tests, we can just add a filter to only run tests whose path contains _integration\_tests_.

```shell hljs

$ scarb test -f integration_tests
     Running cairo-test adder
   Compiling test(adder_unittest) adder v0.1.0 (cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
   Compiling test(adder_integration_tests) adder_integration_tests v0.1.0 (cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
    Finished release target(s) in 7 seconds
testing adder ...
running 1 test
test adder_integration_tests::integration_tests::internal ... ok (gas usage est.: 23110)
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;

running 0 tests
test result: ok. 0 passed; 0 failed; 0 ignored; 1 filtered out;

```

We see that in the second section for the unit tests, 1 has been filtered out because it is not in the _integration\_tests_ file.

As you add more integration tests, you might want to make more files in the _tests_ directory to help organize them; for example, you can group the test functions by the functionality theyâ€™re testing. As mentioned earlier, each file in the tests directory is compiled as its own separate crate, which is useful for creating separate scopes to more closely imitate the way end users will be using your crate. However, this means files in the tests directory donâ€™t share the same behavior as files in _src_ do, as you learned in Chapter 7 regarding how to separate code into modules and files.

The different behavior of tests directory files is most noticeable when you have a set of helper functions to use in multiple integration test files and you try to follow the steps in the [Separating Modules into Different Files](https://book.cairo-lang.org/es/ch07-05-separating-modules-into-different-files.html) section of Chapter 7 to extract them into a common module. For example, if we create _tests/common.cairo_ and place a function named `setup` in it, we can add some code to `setup` that we want to call from multiple test functions in multiple test files:

Filename: tests/common.cairo

```cairo noplayground hljs

pub fn setup() {
    println!("Setting up tests...");
}

```

Filename: tests/integration\_tests.cairo

```cairo noplayground hljs

use adder::it_adds_two;

#[test]
fn internal() {
    assert!(it_adds_two(2, 2) == 4, "internal_adder failed");
}

```

Filename: src/lib.cairo

```cairo noplayground hljs

pub fn it_adds_two(a: u8, b: u8) -> u8 {
    a + b
}

#[cfg(test)]
mod tests {
    #[test]
    fn add() {
        assert_eq!(4, super::it_adds_two(2, 2));
    }
}

```

When we run the tests with `scarb test`, weâ€™ll see a new section in the test output for the _common.cairo_ file, even though this file doesnâ€™t contain any test functions nor did we call the setup function from anywhere:

```shell hljs

$ scarb test
     Running test adder (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Finished `release` profile [optimized] target(s) in 0.64s
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
    Finished `dev` profile target(s) in 8 seconds

Collected 2 test(s) from adder package
Running 1 test(s) from src/
[PASS] adder::tests::add (gas: ~1)
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::internal (gas: ~1)
Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

```

To avoid systematically getting a section for each file of the _tests_ folder, we also have the option of making the `tests/` directory behave like a regular crate, by adding a `tests/lib.cairo` file. In that case, the `tests` directory will no longer compile as one crate per file, but as one crate for the whole directory.

Let's create this _tests/lib.cairo_ file :

Filename: tests/lib.cairo

```cairo noplayground hljs

mod integration_tests;
mod common;

```

The project directory will now look like this :

```shell hljs

adder
â”œâ”€â”€ Scarb.lock
â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â””â”€â”€ lib.cairo
â””â”€â”€ tests
    â”œâ”€â”€ common.cairo
    â”œâ”€â”€ integration_tests.cairo
    â””â”€â”€ lib.cairo

```

When we run the `scarb test` command again, here is the output :

```shell hljs

$ scarb test
     Running test adder (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Finished `release` profile [optimized] target(s) in 0.51s
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
    Finished `dev` profile target(s) in 7 seconds

Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_tests::integration_tests::internal (gas: ~1)
Running 1 test(s) from src/
[PASS] adder::tests::add (gas: ~1)
Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

```

This way, only the test functions will be tested and the `setup` function can be imported without being tested.

Cairo's testing features provide a way to specify how code should function to ensure it continues to work as you expect, even as you make changes. Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the libraryâ€™s public API to test the code in the same way external code will use it. Even though Cairo's type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.

Start

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=713971479.1738497975&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015666~102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1074171038)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-03-operator-overloading.md "Suggest an edit")

Operator overloading is a feature in some programming languages that allows the redefinition of standard operators, such as addition ( `+`), subtraction ( `-`), multiplication ( `*`), and division ( `/`), to work with user-defined types. This can make the syntax of the code more intuitive, by enabling operations on user-defined types to be expressed in the same way as operations on primitive types.

Di Cairo, operator overloading dicapai melalui implementasi trait khusus. Setiap operator memiliki trait terkait, dan pengulangan operator melibatkan penyediaan implementasi trait tersebut untuk tipe kustom. Namun, penting untuk menggunakan operator overloading dengan bijak. Penyalahgunaan dapat menyebabkan kebingungan, membuat kode menjadi lebih sulit untuk dikelola, misalnya ketika tidak ada makna semantik pada operator yang di-overload.

Pertimbangkan contoh di mana dua `Potion` perlu digabungkan. `Potion` memiliki dua bidang data, yaitu mana dan kesehatan. Menggabungkan dua `Potion` seharusnya menambahkan bidang masing-masing.

```cairo hljs

struct Potion {
    health: felt252,
    mana: felt252,
}

impl PotionAdd of Add<Potion> {
    fn add(lhs: Potion, rhs: Potion) -> Potion {
        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana }
    }
}

fn main() {
    let health_potion: Potion = Potion { health: 100, mana: 0 };
    let mana_potion: Potion = Potion { health: 0, mana: 100 };
    let super_potion: Potion = health_potion + mana_potion;
    // Both potions were combined with the `+` operator.
    assert(super_potion.health == 100, '');
    assert(super_potion.mana == 100, '');
}

```

Dalam kode di atas, kami sedang mengimplementasikan trait `Add` untuk tipe `Potion`. Fungsi tambah mengambil dua argumen: `lhs` dan `rhs` (kiri dan kanan). Tubuh fungsi mengembalikan instance `Potion` baru, dengan nilai bidangnya merupakan kombinasi dari `lhs` dan `rhs`.

Seperti yang diilustrasikan dalam contoh tersebut, pengoverloadan operator memerlukan spesifikasi tipe konkret yang di-overload. Trait generik yang di-overload adalah `Add<T>`, dan kami mendefinisikan implementasi konkret untuk tipe `Potion` dengan `Add<Potion>`.

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-04-hash.md "Suggest an edit")

At its essence, hashing is a process of converting input data (often called a message) of any length into a fixed-size value, typically referred to as a "hash." This transformation is deterministic, meaning that the same input will always produce the same hash value. Hash functions are a fundamental component in various fields, including data storage, cryptography and data integrity verification. They are very often used when developing smart contracts, especially when working with [Merkle trees](https://en.wikipedia.org/wiki/Merkle_tree#Uses).

In this chapter, we will present the two hash functions implemented natively in the Cairo core library: `Poseidon` and `Pedersen`. We will discuss when and how to use them, and see examples with Cairo programs.

The Cairo core library provides two hash functions: Pedersen and Poseidon.

Pedersen hash functions are cryptographic algorithms that rely on [elliptic curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography). These functions perform operations on points along an elliptic curve â€” essentially, doing math with the locations of these points â€” which are easy to do in one direction and hard to undo. This one-way difficulty is based on the Elliptic Curve Discrete Logarithm Problem (ECDLP), which is a problem so hard to solve that it ensures the security of the hash function. The difficulty of reversing these operations is what makes the Pedersen hash function secure and reliable for cryptographic purposes.

Poseidon is a family of hash functions designed to be very efficient as algebraic circuits. Its design is particularly efficient for Zero-Knowledge proof systems, including STARKs (so, Cairo). Poseidon uses a method called a 'sponge construction,' which soaks up data and transforms it securely using a process known as the Hades permutation. Cairo's version of Poseidon is based on a three-element state permutation with [specific parameters](https://github.com/starkware-industries/poseidon/blob/main/poseidon3.txt).

Pedersen was the first hash function used on Starknet, and is still used to compute the addresses of variables in storage (for example, `LegacyMap` uses Pedersen to hash the keys of a storage mapping on Starknet). However, as Poseidon is cheaper and faster than Pedersen when working with STARK proofs system, it's now the recommended hash function to use in Cairo programs.

The core library makes it easy to work with hashes. The `Hash` trait is implemented for all types that can be converted to `felt252`, including `felt252` itself. For more complex types like structs, deriving `Hash` allows them to be hashed easily using the hash function of your choice - given that all of the struct's fields are themselves hashable. You cannot derive the `Hash` trait on a struct that contains un-hashable values, such as `Array<T>` or `Felt252Dict<T>`, even if `T` itself is hashable.

The `Hash` trait is accompanied by the `HashStateTrait` and `HashStateExTrait` that define the basic methods to work with hashes. They allow you to initialize a hash state that will contain the temporary values of the hash after each application of the hash function, update the hash state and finalize it when the computation is completed. `HashStateTrait` and `HashStateExTrait` are defined as follows:

```cairo noplayground hljs

/// A trait for hash state accumulators.
trait HashStateTrait<S> {
    fn update(self: S, value: felt252) -> S;
    fn finalize(self: S) -> felt252;
}

/// Extension trait for hash state accumulators.
trait HashStateExTrait<S, T> {
    /// Updates the hash state with the given value.
    fn update_with(self: S, value: T) -> S;
}

/// A trait for values that can be hashed.
trait Hash<T, S, +HashStateTrait<S>> {
    /// Updates the hash state with the given value.
    fn update_state(state: S, value: T) -> S;
}

```

To use hashes in your code, you must first import the relevant traits and functions. In the following example, we will demonstrate how to hash a struct using both the Pedersen and Poseidon hash functions.

The first step is to initialize the hash with either `PoseidonTrait::new() -> HashState` or `PedersenTrait::new(base: felt252) -> HashState` depending on which hash function we want to work with. Then the hash state can be updated with the `update(self: HashState, value: felt252) -> HashState` or `update_with(self: S, value: T) -> S` functions as many times as required. Then the function `finalize(self: HashState) -> felt252` is called on the hash state and it returns the value of the hash as a `felt252`.

```cairo hljs

use core::poseidon::PoseidonTrait;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop, Hash)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

fn main() -> felt252 {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    let hash = PoseidonTrait::new().update_with(struct_to_hash).finalize();
    hash
}

```

Pedersen is different from Poseidon, as it starts with a base state. This base state must be of `felt252` type, which forces us to either hash the struct with an arbitrary base state using the `update_with` method, or serialize the struct into an array to loop through all of its fields and hash its elements together.

Here is a short example of Pedersen hashing:

```cairo hljs hide-boring

use core::pedersen::PedersenTrait;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop, Hash, Serde, Copy)]
struct StructForHash {
    first: felt252,
    second: felt252,
    third: (u32, u32),
    last: bool,
}

fn main() -> (felt252, felt252) {
    let struct_to_hash = StructForHash { first: 0, second: 1, third: (1, 2), last: false };

    // hash1 is the result of hashing a struct with a base state of 0
    let hash1 = PedersenTrait::new(0).update_with(struct_to_hash).finalize();

    let mut serialized_struct: Array<felt252> = ArrayTrait::new();
    Serde::serialize(@struct_to_hash, ref serialized_struct);
    let first_element = serialized_struct.pop_front().unwrap();
    let mut state = PedersenTrait::new(first_element);

    while let Option::Some(value) = serialized_struct.pop_front() {
        state = state.update(value);
    };

    // hash2 is the result of hashing only the fields of the struct
    let hash2 = state.finalize();

    (hash1, hash2)
}

```

Let us look at an example of hashing a struct that contains a `Span<felt252>`.
To hash a `Span<felt252>` or a struct that contains a `Span<felt252>` you can use the built-in function `poseidon_hash_span(mut span: Span<felt252>) -> felt252`. Similarly, you can hash `Array<felt252>` by calling `poseidon_hash_span` on its span.

First, let us import the following traits and function:

```cairo noplayground hljs

use core::poseidon::PoseidonTrait;
use core::poseidon::poseidon_hash_span;
use core::hash::{HashStateTrait, HashStateExTrait};

```

Now we define the struct. As you might have noticed, we didn't derive the `Hash` trait. If you attempt to derive the `Hash` trait for this struct, it will result in an error because the structure contains a field that is not hashable.

```cairo noplayground hljs

#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array<felt252>,
}

```

In this example, we initialized a `HashState` ( `hash`), updated it and then called the function `finalize()` on the
`HashState` to get the computed hash `hash_felt252`. We used `poseidon_hash_span` on the `Span` of the `Array<felt252>` to compute its hash.

```cairo hljs hide-boring

use core::poseidon::PoseidonTrait;
use core::poseidon::poseidon_hash_span;
use core::hash::{HashStateTrait, HashStateExTrait};

#[derive(Drop)]
struct StructForHashArray {
    first: felt252,
    second: felt252,
    third: Array<felt252>,
}

fn main() {
    let struct_to_hash = StructForHashArray { first: 0, second: 1, third: array![1, 2, 3, 4, 5] };

    let mut hash = PoseidonTrait::new().update(struct_to_hash.first).update(struct_to_hash.second);
    let hash_felt252 = hash.update(poseidon_hash_span(struct_to_hash.third.span())).finalize();
}

```

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=965113800.1738497976&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102308675~102482432~102528644~102539968~102546754&z=1662494477)

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1619814869.1738497977&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102558064&z=1520434851)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/tr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-03-functions.md "Suggest an edit")

Fonksiyonlar Cairo kodunda yaygÄ±ndÄ±r. Dilin en Ã¶nemli fonksiyonlarÄ±ndan birini zaten gÃ¶rdÃ¼nÃ¼z: birÃ§ok programÄ±n giriÅŸ noktasÄ± olan `main` fonksiyonu. AyrÄ±ca yeni fonksiyonlar bildirmenize izin veren `fn` anahtar kelimesini de gÃ¶rdÃ¼nÃ¼z.

Cairo kodu, fonksiyon ve deÄŸiÅŸken adlarÄ± iÃ§in geleneksel stil olarak _snake case_ kullanÄ±r, burada tÃ¼m harfler kÃ¼Ã§Ã¼k harftir ve alt Ã§izgiler kelimeleri ayÄ±rÄ±r. Ä°ÅŸte bir fonksiyon tanÄ±mÄ± iÃ§eren bir program Ã¶rneÄŸi:

```cairo hljs

fn another_function() {
    println!("Another function.");
}

fn main() {
    println!("Hello, world!");
    another_function();
}

```

Bir fonksiyonu Cairo'da `fn`'yi takiben bir fonksiyon adÄ± ve bir parantez kÃ¼mesi girerek tanÄ±mlarÄ±z. SÃ¼slÃ¼ parantezler, fonksiyon gÃ¶vdesinin nerede baÅŸlayÄ±p bittiÄŸini derleyiciye sÃ¶yler.

TanÄ±mladÄ±ÄŸÄ±mÄ±z herhangi bir fonksiyonu, adÄ±nÄ± takiben bir parantez kÃ¼mesi girerek Ã§aÄŸÄ±rabiliriz. Programda `another_function` tanÄ±mlandÄ±ÄŸÄ±ndan, `main` fonksiyonunun iÃ§inden Ã§aÄŸrÄ±labilir. Kaynak kodda `another_function`'Ä± `main` fonksiyonundan _Ã¶nce_ tanÄ±mladÄ±ÄŸÄ±mÄ±zÄ± unutmayÄ±n; bunu sonrasÄ±nda da tanÄ±mlayabilirdik. Cairo, fonksiyonlarÄ±nÄ±zÄ± nerede tanÄ±mladÄ±ÄŸÄ±nÄ±zÄ± umursamaz, yeter ki Ã§aÄŸÄ±ran tarafÄ±ndan gÃ¶rÃ¼lebilecek bir kapsamda tanÄ±mlansÄ±nlar.

FonksiyonlarÄ± daha fazla keÅŸfetmek iÃ§in Scarb ile _functions_ adÄ±nda yeni bir proje baÅŸlatalÄ±m. `another_function` Ã¶rneÄŸini _src/lib.cairo_ iÃ§ine yerleÅŸtirin ve Ã§alÄ±ÅŸtÄ±rÄ±n. AÅŸaÄŸÄ±daki Ã§Ä±ktÄ±yÄ± gÃ¶rmelisiniz:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_15_functions v0.1.0 (listings/ch02-common-programming-concepts/no_listing_15_functions/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_15_functions
Hello, world!
Another function.
Run completed successfully, returning []

```

The lines execute in the order in which they appear in the `main` function. First the `Hello, world!` message prints, and then `another_function` is called and its message is printed.

FonksiyonlarÄ±, fonksiyonun imzasÄ±nÄ±n bir parÃ§asÄ± olan Ã¶zel deÄŸiÅŸkenler olan _parametreler_ ile tanÄ±mlayabiliriz. Bir fonksiyonun parametreleri olduÄŸunda, bu parametreler iÃ§in somut deÄŸerler saÄŸlayabilirsiniz. Teknik olarak, somut deÄŸerlere _argÃ¼manlar_ denir, ancak gÃ¼nlÃ¼k konuÅŸmada, insanlar genellikle fonksiyonun tanÄ±mÄ±ndaki deÄŸiÅŸkenler veya fonksiyonu Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±zda geÃ§irilen somut deÄŸerler iÃ§in _parametre_ ve _argÃ¼man_ kelimelerini birbirinin yerine kullanÄ±r.

`another_function`'un bu versiyonunda bir parametre ekliyoruz

```cairo hljs

fn main() {
    another_function(5);
}

fn another_function(x: felt252) {
    println!("The value of x is: {}", x);
}

```

Bu programÄ± Ã§alÄ±ÅŸtÄ±rmayÄ± deneyin; aÅŸaÄŸÄ±daki Ã§Ä±ktÄ±yÄ± almalÄ±sÄ±nÄ±z

```shell hljs

$ scarb cairo-run
   Compiling no_listing_16_single_param v0.1.0 (listings/ch02-common-programming-concepts/no_listing_16_single_param/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_16_single_param
The value of x is: 5
Run completed successfully, returning []

```

`another_function`'Ä±n bildirimi `x` adÄ±nda bir parametreye sahiptir. `x`'in tÃ¼rÃ¼ `felt252` olarak belirtilmiÅŸtir. `another_function`'a `5` geÃ§irdiÄŸimizde, `println!` makrosu `x`'i iÃ§eren sÃ¼slÃ¼ parantez Ã§iftinin olduÄŸu yere format dizgisinde `5` koyar.

Fonksiyon imzalarÄ±nda, her parametrenin tÃ¼rÃ¼nÃ¼ _mutlaka_ belirtmelisiniz. Bu, Cairoâ€™nun tasarÄ±mÄ±nda bilinÃ§li bir karardÄ±r: fonksiyon tanÄ±mlarÄ±nda tÃ¼r annotasyonlarÄ± gerektirmek, kodun geri kalanÄ±nda ne tÃ¼r bir ÅŸey kastettiÄŸinizi anlamak iÃ§in derleyicinin neredeyse hiÃ§ sizin tarafÄ±nÄ±zdan bunlarÄ± kullanmanÄ±zÄ± gerektirmez. Derleyici, fonksiyonun hangi tÃ¼rleri beklediÄŸini bildiÄŸinde daha yardÄ±mcÄ± hata mesajlarÄ± verebilir.

Birden fazla parametre tanÄ±mlarken, parametre bildirimlerini aÅŸaÄŸÄ±daki gibi virgÃ¼lle ayÄ±rÄ±n:

```cairo hljs

fn main() {
    print_labeled_measurement(5, "h");
}

fn print_labeled_measurement(value: u128, unit_label: ByteArray) {
    println!("The measurement is: {value}{unit_label}");
}

```

Bu Ã¶rnek, `value` ve `unit_label` adÄ±nda iki parametre ile `print_labeled_measurement` adÄ±nda bir fonksiyon oluÅŸturur. Ä°lk parametre `value` adÄ±nÄ± taÅŸÄ±r ve bir `u128`'dir. Ä°kincisi `unit_label` adÄ±nda ve `ByteArray` tÃ¼rÃ¼ndedir - Cairo'nun string literallerini temsil etmek iÃ§in iÃ§sel tÃ¼rÃ¼. Fonksiyon daha sonra hem `value` hem de `unit_label` iÃ§eren bir metin yazdÄ±rÄ±r.

Bu kodu Ã§alÄ±ÅŸtÄ±rmayÄ± deneyelim. _functions_ projesinin _src/lib.cairo_ dosyasÄ±ndaki mevcut programÄ± Ã¶nceki Ã¶rnekle deÄŸiÅŸtirin ve `scarb cairo-run` kullanarak Ã§alÄ±ÅŸtÄ±rÄ±n:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_17_multiple_params v0.1.0 (listings/ch02-common-programming-concepts/no_listing_17_multiple_params/Scarb.toml)
    Finished `dev` profile target(s) in 5 seconds
     Running no_listing_17_multiple_params
The measurement is: 5h
Run completed successfully, returning []

```

Fonksiyonu `value` iÃ§in `5` deÄŸeriyle ve `unit_label` iÃ§in `"h"` deÄŸeriyle Ã§aÄŸÄ±rdÄ±ÄŸÄ±mÄ±z iÃ§in, program Ã§Ä±ktÄ±sÄ± bu deÄŸerleri iÃ§erir.

Cairo'da, adlandÄ±rÄ±lmÄ±ÅŸ parametreler bir fonksiyonu Ã§aÄŸÄ±rÄ±rken argÃ¼manlarÄ±n isimlerini belirtmenize olanak tanÄ±r. Bu, fonksiyon Ã§aÄŸrÄ±larÄ±nÄ± daha okunabilir ve kendini aÃ§Ä±klayÄ±cÄ± hale getirir. EÄŸer adlandÄ±rÄ±lmÄ±ÅŸ parametreleri kullanmak istiyorsanÄ±z, parametrenin adÄ±nÄ± ve ona geÃ§irmek istediÄŸiniz deÄŸeri belirtmeniz gereklidir. SÃ¶zdizimi ÅŸÃ¶yledir: `parameter_name: value`. EÄŸer parametre ile aynÄ± ada sahip bir deÄŸiÅŸken geÃ§irirseniz, `parameter_name: variable_name` yerine sadece `:parameter_name` yazabilirsiniz.

Ä°ÅŸte bir Ã¶rnek

```cairo hljs

fn foo(x: u8, y: u8) {}

fn main() {
    let first_arg = 3;
    let second_arg = 4;
    foo(x: first_arg, y: second_arg);
    let x = 1;
    let y = 2;
    foo(:x, :y)
}

```

Fonksiyon gÃ¶vdeleri, isteÄŸe baÄŸlÄ± olarak bir expression ile sonlanan bir dizi statement'tan oluÅŸur. Åžu ana kadar ele aldÄ±ÄŸÄ±mÄ±z fonksiyonlar, bir sonlandÄ±rma expression'Ä± iÃ§ermemiÅŸti, ancak bir statement iÃ§inde bir expression gÃ¶rmÃ¼ÅŸsÃ¼nÃ¼zdÃ¼r. Cairo bir expression tabanlÄ± dil olduÄŸundan, bu Ã¶nemli bir ayrÄ±mÄ± anlamak Ã¶nemlidir. DiÄŸer diller aynÄ± ayrÄ±mlara sahip deÄŸildir, bu yÃ¼zden statement'lar ve expression'lar neyi ifade eder ve farklÄ±lÄ±klarÄ± fonksiyon gÃ¶vdelerini nasÄ±l etkiler, bunlara bakalÄ±m.

- **Statements**, bazÄ± eylemleri gerÃ§ekleÅŸtiren ve bir deÄŸer dÃ¶ndÃ¼rmeyen talimatlardÄ±r.
- **Expressions** bir sonuÃ§ deÄŸerine gÃ¶re deÄŸerlendirilir. Åžimdi bazÄ± Ã¶rneklere bakalÄ±m.

Biz aslÄ±nda zaten statement'lar ve expression'lar kullanmÄ±ÅŸÄ±zdÄ±r. Bir deÄŸiÅŸken oluÅŸturmak ve `let` anahtar kelimesi ile ona bir deÄŸer atamak bir statement'dÄ±r. Listing 2-1'de, `let y = 6;` bir statement'dÄ±r.

```cairo hljs

fn main() {
    let y = 6;
}

```

Listing 2-1: A `main` function declaration containing one statement

Fonksiyon tanÄ±mlarÄ± da ifadelerdir; Ã¶nceki Ã¶rneÄŸin tamamÄ± kendi iÃ§inde bir ifadedir.

Statement'lar deÄŸer dÃ¶ndÃ¼rmez. Bu nedenle, bir `let` statement'Ä±nÄ± baÅŸka bir deÄŸiÅŸkene atayamazsÄ±nÄ±z, aÅŸaÄŸÄ±daki kodun yapmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ± gibi; bir hata alÄ±rsÄ±nÄ±z:

```cairo noplayground hljs

fn main() {
    let x = (let y = 6);
}

```

Bu programÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±nÄ±zda alacaÄŸÄ±nÄ±z hata ÅŸuna benzer:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_18_statements_dont_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/Scarb.toml)
error: Missing token TerminalRParen.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:14
    let x = (let y = 6);
             ^

error: Missing token TerminalSemicolon.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
    let x = (let y = 6);
                      ^

error: Skipped tokens. Expected: statement.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:23
    let x = (let y = 6);
                      ^^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:9
    let x = (let y = 6);
        ^

warn[E0001]: Unused variable. Consider ignoring by prefixing with `_`.
 --> listings/ch02-common-programming-concepts/no_listing_20_statements_dont_return_values/src/lib.cairo:3:18
    let x = (let y = 6);
                 ^

error: could not compile `no_listing_18_statements_dont_return_values` due to previous error
error: `scarb metadata` exited with error

```

`let y = 6` statement'Ä± bir deÄŸer dÃ¶ndÃ¼rmez, bu yÃ¼zden `x`'in baÄŸlanacak bir ÅŸeyi yoktur. Bu, C ve Ruby gibi diÄŸer dillerde olanlardan farklÄ±dÄ±r, bu dillerde atama, atamanÄ±n deÄŸerini dÃ¶ndÃ¼rÃ¼r. Bu dillerde `x = y = 6` yazabilir ve hem `x` hem de `y`'nin deÄŸeri `6` olur; bu Cairo'da sÃ¶z konusu deÄŸildir.

Expression'lar bir deÄŸere deÄŸerlendirilir ve Cairo'da yazacaÄŸÄ±nÄ±z kodun Ã§oÄŸunu oluÅŸturur. Ã–rneÄŸin, `5 + 6` gibi bir matematik iÅŸlemi, deÄŸeri `11` olarak deÄŸerlendirilen bir expression'dÄ±r. Expression'lar statement'larÄ±n bir parÃ§asÄ± olabilir: Listing 2-1'de, `let y = 6;` statement'Ä±ndaki `6`, deÄŸeri `6` olarak deÄŸerlendirilen bir expression'dÄ±r.

Bir fonksiyonu Ã§aÄŸÄ±rmak bir expression'dÄ±r Ã§Ã¼nkÃ¼ her zaman bir deÄŸere deÄŸerlendirilir: belirtilmiÅŸse fonksiyonun aÃ§Ä±k dÃ¶nÃ¼ÅŸ deÄŸeri, aksi takdirde 'unit' tÃ¼rÃ¼ `()`.

Ã–rneÄŸin, kÃ¼me parantezleriyle oluÅŸturulan yeni bir kapsam bloÄŸu bir ifadedir:

```cairo hljs

fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}

```

Bu expression:

```cairo noplayground hljs

    let y = {
        let x = 3;
        x + 1
    };

```

bu durumda `4` olarak deÄŸerlendirilen bir bloktur. Bu deÄŸer, `let` statement'Ä±nÄ±n bir parÃ§asÄ± olarak `y`'e baÄŸlanÄ±r. `x + 1` satÄ±rÄ±nÄ±n sonunda, ÅŸimdiye kadar gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z Ã§oÄŸu satÄ±rdan farklÄ± olarak bir noktalÄ± virgÃ¼l yoktur. Expression'lar sonunda noktalÄ± virgÃ¼l iÃ§ermez. Bir expression'Ä±n sonuna noktalÄ± virgÃ¼l eklerseniz, onu bir statement'a dÃ¶nÃ¼ÅŸtÃ¼rÃ¼rsÃ¼nÃ¼z ve o zaman bir deÄŸer dÃ¶ndÃ¼rmez. Bunu, fonksiyon dÃ¶nÃ¼ÅŸ deÄŸerlerini ve expression'larÄ± keÅŸfederken aklÄ±nÄ±zda bulundurun.

Fonksiyonlar, onlarÄ± Ã§aÄŸÄ±ran koda deÄŸerler dÃ¶ndÃ¼rebilir. DÃ¶nÃ¼ÅŸ deÄŸerlerini isimlendirmeyiz, ancak tÃ¼rlerini bir ok ( `->`) sonrasÄ±nda belirtmeliyiz. Cairo'da, fonksiyonun dÃ¶nÃ¼ÅŸ deÄŸeri, fonksiyonun gÃ¶vde bloÄŸundaki son expression ile eÅŸanlamlÄ±dÄ±r. `return` anahtar kelimesini kullanarak ve bir deÄŸer belirterek bir fonksiyondan erken dÃ¶nÃ¼ÅŸ yapabilirsiniz, ancak Ã§oÄŸu fonksiyon son expression'Ä± dolaylÄ± olarak dÃ¶ndÃ¼rÃ¼r. Ä°ÅŸte bir deÄŸer dÃ¶ndÃ¼ren bir fonksiyonun Ã¶rneÄŸi:

```cairo hljs

fn five() -> u32 {
    5
}

fn main() {
    let x = five();
    println!("The value of x is: {}", x);
}

```

`five` fonksiyonunda fonksiyon Ã§aÄŸrÄ±larÄ± veya hatta `let` statement'larÄ± yokturâ€”sadece tek baÅŸÄ±na `5` numarasÄ± vardÄ±r. Bu, Cairo'da geÃ§erli bir fonksiyondur. Fonksiyonun dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼nÃ¼n de `-> u32` olarak belirtildiÄŸine dikkat edin. Bu kodu Ã§alÄ±ÅŸtÄ±rmayÄ± deneyin; Ã§Ä±ktÄ± ÅŸÃ¶yle gÃ¶rÃ¼nmelidir:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_20_function_return_values v0.1.0 (listings/ch02-common-programming-concepts/no_listing_22_function_return_values/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_20_function_return_values
The value of x is: 5
Run completed successfully, returning []

```

`five` iÃ§indeki `5`, fonksiyonun dÃ¶nÃ¼ÅŸ deÄŸeridir, bu yÃ¼zden dÃ¶nÃ¼ÅŸ tÃ¼rÃ¼ `u32`'dir. Bunu daha detaylÄ± inceleyelim. Ä°ki Ã¶nemli nokta var: ilk olarak, `let x = five();` satÄ±rÄ±, bir fonksiyonun dÃ¶nÃ¼ÅŸ deÄŸerini bir deÄŸiÅŸkeni baÅŸlatmak iÃ§in kullandÄ±ÄŸÄ±mÄ±zÄ± gÃ¶sterir. Ã‡Ã¼nkÃ¼ `five` fonksiyonu bir `5` dÃ¶ndÃ¼rÃ¼r, bu satÄ±r aÅŸaÄŸÄ±dakiyle aynÄ±dÄ±r:

```cairo noplayground hljs

let x = 5;

```

Ä°kincisi, `five` fonksiyonunun parametreleri yoktur ve dÃ¶nÃ¼ÅŸ deÄŸerinin tÃ¼rÃ¼nÃ¼ tanÄ±mlar, ancak fonksiyonun gÃ¶vdesi, dÃ¶ndÃ¼rmek istediÄŸimiz deÄŸerin bir expression'Ä± olduÄŸu iÃ§in noktalÄ± virgÃ¼l olmadan yalnÄ±z bir `5`'tir. Bir baÅŸka Ã¶rneÄŸe bakalÄ±m:

```cairo hljs

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -> u32 {
    x + 1
}

```

Bu kodu Ã§alÄ±ÅŸtÄ±rmak `x = 6` yazdÄ±racaktÄ±r. Ancak, `x + 1` satÄ±rÄ±nÄ±n sonuna noktalÄ± virgÃ¼l koyarsak, bunu bir expression'dan bir statement'a Ã§evirirsek, bir hata alÄ±rÄ±z:

```cairo does_not_compile hljs

fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: u32) -> u32 {
    x + 1;
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_22_function_return_invalid v0.1.0 (listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/Scarb.toml)
error: Unexpected return type. Expected: "core::integer::u32", found: "()".
 --> listings/ch02-common-programming-concepts/no_listing_24_function_return_invalid/src/lib.cairo:9:28
fn plus_one(x: u32) -> u32 {
                           ^

error: could not compile `no_listing_22_function_return_invalid` due to previous error
error: `scarb metadata` exited with error

```

Ana hata mesajÄ± olan `Unexpected return type`, bu kodla ilgili temel sorunu ortaya koyar. `plus_one` fonksiyonunun tanÄ±mÄ±, bir `u32` dÃ¶ndÃ¼receÄŸini sÃ¶yler, ancak statement'lar bir deÄŸere deÄŸerlendirilmez, bu `()`, yani unit tÃ¼rÃ¼ ile ifade edilir. DolayÄ±sÄ±yla, hiÃ§bir ÅŸey dÃ¶ndÃ¼rÃ¼lmez, bu da fonksiyonun tanÄ±mÄ± ile Ã§eliÅŸir ve bir hataya neden olur.

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch101-01-02-storage-vecs.md "Suggest an edit")

The `Vec` type provides a way to store collections of values in the contract's storage. In this section, we will explore how to declare, add elements to and retrieve elements from a `Vec`, as well as how the storage addresses for `Vec` variables are computed.

The `Vec` type is provided by the Cairo core library, inside the `core::starknet::storage` module. Its associated methods are defined in the `VecTrait` and `MutableVecTrait` traits that you will also need to import for read and write operations on the `Vec` type.

> The `Array<T>` type is a **memory** type and cannot be directly stored in contract storage. For storage, use the `Vec<T>` type, which is a \[phantom type\]\[phantom types\] designed specifically for contract storage. However, `Vec<T>` has limitations: it can't be instantiated as a regular variable, used as a function parameter, or included as a member in regular structs. To work with the full contents of a `Vec<T>`, you'll need to copy its elements to and from a memory `Array<T>`.

To declare a Storage Vector, use the `Vec` type enclosed in angle brackets `<>`, specifying the type of elements it will store. In Listing 15-3, we create a simple contract that registers all the addresses that call it and stores them in a `Vec`. We can then retrieve the `n`-th registered address, or all registered addresses.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
trait IAddressList<TState> {
    fn register_caller(ref self: TState);
    fn get_n_th_registered_address(self: @TState, index: u64) -> Option<ContractAddress>;
    fn get_all_addresses(self: @TState) -> Array<ContractAddress>;
    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
}

#[starknet::contract]
mod AddressList {
    use starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait, MutableVecTrait,
    };
    use core::starknet::{get_caller_address, ContractAddress};

    #[storage]
    struct Storage {
        addresses: Vec<ContractAddress>,
    }

    impl AddressListImpl of super::IAddressList<ContractState> {
        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.append().write(caller);
        }

        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -> Option<ContractAddress> {
            if let Option::Some(storage_ptr) = self.addresses.get(index) {
                return Option::Some(storage_ptr.read());
            }
            return Option::None;
        }

        fn get_all_addresses(self: @ContractState) -> Array<ContractAddress> {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses.at(i).read());
            };
            addresses
        }

        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            let mut storage_ptr = self.addresses.at(index);
            storage_ptr.write(new_address);
        }
    }
}

```

Listing 15-3: Declaring a storage `Vec` in the Storage struct

To add an element to a `Vec`, you use the `append` method to get a storage pointer to the next available slot, and then call the `write` function on it with the value to add.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
trait IAddressList<TState> {
    fn register_caller(ref self: TState);
    fn get_n_th_registered_address(self: @TState, index: u64) -> Option<ContractAddress>;
    fn get_all_addresses(self: @TState) -> Array<ContractAddress>;
    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
}

#[starknet::contract]
mod AddressList {
    use starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait, MutableVecTrait,
    };
    use core::starknet::{get_caller_address, ContractAddress};

    #[storage]
    struct Storage {
        addresses: Vec<ContractAddress>,
    }

    impl AddressListImpl of super::IAddressList<ContractState> {
        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.append().write(caller);
        }

        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -> Option<ContractAddress> {
            if let Option::Some(storage_ptr) = self.addresses.get(index) {
                return Option::Some(storage_ptr.read());
            }
            return Option::None;
        }

        fn get_all_addresses(self: @ContractState) -> Array<ContractAddress> {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses.at(i).read());
            };
            addresses
        }

        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            let mut storage_ptr = self.addresses.at(index);
            storage_ptr.write(new_address);
        }
    }
}

```

To retrieve an element, you can use the `at` or `get` methods to get a storage pointer to the element at the specified index, and then call the `read` method to get the value. If the index is out of bounds, the `at` method panics, while the `get` method returns `None`.

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
trait IAddressList<TState> {
    fn register_caller(ref self: TState);
    fn get_n_th_registered_address(self: @TState, index: u64) -> Option<ContractAddress>;
    fn get_all_addresses(self: @TState) -> Array<ContractAddress>;
    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
}

#[starknet::contract]
mod AddressList {
    use starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait, MutableVecTrait,
    };
    use core::starknet::{get_caller_address, ContractAddress};

    #[storage]
    struct Storage {
        addresses: Vec<ContractAddress>,
    }

    impl AddressListImpl of super::IAddressList<ContractState> {
        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.append().write(caller);
        }

        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -> Option<ContractAddress> {
            if let Option::Some(storage_ptr) = self.addresses.get(index) {
                return Option::Some(storage_ptr.read());
            }
            return Option::None;
        }

        fn get_all_addresses(self: @ContractState) -> Array<ContractAddress> {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses.at(i).read());
            };
            addresses
        }

        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            let mut storage_ptr = self.addresses.at(index);
            storage_ptr.write(new_address);
        }
    }
}

```

If you want to retrieve all the elements of the Vec, you can iterate over the indices of the storage `Vec`, read the value at each index, and append it to a memory `Array<T>`.
Similarly, you can't store an `Array<T>` in storage: you would need to iterate over the elements of the array and append them to a storage `Vec<T>`.

At this point, you should be familiar with the concept of storage pointers and storage paths introduced in the ["Contract Storage"](https://book.cairo-lang.org/ch101-01-00-contract-storage.html) section and how they are used to access storage variables through a pointer-based model. Thus how would you modify the address stored at a specific index of a `Vec`?

```cairo noplayground hljs hide-boring

use core::starknet::ContractAddress;

#[starknet::interface]
trait IAddressList<TState> {
    fn register_caller(ref self: TState);
    fn get_n_th_registered_address(self: @TState, index: u64) -> Option<ContractAddress>;
    fn get_all_addresses(self: @TState) -> Array<ContractAddress>;
    fn modify_nth_address(ref self: TState, index: u64, new_address: ContractAddress);
}

#[starknet::contract]
mod AddressList {
    use starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, Vec, VecTrait, MutableVecTrait,
    };
    use core::starknet::{get_caller_address, ContractAddress};

    #[storage]
    struct Storage {
        addresses: Vec<ContractAddress>,
    }

    impl AddressListImpl of super::IAddressList<ContractState> {
        fn register_caller(ref self: ContractState) {
            let caller = get_caller_address();
            self.addresses.append().write(caller);
        }

        fn get_n_th_registered_address(
            self: @ContractState, index: u64,
        ) -> Option<ContractAddress> {
            if let Option::Some(storage_ptr) = self.addresses.get(index) {
                return Option::Some(storage_ptr.read());
            }
            return Option::None;
        }

        fn get_all_addresses(self: @ContractState) -> Array<ContractAddress> {
            let mut addresses = array![];
            for i in 0..self.addresses.len() {
                addresses.append(self.addresses.at(i).read());
            };
            addresses
        }

        fn modify_nth_address(ref self: ContractState, index: u64, new_address: ContractAddress) {
            let mut storage_ptr = self.addresses.at(index);
            storage_ptr.write(new_address);
        }
    }
}

```

The answer is fairly simple: get a mutable pointer to the storage pointer at the desired index, and use the `write` method to modify the value at that index.

The address in storage of a variable stored in a `Vec` is computed according to the following rules:

- The length of the `Vec` is stored at the base address, computed as `sn_keccak(variable_name)`.
- The elements of the `Vec` are stored in addresses computed as `h(base_address, i)`, where `i` is the index of the element in the `Vec` and `h` is the Pedersen hash function.

- Use the `Vec` type to store collections of values in contract storage
- Access Vecs using the `append` method to add elements, and the `at` or `get` methods to read elements
- The address of a `Vec` variable is computed using the `sn_keccak` and the Pedersen hash functions

This wraps up our tour of the Contract Storage! In the next section, we'll start looking at the different kind of functions defined in a contract. You already know most of them, as we used them in the previous chapters, but we'll explain them in more detail.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1294037170.1738497977&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1094856211)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch200-introduction.md "Suggest an edit")

Ever wondered how your Cairo programs were executed?

First, they are compiled by the Cairo Compiler, then executed
by the Cairo Virtual Machine, or _Cairo VM_ for short,
which generates a trace of execution, used by the Prover
to generate a STARK proof of that execution. This proof can later
be verified by a Verifier.

The following chapters will go deep inside the inner workings of the Cairo VM.
We'll cover its architecture, its memory model, and its execution model.
Next, we'll explore builtins and hints, their purpose, and how they work.
Finally, we'll look at the runner, which orchestrates the execution of a Cairo program.

But first, what do we mean by "virtual machine"?

Virtual Machines (VMs) are software emulations of physical computers.
They provide a complete programming environment through an API which
includes everything required for the correct execution of programs above it.

Every virtual machine API includes an instruction set architecture (ISA)
in which to express programs. It could be the same instruction set as some
physical machine (e.g. RISC-V), or a dedicated one implemented in the VM
(e.g. Cairo assembly, CASM).

Those that emulate an OS are called _System Virtual Machines_, such as Xen and VMWare.
We're not interested in them here.

The other ones we're interested in are _Process Virtual Machines_.
They provide the environment needed by a single user-level process.

The most well-known process VM might be the Java Virtual Machine (JVM).

- Given a Java program `prgm.java`, it is compiled into a class `prgm.class`,
containing _Java bytecode_ (JVM instructions and metadata).
- The JVM verifies that the bytecode is safe to run.
- The bytecode is either interpreted (slow) or compiled to machine code just in time (JIT, fast).
- If using JIT, the bytecode is translated to machine code while executing the program.
- Java programs could also be directly compiled to a specific CPU architecture (read machine code) through a process called _ahead-of-time compilation_ (AOT).

The Cairo VM is also a process VM, similar to the JVM, with one significant difference:
Java and its JVM are designed for (platform-independent) general-purpose computing,
while Cairo and its Cairo VM are specifically designed for (platform-independent)
_provable_ general-purpose computing.

- A Cairo program `prgm.cairo` is compiled into compilation artifacts `prgm.json`,
containing _Cairo bytecode_ (encoded CASM, the Cairo instruction set, and extra data).
- As seen in the [introduction](https://book.cairo-lang.org/ch00-00-introduction.html), Cairo Zero directly compiles to CASM
while Cairo first compiles to _Sierra_ and then to a safe subset of CASM.
- The Cairo VM _interprets_ the provided CASM and generates a trace of the program execution.
- The obtained trace data can be fed to the Cairo Prover in order to generate a STARK proof,
allowing to prove the correct execution of the program. Creating this _validity proof_ is the
main purpose of Cairo.

Here is a high-level flow diagram showing how a Java program and a Cairo one are executed
with their respective compiler and VM. The proof generation of a Cairo program is included.

![Java and Cairo execution flow](https://book.cairo-lang.org/java-cairo-execution-flow.png)

Java and Cairo program high-level execution flow diagram

An ongoing project, [Cairo Native](https://github.com/lambdaclass/cairo_native) works on providing
Sierra to machine code compilation, including JIT and AOT, for executing Cairo programs.

Even though the high-level flow of both VMs is similar, their actual architectures
are extremely different: the instruction set, the memory model, Cairo's non-determinism
and the output.

Michael L. Scott, in Programming Language Pragmatics, 2015

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1082712678.1738497977&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102558064&z=1784593008)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch00-00-introduction.md "Suggest an edit")

Cairo is a programming language designed to leverage the power of mathematical proofs for computational integrity. Just as C.S. Lewis defined integrity as "doing the right thing, even when no one is watching," Cairo enables programs to prove they've done the right computation, even when executed on untrusted machines.

The language is built on STARK technology, a modern evolution of PCP (Probabilistically Checkable Proofs) that transforms computational claims into constraint systems. While Cairo's ultimate purpose is to generate these mathematical proofs that can be verified efficiently and with absolute certainty.

Cairo enables a paradigm shift in how we think about trusted computation. Its primary application today is Starknet, a Layer 2 scaling solution for Ethereum that addresses one of blockchain's fundamental challenges: scalability without sacrificing security.

In the traditional blockchain model, every participant must verify every computation. Starknet changes this by using Cairo's proof system: computations are executed off-chain by a prover who generates a STARK proof, which is then verified by an Ethereum smart contract. This verification requires significantly less computational power than re-executing the computations, enabling massive scalability while maintaining security.

However, Cairo's potential extends beyond blockchain. Any scenario where computational integrity needs to be verified efficiently can benefit from Cairo's verifiable computation capabilities.

This book caters to three main audiences, each with their own learning path:

1. **General-Purpose Developers**: If you're interested in Cairo for its verifiable computation capabilities outside of blockchain, you'll want to focus on chapters 1-12. These chapters cover the core language features and programming concepts without diving deep into smart contract specifics.

2. **New Smart Contract Developers**: If you're new to both Cairo and smart contracts, we recommend reading the book front to back. This will give you a solid foundation in both the language fundamentals and smart contract development principles.

3. **Experienced Smart Contract Developers**: If you're already familiar with smart contract development in other languages, or Rust, you might want to follow this focused path:
   - Chapters 1-3 for Cairo basics
   - Chapter 8 for Cairo's trait and generics system
   - Skip to Chapter 15 for smart contract development
   - Reference other chapters as needed

Regardless of your background, this book assumes basic programming knowledge such as variables, functions, and common data structures. While prior experience with Rust can be helpful (as Cairo shares many similarities), it's not required.

- Cairo CPU Architecture: [https://eprint.iacr.org/2021/1063](https://eprint.iacr.org/2021/1063)
- Cairo, Sierra and Casm: [https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5)
- State of non determinism: [https://twitter.com/PapiniShahar/status/1638203716535713798](https://twitter.com/PapiniShahar/status/1638203716535713798)

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1912115479.1738497978&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=1412572689)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-05-control-flow.md "Suggest an edit")

Kemampuan untuk menjalankan beberapa kode tergantung pada apakah suatu kondisi benar, dan untuk menjalankan beberapa kode secara berulang selama suatu kondisi benar adalah blok dasar dalam sebagian besar bahasa pemrograman. Konstruksi yang paling umum yang memungkinkan Anda mengendalikan alur eksekusi kode Cairo adalah ekspresi if dan loop.

Ekspresi if memungkinkan Anda bercabang dalam kode Anda tergantung pada kondisi. Anda memberikan suatu kondisi dan kemudian menyatakan, "Jika kondisi ini terpenuhi, jalankan blok kode ini. Jika kondisinya tidak terpenuhi, jangan jalankan blok kode ini."

Create a new project called _branches_ in your _cairo\_projects_ directory to explore the `if` expression. In the _src/lib.cairo_ file, input the following:

```cairo hljs

fn main() {
    let number = 3;

    if number == 5 {
        println!("condition was true and number = {}", number);
    } else {
        println!("condition was false and number = {}", number);
    }
}

```

Semua ekspresi `if` dimulai dengan kata kunci `if`, diikuti oleh suatu kondisi. Dalam kasus ini, kondisinya memeriksa apakah variabel `number` memiliki nilai yang sama dengan 5. Kami menempatkan blok kode untuk dijalankan jika kondisinya `true` langsung setelah kondisi di dalam kurung kurawal.

Opsionalnya, kita juga dapat menyertakan ekspresi `else`, seperti yang kita pilih di sini, untuk memberikan program blok kode alternatif yang akan dijalankan jika kondisi dinilai `false`. Jika Anda tidak menyediakan ekspresi `else` dan kondisinya `false`, program akan melewati blok `if` dan melanjutkan ke bagian kode berikutnya.

Coba jalankan kode ini; Anda seharusnya melihat keluaran berikut:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_24_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_27_if/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_24_if
condition was false and number = 3
Run completed successfully, returning []

```

Mari mencoba mengubah nilai `number` menjadi suatu nilai yang membuat kondisinya menjadi `true` untuk melihat apa yang terjadi:

```cairo noplayground hljs

    let number = 5;

```

```shell hljs

$ scarb cairo-run
condition was true and number = 5
Run completed successfully, returning []

```

Itâ€™s also worth noting that the condition in this code must be a `bool`. If the condition isnâ€™t a `bool`, weâ€™ll get an error. For example, try running the following code:

```cairo hljs

fn main() {
    let number = 3;

    if number {
        println!("number was three");
    }
}

```

The `if` condition evaluates to a value of 3 this time, and Cairo throws an error:

```shell hljs

$ scarb build
   Compiling no_listing_28_bis_if_not_bool v0.1.0 (listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/Scarb.toml)
error: Mismatched types. The type `core::bool` cannot be created from a numeric literal.
 --> listings/ch02-common-programming-concepts/no_listing_28_bis_if_not_bool/src/lib.cairo:4:18
    let number = 3;
                 ^

error: could not compile `no_listing_28_bis_if_not_bool` due to previous error

```

The error indicates that Cairo inferred the type of `number` to be a `bool` based on its later use as a condition of the `if` statement. It tries to create a `bool` from the value `3`, but Cairo doesn't support instantiating a `bool` from a numeric literal anyway - you can only use `true` or `false` to create a `bool`. Unlike languages such as Ruby and JavaScript, Cairo will not automatically try to convert non-Boolean types to a Boolean. If we want the `if` code block to run only when a number is not equal to 0, for example, we can change the if expression to the following:

```cairo hljs

fn main() {
    let number = 3;

    if number != 0 {
        println!("number was something other than zero");
    }
}

```

Running this code will print `number was something other than zero`.

You can use multiple conditions by combining `if` and `else` in an `else if` expression. For example:

```cairo hljs

fn main() {
    let number = 3;

    if number == 12 {
        println!("number is 12");
    } else if number == 3 {
        println!("number is 3");
    } else if number - 2 == 1 {
        println!("number minus 2 is 1");
    } else {
        println!("number not found");
    }
}

```

Program ini memiliki empat jalur yang mungkin diambil. Setelah dijalankan, Anda seharusnya melihat keluaran berikut:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_25_else_if v0.1.0 (listings/ch02-common-programming-concepts/no_listing_30_else_if/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_25_else_if
number is 3
Run completed successfully, returning []

```

When this program executes, it checks each `if` expression in turn and executes the first body for which the condition evaluates to `true`. Note that even though `number - 2 == 1` is `true`, we donâ€™t see the output `number minus 2 is 1` nor do we see the `number not found` text from the `else` block. Thatâ€™s because Cairo only executes the block for the first true condition, and once it finds one, it doesnâ€™t even check the rest. Using too many `else if` expressions can clutter your code, so if you have more than one, you might want to refactor your code. [Chapter 6](https://book.cairo-lang.org/id/ch06-02-the-match-control-flow-construct.html) describes a powerful Cairo branching construct called `match` for these cases.

Because `if` is an expression, we can use it on the right side of a `let` statement to assign the outcome to a variable.

```cairo hljs

fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    if number == 5 {
        println!("condition was true and number is {}", number);
    }
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_26_if_let v0.1.0 (listings/ch02-common-programming-concepts/no_listing_31_if_let/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_26_if_let
condition was true and number is 5
Run completed successfully, returning []

```

The `number` variable will be bound to a value based on the outcome of the `if` expression, which will be 5 here.

Itâ€™s often useful to execute a block of code more than once. For this task, Cairo provides a simple loop syntax, which will run through the code inside the loop body to the end and then start immediately back at the beginning. To experiment with loops, letâ€™s create a new project called _loops_.

Cairo has three kinds of loops: `loop`, `while`, and `for`. Letâ€™s try each one.

Kata kunci `loop` memberitahu Cairo untuk menjalankan suatu blok kode berulang kali selamanya atau sampai Anda secara eksplisit memberi tahu untuk berhenti.

Sebagai contoh, ubah file _src/lib.cairo_ di direktori _loops_ Anda sehingga terlihat seperti ini:

```cairo hljs

fn main() {
    loop {
        println!("again!");
    }
}

```

When we run this program, weâ€™ll see `again!` printed over and over continuously until either the program runs out of gas or we stop the program manually. Most terminals support the keyboard shortcut ctrl-c to interrupt a program that is stuck in a continual loop. Give it a try:

```shell hljs

$ scarb cairo-run --available-gas=20000000
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished release target(s) in 0 seconds
     Running loops
again!
again!
again!
^Cagain!

```

The symbol `^C` represents where you pressed ctrl-c. You may or may not see the word `again!` printed after the ^C, depending on where the code was in the loop when it received the interrupt signal.

> Note: Cairo prevents us from running program with infinite loops by including a gas meter. The gas meter is a mechanism that limits the amount of computation that can be done in a program. By setting a value to the `--available-gas` flag, we can set the maximum amount of gas available to the program. Gas is a unit of measurement that expresses the computation cost of an instruction. When the gas meter runs out, the program will stop. In the previous case, we set the gas limit high enough for the program to run for quite some time.

> It is particularly important in the context of smart contracts deployed on Starknet, as it prevents from running infinite loops on the network. If you're writing a program that needs to run a loop, you will need to execute it with the `--available-gas` flag set to a value that is large enough to run the program.

Now, try running the same program again, but this time with the `--available-gas` flag set to `200000` instead of `2000000000000`. You will see the program only prints `again!` 3 times before it stops, as it ran out of gas to keep executing the loop.

Fortunately, Cairo also provides a way to break out of a loop using code. You can place the `break` keyword within the loop to tell the program when to stop executing the loop.

```cairo hljs

fn main() {
    let mut i: usize = 0;
    loop {
        if i > 10 {
            break;
        }
        println!("i = {}", i);
        i += 1;
    }
}

```

The `continue` keyword tells the program to go to the next iteration of the loop and to skip the rest of the code in this iteration. Let's add a `continue` statement to our loop to skip the `println!` statement when `i` is equal to `5`.

```cairo hljs

fn main() {
    let mut i: usize = 0;
    loop {
        if i > 10 {
            break;
        }
        if i == 5 {
            i += 1;
            continue;
        }
        println!("i = {}", i);
        i += 1;
    }
}

```

Menjalankan program ini tidak akan mencetak nilai dari `i` ketika nilainya sama dengan `5`.

Salah satu penggunaan dari `loop` adalah untuk mencoba operasi yang mungkin gagal, seperti memeriksa apakah suatu operasi berhasil. Anda mungkin juga perlu meneruskan hasil dari operasi tersebut keluar dari perulangan ke sisa kode Anda. Untuk melakukannya, Anda dapat menambahkan nilai yang ingin Anda kembalikan setelah ekspresi `break` yang Anda gunakan untuk menghentikan perulangan; nilai tersebut akan dikembalikan keluar dari perulangan sehingga Anda dapat menggunakannya, seperti yang ditunjukkan di sini:

```cairo hljs

fn main() {
    let mut counter = 0;

    let result = loop {
        if counter == 10 {
            break counter * 2;
        }
        counter += 1;
    };

    println!("The result is {}", result);
}

```

Sebelum perulangan, kita mendeklarasikan variabel bernama `counter` dan menginisialisasinya dengan `0`. Kemudian kita mendeklarasikan variabel bernama `result` untuk menyimpan nilai yang dikembalikan dari perulangan. Pada setiap iterasi perulangan, kita memeriksa apakah `counter` sama dengan `10`, dan kemudian menambahkan `1` ke variabel `counter`. Ketika kondisi terpenuhi, kita menggunakan kata kunci `break` dengan nilai `counter * 2`. Setelah perulangan, kita menggunakan titik koma untuk mengakhiri pernyataan yang memberikan nilai ke `result`. Akhirnya, kita mencetak nilai dalam `result`, yang dalam hal ini adalah `20`.

A program will often need to evaluate a condition within a loop. While the condition is `true`, the loop runs. When the condition ceases to be `true`, the program calls `break`, stopping the loop. Itâ€™s possible to implement behavior like this using a combination of `loop`, `if`, `else`, and `break`; you could try that now in a program, if youâ€™d like. However, this pattern is so common that Cairo has a built-in language construct for it, called a `while` loop.

In Listing 2-2, we use `while` to loop the program three times, counting down each time after printing the value of `number`, and then, after the loop, print a message and exit.

```cairo hljs

fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    };

    println!("LIFTOFF!!!");
}

```

Listing 2-2: Using a `while` loop to run code while a condition holds `true`.

This construct eliminates a lot of nesting that would be necessary if you used `loop`, `if`, `else`, and `break`, and itâ€™s clearer. While a condition evaluates to `true`, the code runs; otherwise, it exits the loop.

You can also use the while construct to loop over the elements of a collection, such as an array. For example, the loop in Listing 2-3 prints each element in the array `a`.

```cairo hljs

fn main() {
    let a = [10, 20, 30, 40, 50].span();
    let mut index = 0;

    while index < 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}

```

Listing 2-3: Looping through each element of a collection using a `while` loop

Here, the code counts up through the elements in the array. It starts at index `0`, and then loops until it reaches the final index in the array (that is, when `index < 5` is no longer `true`). Running this code will print every element in the array:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_45_iter_loop_while v0.1.0 (listings/ch02-common-programming-concepts/no_listing_45_iter_loop_while/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_45_iter_loop_while
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
Run completed successfully, returning []

```

All five array values appear in the terminal, as expected. Even though `index` will reach a value of `5` at some point, the loop stops executing before trying to fetch a sixth value from the array.

However, this approach is error prone; we could cause the program to panic if the index value or test condition is incorrect. For example, if you changed the definition of the `a` array to have four elements but forgot to update the condition to `while index < 4`, the code would panic. Itâ€™s also slow, because the compiler adds runtime code to perform the conditional check of whether the index is within the bounds of the array on every iteration through the loop.

As a more concise alternative, you can use a `for` loop and execute some code for each item in a collection. A `for` loop looks like the code in Listing 2-4.

```cairo hljs

fn main() {
    let a = [10, 20, 30, 40, 50].span();

    for element in a {
        println!("the value is: {element}");
    }
}

```

Listing 2-4: Looping through each element of a collection using a `for` loop

When we run this code, weâ€™ll see the same output as in Listing 2-3. More importantly, weâ€™ve now increased the safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.

Using the `for` loop, you wouldnâ€™t need to remember to change any other code if you changed the number of values in the array, as you would with the method used in Listing 2-3.

The safety and conciseness of `for` loops make them the most commonly used loop construct in Cairo. Even in situations in which you want to run some code a certain number of times, as in the countdown example that used a while loop in Listing 2-2. Another way to run code a certain number of times would be to use a `Range`, provided by the core library, which generates all numbers in sequence starting from one number and ending before another number.

Hereâ€™s how you can use a `Range` to count from 1 to 3:

```cairo hljs

fn main() {
    for number in 1..4_u8 {
        println!("{number}!");
    };
    println!("Go!!!");
}

```

This code is a bit nicer, isnâ€™t it?

Loops and recursive functions are two common ways to repeat a block of code multiple times. The `loop` keyword is used to create an infinite loop that can be broken by using the `break` keyword.

```cairo hljs

fn main() -> felt252 {
    let mut x: felt252 = 0;
    loop {
        if x == 2 {
            break;
        } else {
            x += 1;
        }
    };
    x
}

```

Loops can be transformed into recursive functions by calling the function within itself. Here is an example of a recursive function that mimics the behavior of the `loop` example above.

```cairo hljs

fn main() -> felt252 {
    recursive_function(0)
}

fn recursive_function(mut x: felt252) -> felt252 {
    if x == 2 {
        x
    } else {
        recursive_function(x + 1)
    }
}

```

In both cases, the code block will run indefinitely until the condition `x == 2` is met, at which point the value of x will be displayed.

In Cairo, loops and recursions are not only conceptually equivalent: they are also compiled down to similar low-level representations. To understand this, we can compile both examples to Sierra, and analyze the Sierra Code generated by the Cairo compiler for both examples. Add the following in your `Scarb.toml` file:

```toml hljs ini

[lib]
sierra-text = true

```

Then, run `scarb build` to compile both examples. You will find the Sierra code generated by for both examples is extremely similar, as the loop is compiled to a recursive function in the Sierra statements.

> Note: For our example, our findings came from understanding the **statements** section in Sierra that shows the execution traces of the two programs. If you are curious to learn more about Sierra, check out [Exploring Sierra](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5).

Start

Anda berhasil! Ini adalah bab yang cukup besar: Anda telah mempelajari tentang variabel, tipe data, fungsi, komentar, ekspresi `if`, dan perulangan! Untuk berlatih dengan konsep-konsep yang dibahas dalam bab ini, cobalah membuat program untuk melakukan hal-hal berikut:

- Menghasilkan bilangan Fibonacci ke- _n_.
- Menghitung faktorial dari suatu bilangan _n_.

Selanjutnya, kita akan meninjau jenis-jenis koleksi umum dalam Cairo pada bab berikutnya.

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1341483736.1738497979&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=867537662)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch103-02-03-testing-components.md "Suggest an edit")

Testing components is a bit different than testing contracts.
Contracts need to be tested against a specific state, which can be achieved by either deploying the contract in a test, or by simply getting the `ContractState` object and modifying it in the context of your tests.

Components are a generic construct, meant to be integrated in contracts, that can't be deployed on their own and don't have a `ContractState` object that we could use. So how do we test them?

Let's consider that we want to test a very simple component called "Counter", that will allow each contract to have a counter that can be incremented. The component is defined in Listing 17-2:

```cairo noplayground hljs

#[starknet::component]
pub mod CounterComponent {
    use core::starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    #[storage]
    pub struct Storage {
        value: u32,
    }

    #[embeddable_as(CounterImpl)]
    impl Counter<
        TContractState, +HasComponent<TContractState>,
    > of super::ICounter<ComponentState<TContractState>> {
        fn get_counter(self: @ComponentState<TContractState>) -> u32 {
            self.value.read()
        }

        fn increment(ref self: ComponentState<TContractState>) {
            self.value.write(self.value.read() + 1);
        }
    }
}

```

Listing 17-2: A simple Counter component

The easiest way to test a component is to integrate it within a mock contract. This mock contract is only used for testing purposes, and only integrates the component you want to test. This allows you to test the component in the context of a contract, and to use a Dispatcher to call the component's entry points.

We can define such a mock contract as follows:

```cairo noplayground hljs

#[starknet::contract]
mod MockContract {
    use super::counter::CounterComponent;

    component!(path: CounterComponent, storage: counter, event: CounterEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        counter: CounterComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CounterEvent: CounterComponent::Event,
    }

    #[abi(embed_v0)]
    impl CounterImpl = CounterComponent::CounterImpl<ContractState>;
}

```

This contract is entirely dedicated to testing the `Counter` component. It embeds the component with the `component!` macro, exposes the component's entry points by annotating the impl aliases with `#[abi(embed_v0)]`.

We also need to define an interface that will be required to interact externally with this mock contract.

```cairo noplayground hljs

#[starknet::interface]
pub trait ICounter<TContractState> {
    fn get_counter(self: @TContractState) -> u32;
    fn increment(ref self: TContractState);
}

```

We can now write tests for the component by deploying this mock contract and calling its entry points, as we would with a typical contract.

```cairo noplayground hljs

use super::MockContract;
use super::counter::{ICounterDispatcher, ICounterDispatcherTrait};
use core::starknet::syscalls::deploy_syscall;
use core::starknet::SyscallResultTrait;

fn setup_counter() -> ICounterDispatcher {
    let (address, _) = deploy_syscall(
        MockContract::TEST_CLASS_HASH.try_into().unwrap(), 0, array![].span(), false,
    )
        .unwrap_syscall();
    ICounterDispatcher { contract_address: address }
}

#[test]
fn test_constructor() {
    let counter = setup_counter();
    assert_eq!(counter.get_counter(), 0);
}

#[test]
fn test_increment() {
    let counter = setup_counter();
    counter.increment();
    assert_eq!(counter.get_counter(), 1);
}

```

In [Components under the hood](https://book.cairo-lang.org/ch103-02-01-under-the-hood.html), we saw that components leveraged genericity to define storage and logic that could be embedded in multiple contracts. If a contract embeds a component, a `HasComponent` trait is created in this contract, and the component methods are made available.

This informs us that if we can provide a concrete `TContractState` that implements the `HasComponent` trait to the `ComponentState` struct, should be able to directly invoke the methods of the component using this concrete `ComponentState` object, without having to deploy a mock.

Let's see how we can do that by using type aliases. We still need to define a mock contract - let's use the same as above - but this time, we won't need to deploy it.

First, we need to define a concrete implementation of the generic `ComponentState` type using a type alias. We will use the `MockContract::ContractState` type to do so.

```cairo noplayground hljs hide-boring

use super::counter::{CounterComponent};
use super::MockContract;
use CounterComponent::{CounterImpl};

type TestingState = CounterComponent::ComponentState<MockContract::ContractState>;

// You can derive even `Default` on this type alias
impl TestingStateDefault of Default<TestingState> {
    fn default() -> TestingState {
        CounterComponent::component_state_for_testing()
    }
}

#[test]
fn test_increment() {
    let mut counter: TestingState = Default::default();

    counter.increment();
    counter.increment();

    assert_eq!(counter.get_counter(), 2);
}

```

We defined the `TestingState` type as an alias of the `CounterComponent::ComponentState<MockContract::ContractState>` type. By passing the `MockContract::ContractState` type as a concrete type for `ComponentState`, we aliased a concrete implementation of the `ComponentState` struct to `TestingState`.

Because `MockContract` embeds `CounterComponent`, the methods of `CounterComponent` defined in the `CounterImpl` block can now be used on a `TestingState` object.

Now that we have made these methods available, we need to instantiate an object of type `TestingState`, that we will use to test the component. We can do so by calling the `component_state_for_testing` function, which automatically infers that it should return an object of type `TestingState`.

We can even implement this as part of the `Default` trait, which allows us to return an empty `TestingState` with the `Default::default()` syntax.

Let's summarize what we've done so far:

- We defined a mock contract that embeds the component we want to test.
- We defined a concrete implementation of `ComponentState<TContractState>` using a type alias with `MockContract::ContractState`, that we named `TestingState`.
- We defined a function that uses `component_state_for_testing` to return a `TestingState` object.

We can now write tests for the component by calling its functions directly, without having to deploy a mock contract. This approach is more lightweight than the previous one, and it allows testing internal functions of the component that are not exposed to the outside world trivially.

```cairo noplayground hljs hide-boring

use super::counter::{CounterComponent};
use super::MockContract;
use CounterComponent::{CounterImpl};

type TestingState = CounterComponent::ComponentState<MockContract::ContractState>;

// You can derive even `Default` on this type alias
impl TestingStateDefault of Default<TestingState> {
    fn default() -> TestingState {
        CounterComponent::component_state_for_testing()
    }
}

#[test]
fn test_increment() {
    let mut counter: TestingState = Default::default();

    counter.increment();
    counter.increment();

    assert_eq!(counter.get_counter(), 2);
}

```

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1137017110.1738497980&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015665~102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1989543850)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch07-01-packages-and-crates.md "Suggest an edit")

A crate is a subset of a package that is used in the actual Cairo compilation. This includes:

- The package source code, identified by the package name and the crate root, which is the main entry point of the package.
- A subset of the package metadata that identifies crate-level settings of the Cairo compiler, for example, the `edition` field in the _Scarb.toml_ file.

Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as will be discussed in the subsequent sections.

The crate root is the _lib.cairo_ source file that the Cairo compiler starts from and makes up the root module of your crate. Weâ€™ll explain modules in depth in the ["Defining Modules to Control Scope"](https://book.cairo-lang.org/ch07-02-defining-modules-to-control-scope.html) chapter.

A Cairo package is a directory (or equivalent) containing:

- A _Scarb.toml_ manifest file with a `[package]` section.
- Associated source code.

This definition implies that a package might contain other packages, with a corresponding _Scarb.toml_ file for each package.

You can create a new Cairo package using the Scarb command-line tool. To create a new package, run the following command:

```bash hljs

scarb new my_package

```

This command will generate a new package directory named _my\_package_ with the following structure:

```hljs

my_package/
â”œâ”€â”€ Scarb.toml
â””â”€â”€ src
    â””â”€â”€ lib.cairo

```

- _src/_ is the main directory where all the Cairo source files for the package will be stored.
- _lib.cairo_ is the default root module of the crate, which is also the main entry point of the package.
- _Scarb.toml_ is the package manifest file, which contains metadata and configuration options for the package, such as dependencies, package name, version, and authors. You can find documentation about it on the [Scarb reference](https://docs.swmansion.com/scarb/docs/reference/manifest.html).

```toml hljs ini

[package]
name = "my_package"
version = "0.1.0"
edition = "2024_07"

[dependencies]
# foo = { path = "vendor/foo" }

```

As you develop your package, you may want to organize your code into multiple Cairo source files. You can do this by creating additional _.cairo_ files within the _src_ directory or its subdirectories.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1914305878.1738497981&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=196036296)

ðŸ’¬

DisconnectedChatÃ—

SendProcessing math: 100%

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=941052737.1738497981&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102525910~102528644~102539968~102546754&z=1364438902)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-02-data-types.md "Suggest an edit")

Cada valor en Cairo tiene un cierto _tipo de dato_, lo que le dice a Cairo quÃ© tipo de datos se estÃ¡n especificando para que sepa cÃ³mo trabajar con esos datos. Esta secciÃ³n cubre dos subconjuntos de tipos de datos: escalares y compuestos.

Ten en cuenta que Cairo es un lenguaje de _tipado estÃ¡tico_, lo que significa que debe conocer los tipos de todas las variables en tiempo de compilaciÃ³n. El compilador suele inferir el tipo deseado en funciÃ³n del valor y su uso. En casos en que pueden ser posibles varios tipos, podemos utilizar un mÃ©todo de conversiÃ³n donde especificamos el tipo de salida deseado.

```cairo hljs

fn main() {
    let x: felt252 = 3;
    let y: u32 = x.try_into().unwrap();
}

```

VerÃ¡s diferentes anotaciones de tipo para otros tipos de datos.

Un tipo _scalar_ representa un Ãºnico valor. Cairo tiene tres tipos escalares primarios:felts, integers(Enteros) y booleans. Puede que reconozca de otros lenguajes de programaciÃ³n. Veamos cÃ³mo funcionan en Cairo.

In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, represented by the keyword `felt252`. In the context of Cairo, when we say â€œa field elementâ€ we mean an integer in the range 0â‰¤x<P, where P is a very large prime number currently equal to 2251+17â‹…2192+1. When adding, subtracting, or multiplying, if the result falls outside the specified range of the prime number, an overflow (or underflow) occurs, and an appropriate multiple of P is added or subtracted to bring the result back within the range (i.e., the result is computed modP ).

The most important difference between integers and field elements is division: Division of field elements (and therefore division in Cairo) is unlike regular CPUs division, where integer division xy is defined as âŒŠxyâŒ‹ where the integer part of the quotient is returned (so you get 73=2) and it may or may not satisfy the equation xyâ‹…y==x, depending on the divisibility of `x` by `y`.

In Cairo, the result of xy is defined to always satisfy the equation xyâ‹…y==x. If y divides x as integers, you will get the expected result in Cairo (for example 62 will indeed result in `3`). But when y does not divide x, you may get a surprising result: for example, since 2â‹…P+12=P+1â‰¡1modP, the value of 12 in Cairo is P+12 (and not 0 or 0.5), as it satisfies the above equation.

The felt252 type is a fundamental type that serves as the basis for creating all types in the core library. However, it is highly recommended for programmers to use the integer types instead of the `felt252` type whenever possible, as the `integer` types come with added security features that provide extra protection against potential vulnerabilities in the code, such as overflow and underflow checks. By using these integer types, programmers can ensure that their programs are more secure and less susceptible to attacks or other security threats. An `integer` is a number without a fractional component. This type declaration indicates the number of bits the programmer can use to store the integer. Table 3-1 shows the built-in integer types in Cairo. We can use any of these variants to declare the type of an integer value.

| Length | Unsigned |
| --- | --- |
| 8-bit | `u8` |
| 16-bit | `u16` |
| 32-bit | `u32` |
| 64-bit | `u64` |
| 128-bit | `u128` |
| 256-bit | `u256` |
| 32-bit | `usize` |

Table 3-1: Integer Types in Cairo.

Cada variante tiene un tamaÃ±o explÃ­cito. Tenga en cuenta que por ahora, el tipo `usize` es sÃ³lo un alias para `u32`; sin embargo, podrÃ­a ser Ãºtil cuando en el futuro Cairo pueda ser compilado a MLIR.Como las variables son sin signo, no pueden contener un nÃºmero negativo. Este cÃ³digo harÃ¡ que el programa genere un error:

```cairo hljs

fn sub_u8s(x: u8, y: u8) -> u8 {
    x - y
}

fn main() {
    sub_u8s(1, 3);
}

```

All integer types previously mentioned fit into a `felt252`, except for `u256` which needs 4 more bits to be stored. Under the hood, `u256` is basically a struct with 2 fields: `u256 {low: u128, high: u128}`.

Cairo also provides support for signed integers, starting with the prefix `i`. These integers can represent both positive and negative values, with sizes ranging from `i8` to `i128`. Each signed variant can store numbers from âˆ’(2nâˆ’1) to 2nâˆ’1âˆ’1 inclusive, where `n` is the number of bits that variant uses. So an i8 can store numbers from âˆ’(27) to 27âˆ’1, which equals `-128` to `127`.

You can write integer literals in any of the forms shown in Table 3-2. Note that number literals that can be multiple numeric types allow a type suffix, such as `57_u8`, to designate the type. It is also possible to use a visual separator `_` for number literals, in order to improve code readability.

| Numeric literals | Example |
| --- | --- |
| Decimal | `98222` |
| Hex | `0xff` |
| Octal | `0o04321` |
| Binary | `0b01` |

Table 3-2: Integer Literals in Cairo.

Entonces, Â¿cÃ³mo saber quÃ© tipo de entero utilizar? Intenta estimar el valor mÃ¡ximo que puede tener tu int y elige el tamaÃ±o adecuado."La principal situaciÃ³n en la que usarÃ­as `usize` es al indexar algÃºn tipo de colecciÃ³n.

Cairo soporta las operaciones matemÃ¡ticas bÃ¡sicas que esperarÃ­as para todos los tipos de integer: suma, resta, multiplicaciÃ³n y resto (u256 no soporta divisiÃ³n y resto todavÃ­a). Entero trunca hacia cero al entero mÃ¡s cercano. El siguiente cÃ³digo muestra cÃ³mo utilizar cada operaciÃ³n numÃ©rica en una sentencia `let`:

```cairo hljs

fn main() {
    // addition
    let sum = 5_u128 + 10_u128;

    // subtraction
    let difference = 95_u128 - 4_u128;

    // multiplication
    let product = 4_u128 * 30_u128;

    // division
    let quotient = 56_u128 / 32_u128; //result is 1
    let quotient = 64_u128 / 32_u128; //result is 2

    // remainder
    let remainder = 43_u128 % 5_u128; // result is 3
}

```

Cada expresiÃ³n de estas sentencias utiliza un operador matemÃ¡tico y se evalÃºa a un Ãºnico valor, que se asigna a una variable.

[Appendix B](https://book.cairo-lang.org/es/appendix-02-operators-and-symbols.html#operators) contains a list of all operators that Cairo provides.

As in most other programming languages, a Boolean type in Cairo has two possible values: `true` and `false`. Booleans are one `felt252` in size. The Boolean type in Cairo is specified using `bool`. For example:

```cairo hljs

fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}

```

When declaring a `bool` variable, it is mandatory to use either `true` or `false` literals as value. Hence, it is not allowed to use integer literals (i.e. `0` instead of false) for `bool` declarations.

The main way to use Boolean values is through conditionals, such as an `if` expression. Weâ€™ll cover how `if` expressions work in Cairo in the ["Control Flow"](https://book.cairo-lang.org/es/ch02-05-control-flow.html) section.

Cairo doesn't have a native type for strings but provides two ways to handle them: short strings using simple quotes and ByteArray using double quotes.

A short string is an ASCII string where each character is encoded on one byte (see the [ASCII table](https://www.asciitable.com/)). For example:

- `'a'` is equivalent to `0x61`
- `'b'` is equivalent to `0x62`
- `'c'` is equivalent to `0x63`
- `0x616263` is equivalent to `'abc'`.

Cairo uses the `felt252` for short strings. As the `felt252` is on 251 bits, a short string is limited to 31 characters (31 \* 8 = 248 bits, which is the maximum multiple of 8 that fits in 251 bits).

You can choose to represent your short string with an hexadecimal value like `0x616263` or by directly writing the string using simple quotes like `'abc'`, which is more convenient.

Here are some examples of declaring short strings in Cairo:

```cairo hljs hide-boring

fn main() {
    let my_first_char = 'C';
    let my_first_char_in_hex = 0x43;

    let my_first_string = 'Hello world';
    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;

    let long_string: ByteArray = "this is a string which has more than 31 characters";
}

```

Cairo's Core Library provides a `ByteArray` type for handling strings and byte sequences longer than short strings. This type is particularly useful for longer strings or when you need to perform operations on the string data.

The `ByteArray` in Cairo is implemented as a combination of two parts:

1. An array of `bytes31` words, where each word contains 31 bytes of data.
2. A pending `felt252` word that acts as a buffer for bytes that haven't yet filled a complete `bytes31` word.

This design enables efficient handling of byte sequences while aligning with Cairo's memory model and basic types. Developers interact with `ByteArray` through its provided methods and operators, abstracting away the internal implementation details.

Unlike short strings, `ByteArray` strings can contain more than 31 characters and are written using double quotes:

```cairo hljs hide-boring

fn main() {
    let my_first_char = 'C';
    let my_first_char_in_hex = 0x43;

    let my_first_string = 'Hello world';
    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;

    let long_string: ByteArray = "this is a string which has more than 31 characters";
}

```

Una _tuple_ es una forma general de agrupar un nÃºmero de valores con una variedad de tipos en un tipo compuesto. Las tuplas tienen una longitud fija: una vez declaradas, no pueden aumentar ni disminuir de tamaÃ±o.

Se crea una tupla escribiendo una lista de valores separados por comas entre parÃ©ntesis. Cada posiciÃ³n de la tupla tiene un tipo, y los tipos de los distintos valores de la tupla no tienen por quÃ© ser iguales. Hemos aÃ±adido anotaciones opcionales de tipo en este ejemplo:

```cairo hljs

fn main() {
    let tup: (u32, u64, bool) = (10, 20, true);
}

```

La variable `tup` se vincula a toda la tupla porque una tupla se considera un Ãºnico elemento compuesto. Para obtener los valores individuales de una tupla, podemos utilizar la concordancia de patrones para desestructurar un valor de tupla, asÃ­:

```cairo hljs

fn main() {
    let tup = (500, 6, true);

    let (x, y, z) = tup;

    if y == 6 {
        println!("y is 6!");
    }
}

```

This program first creates a tuple and binds it to the variable `tup`. It then uses a pattern with `let` to take `tup` and turn it into three separate variables, `x`, `y`, and `z`. This is called _destructuring_ because it breaks the single tuple into three parts. Finally, the program prints `y is 6!` as the value of `y` is `6`.

We can also declare the tuple with value and types, and destructure it at the same time. For example:

```cairo hljs

fn main() {
    let (x, y): (felt252, felt252) = (2, 3);
}

```

Un _tipo unidad_ es un tipo que sÃ³lo tiene un valor `()`.Se representa mediante una tupla sin elementos. Su tamaÃ±o es siempre cero y se garantiza que no existirÃ¡ en el cÃ³digo compilado.

You might be wondering why you would even need a unit type? In Cairo, everything is an expression, and an expression that returns nothing actually returns `()` implicitly.

Another way to have a collection of multiple values is with a _fixed size array_. Unlike a tuple, every element of a fixed size array must have the same type.

We write the values in a fixed-size array as a comma-separated list inside square brackets. The arrayâ€™s type is written using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:

```cairo hljs

fn main() {
    let arr1: [u64; 5] = [1, 2, 3, 4, 5];
}

```

In the type annotation `[u64; 5]`, `u64` specifies the type of each element, while `5` after the semicolon defines the array's length. This syntax ensures that the array always contains exactly 5 elements of type `u64`.

Fixed size arrays are useful when you want to hardcode a potentially long sequence of data directly in your program. This type of array must not be confused with the [`Array<T>` type](https://book.cairo-lang.org/es/ch03-01-arrays.html), which is a similar collection type provided by the core library that _is_ allowed to grow in size. If you're unsure whether to use a fixed size array or the `Array<T>` type, chances are that you are looking for the `Array<T>` type.

Because their size is known at compile-time, fixed-size arrays don't require runtime memory management, which makes them more efficient than dynamically-sized arrays. Overall, they're more useful when you know the number of elements will not need to change. For example, they can be used to efficiently store lookup tables that won't change during runtime. If you were using the names of the month in a program, you would probably use a fixed size array rather than an `Array<T>` because you know it will always contain 12 elements:

```cairo hljs

    let months = [\
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',\
        'October', 'November', 'December',\
    ];

```

You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:

```cairo hljs

    let a = [3; 5];

```

The array named `a` will contain `5` elements that will all be set to the value `3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a more concise way.

As a fixed-size array is a data structure known at compile time, it's content is represented as a sequence of values in the program bytecode. Accessing an element of that array will simply read that value from the program bytecode efficiently.

We have two different ways of accessing fixed size array elements:

- Deconstructing the array into multiple variables, as we did with tuples.

```cairo hljs

fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by deconstruction
    let [a, b, c, _, _] = my_arr;
    println!("c: {}", c); // c: 3
}

```

- Converting the array to a [Span](https://book.cairo-lang.org/es/ch03-01-arrays.html#Span), that supports indexing. This operation is _free_ and doesn't incur any runtime cost.

```cairo hljs

fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by index
    let my_span = my_arr.span();
    println!("my_span[2]: {}", my_span[2]); // my_span[2]: 3
}

```

Note that if we plan to repeatedly access the array, then it makes sense to call `.span()` only once and keep it available throughout the accesses.

Cairo addresses conversion between types by using the `try_into` and `into` methods provided by the `TryInto` and `Into` traits from the core library. There are numerous implementations of these traits within the standard library for conversion between types, and they can be implemented for [custom types as well](https://book.cairo-lang.org/es/ch05-02-an-example-program-using-structs.html#conversions-of-custom-types).

The `Into` trait allows for a type to define how to convert itself into another type. It can be used for type conversion when success is guaranteed, such as when the source type is smaller than the destination type.

To perform the conversion, call `var.into()` on the source value to convert it to another type. The new variable's type must be explicitly defined, as demonstrated in the example below.

```cairo hljs

fn main() {
    let my_u8: u8 = 10;
    let my_u16: u16 = my_u8.into();
    let my_u32: u32 = my_u16.into();
    let my_u64: u64 = my_u32.into();
    let my_u128: u128 = my_u64.into();

    let my_felt252 = 10;
    // As a felt252 is smaller than a u256, we can use the into() method
    let my_u256: u256 = my_felt252.into();
    let my_other_felt252: felt252 = my_u8.into();
    let my_third_felt252: felt252 = my_u16.into();
}

```

Similar to `Into`, `TryInto` is a generic trait for converting between types. Unlike `Into`, the `TryInto` trait is used for fallible conversions, and as such, returns [Option<T>](https://book.cairo-lang.org/es/ch06-01-enums.html#the-option-enum-and-its-advantages). An example of a fallible conversion is when the target type might not fit the source value.

Also similar to `Into` is the process to perform the conversion; just call `var.try_into()` on the source value to convert it to another type. The new variable's type also must be explicitly defined, as demonstrated in the example below.

```cairo hljs

fn main() {
    let my_u256: u256 = 10;

    // Since a u256 might not fit in a felt252, we need to unwrap the Option<T> type
    let my_felt252: felt252 = my_u256.try_into().unwrap();
    let my_u128: u128 = my_felt252.try_into().unwrap();
    let my_u64: u64 = my_u128.try_into().unwrap();
    let my_u32: u32 = my_u64.try_into().unwrap();
    let my_u16: u16 = my_u32.try_into().unwrap();
    let my_u8: u8 = my_u16.try_into().unwrap();

    let my_large_u16: u16 = 2048;
    let my_large_u8: u8 = my_large_u16.try_into().unwrap(); // panics with 'Option::unwrap failed.'
}

```

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-06-useful-development-tools.md "Suggest an edit")

In this appendix, we talk about some useful development tools that the Cairo
project provides. Weâ€™ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.

Scarb projects can be formatted using the `scarb fmt` command.
If you're using the Cairo binaries directly, you can run `cairo-format` instead.
Many collaborative projects use `scarb fmt` to prevent arguments about which
style to use when writing Cairo: everyone formats their code using the tool.

To format any Cairo project, enter the following inside the project directory:

```bash hljs

scarb fmt

```

For things you do not want `scarb fmt` to mangle, use `#[cairofmt::skip]`:

```cairo noplayground hljs

#[cairofmt::skip]
let table: Array<ByteArray> = array![\
    "oxo",\
    "xox",\
    "oxo",\
];

```

To help IDE integration, the Cairo community recommends using the
[`cairo-language-server`](https://github.com/starkware-libs/cairo/tree/main/crates/cairo-lang-language-server). This tool is a set of
compiler-centric utilities that speaks the [Language Server Protocol](http://langserver.org/), which is a specification for IDEs and programming languages to
communicate with each other. Different clients can use `cairo-language-server`, such as
[the Cairo extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1).

Visit the `vscode-cairo` [page](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1)
to install it on VSCode. You will get abilities such as autocompletion, jump to
definition, and inline errors.

> Note: If you have Scarb installed, it should work out of the box with the Cairo VSCode extension, without a manual installation of the language server.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1042369332.1738497982&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=2025563829)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-08-printing.md "Suggest an edit")

When writing a program, it is quite common to print some data to the console, either for the normal process of the program or for debugging purpose. In this chapter, we describe the options you have to print simple and complex data types.

Cairo provides two macros to print standard data types:

- `println!` which prints on a new line
- `print!` with inline printing

Both take a `ByteArray` string as first parameter (see [Data Types](https://book.cairo-lang.org/ch02-02-data-types.html#byte-array-strings)), which can be a simple string to print a message or a string with placeholders to format the way values are printed.

There are two ways to use these placeholders and both can be mixed:

- empty curly brackets `{}` are replaced by values given as parameters to the `print!` macro, in the same order.
- curly brackets with variable names are directly replaced by the variable value.

Here are some examples:

```cairo hljs

fn main() {
    let a = 10;
    let b = 20;
    let c = 30;

    println!("Hello world!");
    println!("{} {} {}", a, b, c); // 10 20 30
    println!("{c} {a} {}", b); // 30 10 20
}

```

> `print!` and `println!` macros use the `Display` trait under the hood, and are therefore used to print the value of types that implement it. This is the case for basic data types, but not for more complex ones. If you try to print complex data type values with these macros, e.g. for debugging purposes, you will get an error. In that case, you can either [manually implement](https://book.cairo-lang.org/ch12-08-printing.html#printing-custom-data-types) the `Display` trait for your type or use the `Debug` trait (see [below](https://book.cairo-lang.org/ch12-08-printing.html#print-debug-traces)).

Cairo also provides a useful macro to handle string formatting: `format!`. This macro works like `println!`, but instead of printing the output to the screen, it returns a `ByteArray` with the contents. In the following example, we perform string concatenation using either the `+` operator or the
`format!` macro. The version of the code using `format!` is much easier to read, and the code generated by the `format!` macro uses snapshots, so that this call doesnâ€™t take ownership of any of its parameters.

```cairo hljs

fn main() {
    let s1: ByteArray = "tic";
    let s2: ByteArray = "tac";
    let s3: ByteArray = "toe";
    let s = s1 + "-" + s2 + "-" + s3;
    // using + operator consumes the strings, so they can't be used again!

    let s1: ByteArray = "tic";
    let s2: ByteArray = "tac";
    let s3: ByteArray = "toe";
    let s = format!("{s1}-{s2}-{s3}"); // s1, s2, s3 are not consumed by format!
    // or
    let s = format!("{}-{}-{}", s1, s2, s3);

    println!("{}", s);
}

```

As previously explained, if you try to print the value of a custom data type with `print!` or `println!` macros, you'll get an error telling you that the `Display` trait is not implemented for your custom type:

```shell hljs

error: Trait has no implementation in context: core::fmt::Display::<package_name::struct_name>

```

The `println!` macro can do many kinds of formatting, and by default, the curly brackets tell `println!` to use formatting known as `Display` \- output intended for direct end user consumption. The primitive types weâ€™ve seen so far implement `Display` by default because thereâ€™s only one way youâ€™d want to show a `1` or any other primitive type to a user. But with structs, the way `println!` should format the output is less clear because there are more display possibilities: Do we want commas or not? Do we want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Cairo doesnâ€™t try to guess what we want, and structs donâ€™t have a provided implementation of `Display` to use with `println!` and the `{}` placeholder.

Here is the `Display` trait to implement:

```cairo noplayground hljs

trait Display<T> {
    fn fmt(self: @T, ref f: Formatter) -> Result<(), Error>;
}

```

The second parameter `f` is of type `Formatter`, which is just a struct containing a `ByteArray`, representing the pending result of formatting:

```cairo noplayground hljs

#[derive(Default, Drop)]
pub struct Formatter {
    /// The pending result of formatting.
    pub buffer: ByteArray,
}

```

Knowing this, here is an example of how to implement the `Display` trait for a custom `Point` struct:

```cairo hljs

use core::fmt::{Display, Formatter, Error};

#[derive(Copy, Drop)]
struct Point {
    x: u8,
    y: u8,
}

impl PointDisplay of Display<Point> {
    fn fmt(self: @Point, ref f: Formatter) -> Result<(), Error> {
        let str: ByteArray = format!("Point ({}, {})", *self.x, *self.y);
        f.buffer.append(@str);
        Result::Ok(())
    }
}

fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{}", p); // Point: (1, 3)
}

```

Cairo also provides the `write!` and `writeln!` macros to write formatted strings in a formatter.
Here is a short example using `write!` macro to concatenate multiple strings on the same line and then print the result:

```cairo hljs

use core::fmt::Formatter;

fn main() {
    let mut formatter: Formatter = Default::default();
    let a = 10;
    let b = 20;
    write!(formatter, "hello");
    write!(formatter, "world");
    write!(formatter, " {a} {b}");

    println!("{}", formatter.buffer); // helloworld 10 20
}

```

It is also possible to implement the `Display` trait for the `Point` struct using these macros, as shown here:

```cairo hljs

use core::fmt::{Display, Formatter, Error};

#[derive(Copy, Drop)]
struct Point {
    x: u8,
    y: u8,
}

impl PointDisplay of Display<Point> {
    fn fmt(self: @Point, ref f: Formatter) -> Result<(), Error> {
        let x = *self.x;
        let y = *self.y;

        writeln!(f, "Point ({x}, {y})")
    }
}

fn main() {
    let p = Point { x: 1, y: 3 };
    println!("{}", p); // Point: (1, 3)
}

```

> Printing complex data types this way might not be ideal as it requires additional steps to use the `print!` and `println!` macros. If you need to print complex data types, especially when debugging, use the `Debug` trait described below instead.

By default, the `Display` trait prints integer values in decimal. But, as in Rust, you can use the `{:x}` notation to print them in hexadecimal.

Under the hood, Cairo implements the `LowerHex` trait for common types such as unsigned integers, `felt252` and `NonZero` but also for common Starknet types such as `ContractAddress` and `ClassHash`.

If it makes sense for you, you can also implement the `LowerHex` trait for your custom types using the same approach as for the `Display` trait (see [Printing Custom Data Types](https://book.cairo-lang.org/ch12-08-printing.html#printing-custom-data-types)).

Cairo provides the `Debug` trait, which can be derived to print the value of variables when debugging. Simply add `:?` within the curly brackets `{}` placeholders in a `print!` or `println!` macro string.

This trait is very useful and is implemented by default for basic data types. It can also be simply derived for complex data types using the `#[derive(Debug)]` attribute, as long as all types they contain implement it. This eliminates the need to manually implement extra code to print complex data types.

Note that `assert_xx!` macros used in tests require the provided values to implement the `Debug` trait, as they also print the result in case of assertion failure.

For more details about the `Debug` trait and its usage for printing values when debugging, please refer to the [Derivable Traits](https://book.cairo-lang.org/appendix-03-derivable-traits.html#debug-trait-for-printing-and-debugging) appendix.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=297835910.1738497982&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1827479494)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=4753179.1738497983&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=247459529)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-02-smart-pointers.md "Suggest an edit")

A pointer is a general concept for a variable that contains a memory address. This address refers to, or â€œpoints at,â€ some other data. While pointers are a powerful feature, they can also be a source of bugs and security vulnerabilities. For example, a pointer can reference an unassigned memory cell, which means that attempting to access the data at that address would cause the program to crash, making it unprovable. To prevent such issues, Cairo uses _Smart Pointers_.

Smart pointers are data structures that act like a pointer, but also have additional metadata and capabilities. The concept of smart pointers isnâ€™t unique to Cairo: smart pointers originated in C++ and exist in other languages like Rust as well. In the specific case of Cairo, smart pointers ensure that memory is not addressed in an unsafe way that could cause a program to be unprovable, by providing a safe way to access memory through strict type checking and ownership rules.

Though we didnâ€™t call them as such at the time, weâ€™ve already encountered a few smart pointers in this book, including `Felt252Dict<T>` and `Array<T>` in Chapter 3. Both these types count as smart pointers because they own a memory segment and allow you to manipulate it. They also have metadata and extra capabilities or guarantees. Arrays keep track of their current length to ensure that existing elements are not overwritten, and that new elements are only appended to the end.

The Cairo VM memory is composed by multiple segments that can store data, each identified by a unique index. When you create an array, you allocate a new segment in the memory to store the future elements. The array itself is just a pointer to that segment where the elements are stored.

The principal smart pointer type in Cairo is a _box_, denoted as `Box<T>`. Manually defining boxes allow you to store data in a specific memory segment of the Cairo VM called the _boxed segment_. This segment is dedicated to store all boxed values, and what remains in the execution segment is only a pointer to the boxed segment. Whenever you instantiate a new pointer variable of type `Box<T>`, you append the data of type `T` to the boxed segment.

Boxes have very little performance overhead, other than writing their inner values to the boxed segment. But they donâ€™t have many extra capabilities either. Youâ€™ll use them most often in these situations:

- When you have a type whose size canâ€™t be known at compile time and you want to use a value of that type in a context that requires an exact size
- When you have a large amount of data and you want to transfer ownership but ensure the data wonâ€™t be copied when you do so

Weâ€™ll demonstrate the first situation in the [â€œEnabling Recursive Types with Boxesâ€](https://book.cairo-lang.org/ch12-02-smart-pointers.html#enabling-recursive-types-with-nullable-boxes) section.
In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around in memory. To improve performance in this situation, we can store the large amount of data in the boxed segment using a box type. Then, only the small amount of pointer data is copied around in memory, while the data it references stays in one place on the boxed segment.

Before we discuss the boxed segment storage use cases for `Box<T>`, weâ€™ll cover the syntax and how to interact with values stored within a `Box<T>`.

Listing 12-1 shows how to use a box to store a value in the boxed segment:

```cairo hljs

fn main() {
    let b = BoxTrait::new(5_u128);
    println!("b = {}", b.unbox())
}

```

Listing 12-1: Storing a `u128` value in the boxed segment using a box

We define the variable `b` to have the value of a `Box` that points to the value `5`, which is stored in the boxed segment. This program will print `b = 5`; in this case, we can access the data in the box similar to how we would if this data was simply in the execution memory. Putting a single value in a box isnâ€™t very useful, so you wonâ€™t use boxes by themselves in this way very often. Having values like a single `u128` in the execution memory, where theyâ€™re stored by default, is more appropriate in the majority of situations. Letâ€™s look at a case where boxes allow us to define types that we wouldnâ€™t be allowed to if we didnâ€™t have boxes.

A value of recursive type can have another value of the same type as part of itself. Recursive types pose an issue because at compile time because Cairo needs to know how much space a type takes up. However, the nesting of values of recursive types could theoretically continue infinitely, so Cairo canâ€™t know how much space the value needs. Because boxes have a known size, we can enable recursive types by inserting a box in the recursive type definition.

As an example of a recursive type, letâ€™s explore the implementation of a binary tree. The binary tree type weâ€™ll define is straightforward except for the recursion; therefore, the concepts in the example weâ€™ll work with will be useful any time you get into more complex situations involving recursive types.

A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. The last element of a branch is a leaf, which is a node without children.

Listing 12-2 shows an attempt to implement a binary tree of `u32` values. Note that this code wonâ€™t compile yet because the `BinaryTree` type doesnâ€™t have a known size, which weâ€™ll demonstrate.

```cairo noplayground hljs

#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, BinaryTree, BinaryTree),
}

fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, leaf2, leaf3));
    let _root = BinaryTree::Node((5, leaf1, node));
}

```

Listing 12-2: The first attempt at implementing a binary tree of `u32` values

> Note: Weâ€™re implementing a binary tree that holds only u32 values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 8, to define a binary tree that could store values of any type.

The root node contains 5 and two child nodes. The left child is a leaf containing 1. The right child is another node containing 4, which in turn has two leaf children: one containing 2 and another containing 3. This structure forms a simple binary tree with a depth of 2.

If we try to compile the code in listing 12-2, we get the following error:

```plaintext hljs

$ scarb build
   Compiling listing_recursive_types_wrong v0.1.0 (listings/ch12-advanced-features/listing_recursive_types_wrong/Scarb.toml)
error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --> listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:6:5
    Node: (u32, BinaryTree, BinaryTree),
    ^*********************************^

error: Recursive type "listing_recursive_types_wrong::BinaryTree" has infinite size.
 --> listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:10:17
    let leaf1 = BinaryTree::Leaf(1);
                ^*****************^

error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --> listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:13:33
    let node = BinaryTree::Node((4, leaf2, leaf3));
                                ^***************^

error: could not compile `listing_recursive_types_wrong` due to previous error

```

The error shows this type â€œhas infinite size.â€ The reason is that weâ€™ve defined `BinaryTree` with a variant that is recursive: it holds another value of itself directly. As a result, Cairo canâ€™t figure out how much space it needs to store a `BinaryTree` value.

Hopefully, we can fix this error by using a `Box<T>` to store the recursive variant of `BinaryTree`. Because a `Box<T>` is a pointer, Cairo always knows how much space a `Box<T>` needs: a pointerâ€™s size doesnâ€™t change based on the amount of data itâ€™s pointing to. This means we can put a `Box<T>` inside the `Node` variant instead of another `BinaryTree` value directly. The `Box<T>` will point to the child `BinaryTree` values that will be stored in their own segment, rather than inside the `Node` variant. Conceptually, we still have a binary tree, created with binary trees holding other binary trees, but this implementation is now more like placing the items next to one another rather than inside one another.

We can change the definition of the `BinaryTree` enum in Listing 12-2 and the usage of the `BinaryTree` in Listing 12-2 to the code in Listing 12-3, which will compile:

```cairo hljs

use core::box::{BoxTrait};

mod display;
use display::DebugBinaryTree;

#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, Box<BinaryTree>, Box<BinaryTree>),
}

fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, BoxTrait::new(leaf2), BoxTrait::new(leaf3)));
    let root = BinaryTree::Node((5, BoxTrait::new(leaf1), BoxTrait::new(node)));

    println!("{:?}", root);
}

```

Listing 12-3: Defining a recursive Binary Tree using Boxes

The `Node` variant now holds a `(u32, Box<BinaryTree>, Box<BinaryTree>)`, indicating that the `Node` variant will store a `u32` value, and two `Box<BinaryTree>` values. Now, we know that the `Node` variant will need a size of `u32` plus the size of the two `Box<BinaryTree>` values. By using a box, weâ€™ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a `BinaryTree` value.

Passing pointers between functions allows you to reference data without copying the data itself. Using boxes can improve performance as it allows you to pass a pointer to some data from one function to another, without the need to copy the entire data in memory before performing the function call. Instead of having to write `n` values into memory before calling a function, only a single value is written, corresponding to the pointer to the data. If the data stored in the box is very large, the performance improvement can be significant, as you would save `n-1` memory operations before each function call.

Let's take a look at the code in Listing 12-4, which shows two ways of passing data to a function: by value and by pointer.

```cairo hljs

#[derive(Drop)]
struct Cart {
    paid: bool,
    items: u256,
    buyer: ByteArray,
}

fn pass_data(cart: Cart) {
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

fn pass_pointer(cart: Box<Cart>) {
    let cart = cart.unbox();
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

fn main() {
    let new_struct = Cart { paid: true, items: 1, buyer: "Eli" };
    pass_data(new_struct);

    let new_box = BoxTrait::new(Cart { paid: false, items: 2, buyer: "Uri" });
    pass_pointer(new_box);
}

```

Listing 12-4: Storing large amounts of data in a box for performance.

The `main` function includes 2 function calls:

- `pass_data` that takes a variable of type `Cart`.
- `pass_pointer` that takes a pointer of type `Box<Cart>`.

When passing data to a function, the entire data is copied into the last available memory cells right before the function call. Calling `pass_data` will copy all 3 fields of `Cart` to memory, while `pass_pointer` only requires the copy of the `new_box` pointer which is of size 1.

![box memory](https://book.cairo-lang.org/box_memory.png)

CairoVM Memory layout when using boxes

The illustration above demonstrates how the memory behaves in both cases. The first instance of `Cart` is stored in the execution segment, and we need to copy all its fields to memory before calling the `pass_data` function. The second instance of `Cart` is stored in the boxed segment, and the pointer to it is stored in the execution segment. When calling the `pass_pointer` function, only the pointer to the struct is copied to memory right before the function call. In both cases, however, instantiating the struct will store all its values in the execution segment: the boxed segment can only be filled with data taken from the execution segment.

`Nullable<T>` is another type of smart pointer that can either point to a value or be `null` in the absence of value. It is defined at the Sierra level. This type is mainly used in dictionaries that contain types that don't implement the `zero_default` method of the `Felt252DictValue<T>` trait (i.e., arrays and structs).

If we try to access an element that does not exist in a dictionary, the code will fail if the `zero_default` method cannot be called.

[Chapter 3](https://book.cairo-lang.org/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively) about dictionaries thoroughly explains how to store a `Span<felt252>` variable inside a dictionary using the `Nullable<T>` type. Please refer to it for further information.- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch103-05-oracle-interactions.md "Suggest an edit")

This section focuses on the concept of bringing off-chain data to the Starknet blockchain using oracles. Oracles are third-party services that serve as intermediaries, securely transmitting external data, such as asset prices, weather information, or other real-world data, to blockchains and smart contracts. It also provides practical examples and code snippets demonstrating how developers can interact with a specific oracle named Pragma on Starknet network, covering topics like querying and handling price data, and verifiable random function (VRF) to generate random numbers.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=132453149.1738497983&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=362240321)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-04-cairo-prelude.md "Suggest an edit")

The Cairo prelude is a collection of commonly used modules, functions, data
types, and traits that are automatically brought into scope of every module in a
Cairo crate without needing explicit import statements. Cairo's prelude provides
the basic building blocks developers need to start Cairo programs and writing
smart contracts.

The core library prelude is defined in the _[lib.cairo](https://github.com/starkware-libs/cairo/blob/main/corelib/src/lib.cairo)_
file of the corelib crate and contains Cairo's primitive data types, traits,
operators, and utility functions. This includes:

- Data types: integers, bools, arrays, dicts, etc.
- Traits: behaviors for arithmetic, comparison, and serialization operations
- Operators: arithmetic, logical, bitwise
- Utility functions - helpers for arrays, maps, boxing, etc.

The core library prelude delivers the fundamental programming
constructs and operations needed for basic Cairo programs, without requiring the
explicit import of elements. Since the core library prelude is automatically
imported, its contents are available for use in any Cairo crate without explicit
imports. This prevents repetition and provides a better devX. This is what
allows you to use `ArrayTrait::append()` or the `Default` trait without bringing
them explicitly into scope.

You can choose which prelude to use. For example, adding `edition = "2024_07"` in the _Scarb.toml_ configuration file will load the prelude from July 2024. Note that when you create a new project using `scarb new` command, the _Scarb.toml_ file will automatically include `edition = "2024_07"`.
Different prelude versions will expose different functions and traits, so it is important to specify the correct edition in the _Scarb.toml_ file. Generally, you want to start a new project using the latest edition, and migrate to newer editions as they are released.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1997828034.1738497984&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015666~102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565~102558063&z=1574693013)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=2073031983.1738497984&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=1129449899)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-01-custom-data-structures.md "Suggest an edit")

When you first start programming in Cairo, you'll likely want to use arrays
( `Array<T>`) to store collections of data. However, you will quickly realize
that arrays have one big limitation - the data stored in them is immutable. Once
you append a value to an array, you can't modify it.

This can be frustrating when you want to use a mutable data structure. For
example, say you're making a game where the players have a level, and they can
level up. You might try to store the level of the players in an array:

```cairo noplayground hljs

    let mut level_players = array![5, 1, 10];

```

But then you realize you can't increase the level at a specific index once it's
set. If a player dies, you cannot remove it from the array unless he happens to
be in the first position.

Fortunately, Cairo provides a handy built-in [dictionary type](https://book.cairo-lang.org/ch03-02-dictionaries.html) called `Felt252Dict<T>` that allows us to
simulate the behavior of mutable data structures. Let's first explore how to create a struct that contains, among others, a `Felt252Dict<T>`.

> Note: Several concepts used in this chapter were already presented earlier in the book. We recommend checking out the following chapters if you need to revise them:
> [Structs](https://book.cairo-lang.org/ch05-00-using-structs-to-structure-related-data.html),
> [Methods](https://book.cairo-lang.org/ch05-03-method-syntax.html),
> [Generic types](https://book.cairo-lang.org/ch08-00-generic-types-and-traits.html),
> [Traits](https://book.cairo-lang.org/ch08-02-traits-in-cairo.html).

Defining dictionaries as struct members is possible in Cairo but correctly interacting with them may not be entirely seamless. Let's try implementing a custom _user database_ that will allow us to add users and query them. We will need to define a struct to represent the new type and a trait to define its functionality:

```cairo noplayground hljs

struct UserDatabase<T> {
    users_updates: u64,
    balances: Felt252Dict<T>,
}

trait UserDatabaseTrait<T> {
    fn new() -> UserDatabase<T>;
    fn update_user<+Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T);
    fn get_balance<+Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T;
}

```

Our new type `UserDatabase<T>` represents a database of users. It is generic over the balances of the users, giving major flexibility to whoever uses our data type. Its two members are:

- `users_updates`, the number of users updates in the dictionary.
- `balances`, a mapping of each user to its balance.

The database core functionality is defined by `UserDatabaseTrait`. The following methods are defined:

- `new` for easily creating new `UserDatabase` types.
- `update_user` to update the balance of users in the database.
- `get_balance` to find user's balance in the database.

The only remaining step is to implement each of the methods in `UserDatabaseTrait`, but since we are working with [Generic types](https://book.cairo-lang.org/ch08-00-generic-types-and-traits.html) we also need to correctly establish the requirements of `T` so it can be a valid `Felt252Dict<T>` value type:

1. `T` should implement the `Copy<T>` since it's required for getting values from a `Felt252Dict<T>`.
2. All value types of a dictionary implement the `Felt252DictValue<T>`, our generic type should do as well.
3. To insert values, `Felt252DictTrait<T>` requires all value types to be droppable (implement the `Drop<T>` trait).

The implementation, with all restrictions in place, would be as follows:

```cairo noplayground hljs

impl UserDatabaseImpl<T, +Felt252DictValue<T>> of UserDatabaseTrait<T> {
    // Creates a database
    fn new() -> UserDatabase<T> {
        UserDatabase { users_updates: 0, balances: Default::default() }
    }

    // Get the user's balance
    fn get_balance<+Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T {
        self.balances.get(name)
    }

    // Add a user
    fn update_user<+Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T) {
        self.balances.insert(name, balance);
        self.users_updates += 1;
    }
}

```

Our database implementation is almost complete, except for one thing: the compiler doesn't know how to make a `UserDatabase<T>` go out of scope, since it doesn't implement the `Drop<T>` trait, nor the `Destruct<T>` trait.
Since it has a `Felt252Dict<T>` as a member, it cannot be dropped, so we are forced to implement the `Destruct<T>` trait manually (refer to the [Ownership](https://book.cairo-lang.org/ch04-01-what-is-ownership.html#the-drop-trait) chapter for more information).
Using `#[derive(Destruct)]` on top of the `UserDatabase<T>` definition won't work because of the use of [Generic types](https://book.cairo-lang.org/ch08-00-generic-types-and-traits.html) in the struct definition. We need to code the `Destruct<T>` trait implementation by ourselves:

```cairo noplayground hljs

impl UserDatabaseDestruct<T, +Drop<T>, +Felt252DictValue<T>> of Destruct<UserDatabase<T>> {
    fn destruct(self: UserDatabase<T>) nopanic {
        self.balances.squash();
    }
}

```

Implementing `Destruct<T>` for `UserDatabase` was our last step to get a fully functional database. We can now try it out:

```cairo hljs hide-boring

use core::dict::Felt252Dict;

struct UserDatabase<T> {
    users_updates: u64,
    balances: Felt252Dict<T>,
}

trait UserDatabaseTrait<T> {
    fn new() -> UserDatabase<T>;
    fn update_user<+Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T);
    fn get_balance<+Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T;
}

impl UserDatabaseImpl<T, +Felt252DictValue<T>> of UserDatabaseTrait<T> {
    // Creates a database
    fn new() -> UserDatabase<T> {
        UserDatabase { users_updates: 0, balances: Default::default() }
    }

    // Get the user's balance
    fn get_balance<+Copy<T>>(ref self: UserDatabase<T>, name: felt252) -> T {
        self.balances.get(name)
    }

    // Add a user
    fn update_user<+Drop<T>>(ref self: UserDatabase<T>, name: felt252, balance: T) {
        self.balances.insert(name, balance);
        self.users_updates += 1;
    }
}

impl UserDatabaseDestruct<T, +Drop<T>, +Felt252DictValue<T>> of Destruct<UserDatabase<T>> {
    fn destruct(self: UserDatabase<T>) nopanic {
        self.balances.squash();
    }
}

fn main() {
    let mut db = UserDatabaseTrait::<u64>::new();

    db.update_user('Alex', 100);
    db.update_user('Maria', 80);

    db.update_user('Alex', 40);
    db.update_user('Maria', 0);

    let alex_latest_balance = db.get_balance('Alex');
    let maria_latest_balance = db.get_balance('Maria');

    assert!(alex_latest_balance == 40, "Expected 40");
    assert!(maria_latest_balance == 0, "Expected 0");
}

```

First, let's think about how we want our mutable dynamic array to behave. What
operations should it support?

It should:

- Allow us to append items at the end.
- Let us access any item by index.
- Allow setting the value of an item at a specific index.
- Return the current length.

We can define this interface in Cairo like:

```cairo noplayground hljs

trait MemoryVecTrait<V, T> {
    fn new() -> V;
    fn get(ref self: V, index: usize) -> Option<T>;
    fn at(ref self: V, index: usize) -> T;
    fn push(ref self: V, value: T) -> ();
    fn set(ref self: V, index: usize, value: T);
    fn len(self: @V) -> usize;
}

```

This provides a blueprint for the implementation of our dynamic array. We named
it _MemoryVec_ as it is similar to the `Vec<T>` data structure in Rust.

> Note: The core library of Cairo already includes a `Vec<T>` data structure, strictly used as a storage type in smart contracts.
> To differentiate our data structure from the core library's one, we named our implementation _MemoryVec_.

To store our data, we'll use a `Felt252Dict<T>` which maps index numbers (felts)
to values. We'll also store a separate `len` field to track the length.

Here is what our struct looks like. We wrap the type `T` inside `Nullable`
pointer to allow using any type `T` in our data structure, as explained in the
[Dictionaries](https://book.cairo-lang.org/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively) section:

```cairo noplayground hljs hide-boring

use core::dict::Felt252Dict;
use core::nullable::NullableTrait;
use core::num::traits::WrappingAdd;

trait MemoryVecTrait<V, T> {
    fn new() -> V;
    fn get(ref self: V, index: usize) -> Option<T>;
    fn at(ref self: V, index: usize) -> T;
    fn push(ref self: V, value: T) -> ();
    fn set(ref self: V, index: usize, value: T);
    fn len(self: @V) -> usize;
}

struct MemoryVec<T> {
    data: Felt252Dict<Nullable<T>>,
    len: usize,
}

impl DestructMemoryVec<T, +Drop<T>> of Destruct<MemoryVec<T>> {
    fn destruct(self: MemoryVec<T>) nopanic {
        self.data.squash();
    }
}

impl MemoryVecImpl<T, +Drop<T>, +Copy<T>> of MemoryVecTrait<MemoryVec<T>, T> {
    fn new() -> MemoryVec<T> {
        MemoryVec { data: Default::default(), len: 0 }
    }

    fn get(ref self: MemoryVec<T>, index: usize) -> Option<T> {
        if index < self.len() {
            Option::Some(self.data.get(index.into()).deref())
        } else {
            Option::None
        }
    }

    fn at(ref self: MemoryVec<T>, index: usize) -> T {
        assert!(index < self.len(), "Index out of bounds");
        self.data.get(index.into()).deref()
    }

    fn push(ref self: MemoryVec<T>, value: T) -> () {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len.wrapping_add(1_usize);
    }
    fn set(ref self: MemoryVec<T>, index: usize, value: T) {
        assert!(index < self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
    fn len(self: @MemoryVec<T>) -> usize {
        *self.len
    }
}

```

Since we again have `Felt252Dict<T>` as a struct member, we need to implement the `Destruct<T>` trait to tell the compiler how to make `MemoryVec<T>` go out of scope.

```cairo noplayground hljs hide-boring

use core::dict::Felt252Dict;
use core::nullable::NullableTrait;
use core::num::traits::WrappingAdd;

trait MemoryVecTrait<V, T> {
    fn new() -> V;
    fn get(ref self: V, index: usize) -> Option<T>;
    fn at(ref self: V, index: usize) -> T;
    fn push(ref self: V, value: T) -> ();
    fn set(ref self: V, index: usize, value: T);
    fn len(self: @V) -> usize;
}

struct MemoryVec<T> {
    data: Felt252Dict<Nullable<T>>,
    len: usize,
}

impl DestructMemoryVec<T, +Drop<T>> of Destruct<MemoryVec<T>> {
    fn destruct(self: MemoryVec<T>) nopanic {
        self.data.squash();
    }
}

impl MemoryVecImpl<T, +Drop<T>, +Copy<T>> of MemoryVecTrait<MemoryVec<T>, T> {
    fn new() -> MemoryVec<T> {
        MemoryVec { data: Default::default(), len: 0 }
    }

    fn get(ref self: MemoryVec<T>, index: usize) -> Option<T> {
        if index < self.len() {
            Option::Some(self.data.get(index.into()).deref())
        } else {
            Option::None
        }
    }

    fn at(ref self: MemoryVec<T>, index: usize) -> T {
        assert!(index < self.len(), "Index out of bounds");
        self.data.get(index.into()).deref()
    }

    fn push(ref self: MemoryVec<T>, value: T) -> () {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len.wrapping_add(1_usize);
    }
    fn set(ref self: MemoryVec<T>, index: usize, value: T) {
        assert!(index < self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
    fn len(self: @MemoryVec<T>) -> usize {
        *self.len
    }
}

```

The key thing that makes this vector mutable is that we can insert values into
the dictionary to set or update values in our data structure. For example, to
update a value at a specific index, we do:

```cairo noplayground hljs hide-boring

use core::dict::Felt252Dict;
use core::nullable::NullableTrait;
use core::num::traits::WrappingAdd;

trait MemoryVecTrait<V, T> {
    fn new() -> V;
    fn get(ref self: V, index: usize) -> Option<T>;
    fn at(ref self: V, index: usize) -> T;
    fn push(ref self: V, value: T) -> ();
    fn set(ref self: V, index: usize, value: T);
    fn len(self: @V) -> usize;
}

struct MemoryVec<T> {
    data: Felt252Dict<Nullable<T>>,
    len: usize,
}

impl DestructMemoryVec<T, +Drop<T>> of Destruct<MemoryVec<T>> {
    fn destruct(self: MemoryVec<T>) nopanic {
        self.data.squash();
    }
}

impl MemoryVecImpl<T, +Drop<T>, +Copy<T>> of MemoryVecTrait<MemoryVec<T>, T> {
    fn new() -> MemoryVec<T> {
        MemoryVec { data: Default::default(), len: 0 }
    }

    fn get(ref self: MemoryVec<T>, index: usize) -> Option<T> {
        if index < self.len() {
            Option::Some(self.data.get(index.into()).deref())
        } else {
            Option::None
        }
    }

    fn at(ref self: MemoryVec<T>, index: usize) -> T {
        assert!(index < self.len(), "Index out of bounds");
        self.data.get(index.into()).deref()
    }

    fn push(ref self: MemoryVec<T>, value: T) -> () {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len.wrapping_add(1_usize);
    }
    fn set(ref self: MemoryVec<T>, index: usize, value: T) {
        assert!(index < self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
    fn len(self: @MemoryVec<T>) -> usize {
        *self.len
    }
}

```

This overwrites the previously existing value at that index in the dictionary.

While arrays are immutable, dictionaries provide the flexibility we need for
modifiable data structures like vectors.

The implementation of the rest of the interface is straightforward. The
implementation of all the methods defined in our interface can be done as follow
:

```cairo noplayground hljs hide-boring

use core::dict::Felt252Dict;
use core::nullable::NullableTrait;
use core::num::traits::WrappingAdd;

trait MemoryVecTrait<V, T> {
    fn new() -> V;
    fn get(ref self: V, index: usize) -> Option<T>;
    fn at(ref self: V, index: usize) -> T;
    fn push(ref self: V, value: T) -> ();
    fn set(ref self: V, index: usize, value: T);
    fn len(self: @V) -> usize;
}

struct MemoryVec<T> {
    data: Felt252Dict<Nullable<T>>,
    len: usize,
}

impl DestructMemoryVec<T, +Drop<T>> of Destruct<MemoryVec<T>> {
    fn destruct(self: MemoryVec<T>) nopanic {
        self.data.squash();
    }
}

impl MemoryVecImpl<T, +Drop<T>, +Copy<T>> of MemoryVecTrait<MemoryVec<T>, T> {
    fn new() -> MemoryVec<T> {
        MemoryVec { data: Default::default(), len: 0 }
    }

    fn get(ref self: MemoryVec<T>, index: usize) -> Option<T> {
        if index < self.len() {
            Option::Some(self.data.get(index.into()).deref())
        } else {
            Option::None
        }
    }

    fn at(ref self: MemoryVec<T>, index: usize) -> T {
        assert!(index < self.len(), "Index out of bounds");
        self.data.get(index.into()).deref()
    }

    fn push(ref self: MemoryVec<T>, value: T) -> () {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len.wrapping_add(1_usize);
    }
    fn set(ref self: MemoryVec<T>, index: usize, value: T) {
        assert!(index < self.len(), "Index out of bounds");
        self.data.insert(index.into(), NullableTrait::new(value));
    }
    fn len(self: @MemoryVec<T>) -> usize {
        *self.len
    }
}

```

The full implementation of the `MemoryVec` structure can be found in the
community-maintained library [Alexandria](https://github.com/keep-starknet-strange/alexandria/blob/main/packages/data_structures/src/vec.cairo).

We will now look at a second example and its implementation details: a Stack.

A Stack is a LIFO (Last-In, First-Out) collection. The insertion of a new
element and removal of an existing element takes place at the same end,
represented as the top of the stack.

Let us define what operations we need to create a stack:

- Push an item to the top of the stack.
- Pop an item from the top of the stack.
- Check whether there are still any elements in the stack.

From these specifications we can define the following interface :

```cairo noplayground hljs

trait StackTrait<S, T> {
    fn push(ref self: S, value: T);
    fn pop(ref self: S) -> Option<T>;
    fn is_empty(self: @S) -> bool;
}

```

To create a stack data structure in Cairo, we can again use a `Felt252Dict<T>`
to store the values of the stack along with a `usize` field to keep track of the
length of the stack to iterate over it.

The Stack struct is defined as:

```cairo noplayground hljs

struct NullableStack<T> {
    data: Felt252Dict<Nullable<T>>,
    len: usize,
}

```

Next, let's see how our main functions `push` and `pop` are implemented.

```cairo noplayground hljs hide-boring

use core::dict::Felt252Dict;
use core::nullable::{match_nullable, FromNullableResult, NullableTrait};

trait StackTrait<S, T> {
    fn push(ref self: S, value: T);
    fn pop(ref self: S) -> Option<T>;
    fn is_empty(self: @S) -> bool;
}

struct NullableStack<T> {
    data: Felt252Dict<Nullable<T>>,
    len: usize,
}

impl DestructNullableStack<T, +Drop<T>> of Destruct<NullableStack<T>> {
    fn destruct(self: NullableStack<T>) nopanic {
        self.data.squash();
    }
}

impl NullableStackImpl<T, +Drop<T>, +Copy<T>> of StackTrait<NullableStack<T>, T> {
    fn push(ref self: NullableStack<T>, value: T) {
        self.data.insert(self.len.into(), NullableTrait::new(value));
        self.len += 1;
    }

    fn pop(ref self: NullableStack<T>) -> Option<T> {
        if self.is_empty() {
            return Option::None;
        }
        self.len -= 1;
        Option::Some(self.data.get(self.len.into()).deref())
    }

    fn is_empty(self: @NullableStack<T>) -> bool {
        *self.len == 0
    }
}

```

The code uses the `insert` and `get` methods to access the values in the
`Felt252Dict<T>`. To push an element to the top of the stack, the `push`
function inserts the element in the dict at index `len` and increases the
`len` field of the stack to keep track of the position of the stack top. To
remove a value, the `pop` function decreases the value of `len` to update the
position of the stack top and then retrieves the last value at position `len`.

The full implementation of the Stack, along with more data structures that you
can use in your code, can be found in the community-maintained
[Alexandria](https://github.com/keep-starknet-strange/alexandria/tree/main/packages/data_structures/src) library, in the "data\_structures" crate.

Start

Well done! Now you have knowledge of arrays, dictionaries and even custom data structures.
While Cairo's memory model is immutable and can make it difficult to implement
mutable data structures, we can fortunately use the `Felt252Dict<T>` type to
simulate mutable data structures. This allows us to implement a wide range of
data structures that are useful for many applications, effectively hiding the
complexity of the underlying memory model.

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch204-01-how-builtins-work.md "Suggest an edit")

A builtin enforces some constraints on the Cairo memory
to perform specific tasks, such as computing a hash.

Each builtin works on a dedicated memory segment,
which represents in the end a fixed address range.
This communication method is called _memory-mapped I/O_:
specific ranges of memory addresses dedicated to builtins.

For a Cairo program to interact with a builtin, it simply
needs to read or write to the corresponding memory cells.

There are two main types of builtin constraints that we'll
refer as _validation property_ and _deduction property_.
The builtins with a deduction property are usually split
in block of cells where some cells are constrained by
a validation property

If the defined property doesn't hold, then the Cairo VM
will panic.

A validation property defines constraints a value must
hold for it to be written to a builtin memory cell.

For example, the _Range Check_ builtin only accepts felts and verify
that such a felt is within the range `[0, 2**128)`.\
A program can write a value to the Range Check builtin\
only if those two constraints hold. Those two constraints\
represent the validation property of the Range Check builtin.\
\
![Diagram snapshot Cairo memory using the Range Check builtin](https://book.cairo-lang.org/range-check-validation-property.png)\
\
Diagram of the Cairo VM memory using the Range Check builtin\
\
A deduction property defines constraints on a block\
of cells, when reading or writing to a cell.\
\
A block of cells has two categories of cells:\
\
- _Input cells_ \- cells the program can write to,\
their constraints are similar to a validation property.\
- _Output cells_ \- cells the program must read,\
and their value is computed based on the deduction\
property and the input cells value.\
\
A program that only writes to the input cells, without\
ever reading the output cell, is valid as long as the constraints\
on those cells hold. Though, it is useless.\
\
For example, the _Pedersen_ builtin works with triplets of cells:\
\
- Two input cells to store two felts, `a` and `b`.\
- One output cell which will store `Pedersen(a, b)`.\
\
To compute the Pedersen hash of `a` and `b`, the program must:\
\
- Write `a` to the first cell\
- Write `b` to the second cell\
- Read the third cell, which will compute and write \`Pedersen(a, b) to it.\
\
In the following diagram, the Pedersen builtin is used,\
highlighting its deduction property: the output cell `2:2`\
being read when writing its value to the cell `1:5`.\
\
![Diagram of Cairo VM memory Pedersen builtins](https://book.cairo-lang.org/pedersen-deduction-property.png)\
\
Diagram of the Cairo VM memory using the Pedersen builtin\
\
ðŸ’¬\
\
DisconnectedChatÃ—\
\
Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch09-00-error-handling.md "Suggest an edit")

In this chapter, we will explore various error handling techniques provided by Cairo, which not only allow you to address potential issues in your code, but also make it easier to create programs that are adaptable and maintainable. By examining different approaches to managing errors, such as pattern matching with the `Result` enum, using the `?` operator for more ergonomic error propagation, and employing the `unwrap` or `expect` methods for handling recoverable errors, you'll gain a deeper understanding of Cairo's error handling features. These concepts are crucial for building robust applications that can effectively handle unexpected situations, ensuring your code is ready for production.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=2094414910.1738497986&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=260267360)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1452911018.1738497987&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1680066494)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-04-comments.md "Suggest an edit")

All programmers strive to make their code easy to understand, but sometimes extra explanation is warranted. In these cases, programmers leave comments in their source code that the compiler will ignore but people reading the source code may find useful.

Hereâ€™s a simple comment:

```cairo noplayground hljs

// hello, world

```

In Cairo, the idiomatic comment style starts a comment with two slashes, and the comment continues until the end of the line. For comments that extend beyond a single line, youâ€™ll need to include `//` on each line, like this:

```cairo noplayground hljs

// So weâ€™re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain whatâ€™s going on.

```

Comments can also be placed at the end of lines containing code:

```cairo hljs

fn main() -> felt252 {
    1 + 4 // return the sum of 1 and 4
}

```

But youâ€™ll more often see them used in this format, with the comment on a separate line above the code itâ€™s annotating:

```cairo hljs

fn main() -> felt252 {
    // this function performs a simple addition
    1 + 4
}

```

Item-level documentation comments refer to specific items such as functions, implementations, traits, etc. They are prefixed with three slashes ( `///`). These comments provide a detailed description of the item, examples of usage, and any conditions that might cause a panic. In case of functions, the comments may also include separate sections for parameter and return value descriptions.

````cairo noplayground hljs

/// Returns the sum of `arg1` and `arg2`.
/// `arg1` cannot be zero.
///
/// # Panics
///
/// This function will panic if `arg1` is `0`.
///
/// # Examples
///
/// ```
/// let a: felt252 = 2;
/// let b: felt252 = 3;
/// let c: felt252 = add(a, b);
/// assert(c == a + b, "Should equal a + b");
/// ```
fn add(arg1: felt252, arg2: felt252) -> felt252 {
    assert(arg1 != 0, 'Cannot be zero');
    arg1 + arg2
}

````

Module documentation comments provide an overview of the entire module, including its purpose and examples of use. These comments are meant to be placed above the module they're describing and are prefixed with `//!`. This type of documentation gives a broad understanding of what the module does and how it can be used.

````cairo noplayground hljs

//! # my_module and implementation
//!
//! This is an example description of my_module and some of its features.
//!
//! # Examples
//!
//! ```
//! mod my_other_module {
//!   use path::to::my_module;
//!
//!   fn foo() {
//!     my_module.bar();
//!   }
//! }
//! ```
mod my_module { // rest of implementation...
}

````

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch10-00-testing-cairo-programs.md "Suggest an edit")

Correctness in our programs is the extent to which our code does what we intend it to do. Cairo is designed with a high degree of concern about the correctness of programs, but correctness is complex and not easy to prove. Cairo's linear type system shoulders a huge part of this burden, but the type system cannot catch everything. As such, Cairo includes support for writing tests.

Testing is a complex skill: although we canâ€™t cover every detail about how to write good tests in one chapter, weâ€™ll discuss the mechanics of Cairo's testing facilities. Weâ€™ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1970251708.1738497987&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=919066487)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch00-01-foreword.md "Suggest an edit")

Zero-knowledge proofs have emerged as a transformative technology in the blockchain space, offering solutions for both privacy and scalability challenges. Among these, STARKs (Scalable Transparent ARguments of Knowledge) stand out as a particularly powerful innovation. Unlike traditional proof systems, STARKs rely solely on collision-resistant hash functions, making them post-quantum secure and eliminating the need for trusted setups.

However, writing general-purpose programs that can generate cryptographic proofs has historically been a significant challenge. Developers needed deep expertise in cryptography and complex mathematical concepts to create verifiable computations, making it impractical for mainstream adoption.

This is where Cairo comes in. As a general-purpose programming language designed specifically for creating provable programs, Cairo abstracts away the underlying cryptographic complexities while maintaining the full power of STARKs. Strongly inspired by Rust, Cairo has been built to help you create provable programs without requiring specific knowledge of its underlying architecture, allowing you to focus on the program logic itself.

æƒ³åœ¨Starknetä¸Šéƒ¨ç½²åˆçº¦çš„åŒºå—é“¾å¼€å‘è€…å°†ä½¿ç”¨Cairoç¼–ç¨‹è¯­è¨€æ¥ç¼–å†™ä»–ä»¬çš„æ™ºèƒ½åˆçº¦ã€‚è¿™å…è®¸Starknetæ“ä½œç³»ç»Ÿç”Ÿæˆäº¤æ˜“çš„æ‰§è¡Œè·Ÿè¸ªï¼Œä»¥ä¾›è¯æ˜Žè€…ç”Ÿæˆè¯æ˜Žï¼Œç„¶åŽåœ¨æ›´æ–°Starknetçš„çŠ¶æ€æ ¹ä¹‹å‰åœ¨Ethereum L1ä¸Šç”±éªŒè¯è€…éªŒè¯è¯¥è¯æ˜Žã€‚

However, Cairo is not only for blockchain developers. As a general purpose programming language, it can be used for any computation that would benefit from being proved on one computer and verified on other machines. Powered by a Rust VM, and a next-generation prover, the execution and proof generation of Cairo programs is blazingly fast - making Cairo the best tool for building provable applications.

æœ¬ä¹¦æ˜¯ä¸ºå¯¹ç¼–ç¨‹æ¦‚å¿µæœ‰åŸºæœ¬äº†è§£çš„å¼€å‘äººå‘˜è®¾è®¡çš„ã€‚å®ƒæ˜¯ä¸€æœ¬å‹å¥½è€Œå¹³æ˜“è¿‘äººçš„ä¹¦æœ¬ï¼Œæ—¨åœ¨å¸®åŠ©ä½ æé«˜ä½ çš„CairoçŸ¥è¯†æ°´å¹³ï¼ŒåŒæ—¶ä¹Ÿå¸®åŠ©ä½ æé«˜ä½ çš„é€šç”¨ç¼–ç¨‹æŠ€èƒ½ã€‚å› æ­¤ï¼Œè¯·æ½œä¸‹å¿ƒæ¥ï¼Œå¹¶å‡†å¤‡å¥½å­¦ä¹ æ‰€æœ‰å…³äºŽCairoçš„çŸ¥è¯†!

This book would not have been possible without the help of the Cairo community. We would like to thank every contributor for their contributions to this book!

We would like to thank the Rust community for the [Rust Book](https://doc.rust-lang.org/book/), which has been a great source of inspiration for this book. Many examples and explanations have been adapted from the Rust Book to fit the Cairo programming language, as the two languages share many similarities.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1581578627.1738497988&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1752223430)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-00-advanced-features.md "Suggest an edit")

Now, let's learn about more advanced features offered by Cairo.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=342860026.1738497988&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102558064&z=377504772)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-00.md "Suggest an edit")

The following sections contain reference material you may find useful in your Cairo journey.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=923524759.1738497989&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=1159996816)

DisconnectedChatÃ—

SendLoading \[MathJax\]/jax/output/HTML-CSS/jax.js

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=874364570.1738497989&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102325445~102482432~102528644~102539968~102546754~102556565&z=214164309)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-02-data-types.md "Suggest an edit")

Every value in Cairo is of a certain _data type_, which tells Cairo what kind of
data is being specified so it knows how to work with that data. This section covers two subsets of data types: scalars and compounds.

Keep in mind that Cairo is a _statically typed_ language, which means that it
must know the types of all variables at compile time. The compiler can usually infer the desired type based on the value and its usage. In cases when many types are possible, we can use a conversion method where we specify the desired output type.

```cairo hljs

fn main() {
    let x: felt252 = 3;
    let y: u32 = x.try_into().unwrap();
}

```

Youâ€™ll see different type annotations for other data types.

A _scalar_ type represents a single value. Cairo has three primary scalar types:
felts, integers, and booleans. You may recognize
these from other programming languages. Letâ€™s jump into how they work in Cairo.

In Cairo, if you don't specify the type of a variable or argument, its type defaults to a field element, represented by the keyword `felt252`. In the context of Cairo, when we say â€œa field elementâ€ we mean an integer in the range 0â‰¤x<P,
where P is a very large prime number currently equal to 2251+17â‹…2192+1. When adding, subtracting, or multiplying, if the result falls outside the specified range of the prime number, an overflow (or underflow) occurs, and an appropriate multiple of P is added or subtracted to bring the result back within the range (i.e., the result is computed modP ).

The most important difference between integers and field elements is division: Division of field elements (and therefore division in Cairo) is unlike regular CPUs division, where
integer division xy is defined as âŒŠxyâŒ‹
where the integer part of the quotient is returned (so you get 73=2) and it may or may not satisfy the equation xyâ‹…y==x,
depending on the divisibility of `x` by `y`.

In Cairo, the result of xy is defined to always satisfy the equation xyâ‹…y==x. If y divides x as integers, you will get the expected result in Cairo (for example 62 will indeed result in `3`).
But when y does not divide x, you may get a surprising result: for example, since 2â‹…P+12=P+1â‰¡1modP, the value of 12 in Cairo is P+12 (and not 0 or 0.5), as it satisfies the above equation.

The felt252 type is a fundamental type that serves as the basis for creating all types in the core library.
However, it is highly recommended for programmers to use the integer types instead of the `felt252` type whenever possible, as the `integer` types come with added security features that provide extra protection against potential vulnerabilities in the code, such as overflow and underflow checks. By using these integer types, programmers can ensure that their programs are more secure and less susceptible to attacks or other security threats.
An `integer` is a number without a fractional component. This type declaration indicates the number of bits the programmer can use to store the integer.
Table 3-1 shows the built-in integer types in Cairo. We can use any of these variants to declare the type of an integer value.

| Length | Unsigned |
| --- | --- |
| 8-bit | `u8` |
| 16-bit | `u16` |
| 32-bit | `u32` |
| 64-bit | `u64` |
| 128-bit | `u128` |
| 256-bit | `u256` |
| 32-bit | `usize` |

Table 3-1: Integer Types in Cairo.

Each variant has an explicit size. Note that for now, the `usize` type is just an alias for `u32`; however, it might be useful when in the future Cairo can be compiled to MLIR.
As variables are unsigned, they can't contain a negative number. This code will cause the program to panic:

```cairo hljs

fn sub_u8s(x: u8, y: u8) -> u8 {
    x - y
}

fn main() {
    sub_u8s(1, 3);
}

```

All integer types previously mentioned fit into a `felt252`, except for `u256` which needs 4 more bits to be stored. Under the hood, `u256` is basically a struct with 2 fields: `u256 {low: u128, high: u128}`.

Cairo also provides support for signed integers, starting with the prefix `i`. These integers can represent both positive and negative values, with sizes ranging from `i8` to `i128`.
Each signed variant can store numbers from âˆ’(2nâˆ’1) to 2nâˆ’1âˆ’1 inclusive, where `n` is the number of bits that variant uses. So an i8 can store numbers from âˆ’(27) to 27âˆ’1, which equals `-128` to `127`.

You can write integer literals in any of the forms shown in Table 3-2. Note
that number literals that can be multiple numeric types allow a type suffix,
such as `57_u8`, to designate the type.
It is also possible to use a visual separator `_` for number literals, in order to improve code readability.

| Numeric literals | Example |
| --- | --- |
| Decimal | `98222` |
| Hex | `0xff` |
| Octal | `0o04321` |
| Binary | `0b01` |

Table 3-2: Integer Literals in Cairo.

So how do you know which type of integer to use? Try to estimate the max value your int can have and choose the good size.
The primary situation in which youâ€™d use `usize` is when indexing some sort of collection.

Cairo supports the basic mathematical operations youâ€™d expect for all the integer
types: addition, subtraction, multiplication, division, and remainder. Integer
division truncates toward zero to the nearest integer. The following code shows
how youâ€™d use each numeric operation in a `let` statement:

```cairo hljs

fn main() {
    // addition
    let sum = 5_u128 + 10_u128;

    // subtraction
    let difference = 95_u128 - 4_u128;

    // multiplication
    let product = 4_u128 * 30_u128;

    // division
    let quotient = 56_u128 / 32_u128; //result is 1
    let quotient = 64_u128 / 32_u128; //result is 2

    // remainder
    let remainder = 43_u128 % 5_u128; // result is 3
}

```

Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable.

[Appendix B](https://book.cairo-lang.org/appendix-02-operators-and-symbols.html#operators) contains a list of all operators that Cairo provides.

As in most other programming languages, a Boolean type in Cairo has two possible
values: `true` and `false`. Booleans are one `felt252` in size. The Boolean type in
Cairo is specified using `bool`. For example:

```cairo hljs

fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}

```

When declaring a `bool` variable, it is mandatory to use either `true` or `false` literals as value. Hence, it is not allowed to use integer literals (i.e. `0` instead of false) for `bool` declarations.

The main way to use Boolean values is through conditionals, such as an `if`
expression. Weâ€™ll cover how `if` expressions work in Cairo in the ["Control Flow"](https://book.cairo-lang.org/ch02-05-control-flow.html) section.

Cairo doesn't have a native type for strings but provides two ways to handle them: short strings using simple quotes and ByteArray using double quotes.

A short string is an ASCII string where each character is encoded on one byte (see the [ASCII table](https://www.asciitable.com/)). For example:

- `'a'` is equivalent to `0x61`
- `'b'` is equivalent to `0x62`
- `'c'` is equivalent to `0x63`
- `0x616263` is equivalent to `'abc'`.

Cairo uses the `felt252` for short strings. As the `felt252` is on 251 bits, a short string is limited to 31 characters (31 \* 8 = 248 bits, which is the maximum multiple of 8 that fits in 251 bits).

You can choose to represent your short string with an hexadecimal value like `0x616263` or by directly writing the string using simple quotes like `'abc'`, which is more convenient.

Here are some examples of declaring short strings in Cairo:

```cairo hljs hide-boring

fn main() {
    let my_first_char = 'C';
    let my_first_char_in_hex = 0x43;

    let my_first_string = 'Hello world';
    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;

    let long_string: ByteArray = "this is a string which has more than 31 characters";
}

```

Cairo's Core Library provides a `ByteArray` type for handling strings and byte sequences longer than short strings. This type is particularly useful for longer strings or when you need to perform operations on the string data.

The `ByteArray` in Cairo is implemented as a combination of two parts:

1. An array of `bytes31` words, where each word contains 31 bytes of data.
2. A pending `felt252` word that acts as a buffer for bytes that haven't yet filled a complete `bytes31` word.

This design enables efficient handling of byte sequences while aligning with Cairo's memory model and basic types. Developers interact with `ByteArray` through its provided methods and operators, abstracting away the internal implementation details.

Unlike short strings, `ByteArray` strings can contain more than 31 characters and are written using double quotes:

```cairo hljs hide-boring

fn main() {
    let my_first_char = 'C';
    let my_first_char_in_hex = 0x43;

    let my_first_string = 'Hello world';
    let my_first_string_in_hex = 0x48656C6C6F20776F726C64;

    let long_string: ByteArray = "this is a string which has more than 31 characters";
}

```

A _tuple_ is a general way of grouping together a number of values with a
variety of types into one compound type. Tuples have a fixed length: once
declared, they cannot grow or shrink in size.

We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple donâ€™t have to be the same. Weâ€™ve added optional
type annotations in this example:

```cairo hljs

fn main() {
    let tup: (u32, u64, bool) = (10, 20, true);
}

```

The variable `tup` binds to the entire tuple because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:

```cairo hljs

fn main() {
    let tup = (500, 6, true);

    let (x, y, z) = tup;

    if y == 6 {
        println!("y is 6!");
    }
}

```

This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called _destructuring_ because it breaks
the single tuple into three parts. Finally, the program prints `y is 6!` as the value of
`y` is `6`.

We can also declare the tuple with value and types, and destructure it at the same time.
For example:

```cairo hljs

fn main() {
    let (x, y): (felt252, felt252) = (2, 3);
}

```

A _unit type_ is a type which has only one value `()`.
It is represented by a tuple with no elements.
Its size is always zero, and it is guaranteed to not exist in the compiled code.

You might be wondering why you would even need a unit type? In Cairo, everything is an expression, and an expression that returns nothing actually returns `()` implicitly.

Another way to have a collection of multiple values is with a _fixed size array_. Unlike a tuple, every element of a fixed size array must have the same type.

We write the values in a fixed-size array as a comma-separated list inside square brackets. The arrayâ€™s type is written using square brackets with the type of each element, a semicolon, and then the number of elements in the array, like so:

```cairo hljs

fn main() {
    let arr1: [u64; 5] = [1, 2, 3, 4, 5];
}

```

In the type annotation `[u64; 5]`, `u64` specifies the type of each element, while `5` after the semicolon defines the array's length. This syntax ensures that the array always contains exactly 5 elements of type `u64`.

Fixed size arrays are useful when you want to hardcode a potentially long sequence of data directly in your program. This type of array must not be confused with the [`Array<T>` type](https://book.cairo-lang.org/ch03-01-arrays.html), which is a similar collection type provided by the core library that _is_ allowed to grow in size. If you're unsure whether to use a fixed size array or the `Array<T>` type, chances are that you are looking for the `Array<T>` type.

Because their size is known at compile-time, fixed-size arrays don't require runtime memory management, which makes them more efficient than dynamically-sized arrays. Overall, they're more useful when you know the number of elements will not need to change. For example, they can be used to efficiently store lookup tables that won't change during runtime. If you were using the names of the month in a program, you would probably use a fixed size array rather than an `Array<T>` because you know it will always contain 12 elements:

```cairo hljs

    let months = [\
        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',\
        'October', 'November', 'December',\
    ];

```

You can also initialize an array to contain the same value for each element by specifying the initial value, followed by a semicolon, and then the length of the array in square brackets, as shown here:

```cairo hljs

    let a = [3; 5];

```

The array named `a` will contain `5` elements that will all be set to the value `3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a more concise way.

As a fixed-size array is a data structure known at compile time, it's content is represented as a sequence of values in the program bytecode. Accessing an element of that array will simply read that value from the program bytecode efficiently.

We have two different ways of accessing fixed size array elements:

- Deconstructing the array into multiple variables, as we did with tuples.

```cairo hljs

fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by deconstruction
    let [a, b, c, _, _] = my_arr;
    println!("c: {}", c); // c: 3
}

```

- Converting the array to a [Span](https://book.cairo-lang.org/ch03-01-arrays.html#Span), that supports indexing. This operation is _free_ and doesn't incur any runtime cost.

```cairo hljs

fn main() {
    let my_arr = [1, 2, 3, 4, 5];

    // Accessing elements of a fixed-size array by index
    let my_span = my_arr.span();
    println!("my_span[2]: {}", my_span[2]); // my_span[2]: 3
}

```

Note that if we plan to repeatedly access the array, then it makes sense to call `.span()` only once and keep it available throughout the accesses.

Cairo addresses conversion between types by using the `try_into` and `into` methods provided by the `TryInto` and `Into` traits from the core library. There are numerous implementations of these traits within the standard library for conversion between types, and they can be implemented for [custom types as well](https://book.cairo-lang.org/ch05-02-an-example-program-using-structs.html#conversions-of-custom-types).

The `Into` trait allows for a type to define how to convert itself into another type. It can be used for type conversion when success is guaranteed, such as when the source type is smaller than the destination type.

To perform the conversion, call `var.into()` on the source value to convert it to another type. The new variable's type must be explicitly defined, as demonstrated in the example below.

```cairo hljs

fn main() {
    let my_u8: u8 = 10;
    let my_u16: u16 = my_u8.into();
    let my_u32: u32 = my_u16.into();
    let my_u64: u64 = my_u32.into();
    let my_u128: u128 = my_u64.into();

    let my_felt252 = 10;
    // As a felt252 is smaller than a u256, we can use the into() method
    let my_u256: u256 = my_felt252.into();
    let my_other_felt252: felt252 = my_u8.into();
    let my_third_felt252: felt252 = my_u16.into();
}

```

Similar to `Into`, `TryInto` is a generic trait for converting between types. Unlike `Into`, the `TryInto` trait is used for fallible conversions, and as such, returns [Option<T>](https://book.cairo-lang.org/ch06-01-enums.html#the-option-enum-and-its-advantages). An example of a fallible conversion is when the target type might not fit the source value.

Also similar to `Into` is the process to perform the conversion; just call `var.try_into()` on the source value to convert it to another type. The new variable's type also must be explicitly defined, as demonstrated in the example below.

```cairo hljs

fn main() {
    let my_u256: u256 = 10;

    // Since a u256 might not fit in a felt252, we need to unwrap the Option<T> type
    let my_felt252: felt252 = my_u256.try_into().unwrap();
    let my_u128: u128 = my_felt252.try_into().unwrap();
    let my_u64: u64 = my_u128.try_into().unwrap();
    let my_u32: u32 = my_u64.try_into().unwrap();
    let my_u16: u16 = my_u32.try_into().unwrap();
    let my_u8: u8 = my_u16.try_into().unwrap();

    let my_large_u16: u16 = 2048;
    let my_large_u8: u8 = my_large_u16.try_into().unwrap(); // panics with 'Option::unwrap failed.'
}

```

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-01-installation.md "Suggest an edit")

åªéœ€ä¸‹è½½ [Scarb](https://docs.swmansion.com/scarb/docs)ï¼Œå³å¯å®‰è£… Cairoã€‚Scarb å°† Cairo ç¼–è¯‘å™¨å’Œ Cairo è¯­è¨€æœåŠ¡å™¨æ†ç»‘åœ¨ä¸€ä¸ªæ˜“äºŽå®‰è£…çš„è½¯ä»¶åŒ…ä¸­ï¼Œè¿™æ ·ä½ å°±å¯ä»¥ç«‹å³å¼€å§‹ç¼–å†™ Cairo ä»£ç äº†ã€‚

ScarbåŒæ ·æ˜¯Cairoçš„è½¯ä»¶åŒ…ç®¡ç†å™¨ï¼Œåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå—åˆ° [Cargo](https://doc.rust-lang.org/cargo/) çš„å¯å‘ï¼ŒRustçš„æž„å»ºç³»ç»Ÿå’Œè½¯ä»¶åŒ…ç®¡ç†å™¨ã€‚

Scarbä¼šä¸ºä½ å¤„ç†å¾ˆå¤šä»»åŠ¡ï¼Œæ¯”å¦‚æž„å»ºä½ çš„ä»£ç ï¼ˆçº¯Cairoæˆ–Starknetåˆçº¦ï¼‰ï¼Œä¸ºä½ ä¸‹è½½ä½ çš„ä»£ç æ‰€ä¾èµ–çš„åº“å¹¶æž„å»ºä»–ä»¬ï¼Œä»¥åŠä¸ºVSCode Cairo 1æ‰©å±•æä¾›LSPæ”¯æŒã€‚

å¦‚æžœä½ ä½¿ç”¨ Scarb å¯åŠ¨é¡¹ç›®ï¼Œç®¡ç†å¤–éƒ¨ä»£ç å’Œä¾èµ–å…³ç³»å°±ä¼šå®¹æ˜“å¾—å¤šã€‚

[Starknet Foundry](https://foundry-rs.github.io/starknet-foundry/index.html) is a toolchain for Cairo programs and Starknet smart contract development. It supports many features, including writing and running tests with advanced features, deploying contracts, interacting with the Starknet network, and more.

Let's start by installing Scarb and Starknet Foundry.

Scarbéœ€è¦ `PATH` çŽ¯å¢ƒå˜é‡é‡Œæœ‰ä¸€ä¸ªGitå¯æ‰§è¡Œæ–‡ä»¶ã€‚

To install Scarb, please refer to the [installation instructions](https://docs.swmansion.com/scarb/download). We strongly recommend that you install Scarb [via asdf](https://docs.swmansion.com/scarb/download.html#install-via-asdf), a CLI tool that can manage multiple language runtime versions on a per-project basis. This will ensure that the version of Scarb you use to work on a project always matches the one defined in the project settings, avoiding problems related to version mismatches.

Please refer to the [asdf documentation](https://asdf-vm.com/guide/getting-started.html) to install all prerequisites.

Once you have asdf installed locally, you can download Scarb plugin with the following command:

```bash hljs

asdf plugin add scarb

```

This will allow you to download specific versions:

```bash hljs

asdf install scarb 2.9.2

```

and set a global version:

```bash hljs

asdf global scarb 2.9.2

```

Otherwise, you can simply run the following command in your terminal, and follow the onscreen instructions. This will install the latest stable release of Scarb.

```bash hljs

curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh

```

In both cases, you can verify installation by running the following command in a new terminal session, it should print both Scarb and Cairo language versions, e.g:

```bash hljs

$ scarb --version
scarb 2.9.2 (5070ff374 2024-12-11)
cairo: 2.9.2 (https://crates.io/crates/cairo-lang-compiler/2.9.2)
sierra: 1.6.0

```

To install Starknet Foundry, please refer to the [installation instructions](https://foundry-rs.github.io/starknet-foundry/getting-started/installation.html). We also recommend that you install it via asdf.

Once installed, you can run the following command to see the version:

```bash hljs

$ snforge --version
snforge 0.35.1

```

We'll describe Starknet Foundry in more detail in [Chapter 10](https://book.cairo-lang.org/zh-cn/ch10-01-how-to-write-tests.html) for Cairo programs testing and in [Chapter 18](https://book.cairo-lang.org/zh-cn/ch104-02-testing-smart-contracts.html#testing-smart-contracts-with-starknet-foundry) when discussing Starknet smart contract testing and security in the second part of the book.

Cairo has a VSCode extension that provides syntax highlighting, code completion, and other useful features. You can install it from the [VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=starkware.cairo1). Once installed, go into the extension settings, and make sure to tick the `Enable Language Server` and `Enable Scarb` options.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=525293945.1738497990&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102558063&z=1037210271)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-00-common-programming-concepts.md "Suggest an edit")

This chapter covers concepts that appear in almost every programming language and how they work in Cairo. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Cairo, but weâ€™ll discuss them in the context of Cairo and explain the conventions around using these concepts.

Specifically, youâ€™ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Cairo program, and learning them early will give you a strong core to start from.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1804122886.1738497991&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=2051283224)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch08-01-generic-data-types.md "Suggest an edit")

We use generics to create definitions for item declarations, such as structs and functions, which we can then use with many different concrete data types. In Cairo, we can use generics when defining functions, structs, enums, traits, implementations and methods. In this chapter, we are going to take a look at how to effectively use generic types with all of them.

Generics allow us to write reusable code that works with many types, thus avoiding code duplication, while enhancing code maintainability.

Making a function generic means it can operate on different types, avoiding the need for multiple, type-specific implementations. This leads to significant code reduction and increases the flexibility of the code.

When defining a function that uses generics, we place the generics in the function signature, where we would usually specify the data types of the parameter and return value. For example, imagine we want to create a function which given two `Array` of items, will return the largest one. If we need to perform this operation for lists of different types, then we would have to redefine the function each time. Luckily we can implement the function once using generics and move on to other tasks.

```cairo hljs

// Specify generic type T between the angulars
fn largest_list<T>(l1: Array<T>, l2: Array<T>) -> Array<T> {
    if l1.len() > l2.len() {
        l1
    } else {
        l2
    }
}

fn main() {
    let mut l1 = array![1, 2];
    let mut l2 = array![3, 4, 5];

    // There is no need to specify the concrete type of T because
    // it is inferred by the compiler
    let l3 = largest_list(l1, l2);
}

```

The `largest_list` function compares two lists of the same type and returns the one with more elements and drops the other. If you compile the previous code, you will notice that it will fail with an error saying that there are no traits defined for dropping an array of a generic type. This happens because the compiler has no way to guarantee that an `Array<T>` is droppable when executing the `main` function. In order to drop an array of `T`, the compiler must first know how to drop `T`. This can be fixed by specifying in the function signature of `largest_list` that `T` must implement the `Drop` trait. The correct function definition of `largest_list` is as follows:

```cairo hljs

fn largest_list<T, impl TDrop: Drop<T>>(l1: Array<T>, l2: Array<T>) -> Array<T> {
    if l1.len() > l2.len() {
        l1
    } else {
        l2
    }
}

```

The new `largest_list` function includes in its definition the requirement that whatever generic type is placed there, it must be droppable. This is what we call _trait bounds_. The `main` function remains unchanged, the compiler is smart enough to deduce which concrete type is being used and if it implements the `Drop` trait.

When defining generic types, it is useful to have information about them. Knowing which traits a generic type implements allows us to use it more effectively in a function's logic at the cost of constraining the generic types that can be used with the function. We saw an example of this previously by adding the `TDrop` implementation as part of the generic arguments of `largest_list`. While `TDrop` was added to satisfy the compiler's requirements, we can also add constraints to benefit our function logic.

Imagine that we want, given a list of elements of some generic type `T`, to find the smallest element among them. Initially, we know that for an element of type `T` to be comparable, it must implement the `PartialOrd` trait. The resulting function would be:

```cairo hljs

// Given a list of T get the smallest one
// The PartialOrd trait implements comparison operations for T
fn smallest_element<T, impl TPartialOrd: PartialOrd<T>>(list: @Array<T>) -> T {
    // This represents the smallest element through the iteration
    // Notice that we use the desnap (*) operator
    let mut smallest = *list[0];

    // The index we will use to move through the list
    let mut index = 1;

    // Iterate through the whole list storing the smallest
    while index < list.len() {
        if *list[index] < smallest {
            smallest = *list[index];
        }
        index = index + 1;
    };

    smallest
}

fn main() {
    let list: Array<u8> = array![5, 3, 10];

    // We need to specify that we are passing a snapshot of `list` as an argument
    let s = smallest_element(@list);
    assert!(s == 3);
}

```

The `smallest_element` function uses a generic type `T` that implements the `PartialOrd` trait, takes a snapshot of an `Array<T>` as a parameter and returns a copy of the smallest element. Because the parameter is of type `@Array<T>`, we no longer need to drop it at the end of the execution and so we are not required to implement the `Drop` trait for `T` as well. Why does it not compile then?

When indexing on `list`, the value results in a snap of the indexed element, and unless `PartialOrd` is implemented for `@T` we need to desnap the element using `*`. The `*` operation requires a copy from `@T` to `T`, which means that `T` needs to implement the `Copy` trait. After copying an element of type `@T` to `T`, there are now variables with type `T` that need to be dropped, requiring `T` to implement the `Drop` trait as well. We must then add both `Drop` and `Copy` traits implementation for the function to be correct. After updating the `smallest_element` function the resulting code would be:

```cairo hljs

fn smallest_element<T, impl TPartialOrd: PartialOrd<T>, impl TCopy: Copy<T>, impl TDrop: Drop<T>>(
    list: @Array<T>,
) -> T {
    let mut smallest = *list[0];
    let mut index = 1;

    while index < list.len() {
        if *list[index] < smallest {
            smallest = *list[index];
        }
        index = index + 1;
    };

    smallest
}

```

Until now, we have always specified a name for each implementation of the required generic trait: `TPartialOrd` for `PartialOrd<T>`, `TDrop` for `Drop<T>`, and `TCopy` for `Copy<T>`.

However, most of the time, we don't use the implementation in the function body; we only use it as a constraint. In these cases, we can use the `+` operator to specify that the generic type must implement a trait without naming the implementation. This is referred to as an _anonymous generic implementation parameter_.

For example, `+PartialOrd<T>` is equivalent to `impl TPartialOrd: PartialOrd<T>`.

We can rewrite the `smallest_element` function signature as follows:

```cairo hljs hide-boring

fn smallest_element<T, +PartialOrd<T>, +Copy<T>, +Drop<T>>(list: @Array<T>) -> T {
    let mut smallest = *list[0];
    let mut index = 1;
    loop {
        if index >= list.len() {
            break smallest;
        }
        if *list[index] < smallest {
            smallest = *list[index];
        }
        index = index + 1;
    }
}

```

We can also define structs to use a generic type parameter for one or more fields using the `<>` syntax, similar to function definitions. First, we declare the name of the type parameter inside the angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types. The next code example shows the definition `Wallet<T>` which has a `balance` field of type `T`.

```cairo hljs

#[derive(Drop)]
struct Wallet<T> {
    balance: T,
}

fn main() {
    let w = Wallet { balance: 3 };
}

```

The above code derives the `Drop` trait for the `Wallet` type automatically. It is equivalent to writing the following code:

```cairo hljs

struct Wallet<T> {
    balance: T,
}

impl WalletDrop<T, +Drop<T>> of Drop<Wallet<T>>;

fn main() {
    let w = Wallet { balance: 3 };
}

```

We avoid using the `derive` macro for `Drop` implementation of `Wallet` and instead define our own `WalletDrop` implementation. Notice that we must define, just like functions, an additional generic type for `WalletDrop` saying that `T` implements the `Drop` trait as well. We are basically saying that the struct `Wallet<T>` is droppable as long as `T` is also droppable.

Finally, if we want to add a field to `Wallet` representing its address and we want that field to be different than `T` but generic as well, we can simply add another generic type between the `<>`:

```cairo hljs

#[derive(Drop)]
struct Wallet<T, U> {
    balance: T,
    address: U,
}

fn main() {
    let w = Wallet { balance: 3, address: 14 };
}

```

We add to the `Wallet` struct definition a new generic type `U` and then assign this type to the new field member `address`. Notice that the `derive` attribute for the `Drop` trait works for `U` as well.

As we did with structs, we can define enums to hold generic data types in their variants. For example the `Option<T>` enum provided by the Cairo core library:

```cairo noplayground hljs

enum Option<T> {
    Some: T,
    None,
}

```

The `Option<T>` enum is generic over a type `T` and has two variants: `Some`, which holds one value of type `T` and `None` that doesn't hold any value. By using the `Option<T>` enum, it is possible for us to express the abstract concept of an optional value and because the value has a generic type `T` we can use this abstraction with any type.

Enums can use multiple generic types as well, like the definition of the `Result<T, E>` enum that the core library provides:

```cairo noplayground hljs

enum Result<T, E> {
    Ok: T,
    Err: E,
}

```

The `Result<T, E>` enum has two generic types, `T` and `E`, and two variants: `Ok` which holds the value of type `T` and `Err` which holds the value of type `E`. This definition makes it convenient to use the `Result` enum anywhere we have an operation that might succeed (by returning a value of type `T`) or fail (by returning a value of type `E`).

We can implement methods on structs and enums, and use the generic types in their definitions, too. Using our previous definition of `Wallet<T>` struct, we define a `balance` method for it:

```cairo hljs

#[derive(Copy, Drop)]
struct Wallet<T> {
    balance: T,
}

trait WalletTrait<T> {
    fn balance(self: @Wallet<T>) -> T;
}

impl WalletImpl<T, +Copy<T>> of WalletTrait<T> {
    fn balance(self: @Wallet<T>) -> T {
        return *self.balance;
    }
}

fn main() {
    let w = Wallet { balance: 50 };
    assert!(w.balance() == 50);
}

```

We first define `WalletTrait<T>` trait using a generic type `T` which defines a method that returns the value of the field `balance` from `Wallet`. Then we give an implementation for the trait in `WalletImpl<T>`. Note that you need to include a generic type in both definitions of the trait and the implementation.

We can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only for `Wallet<u128>` instances rather than `Wallet<T>`. In the code example, we define an implementation for wallets which have a concrete type of `u128` for the `balance` field.

```cairo hljs

#[derive(Copy, Drop)]
struct Wallet<T> {
    balance: T,
}

/// Generic trait for wallets
trait WalletTrait<T> {
    fn balance(self: @Wallet<T>) -> T;
}

impl WalletImpl<T, +Copy<T>> of WalletTrait<T> {
    fn balance(self: @Wallet<T>) -> T {
        return *self.balance;
    }
}

/// Trait for wallets of type u128
trait WalletReceiveTrait {
    fn receive(ref self: Wallet<u128>, value: u128);
}

impl WalletReceiveImpl of WalletReceiveTrait {
    fn receive(ref self: Wallet<u128>, value: u128) {
        self.balance += value;
    }
}

fn main() {
    let mut w = Wallet { balance: 50 };
    assert!(w.balance() == 50);

    w.receive(100);
    assert!(w.balance() == 150);
}

```

The new method `receive` increments the size of `balance` of any instance of a `Wallet<u128>`. Notice that we changed the `main` function making `w` a mutable variable in order for it to be able to update its balance. If we were to change the initialization of `w` by changing the type of `balance` the previous code wouldn't compile.

Cairo allows us to define generic methods inside generic traits as well. Using the past implementation from `Wallet<U, V>` we are going to define a trait that picks two wallets of different generic types and creates a new one with a generic type of each. First, let's rewrite the struct definition:

```cairo noplayground hljs

struct Wallet<T, U> {
    balance: T,
    address: U,
}

```

Next, we are going to naively define the mixup trait and implementation:

```cairo noplayground hljs

// This does not compile!
trait WalletMixTrait<T1, U1> {
    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2>;
}

impl WalletMixImpl<T1, U1> of WalletMixTrait<T1, U1> {
    fn mixup<T2, U2>(self: Wallet<T1, U1>, other: Wallet<T2, U2>) -> Wallet<T1, U2> {
        Wallet { balance: self.balance, address: other.address }
    }
}

```

We are creating a trait `WalletMixTrait<T1, U1>` with the `mixup<T2, U2>` method which given an instance of `Wallet<T1, U1>` and `Wallet<T2, U2>` creates a new `Wallet<T1, U2>`. As `mixup` signature specifies, both `self` and `other` are getting dropped at the end of the function, which is why this code does not compile. If you have been following from the start until now you would know that we must add a requirement for all the generic types specifying that they will implement the `Drop` trait for the compiler to know how to drop instances of `Wallet<T, U>`. The updated implementation is as follows:

```cairo hljs

trait WalletMixTrait<T1, U1> {
    fn mixup<T2, +Drop<T2>, U2, +Drop<U2>>(
        self: Wallet<T1, U1>, other: Wallet<T2, U2>,
    ) -> Wallet<T1, U2>;
}

impl WalletMixImpl<T1, +Drop<T1>, U1, +Drop<U1>> of WalletMixTrait<T1, U1> {
    fn mixup<T2, +Drop<T2>, U2, +Drop<U2>>(
        self: Wallet<T1, U1>, other: Wallet<T2, U2>,
    ) -> Wallet<T1, U2> {
        Wallet { balance: self.balance, address: other.address }
    }
}

```

We add the requirements for `T1` and `U1` to be droppable on `WalletMixImpl` declaration. Then we do the same for `T2` and `U2`, this time as part of `mixup` signature. We can now try the `mixup` function:

```cairo noplayground hljs

fn main() {
    let w1: Wallet<bool, u128> = Wallet { balance: true, address: 10 };
    let w2: Wallet<felt252, u8> = Wallet { balance: 32, address: 100 };

    let w3 = w1.mixup(w2);

    assert!(w3.balance);
    assert!(w3.address == 100);
}

```

We first create two instances: one of `Wallet<bool, u128>` and the other of `Wallet<felt252, u8>`. Then, we call `mixup` and create a new `Wallet<bool, u8>` instance.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=919951450.1738497993&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=1135243559)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/title-page.md "Suggest an edit")

_By the Cairo Community and its [contributors](https://github.com/cairo-book/cairo-book.github.io). Special thanks to [StarkWare](https://starkware.co/) through [OnlyDust](https://www.onlydust.xyz/), and [Voyager](https://voyager.online/) for supporting the creation of this book._

This version of the text assumes youâ€™re using [Cairo](https://github.com/starkware-libs/cairo) [version 2.9.2](https://github.com/starkware-libs/cairo/releases) and [Starknet Foundry](https://foundry-rs.github.io/starknet-foundry/index.html) [version 0.35.1](https://github.com/foundry-rs/starknet-foundry/releases). See the [Installation](https://book.cairo-lang.org/zh-cn/ch01-01-installation.html) section of Chapter 1 to install or update Cairo and Starknet Foundry.

While reading this book, if you want to experiment with Cairo code and see how it compiles into Sierra (Intermediate Representation) and CASM (Cairo Assembly), you can use the [cairovm.codes](https://cairovm.codes/) playground.

This book is open source. Find a typo or want to contribute? Check out the book's [GitHub repository](https://github.com/cairo-book/cairo-book).

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=811457256.1738497995&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=497156064)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch08-02-traits-in-cairo.md "Suggest an edit")

A trait defines a set of methods that can be implemented by a type. These methods can be called on instances of the type when this trait is implemented.
A trait combined with a generic type defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way.
We can use _trait bounds_ to specify that a generic type can be any type that has certain behavior.

> Note: Traits are similar to a feature often called interfaces in other languages, although with some differences.

While traits can be written to not accept generic types, they are most useful when used with generic types. We already covered generics in the [previous chapter](https://book.cairo-lang.org/ch08-01-generic-data-types.html), and we will use them in this chapter to demonstrate how traits can be used to define shared behavior for generic types.

A typeâ€™s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.

For example, letâ€™s say we have a struct `NewsArticle` that holds a news story in a particular location. We can define a trait `Summary` that describes the behavior of something that can summarize the `NewsArticle` type.

```cairo noplayground hljs hide-boring

#[derive(Drop, Clone)]
struct NewsArticle {
    headline: ByteArray,
    location: ByteArray,
    author: ByteArray,
    content: ByteArray,
}

pub trait Summary {
    fn summarize(self: @NewsArticle) -> ByteArray;
}

impl NewsArticleSummary of Summary {
    fn summarize(self: @NewsArticle) -> ByteArray {
        format!("{:?} by {:?} ({:?})", self.headline, self.author, self.location)
    }
}

```

Listing 8-1: A `Summary` trait that consists of the behavior provided by a `summarize` method

In Listing 8-1, we declare a trait using the `trait` keyword and then the traitâ€™s name, which is `Summary` in this case.
Weâ€™ve also declared the trait as `pub` so that crates depending on this crate can make use of this trait too, as weâ€™ll see in a few examples.

Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is `fn summarize(self: @NewsArticle) -> ByteArray;`. After the method signature, instead of providing an implementation within curly brackets, we use a semicolon.

> Note: the `ByteArray` type is the type used to represent strings in Cairo.

As the trait is not generic, the `self` parameter is not generic either and is of type `@NewsArticle`. This means that the `summarize` method can only be called on instances of `NewsArticle`.

Now, consider that we want to make a media aggregator library crate named _aggregator_ that can display summaries of data that might be stored in a `NewsArticle` or `Tweet` instance. To do this, we need a summary from each type, and weâ€™ll request that summary by calling a summarize method on an instance of that type. By defining the `Summary` trait on generic type `T`, we can implement the `summarize` method on any type we want to be able to summarize.

```cairo noplayground hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(self: @T) -> ByteArray;
    }

    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary<NewsArticle> {
        fn summarize(self: @NewsArticle) -> ByteArray {
            format!("{} by {} ({})", self.headline, self.author, self.location)
        }
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize(self: @Tweet) -> ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
}

use aggregator::{Summary, NewsArticle, Tweet};

fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    }; // Tweet instantiation

    println!("New article available! {}", news.summarize());
    println!("New tweet! {}", tweet.summarize());
}

```

Listing 8-2: A `Summary` trait that consists of the behavior provided by a `summarize` method for a generic type

Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that implements the `Summary` trait will have the method `summarize` defined with this signature exactly.

A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.

Now that weâ€™ve defined the desired signatures of the `Summary` traitâ€™s methods,
we can implement it on the types in our media aggregator. The following code shows
an implementation of the `Summary` trait on the `NewsArticle` struct that uses
the headline, the author, and the location to create the return value of
`summarize`. For the `Tweet` struct, we define `summarize` as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.

```cairo noplayground hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(self: @T) -> ByteArray;
    }

    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary<NewsArticle> {
        fn summarize(self: @NewsArticle) -> ByteArray {
            format!("{} by {} ({})", self.headline, self.author, self.location)
        }
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize(self: @Tweet) -> ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
}

use aggregator::{Summary, NewsArticle, Tweet};

fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    }; // Tweet instantiation

    println!("New article available! {}", news.summarize());
    println!("New tweet! {}", tweet.summarize());
}

```

Listing 8-3: Implementation of the `Summary` trait on `NewsArticle` and `Tweet`

Implementing a trait on a type is similar to implementing regular methods. The
difference is that after `impl`, we put a name for the implementation,
then use the `of` keyword, and then specify the name of the trait we are writing the implementation for.
If the implementation is for a generic type, we place the generic type name in the angle brackets after the trait name.

Note that for the trait method to be accessible, there must be an implementation of that trait visible from the scope where the method is called. If the trait is `pub` and the implementation is not, and the implementation is not visible in the scope where the trait method is called, this will cause a compilation error.

Within the `impl` block, we put the method signatures
that the trait definition has defined. Instead of adding a semicolon after each
signature, we use curly brackets and fill in the method body with the specific
behavior that we want the methods of the trait to have for the particular type.

Now that the library has implemented the `Summary` trait on `NewsArticle` and
`Tweet`, users of the crate can call the trait methods on instances of
`NewsArticle` and `Tweet` in the same way we call regular methods. The only
difference is that the user must bring the trait into scope as well as the
types. Hereâ€™s an example of how a crate could use our `aggregator` crate:

```cairo hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(self: @T) -> ByteArray;
    }

    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary<NewsArticle> {
        fn summarize(self: @NewsArticle) -> ByteArray {
            format!("{} by {} ({})", self.headline, self.author, self.location)
        }
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize(self: @Tweet) -> ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
}

use aggregator::{Summary, NewsArticle, Tweet};

fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    }; // Tweet instantiation

    println!("New article available! {}", news.summarize());
    println!("New tweet! {}", tweet.summarize());
}

```

This code prints the following:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_15_traits v0.1.0 (listings/ch08-generic-types-and-traits/no_listing_15_traits/Scarb.toml)
    Finished `dev` profile target(s) in 3 seconds
     Running no_listing_15_traits
New article available! Cairo has become the most popular language for developers by Cairo Digger (Worldwide)
New tweet! EliBenSasson: Crypto is full of short-term maximizing projects.
 @Starknet and @StarkWareLtd are about long-term vision maximization.
Run completed successfully, returning []

```

Other crates that depend on the _aggregator_ crate can also bring the `Summary` trait into scope to implement `Summary` on their own types.

Sometimes itâ€™s useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type. Then, as we implement the trait on a particular type, we can keep or override each methodâ€™s default behavior.

In Listing 8-5 we specify a default string for the `summarize` method of the `Summary` trait instead of only defining the method signature, as we did in Listing 8-2.

Filename: src/lib.cairo

```cairo hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(self: @T) -> ByteArray {
            "(Read more...)"
        }
    }

    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary<NewsArticle> {}

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize(self: @Tweet) -> ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
}

use aggregator::{Summary, NewsArticle};

fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    println!("New article available! {}", news.summarize());
}

```

Listing 8-5: Defining a `Summary` trait with a default implementation of the `summarize` method

To use a default implementation to summarize instances of `NewsArticle`, we specify an empty `impl` block with `impl NewsArticleSummary of Summary<NewsArticle> {}`.

Even though weâ€™re no longer defining the `summarize` method on `NewsArticle` directly, weâ€™ve provided a default implementation and specified that `NewsArticle` implements the `Summary` trait. As a result, we can still call the `summarize` method on an instance of `NewsArticle`, like this:

```cairo hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(self: @T) -> ByteArray {
            "(Read more...)"
        }
    }

    #[derive(Drop)]
    pub struct NewsArticle {
        pub headline: ByteArray,
        pub location: ByteArray,
        pub author: ByteArray,
        pub content: ByteArray,
    }

    impl NewsArticleSummary of Summary<NewsArticle> {}

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize(self: @Tweet) -> ByteArray {
            format!("{}: {}", self.username, self.content)
        }
    }
}

use aggregator::{Summary, NewsArticle};

fn main() {
    let news = NewsArticle {
        headline: "Cairo has become the most popular language for developers",
        location: "Worldwide",
        author: "Cairo Digger",
        content: "Cairo is a new programming language for zero-knowledge proofs",
    };

    println!("New article available! {}", news.summarize());
}

```

This code prints `New article available! (Read more...)`.

Creating a default implementation doesnâ€™t require us to change anything about the previous implementation of `Summary` on `Tweet`. The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesnâ€™t have a default implementation.

Default implementations can call other methods in the same trait, even if those other methods donâ€™t have a default implementation. In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it. For example, we could define the `Summary` trait to have a `summarize_author` method whose implementation is required, and then define a `summarize` method that has a default implementation that calls the `summarize_author` method:

```cairo hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(
            self: @T,
        ) -> ByteArray {
            format!("(Read more from {}...)", Self::summarize_author(self))
        }
        fn summarize_author(self: @T) -> ByteArray;
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize_author(self: @Tweet) -> ByteArray {
            format!("@{}", self.username)
        }
    }
}

use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}

```

To use this version of `Summary`, we only need to define `summarize_author` when we implement the trait on a type:

```cairo hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(
            self: @T,
        ) -> ByteArray {
            format!("(Read more from {}...)", Self::summarize_author(self))
        }
        fn summarize_author(self: @T) -> ByteArray;
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize_author(self: @Tweet) -> ByteArray {
            format!("@{}", self.username)
        }
    }
}

use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}

```

After we define `summarize_author`, we can call `summarize` on instances of the `Tweet` struct, and the default implementation of `summarize` will call the definition of `summarize_author` that weâ€™ve provided. Because weâ€™ve implemented `summarize_author`, the `Summary` trait has given us the behavior of the `summarize` method without requiring us to write any more code.

```cairo hljs hide-boring

mod aggregator {
    pub trait Summary<T> {
        fn summarize(
            self: @T,
        ) -> ByteArray {
            format!("(Read more from {}...)", Self::summarize_author(self))
        }
        fn summarize_author(self: @T) -> ByteArray;
    }

    #[derive(Drop)]
    pub struct Tweet {
        pub username: ByteArray,
        pub content: ByteArray,
        pub reply: bool,
        pub retweet: bool,
    }

    impl TweetSummary of Summary<Tweet> {
        fn summarize_author(self: @Tweet) -> ByteArray {
            format!("@{}", self.username)
        }
    }
}

use aggregator::{Summary, Tweet};

fn main() {
    let tweet = Tweet {
        username: "EliBenSasson",
        content: "Crypto is full of short-term maximizing projects. \n @Starknet and @StarkWareLtd are about long-term vision maximization.",
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}

```

This code prints `1 new tweet: (Read more from @EliBenSasson...)`.

Note that it isnâ€™t possible to call the default implementation from an overriding implementation of that same method.

To use traits methods, you need to make sure the correct traits/implementation(s) are imported. In some cases you might need to import not only the trait but also the implementation if they are declared in separate modules.
If `CircleGeometry` implementation was in a separate module/file named _circle_, then to define `boundary` method on `Circle` struct, we'd need to import `ShapeGeometry` trait in the _circle_ module.

If the code were to be organized into modules like in Listing 8-6 where the implementation of a trait is defined in a different module than the trait itself, explicitly importing the relevant trait or implementation would be required.

```cairo noplayground hljs

// Here T is an alias type which will be provided during implementation
pub trait ShapeGeometry<T> {
    fn boundary(self: T) -> u64;
    fn area(self: T) -> u64;
}

mod rectangle {
    // Importing ShapeGeometry is required to implement this trait for Rectangle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Rectangle {
        pub height: u64,
        pub width: u64,
    }

    // Implementation RectangleGeometry passes in <Rectangle>
    // to implement the trait for that type
    impl RectangleGeometry of ShapeGeometry<Rectangle> {
        fn boundary(self: Rectangle) -> u64 {
            2 * (self.height + self.width)
        }
        fn area(self: Rectangle) -> u64 {
            self.height * self.width
        }
    }
}

mod circle {
    // Importing ShapeGeometry is required to implement this trait for Circle
    use super::ShapeGeometry;

    #[derive(Copy, Drop)]
    pub struct Circle {
        pub radius: u64,
    }

    // Implementation CircleGeometry passes in <Circle>
    // to implement the imported trait for that type
    impl CircleGeometry of ShapeGeometry<Circle> {
        fn boundary(self: Circle) -> u64 {
            (2 * 314 * self.radius) / 100
        }
        fn area(self: Circle) -> u64 {
            (314 * self.radius * self.radius) / 100
        }
    }
}

use rectangle::Rectangle;
use circle::Circle;

fn main() {
    let rect = Rectangle { height: 5, width: 7 };
    println!("Rectangle area: {}", ShapeGeometry::area(rect)); //35
    println!("Rectangle boundary: {}", ShapeGeometry::boundary(rect)); //24

    let circ = Circle { radius: 5 };
    println!("Circle area: {}", ShapeGeometry::area(circ)); //78
    println!("Circle boundary: {}", ShapeGeometry::boundary(circ)); //31
}

```

Listing 8-6: Implementing an external trait

Note that in Listing 8-6, `CircleGeometry` and `RectangleGeometry` implementations don't need to be declared as `pub`. Indeed, `ShapeGeometry` trait, which is public, is used to print the result in the `main` function. The compiler will find the appropriate implementation for the `ShapeGeometry` public trait, regardless of the implementation visibility.

Implementations can be aliased when imported. This is most useful when you want to instantiate generic implementations with concrete types. For example, let's say we define a trait `Two` that is used to return the value `2` for a type `T`. We can write a trivial generic implementation of `Two` for all types that implement the `One` trait, simply by adding twice the value of `one` and returning it. However, in our public API, we may only want to expose the `Two` implementation for the `u8` and `u128` types.

```cairo noplayground hljs

trait Two<T> {
    fn two() -> T;
}

mod one_based {
    pub impl TwoImpl<
        T, +Copy<T>, +Drop<T>, +Add<T>, impl One: core::num::traits::One<T>,
    > of super::Two<T> {
        fn two() -> T {
            One::one() + One::one()
        }
    }
}

pub impl U8Two = one_based::TwoImpl<u8>;
pub impl U128Two = one_based::TwoImpl<u128>;

```

Listing 8-7: Using impl aliases to instantiate generic impls with concrete types

We can define the generic implementation in a private module, use an impl alias to instantiate the generic implementation for these two concrete types, and make these two implementations public, while keeping the generic implementation private and unexposed. This way, we can avoid code duplication using the generic implementation, while keeping the public API clean and simple.

> Note: This is still an experimental feature and can only be used if `experimental-features = ["negative_impls"]` is enabled in your _Scarb.toml_ file, under the `[package]` section.

Negative implementations, also known as negative traits or negative bounds, are a mechanism that allows you to express that a type does not implement a certain trait when defining the implementation of a trait over a generic type. Negative impls enable you to write implementations that are applicable only when another implementation does not exist in the current scope.

For example, let's say we have a trait `Producer` and a trait `Consumer`, and we want to define a generic behavior where all types implement the `Consumer` trait by default. However, we want to ensure that no type can be both a `Consumer` and a `Producer`. We can use negative impls to express this restriction.

In Listing 8-8, we define a `ProducerType` that implements the `Producer` trait, and two other types, `AnotherType` and `AThirdType`, which do not implement the `Producer` trait. We then use negative impls to create a default implementation of the `Consumer` trait for all types that do not implement the `Producer` trait.

```cairo hljs

#[derive(Drop)]
struct ProducerType {}

#[derive(Drop, Debug)]
struct AnotherType {}

#[derive(Drop, Debug)]
struct AThirdType {}

trait Producer<T> {
    fn produce(self: T) -> u32;
}

trait Consumer<T> {
    fn consume(self: T, input: u32);
}

impl ProducerImpl of Producer<ProducerType> {
    fn produce(self: ProducerType) -> u32 {
        42
    }
}

impl TConsumerImpl<T, +core::fmt::Debug<T>, +Drop<T>, -Producer<T>> of Consumer<T> {
    fn consume(self: T, input: u32) {
        println!("{:?} consumed value: {}", self, input);
    }
}

fn main() {
    let producer = ProducerType {};
    let another_type = AnotherType {};
    let third_type = AThirdType {};
    let production = producer.produce();

    // producer.consume(production); Invalid: ProducerType does not implement Consumer
    another_type.consume(production);
    third_type.consume(production);
}

```

Listing 8-8: Using negative impls to enforce that a type cannot implement both `Producer` and `Consumer` traits simultaneously

In the `main` function, we create instances of `ProducerType`, `AnotherType`, and `AThirdType`. We then call the `produce` method on the `producer` instance and pass the result to the `consume` method on the `another_type` and `third_type` instances. Finally, we try to call the `consume` method on the `producer` instance, which results in a compile-time error because `ProducerType` does not implement the `Consumer` trait.

> Currently, associated items are considered an experimental feature. In order to use them, you need to add the following to your `Scarb.toml` under the `[package]` section: `experimental-features = ["associated_item_constraints"]`.

In some cases, you may want to constrain the [associated items](https://book.cairo-lang.org/ch12-10-associated-items.html) of a trait based on the type of the generic parameter. You can do this using the `[AssociatedItem: ConstrainedValue]` syntax after a trait bound.

Let's say you want to implement an `extend` method for collections. This method takes an iterator and add its elements to the collection. To ensure type safety, we want the iterator's elements to match the collection's element type. We can achieve this by constraining the `Iterator::Item` associated type to match the collection's type.

In Listing 8-9, we implement this by defining a trait `Extend<T, A>` and use `[Item: A]` as a constraint on the `extend` function's trait bound. Additionally, we use the `Destruct` trait to ensure that the iterator is consumed, and show an example implementation for `Extend<Array<T>, T>`.

```cairo hljs

trait Extend<T, A> {
    fn extend<I, +core::iter::Iterator<I>[Item: A], +Destruct<I>>(ref self: T, iterator: I);
}

impl ArrayExtend<T, +Drop<T>> of Extend<Array<T>, T> {
    fn extend<I, +core::iter::Iterator<I>[Item: T], +Destruct<I>>(ref self: Array<T>, iterator: I) {
        for item in iterator {
            self.append(item);
        };
    }
}

```

Listing 8-9: Using associated items constraints to ensure that a type matches the associated type of another type

The `TypeEqual` trait from the `core::metaprogramming` module lets you create constraints based on type equality. In most of the cases, you don't need `+TypeEqual` and you can achieve the same using only generic arguments and associated type constraints, but `TypeEqual` can be useful in some advanced scenarios.

The first use case is implementing a trait for all types that match certain conditions, except for specific types. We do this using a negative implementation on the `TypeEqual` trait.

In Listing 8-10, we create a `SafeDefault` trait and implement it for any type `T` that implements `Default`. However, we exclude the `SensitiveData` type using `-TypeEqual<T, SensitiveData>`.

```cairo hljs

trait SafeDefault<T> {
    fn safe_default() -> T;
}

#[derive(Drop, Default)]
struct SensitiveData {
    secret: felt252,
}

// Implement SafeDefault for all types EXCEPT SensitiveData
impl SafeDefaultImpl<
    T, +Default<T>, -core::metaprogramming::TypeEqual<T, SensitiveData>,
> of SafeDefault<T> {
    fn safe_default() -> T {
        Default::default()
    }
}

fn main() {
    let _safe: u8 = SafeDefault::safe_default();
    let _unsafe: SensitiveData = Default::default(); // Allowed
    // This would cause a compile error:
// let _dangerous: SensitiveData = SafeDefault::safe_default();
}

```

Listing 8-10: Using the `TypeEqual` trait to exclude a specific type from an implementation

The second use case is ensuring that two types are equal, particularly useful when working with [associated types](https://book.cairo-lang.org/ch12-10-associated-items.html#associated-types).

In Listing 8-11, we show this with a `StateMachine` trait that has an associated type `State`. We create two types, `TA` and `TB`, both using `StateCounter` as their `State`. Then we implement a `combine` function that works only when both state machines have the same state type, using the bound `TypeEqual<A::State, B::State>`.

```cairo hljs

trait StateMachine {
    type State;
    fn transition(ref state: Self::State);
}

#[derive(Copy, Drop)]
struct StateCounter {
    counter: u8,
}

impl TA of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter += 1;
    }
}

impl TB of StateMachine {
    type State = StateCounter;
    fn transition(ref state: StateCounter) {
        state.counter *= 2;
    }
}

fn combine<
    impl A: StateMachine,
    impl B: StateMachine,
    +core::metaprogramming::TypeEqual<A::State, B::State>,
>(
    ref self: A::State,
) {
    A::transition(ref self);
    B::transition(ref self);
}

fn main() {
    let mut initial = StateCounter { counter: 0 };
    combine::<TA, TB>(ref initial);
}

```

Listing 8-11: Using the `TypeEqual` trait to ensure two types have matching associated types

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1694670085.1738497991&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=101509157~102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1697798884)

ðŸ’¬

ConnectedChatÃ—

SendLoading \[MathJax\]/jax/output/HTML-CSS/fonts/TeX/fontdata.js

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-10-arithmetic-circuits.md "Suggest an edit")

Arithmetic circuits are mathematical models used to represent polynomial computations. They are defined over a field (typically a finite field Fp where p is prime) and consist of:

- Input signals (values in the range \[0,pâˆ’1\])
- Arithmetic operations (addition and multiplication gates)
- Output signals

Cairo supports emulated arithmetic circuits with modulo up to 384 bits.

This is especially useful for:

- Implementing verification for other proof systems
- Implementing cryptographic primitives
- Creating more low-level programs, with potential reduced overhead compared to standard Cairo constructs

Cairo's circuit constructs are available in the `core::circuit` module of the corelib.

Arithmetic circuits consist of:

- Addition modulo p: `AddMod` builtin
- Multiplication modulo p: `MulMod` builtin

Because of the modulo properties, we can build four basic arithmetic gates:

- Addition: `AddModGate`
- Subtraction: `SubModGate`
- Multiplication: `MulModGate`
- Inverse: `InvModGate`

Let's create a circuit that computes aâ‹…(a+b) over the BN254 prime field.

We start from the empty struct `CircuitElement<T>`.

The inputs of our circuit are defined as `CircuitInput`:

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

We can combine circuit inputs and gates: `CircuitElement<a>` and `CircuitElement<b>` combined with an addition gate gives `CircuitElement<AddModGate<a, b>>`.

We can use `circuit_add`, `circuit_sub`, `circuit_mul` and `circuit_inverse` to directly combine circuit elements.
For aâˆ—(a+b), the description of our circuit is:

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

Note that `a`, `b` and `add` are intermediate circuit elements and not specifically inputs or gates, which is why we need the distinction between the empty struct `CircuitElement<T>` and the circuit description specified by the type `T`.

The outputs of the circuits are defined as a tuple of circuit elements. It's possible to add any intermediate gates of our circuit, but we must add all gates with degree 0 (gates where the output signal is not used as input of any other gate).
In our case, we will only add the last gate `mul`:

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

We now have a complete description of our circuit and its outputs.
We now need to assign a value to each input.
As circuits are defined with 384-bit modulus, a single `u384` value can be represented as a fixed array of four `u96`.
We can initialize a and b to respectively 10 and 20:

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

As the number of inputs can vary, Cairo use an accumulator and the `new_inputs` and `next` functions return a variant of the `AddInputResult` enum.

```cairo noplayground hljs

pub enum AddInputResult<C> {
    /// All inputs have been filled.
    Done: CircuitData<C>,
    /// More inputs are needed to fill the circuit instance's data.
    More: CircuitInputAccumulator<C>,
}

```

We have to assign a value to every input, by calling `next` on each `CircuitInputAccumulator` variant.
After the inputs initialization, by calling the `done` function we get the complete circuit `CircuitData<C>`, where `C` is a long type that encodes the entire circuit instance.

We then need to define what modulus our circuit is using (up to 384-bit modulus), by defining a `CircuitModulus`. We want to use BN254 prime field modulus:

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

The last part is the evaluation of the circuit, i.e. the actual process of passing the input signals correctly through each gate described by our circuit and getting the values of each output gate.
We can evaluate and get the results for a given modulus as follows:

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

To retrieve the value of a specific output, we can use the `get_output` function on our results with the `CircuitElement` instance of the output gate we want. We can also retrieve any intermediate gate value as well.

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

To recap, we did the following steps:

- Define Circuit Inputs
- Describe the circuit
- Specify the outputs
- Assign values to the inputs
- Define the modulus
- Evaluate the circuit
- Get the output values

And the full code is:

```cairo noplayground hljs hide-boring

use core::circuit::{
    CircuitElement, CircuitInput, circuit_add, circuit_mul, EvalCircuitTrait, CircuitOutputsTrait,
    CircuitModulus, AddInputResultTrait, CircuitInputs, u384,
};

// Circuit: a * (a + b)
// witness: a = 10, b = 20
// expected output: 10 * (10 + 20) = 300
fn eval_circuit() -> (u384, u384) {
    let a = CircuitElement::<CircuitInput<0>> {};
    let b = CircuitElement::<CircuitInput<1>> {};

    let add = circuit_add(a, b);
    let mul = circuit_mul(a, add);

    let output = (mul,);

    let mut inputs = output.new_inputs();
    inputs = inputs.next([10, 0, 0, 0]);
    inputs = inputs.next([20, 0, 0, 0]);

    let instance = inputs.done();

    let bn254_modulus = TryInto::<
        _, CircuitModulus,
    >::try_into([0x6871ca8d3c208c16d87cfd47, 0xb85045b68181585d97816a91, 0x30644e72e131a029, 0x0])
        .unwrap();

    let res = instance.eval(bn254_modulus).unwrap();

    let add_output = res.get_output(add);
    let circuit_output = res.get_output(mul);

    assert(add_output == u384 { limb0: 30, limb1: 0, limb2: 0, limb3: 0 }, 'add_output');
    assert(circuit_output == u384 { limb0: 300, limb1: 0, limb2: 0, limb3: 0 }, 'circuit_output');

    (add_output, circuit_output)
}

fn main() {
    eval_circuit();
}

```

In zero-knowledge proof systems, a prover creates a proof of computational statements, which a verifier can check without performing the full computation. However, these statements must first be converted into a suitable representation for the proof system.

Some proof systems, like zk-SNARKs, use arithmetic circuits over a finite field Fp. These circuits include constraints at specific gates, represented as equations:

(a1â‹…s1+...+anâ‹…sn)â‹…(b1â‹…s1+...+bnâ‹…sn)+(c1â‹…s1+...+cnâ‹…sn)=0modp
Where s1,...,sn are signals, and ai,bi,ci are coefficients.

A witness is an assignment of signals that satisfies all constraints in a circuit. zk-SNARK proofs use these properties to prove knowledge of a witness without revealing private input signals, ensuring the prover's honesty while preserving privacy.

Some work has already been done, such as [Garaga Groth16 verifier](https://felt.gitbook.io/garaga/deploy-your-snark-verifier-on-starknet/groth16/generate-and-deploy-your-verifier-contract)

STARKs (which Cairo uses) use an Algebraic Intermediate Representation (AIR) instead of arithmetic circuits. AIR describes computations as a set of polynomial constraints.

By allowing emulated arithmetic circuits, Cairo can be used to implement zk-SNARKs proof verification inside STARK proofs.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1167901393.1738497996&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1413462909)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-00-getting-started.md "Suggest an edit")

Letâ€™s start your Cairo journey! Thereâ€™s a lot to learn, but every journey starts somewhere. In this chapter, weâ€™ll discuss:

- Installing Scarb, which is Cairo's build toolchain and package manager, on Linux, macOS, and Windows.
- Installing Starknet Foundry, which is the default test runnner when creating a Cairo project.
- Writing a program that prints `Hello, world!`.
- Using basic Scarb commands to create a project and execute a program.

If you have any questions about Starknet or Cairo, you can ask them in the [Starknet Discord server](https://discord.gg/starknet-community). The community is friendly and always willing to help.

Starknet proposes its own AI agent designed to assist with Cairo and Starknet-related questions. This AI agent is trained on the Cairo book and the Starknet documentation, using Retrieval-Augmented Generation (RAG) to efficiently retrieve information and provide accurate assistance.

You can find the Starknet Agent on the [Starknet Agent](https://agent.starknet.id/) website.

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1842961803.1738497997&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=101509157~102015666~102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556565&z=1463825259)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch06-01-enums.md "Suggest an edit")

Enums, short for "enumerations," are a way to define a custom data type that consists of a fixed set of named values, called _variants_. Enums are useful for representing a collection of related values where each value is distinct and has a specific meaning.

Here's a simple example of an enum:

```cairo noplayground hljs

#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}

```

In this example, we've defined an enum called `Direction` with four variants: `North`, `East`, `South`, and `West`. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the `Direction` type. In this particular example, variants don't have any associated value. One variant can be instantiated using this syntax:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}

fn main() {
    let direction = Direction::North;
}

```

Now let's imagine that our variants have associated values, that store the exact degree of the direction. We can define a new `Direction` enum:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}

fn main() {
    let direction = Direction::North(10);
}

```

and instantiate it as follows:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}

fn main() {
    let direction = Direction::North(10);
}

```

In this code, each variant is associated with a `u128` value, representing the direction in degrees. In the next example, we will see that it is also possible to associate different data types with each variant.

It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a direction. You can learn more about it in the [Match Control Flow Construct](https://book.cairo-lang.org/ch06-02-the-match-control-flow-construct.html) section.

Enums can also be used to store more interesting custom data associated with each variant. For example:

```cairo noplayground hljs

#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}

```

In this example, the `Message` enum has three variants: `Quit`, `Echo`, and `Move`, all with different types:

- `Quit` doesn't have any associated value.
- `Echo` is a single `felt252`.
- `Move` is a tuple of two `u128` values.

You could even use a Struct or another enum you defined inside one of your enum variants.

In Cairo, you can define traits and implement them for your custom enums. This allows you to define methods and behaviors associated with the enum. Here's an example of defining a trait and implementing it for the previous `Message` enum:

```cairo noplayground hljs

trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit => { println!("quitting") },
            Message::Echo(value) => { println!("echoing {}", value) },
            Message::Move((x, y)) => { println!("moving from {} to {}", x, y) },
        }
    }
}

```

In this example, we implemented the `Processing` trait for `Message`. Here is how it could be used to process a `Quit` message:

```cairo hljs hide-boring

#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}

trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit => { println!("quitting") },
            Message::Echo(value) => { println!("echoing {}", value) },
            Message::Move((x, y)) => { println!("moving from {} to {}", x, y) },
        }
    }
}
fn main() {
    let msg: Message = Message::Quit;
    msg.process(); // prints "quitting"
}

```

The `Option` enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: `Some: T` and `None`. `Some: T` indicates that there's a value of type `T`, while `None` represents the absence of a value.

```cairo noplayground hljs

enum Option<T> {
    Some: T,
    None,
}

```

The `Option` enum is helpful because it allows you to explicitly represent the possibility of a value being absent, making your code more expressive and easier to reason about. Using `Option` can also help prevent bugs caused by using uninitialized or unexpected `null` values.

To give you an example, here is a function which returns the index of the first element of an array with a given value, or `None` if the element is not present.

We are demonstrating two approaches for the above function:

- Recursive approach with `find_value_recursive`.
- Iterative approach with `find_value_iterative`.

```cairo noplayground hljs

fn find_value_recursive(mut arr: Span<felt252>, value: felt252, index: usize) -> Option<usize> {
    match arr.pop_front() {
        Option::Some(index_value) => { if (*index_value == value) {
            return Option::Some(index);
        } },
        Option::None => { return Option::None; },
    };

    find_value_recursive(arr, value, index + 1)
}

fn find_value_iterative(mut arr: Span<felt252>, value: felt252) -> Option<usize> {
    let mut result = Option::None;
    let mut index = 0;

    while let Option::Some(array_value) = arr.pop_front() {
        if (*array_value == value) {
            result = Option::Some(index);
            break;
        };

        index += 1;
    };

    result
}

```

Enums can be useful in many situations, especially when using the `match` flow construct that we just used. We will describe it in the next section.

Other enums are used very often, such as the `Result` enum, allowing to handle errors gracefully. We will explain the `Result` enum in detail in the ["Error Handling"](https://book.cairo-lang.org/ch09-02-recoverable-errors.html#the-result-enum) chapter.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=83569924.1738497998&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=793706661)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch10-02-test-organization.md "Suggest an edit")

We'll think about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private functions. Integration tests use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.

Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.

The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isnâ€™t working as expected. Youâ€™ll put unit tests in the `src` directory in each file with the code that theyâ€™re testing.

The convention is to create a module named `tests` in each file to contain the test functions and to annotate the module with `#[cfg(test)]` attribute.

The `#[cfg(test)]` annotation on the tests module tells Cairo to compile and run the test code only when you run `scarb test`, not when you run `scarb build`. This saves compile time when you only want to build the project and saves space in the resulting compiled artifact because the tests are not included. Youâ€™ll see that because integration tests go in a different directory, they donâ€™t need the `#[cfg(test)]` annotation. However, because unit tests go in the same files as the code, youâ€™ll use `#[cfg(test)]` to specify that they shouldnâ€™t be included in the compiled result.

Recall that when we created the new `adder` project in the first section of this chapter, we wrote this first test:

```cairo hljs

pub fn add(left: usize, right: usize) -> usize {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}

```

The attribute `cfg` stands for _configuration_ and tells Cairo that the following item should only be included given a certain configuration option. In this case, the configuration option is `test`, which is provided by Cairo for compiling and running tests. By using the `cfg` attribute, Cairo compiles our test code only if we actively run the tests with `scarb test`. This includes any helper functions that might be within this module, in addition to the functions annotated with `#[test]`.

Thereâ€™s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Cairo's privacy rules do allow you to test private functions. Consider the code below with the private function `internal_adder`.

Filename: src/lib.cairo

```cairo noplayground hljs

pub fn add(a: u32, b: u32) -> u32 {
    internal_adder(a, 2)
}

fn internal_adder(a: u32, b: u32) -> u32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add() {
        assert_eq!(4, internal_adder(2, 2));
    }
}

```

Listing 10-10: Testing a private function

Note that the `internal_adder` function is not marked as `pub`. Tests are just Cairo code, and the tests module is just another module. As we discussed in the ["Paths for Referring to an Item in the Module Tree"](https://book.cairo-lang.org/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html) section, items in child modules can use the items in their ancestor modules. In this test, we bring the `tests` moduleâ€™s parent `internal_adder` into scope with `use super::internal_adder;` and then the test can call `internal_adder`. If you donâ€™t think private functions should be tested, thereâ€™s nothing in Cairo that will compel you to do so.

Integration tests use your library in the same way any other code would. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a _tests_ directory.

We create a _tests_ directory at the top level of our project directory, next to _src_. Scarb knows to look for integration test files in this directory. We can then make as many test files as we want, and Scarb will compile each of the files as an individual crate.

Letâ€™s create an integration test. With the code in Listing 10-10 still in the _src/lib.cairo_ file, make a _tests_ directory, and create a new file named _tests/integration\_test.cairo_. Your directory structure should look like this:

```shell hljs

adder
â”œâ”€â”€ Scarb.lock
â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â””â”€â”€ lib.cairo
â””â”€â”€ tests
    â””â”€â”€ integration_tests.cairo

```

Enter the code in Listing 10-11 into the _tests/integration\_test.cairo_ file:

Filename: tests/integration\_tests.cairo

```cairo noplayground hljs

use adder::add_two;

#[test]
fn it_adds_two() {
    assert_eq!(4, add_two(2));
}

```

Listing 10-11: An integration test of a function in the `adder` crate

Each file in the `tests` directory is a separate crate, so we need to bring our library into each test crateâ€™s scope. For that reason we add `use adder::add_two` at the top of the code, which we didnâ€™t need in the unit tests.

We donâ€™t need to annotate any code in _tests/integration\_test.cairo_ with `#[cfg(test)]`. Scarb treats the tests directory specially and compiles files in this directory only when we run `scarb test`. Run `scarb test` now:

```shell hljs

$ scarb test
     Running test adder (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Blocking waiting for file lock on build directory
    Finished `release` profile [optimized] target(s) in 0.88s
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
    Finished `dev` profile target(s) in 9 seconds

Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::it_adds_two (gas: ~1)
Running 1 test(s) from src/
[PASS] adder::tests::internal (gas: ~1)
Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

```

The two sections of output include the unit tests and the integration tests. Note that if any test in a section fails, the following sections will not be run. For example, if a unit test fails, there wonâ€™t be any output for integration tests because those tests will only be run if all unit tests are passing.

The first displayed section is for the integration tests.
Each integration test file has its own section, so if we add more files in the _tests_ directory, there will be more integration test sections.

The second displayed section is the same as weâ€™ve been seeing: one line for each unit test (one named add that we added just above) and then a summary line for the unit tests.

We can still run a particular integration test function by specifying the test functionâ€™s name as an argument of the option -f to `scarb test` like for instance `scarb test -f integration_tests::internal`. To run all the tests in a particular integration test file, we use the same option of `scarb test` but using only the name of the file.

Then, to run all of our integration tests, we can just add a filter to only run tests whose path contains _integration\_tests_.

```shell hljs

$ scarb test -f integration_tests
     Running cairo-test adder
   Compiling test(adder_unittest) adder v0.1.0 (cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
   Compiling test(adder_integration_tests) adder_integration_tests v0.1.0 (cairo-book/listings/ch10-testing-cairo-programs/no_listing_09_integration_test/Scarb.toml)
    Finished release target(s) in 7 seconds
testing adder ...
running 1 test
test adder_integration_tests::integration_tests::internal ... ok (gas usage est.: 23110)
test result: ok. 1 passed; 0 failed; 0 ignored; 0 filtered out;

running 0 tests
test result: ok. 0 passed; 0 failed; 0 ignored; 1 filtered out;

```

We see that in the second section for the unit tests, 1 has been filtered out because it is not in the _integration\_tests_ file.

As you add more integration tests, you might want to make more files in the _tests_ directory to help organize them; for example, you can group the test functions by the functionality theyâ€™re testing. As mentioned earlier, each file in the tests directory is compiled as its own separate crate, which is useful for creating separate scopes to more closely imitate the way end users will be using your crate. However, this means files in the tests directory donâ€™t share the same behavior as files in _src_ do, as you learned in Chapter 7 regarding how to separate code into modules and files.

The different behavior of tests directory files is most noticeable when you have a set of helper functions to use in multiple integration test files and you try to follow the steps in the [Separating Modules into Different Files](https://book.cairo-lang.org/ch07-05-separating-modules-into-different-files.html) section of Chapter 7 to extract them into a common module. For example, if we create _tests/common.cairo_ and place a function named `setup` in it, we can add some code to `setup` that we want to call from multiple test functions in multiple test files:

Filename: tests/common.cairo

```cairo noplayground hljs

pub fn setup() {
    println!("Setting up tests...");
}

```

Filename: tests/integration\_tests.cairo

```cairo noplayground hljs

use adder::it_adds_two;

#[test]
fn internal() {
    assert!(it_adds_two(2, 2) == 4, "internal_adder failed");
}

```

Filename: src/lib.cairo

```cairo noplayground hljs

pub fn it_adds_two(a: u8, b: u8) -> u8 {
    a + b
}

#[cfg(test)]
mod tests {
    #[test]
    fn add() {
        assert_eq!(4, super::it_adds_two(2, 2));
    }
}

```

When we run the tests with `scarb test`, weâ€™ll see a new section in the test output for the _common.cairo_ file, even though this file doesnâ€™t contain any test functions nor did we call the setup function from anywhere:

```shell hljs

$ scarb test
     Running test adder (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Finished `release` profile [optimized] target(s) in 0.64s
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_12_submodules/Scarb.toml)
    Finished `dev` profile target(s) in 8 seconds

Collected 2 test(s) from adder package
Running 1 test(s) from src/
[PASS] adder::tests::add (gas: ~1)
Running 1 test(s) from tests/
[PASS] adder_integrationtest::integration_tests::internal (gas: ~1)
Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

```

To avoid systematically getting a section for each file of the _tests_ folder, we also have the option of making the `tests/` directory behave like a regular crate, by adding a `tests/lib.cairo` file. In that case, the `tests` directory will no longer compile as one crate per file, but as one crate for the whole directory.

Let's create this _tests/lib.cairo_ file :

Filename: tests/lib.cairo

```cairo noplayground hljs

mod integration_tests;
mod common;

```

The project directory will now look like this :

```shell hljs

adder
â”œâ”€â”€ Scarb.lock
â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â””â”€â”€ lib.cairo
â””â”€â”€ tests
    â”œâ”€â”€ common.cairo
    â”œâ”€â”€ integration_tests.cairo
    â””â”€â”€ lib.cairo

```

When we run the `scarb test` command again, here is the output :

```shell hljs

$ scarb test
     Running test adder (snforge test)
   Compiling snforge_scarb_plugin v0.31.0 (git+https://github.com/foundry-rs/starknet-foundry.git?tag=v0.31.0#72ea785ca354e9e506de3e5d687da9fb2c1b3c67)
    Finished `release` profile [optimized] target(s) in 0.51s
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
   Compiling test(listings/ch10-testing-cairo-programs/no_listing_13_single_integration_crate/Scarb.toml)
    Finished `dev` profile target(s) in 7 seconds

Collected 2 test(s) from adder package
Running 1 test(s) from tests/
[PASS] adder_tests::integration_tests::internal (gas: ~1)
Running 1 test(s) from src/
[PASS] adder::tests::add (gas: ~1)
Tests: 2 passed, 0 failed, 0 skipped, 0 ignored, 0 filtered out

```

This way, only the test functions will be tested and the `setup` function can be imported without being tested.

Cairo's testing features provide a way to specify how code should function to ensure it continues to work as you expect, even as you make changes. Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the libraryâ€™s public API to test the code in the same way external code will use it. Even though Cairo's type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1138030675.1738497998&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015666~102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=177428828)

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=318667980.1738497999&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566~102558063&z=105989973)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-02-dictionaries.md "Suggest an edit")

Cairo provides in its core library a dictionary-like type. The `Felt252Dict<T>` data type represents a collection of key-value pairs where each key is unique and associated with a corresponding value. This type of data structure is known differently across different programming languages such as maps, hash tables, associative arrays and many others.

The `Felt252Dict<T>` type is useful when you want to organize your data in a certain way for which using an `Array<T>` and indexing doesn't suffice. Cairo dictionaries also allow the programmer to easily simulate the existence of mutable memory when there is none.

It is normal in other languages when creating a new dictionary to define the data types of both key and value. In Cairo, the key type is restricted to `felt252`, leaving only the possibility to specify the value data type, represented by `T` in `Felt252Dict<T>`.

The core functionality of a `Felt252Dict<T>` is implemented in the trait `Felt252DictTrait` which includes all basic operations. Among them we can find:

1. `insert(felt252, T) -> ()` to write values to a dictionary instance and
2. `get(felt252) -> T` to read values from it.

These functions allow us to manipulate dictionaries like in any other language. In the following example, we create a dictionary to represent a mapping between individuals and their balance:

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();

    balances.insert('Alex', 100);
    balances.insert('Maria', 200);

    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Balance is not 100");

    let maria_balance = balances.get('Maria');
    assert!(maria_balance == 200, "Balance is not 200");
}

```

We can create a new instance of `Felt252Dict<u64>` by using the `default` method of the `Default` trait and add two individuals, each one with their own balance, using the `insert` method. Finally, we check the balance of our users with the `get` method. These methods are defined in the `Felt252DictTrait` trait in the core library.

Throughout the book we have talked about how Cairo's memory is immutable, meaning you can only write to a memory cell once but the `Felt252Dict<T>` type represents a way to overcome this obstacle. We will explain how this is implemented later on in ["Dictionaries Underneath"](https://book.cairo-lang.org/ch03-02-dictionaries.html#dictionaries-underneath).

Building upon our previous example, let us show a code example where the balance of the same user changes:

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();

    // Insert Alex with 100 balance
    balances.insert('Alex', 100);
    // Check that Alex has indeed 100 associated with him
    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Alex balance is not 100");

    // Insert Alex again, this time with 200 balance
    balances.insert('Alex', 200);
    // Check the new balance is correct
    let alex_balance_2 = balances.get('Alex');
    assert!(alex_balance_2 == 200, "Alex balance is not 200");
}

```

Notice how in this example we added the 'Alex' individual twice, each time using a different balance and each time that we checked for its balance it had the last value inserted! `Felt252Dict<T>` effectively allows us to "rewrite" the stored value for any given key.

Before heading on and explaining how dictionaries are implemented it is worth mentioning that once you instantiate a `Felt252Dict<T>`, behind the scenes all keys have their associated values initialized as zero. This means that if for example, you tried to get the balance of an inexistent user you will get 0 instead of an error or an undefined value. This also means there is no way to delete data from a dictionary. Something to take into account when incorporating this structure into your code.

Until this point, we have seen all the basic features of `Felt252Dict<T>` and how it mimics the same behavior as the corresponding data structures in any other language, that is, externally of course. Cairo is at its core a non-deterministic Turing-complete programming language, very different from any other popular language in existence, which as a consequence means that dictionaries are implemented very differently as well!

In the following sections, we are going to give some insights about `Felt252Dict<T>` inner mechanisms and the compromises that were taken to make them work. After that, we are going to take a look at how to use dictionaries with other data structures as well as use the `entry` method as another way to interact with them.

One of the constraints of Cairo's non-deterministic design is that its memory system is immutable, so in order to simulate mutability, the language implements `Felt252Dict<T>` as a list of entries. Each of the entries represents a time when a dictionary was accessed for reading/updating/writing purposes. An entry has three fields:

1. A `key` field that identifies the key for this key-value pair of the dictionary.
2. A `previous_value` field that indicates which previous value was held at `key`.
3. A `new_value` field that indicates the new value that is held at `key`.

If we try implementing `Felt252Dict<T>` using high-level structures we would internally define it as `Array<Entry<T>>` where each `Entry<T>` has information about what key-value pair it represents and the previous and new values it holds. The definition of `Entry<T>` would be:

```cairo noplayground hljs

struct Entry<T> {
    key: felt252,
    previous_value: T,
    new_value: T,
}

```

For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be registered:

- A `get` would register an entry where there is no change in state, and previous and new values are stored with the same value.
- An `insert` would register a new `Entry<T>` where the `new_value` would be the element being inserted, and the `previous_value` the last element inserted before this. In case it is the first entry for a certain key, then the previous value will be zero.

The use of this entry list shows how there isn't any rewriting, just the creation of new memory cells per `Felt252Dict<T>` interaction. Let's show an example of this using the `balances` dictionary from the previous section and inserting the users 'Alex' and 'Maria':

```cairo hljs hide-boring

use core::dict::Felt252Dict;

struct Entry<T> {
    key: felt252,
    previous_value: T,
    new_value: T,
}

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();
    balances.insert('Alex', 100_u64);
    balances.insert('Maria', 50_u64);
    balances.insert('Alex', 200_u64);
    balances.get('Maria');
}

```

These instructions would then produce the following list of entries:

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 100 |
| Maria | 0 | 50 |
| Alex | 100 | 200 |
| Maria | 50 | 50 |

Notice that since 'Alex' was inserted twice, it appears twice and the `previous` and `current` values are set properly. Also reading from 'Maria' registered an entry with no change from previous to current values.

This approach to implementing `Felt252Dict<T>` means that for each read/write operation, there is a scan for the whole entry list in search of the last entry with the same `key`. Once the entry has been found, its `new_value` is extracted and used on the new entry to be added as the `previous_value`. This means that interacting with `Felt252Dict<T>` has a worst-case time complexity of `O(n)` where `n` is the number of entries in the list.

If you pour some thought into alternate ways of implementing `Felt252Dict<T>` you'd surely find them, probably even ditching completely the need for a `previous_value` field, nonetheless, since Cairo is not your normal language this won't work.
One of the purposes of Cairo is, with the STARK proof system, to generate proofs of computational integrity. This means that you need to verify that program execution is correct and inside the boundaries of Cairo restrictions. One of those boundary checks consists of "dictionary squashing" and that requires information on both previous and new values for every entry.

To verify that the proof generated by a Cairo program execution that used a `Felt252Dict<T>` is correct, we need to check that there wasn't any illegal tampering with the dictionary. This is done through a method called `squash_dict` that reviews each entry of the entry list and checks that access to the dictionary remains coherent throughout the execution.

The process of squashing is as follows: given all entries with certain key `k`, taken in the same order as they were inserted, verify that the ith entry `new_value` is equal to the ith + 1 entry `previous_value`.

For example, given the following entry list:

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 150 |
| Maria | 0 | 100 |
| Charles | 0 | 70 |
| Maria | 100 | 250 |
| Alex | 150 | 40 |
| Alex | 40 | 300 |
| Maria | 250 | 190 |
| Alex | 300 | 90 |

After squashing, the entry list would be reduced to:

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 90 |
| Maria | 0 | 190 |
| Charles | 0 | 70 |

In case of a change on any of the values of the first table, squashing would have failed during runtime.

If you run the examples from ["Basic Use of Dictionaries"](https://book.cairo-lang.org/ch03-02-dictionaries.html#basic-use-of-dictionaries) section, you'd notice that there was never a call to squash dictionary, but the program compiled successfully nonetheless. What happened behind the scene was that squash was called automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` trait. This call occurred just before the `balance` dictionary went out of scope.

The `Destruct<T>` trait represents another way of removing instances out of scope apart from `Drop<T>`. The main difference between these two is that `Drop<T>` is treated as a no-op operation, meaning it does not generate new CASM while `Destruct<T>` does not have this restriction. The only type which actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these traits in [Drop and Destruct](https://book.cairo-lang.org/appendix-03-derivable-traits.html#drop-and-destruct) section of Appendix C.

Later in ["Dictionaries as Struct Members"](https://book.cairo-lang.org/ch12-01-custom-data-structures.html#dictionaries-as-struct-members) section, we will have a hands-on example where we implement the `Destruct<T>` trait for a custom type.

Up to this point, we have given a comprehensive overview of the functionality of `Felt252Dict<T>` as well as how and why it is implemented in a certain way. If you haven't understood all of it, don't worry because in this section we will have some more examples using dictionaries.

We will start by explaining the `entry` method which is part of a dictionary basic functionality included in `Felt252DictTrait<T>` which we didn't mention at the beginning. Soon after, we will see examples of how to use `Felt252Dict<T>` with other [complex types](https://book.cairo-lang.org/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively) such as `Array<T>`.

In the ["Dictionaries Underneath"](https://book.cairo-lang.org/ch03-02-dictionaries.html#dictionaries-underneath) section, we explained how `Felt252Dict<T>` internally worked. It was a list of entries for each time the dictionary was accessed in any manner. It would first find the last entry given a certain `key` and then update it accordingly to whatever operation it was executing. The Cairo language gives us the tools to replicate this ourselves through the `entry` and `finalize` methods.

The `entry` method comes as part of `Felt252DictTrait<T>` with the purpose of creating a new entry given a certain key. Once called, this method takes ownership of the dictionary and returns the entry to update. The method signature is as follows:

```cairo noplayground hljs

fn entry(self: Felt252Dict<T>, key: felt252) -> (Felt252DictEntry<T>, T) nopanic

```

The first input parameter takes ownership of the dictionary while the second one is used to create the appropriate entry. It returns a tuple containing a `Felt252DictEntry<T>`, which is the type used by Cairo to represent dictionary entries, and a `T` representing the value held previously.
The `nopanic` notation simply indicates that the function is guaranteed to never panic.

The next thing to do is to update the entry with the new value. For this, we use the `finalize` method which inserts the entry and returns ownership of the dictionary:

```cairo noplayground hljs

fn finalize(self: Felt252DictEntry<T>, new_value: T) -> Felt252Dict<T>

```

This method receives the entry and the new value as parameters, and returns the updated dictionary.

Let us see an example using `entry` and `finalize`. Imagine we would like to implement our own version of the `get` method from a dictionary. We should then do the following:

1. Create the new entry to add using the `entry` method.
2. Insert back the entry where the `new_value` equals the `previous_value`.
3. Return the value.

Implementing our custom get would look like this:

```cairo noplayground hljs

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get<T, +Felt252DictValue<T>, +Drop<T>, +Copy<T>>(
    ref dict: Felt252Dict<T>, key: felt252,
) -> T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}

```

The `ref` keyword means that the ownership of the variable will be given back at the end of
the function. This concept will be explained in more detail in the ["References and Snapshots"](https://book.cairo-lang.org/ch04-02-references-and-snapshots.html) section.

Implementing the `insert` method would follow a similar workflow, except for inserting a new value when finalizing. If we were to implement it, it would look like the following:

```cairo noplayground hljs

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_insert<T, +Felt252DictValue<T>, +Destruct<T>, +Drop<T>>(
    ref dict: Felt252Dict<T>, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}

```

As a finalizing note, these two methods are implemented in a similar way to how `insert` and `get` are implemented for `Felt252Dict<T>`. This code shows some example usage:

```cairo hljs hide-boring

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get<T, +Felt252DictValue<T>, +Drop<T>, +Copy<T>>(
    ref dict: Felt252Dict<T>, key: felt252,
) -> T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}

fn custom_insert<T, +Felt252DictValue<T>, +Destruct<T>, +Drop<T>>(
    ref dict: Felt252Dict<T>, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}

fn main() {
    let mut dict: Felt252Dict<u64> = Default::default();

    custom_insert(ref dict, '0', 100);

    let val = custom_get(ref dict, '0');

    assert!(val == 100, "Expecting 100");
}

```

One restriction of `Felt252Dict<T>` that we haven't talked about is the trait `Felt252DictValue<T>`.
This trait defines the `zero_default` method which is the one that gets called when a value does not exist in the dictionary.
This is implemented by some common data types, such as most unsigned integers, `bool` and `felt252` \- but it is not implemented for more complex types such as arrays, structs (including `u256`), and other types from the core library.
This means that making a dictionary of types not natively supported is not a straightforward task, because you would need to write a couple of trait implementations in order to make the data type a valid dictionary value type.
To compensate this, you can wrap your type inside a `Nullable<T>`.

`Nullable<T>` is a smart pointer type that can either point to a value or be `null` in the absence of value. It is usually used in Object Oriented Programming Languages when a reference doesn't point anywhere. The difference with `Option` is that the wrapped value is stored inside a `Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to use a dedicated `boxed_segment` memory segment for our data, and access this segment using a pointer that can only be manipulated in one place at a time. See [Smart Pointers Chapter](https://book.cairo-lang.org/ch12-02-smart-pointers.html) for more information.

Let's show using an example. We will try to store a `Span<felt252>` inside a dictionary. For that, we will use `Nullable<T>` and `Box<T>`. Also, we are storing a `Span<T>` and not an `Array<T>` because the latter does not implement the `Copy<T>` trait which is required for reading from a dictionary.

```cairo noplayground hljs

use core::dict::Felt252Dict;
use core::nullable::{NullableTrait, match_nullable, FromNullableResult};

fn main() {
    // Create the dictionary
    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

//...

```

In this code snippet, the first thing we did was to create a new dictionary `d`. We want it to hold a `Nullable<Span>`. After that, we created an array and filled it with values.

The last step is inserting the array as a span inside the dictionary. Notice that we do this using the `new` function of the `NullableTrait`.

Once the element is inside the dictionary, and we want to get it, we follow the same steps but in reverse order. The following code shows how to achieve that:

```cairo noplayground hljs

//...

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value found"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

```

Here we:

1. Read the value using `get`.
2. Verified it is non-null using the `match_nullable` function.
3. Unwrapped the value inside the box and asserted it was correct.

The complete script would look like this:

```cairo hljs

use core::dict::Felt252Dict;
use core::nullable::{NullableTrait, match_nullable, FromNullableResult};

fn main() {
    // Create the dictionary
    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value found"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

```

In the previous section, we explored how to store and retrieve complex types inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a look at how to store an array inside a dictionary and dynamically modify its contents.

Storing arrays in dictionaries in Cairo is slightly different from storing other types. This is because arrays are more complex data structures that require special handling to avoid issues with memory copying and references.

First, let's look at how to create a dictionary and insert an array into it. This process is pretty straightforward and follows a similar pattern to inserting other types of data:

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array inserted successfully.");
}

```

However, attempting to read an array from the dictionary using the `get` method will result in a compiler error. This is because `get` tries to copy the array in memory, which is not possible for arrays (as we've already mentioned in the [previous section](https://book.cairo-lang.org/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively), `Array<T>` does not implement the `Copy<T>` trait):

```cairo hljs

use core::nullable::{match_nullable, FromNullableResult};
use core::dict::Felt252Dict;

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array: {:?}", get_array_entry(ref dict, 0));
}

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let val = dict.get(0); // This will cause a compiler error
    let arr = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value!"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };
    arr.span()
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)
error: Trait has no implementation in context: core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>.
 --> listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:13:20
    let val = dict.get(0); // This will cause a compiler error
                   ^*^

error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error
error: `scarb metadata` exited with error

```

To correctly read an array from the dictionary, we need to use dictionary entries. This allows us to get a reference to the array value without copying it:

```cairo noplayground hljs

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

```

> Note: We must convert the array to a `Span` before finalizing the entry, because calling `NullableTrait::new(arr)` moves the array, thus making it impossible to return it from the function.

To modify the stored array, such as appending a new value, we can use a similar approach. The following `append_value` function demonstrates this:

```cairo noplayground hljs

fn append_value(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

```

In the `append_value` function, we access the dictionary entry, dereference the array, append the new value, and finalize the entry with the updated array.

> Note: Removing an item from a stored array can be implemented in a similar manner.

Below is the complete example demonstrating the creation, insertion, reading, and modification of an array in a dictionary:

```cairo hljs

use core::nullable::NullableTrait;
use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn append_value(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Before insertion: {:?}", get_array_entry(ref dict, 0));

    append_value(ref dict, 0, 30);

    println!("After insertion: {:?}", get_array_entry(ref dict, 0));
}

```

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch06-01-enums.md "Suggest an edit")

Enum, singkatan dari "enumerations," adalah cara untuk mendefinisikan tipe data kustom yang terdiri dari set tetap dari nilai-nilai yang diberi nama, disebut _variants_. Enum berguna untuk merepresentasikan kumpulan nilai terkait di mana setiap nilai bersifat berbeda dan memiliki makna tertentu.

Berikut adalah contoh sederhana dari sebuah enum:

```cairo noplayground hljs

#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}

```

In this example, we've defined an enum called `Direction` with four variants: `North`, `East`, `South`, and `West`. The naming convention is to use PascalCase for enum variants. Each variant represents a distinct value of the `Direction` type. In this particular example, variants don't have any associated value. One variant can be instantiated using this syntax:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North,
    East,
    South,
    West,
}

fn main() {
    let direction = Direction::North;
}

```

Now let's imagine that our variants have associated values, that store the exact degree of the direction. We can define a new `Direction` enum:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}

fn main() {
    let direction = Direction::North(10);
}

```

and instantiate it as follows:

```cairo noplayground hljs hide-boring

#[derive(Drop)]
enum Direction {
    North: u128,
    East: u128,
    South: u128,
    West: u128,
}

fn main() {
    let direction = Direction::North(10);
}

```

In this code, each variant is associated with a `u128` value, representing the direction in degrees. In the next example, we will see that it is also possible to associate different data types with each variant.

It's easy to write code that acts differently depending on the variant of an enum instance, in this example to run specific code according to a direction. You can learn more about it in the [Match Control Flow Construct](https://book.cairo-lang.org/id/ch06-02-the-match-control-flow-construct.html) section.

Enums can also be used to store more interesting custom data associated with each variant. For example:

```cairo noplayground hljs

#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}

```

In this example, the `Message` enum has three variants: `Quit`, `Echo`, and `Move`, all with different types:

- `Quit` tidak memiliki nilai terkait.
- `Echo` is a single `felt252`.
- `Move` is a tuple of two `u128` values.

You could even use a Struct or another enum you defined inside one of your enum variants.

Di Cairo, Anda dapat mendefinisikan trait dan mengimplementasikannya untuk enum kustom Anda. Ini memungkinkan Anda mendefinisikan metode dan perilaku yang terkait dengan enum tersebut. Berikut adalah contoh mendefinisikan trait dan mengimplementasikannya untuk enum `Message` sebelumnya:

```cairo noplayground hljs

trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit => { println!("quitting") },
            Message::Echo(value) => { println!("echoing {}", value) },
            Message::Move((x, y)) => { println!("moving from {} to {}", x, y) },
        }
    }
}

```

In this example, we implemented the `Processing` trait for `Message`. Here is how it could be used to process a `Quit` message:

```cairo hljs hide-boring

#[derive(Drop)]
enum Message {
    Quit,
    Echo: felt252,
    Move: (u128, u128),
}

trait Processing {
    fn process(self: Message);
}

impl ProcessingImpl of Processing {
    fn process(self: Message) {
        match self {
            Message::Quit => { println!("quitting") },
            Message::Echo(value) => { println!("echoing {}", value) },
            Message::Move((x, y)) => { println!("moving from {} to {}", x, y) },
        }
    }
}
fn main() {
    let msg: Message = Message::Quit;
    msg.process(); // prints "quitting"
}

```

The `Option` enum is a standard Cairo enum that represents the concept of an optional value. It has two variants: `Some: T` and `None`. `Some: T` indicates that there's a value of type `T`, while `None` represents the absence of a value.

```cairo noplayground hljs

enum Option<T> {
    Some: T,
    None,
}

```

Enum `Option` berguna karena memungkinkan Anda secara eksplisit mewakili kemungkinan nilai yang tidak ada, membuat kode Anda lebih ekspresif dan lebih mudah untuk dipahami. Penggunaan `Option` juga dapat membantu mencegah bug yang disebabkan oleh penggunaan nilai `null` yang tidak diinisialisasi atau tidak terduga.

To give you an example, here is a function which returns the index of the first element of an array with a given value, or `None` if the element is not present.

Kami sedang mendemonstrasikan dua pendekatan untuk fungsi di atas:

- Recursive approach with `find_value_recursive`.
- Iterative approach with `find_value_iterative`.

```cairo noplayground hljs

fn find_value_recursive(mut arr: Span<felt252>, value: felt252, index: usize) -> Option<usize> {
    match arr.pop_front() {
        Option::Some(index_value) => { if (*index_value == value) {
            return Option::Some(index);
        } },
        Option::None => { return Option::None; },
    };

    find_value_recursive(arr, value, index + 1)
}

fn find_value_iterative(mut arr: Span<felt252>, value: felt252) -> Option<usize> {
    let mut result = Option::None;
    let mut index = 0;

    while let Option::Some(array_value) = arr.pop_front() {
        if (*array_value == value) {
            result = Option::Some(index);
            break;
        };

        index += 1;
    };

    result
}

```

Enums can be useful in many situations, especially when using the `match` flow construct that we just used. We will describe it in the next section.

Other enums are used very often, such as the `Result` enum, allowing to handle errors gracefully. We will explain the `Result` enum in detail in the ["Error Handling"](https://book.cairo-lang.org/id/ch09-02-recoverable-errors.html#the-result-enum) chapter.

Start

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1244686271.1738498000&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=1607617128)

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/zh-cn/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch200-introduction.md "Suggest an edit")

Ever wondered how your Cairo programs were executed?

First, they are compiled by the Cairo Compiler, then executed by the Cairo Virtual Machine, or _Cairo VM_ for short, which generates a trace of execution, used by the Prover to generate a STARK proof of that execution. This proof can later be verified by a Verifier.

The following chapters will go deep inside the inner workings of the Cairo VM. We'll cover its architecture, its memory model, and its execution model. Next, we'll explore builtins and hints, their purpose, and how they work. Finally, we'll look at the runner, which orchestrates the execution of a Cairo program.

But first, what do we mean by "virtual machine"?

Virtual Machines (VMs) are software emulations of physical computers. They provide a complete programming environment through an API which includes everything required for the correct execution of programs above it.

Every virtual machine API includes an instruction set architecture (ISA) in which to express programs. It could be the same instruction set as some physical machine (e.g. RISC-V), or a dedicated one implemented in the VM (e.g. Cairo assembly, CASM).

Those that emulate an OS are called _System Virtual Machines_, such as Xen and VMWare. We're not interested in them here.

The other ones we're interested in are _Process Virtual Machines_. They provide the environment needed by a single user-level process.

The most well-known process VM might be the Java Virtual Machine (JVM).

- Given a Java program `prgm.java`, it is compiled into a class `prgm.class`, containing _Java bytecode_ (JVM instructions and metadata).
- The JVM verifies that the bytecode is safe to run.
- The bytecode is either interpreted (slow) or compiled to machine code just in time (JIT, fast).
- If using JIT, the bytecode is translated to machine code while executing the program.
- Java programs could also be directly compiled to a specific CPU architecture (read machine code) through a process called _ahead-of-time compilation_ (AOT).

The Cairo VM is also a process VM, similar to the JVM, with one significant difference: Java and its JVM are designed for (platform-independent) general-purpose computing, while Cairo and its Cairo VM are specifically designed for (platform-independent) _provable_ general-purpose computing.

- A Cairo program `prgm.cairo` is compiled into compilation artifacts `prgm.json`, containing _Cairo bytecode_ (encoded CASM, the Cairo instruction set, and extra data).
- As seen in the [introduction](https://book.cairo-lang.org/zh-cn/ch00-00-introduction.html), Cairo Zero directly compiles to CASM while Cairo first compiles to _Sierra_ and then to a safe subset of CASM.
- The Cairo VM _interprets_ the provided CASM and generates a trace of the program execution.
- The obtained trace data can be fed to the Cairo Prover in order to generate a STARK proof, allowing to prove the correct execution of the program. Creating this _validity proof_ is the main purpose of Cairo.

Here is a high-level flow diagram showing how a Java program and a Cairo one are executed with their respective compiler and VM. The proof generation of a Cairo program is included.

![Java and Cairo execution flow](https://book.cairo-lang.org/zh-cn/java-cairo-execution-flow.png)

Java and Cairo program high-level execution flow diagram

An ongoing project, [Cairo Native](https://github.com/lambdaclass/cairo_native) works on providing Sierra to machine code compilation, including JIT and AOT, for executing Cairo programs.

Even though the high-level flow of both VMs is similar, their actual architectures are extremely different: the instruction set, the memory model, Cairo's non-determinism and the output.

Michael L. Scott, in Programming Language Pragmatics, 2015

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1393407874.1738498001&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1277286867)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/appendix-02-operators-and-symbols.md "Suggest an edit")

This appendix contains a glossary of Cairo's syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, macros, attributes, comments, tuples, and brackets.

Table B-1 contains the operators in Cairo, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to use to overload that operator is listed.

| Operator | Example | Explanation | Overloadable? |
| --- | --- | --- | --- |
| `!` | `!expr` | Logical complement | `Not` |
| `~` | `~expr` | Bitwise NOT | `BitNot` |
| `!=` | `expr != expr` | Non-equality comparison | `PartialEq` |
| `%` | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemEq` |
| `&` | `expr & expr` | Bitwise AND | `BitAnd` |
| `&&` | `expr && expr` | Short-circuiting logical AND |  |
| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulEq` |
| `@` | `@var` | Snapshot |  |
| `*` | `*var` | Desnap |  |
| `+` | `expr + expr` | Arithmetic addition | `Add` |
| `+=` | `var += expr` | Arithmetic addition and assignment | `AddEq` |
| `,` | `expr, expr` | Argument and element separator |  |
| `-` | `-expr` | Arithmetic negation | `Neg` |
| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubEq` |
| `->` | `fn(...) -> type`, `|...| -> type` | Function and closure return type |  |
| `.` | `expr.ident` | Member access |  |
| `/` | `expr / expr` | Arithmetic division | `Div` |
| `/=` | `var /= expr` | Arithmetic division and assignment | `DivEq` |
| `:` | `pat: type`, `ident: type` | Constraints |  |
| `:` | `ident: expr` | Struct field initializer |  |
| `;` | `expr;` | Statement and item terminator |  |
| `<` | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=` | `var = expr` | Assignment |  |
| `==` | `expr == expr` | Equality comparison | `PartialEq` |
| `=>` | `pat => expr` | Part of match arm syntax |  |
| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `|` | `expr | expr` | Bitwise OR | `BitOr` |
| `||` | `expr || expr` | Short-circuiting logical OR |  |
| `?` | expr? | Error propagation |  |

Table B-1: Operators

The following list contains all symbols that are not used as operators; that is, they do not have the same behavior as a function or method call.

Table B-2 shows symbols that appear on their own and are valid in a variety of locations.

| Symbol | Explanation |
| --- | --- |
| `..._u8`, `..._usize`, `..._bool`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `'...'` | Short string, 31 ASCII characters maximum |
| `_` | â€œIgnoredâ€ pattern binding |

Table B-2: Stand-Alone Syntax

Table B-3 shows symbols that are used within the context of a module hierarchy path to access an item.

| Symbol | Explanation |
| --- | --- |
| `ident::ident` | Namespace path |
| `super::path` | Path relative to the parent of the current module |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |

Table B-3: Path-Related Syntax

Table B-4 shows symbols that appear in the context of using generic type parameters.

| Symbol | Explanation |
| --- | --- |
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Array<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to a generic type, function, or method in an expression; often referred to as turbofish |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |

Table B-4: Generics

Table B-5 shows symbols that appear in the context of specifying attributes on an item.

| Symbol | Explanation |
| --- | --- |
| `#[derive(...)]` | Automatically implements a trait for a type |
| `#[inline]` | Hint to the compiler to allow inlining of annotated function |
| `#[inline(always)]` | Hint to the compiler to systematically inline annotated function |
| `#[inline(never)]` | Hint to the compiler to never inline annotated function |
| `#[must_use]` | Hint to the compiler that the return value of a function or a specific returned type must be used |
| `#[generate_trait]` | Automatically generates a trait for an impl |
| `#[available_gas(...)]` | Set the maximum amount of gas available to execute a function |
| `#[panic_with('...', wrapper_name)]` | Creates a wrapper for the annotated function which will panic if the function returns `None` or `Err`, with the given data as the panic error |
| `#[test]` | Describe a function as a test function |
| `#[cfg(...)]` | Configuration attribute, especially used to configure a `tests` module with `#[cfg(test)]` |
| `#[should_panic]` | Specifies that a test function should necessarily panic |
| `#[starknet::contract]` | Defines a Starknet smart contract |
| `#[starknet::interface]` | Defines a Starknet interface |
| `#[starknet::component]` | Defines a Starknet component |
| `#[starknet::embeddable]` | Defines an isolated embeddable implementation that can be injected in any smart contract |
| `#[embeddable_as(...)]` | Defines an embeddable implementation inside a component |
| `#[storage]` | Defines the storage of a smart contract |
| `#[event]` | Defines an event in a smart contract |
| `#[constructor]` | Defines the constructor in a smart contract |
| `#[abi(embed_v0)]` | Defines an implementation of a trait, exposing the functions of the impl as entrypoints of a contract |
| `#[abi(per_item)]` | Allows individual definition of the entrypoint type of functions inside an impl |
| `#[external(v0)]` | Defines an external function when `#[abi(per_item)]` is used |
| `#[flat]` | Defines a enum variant of the `Event` enum that is not nested, ignoring the variant name in the serialization process, very useful for composability when using Starknet components |
| `#[key]` | Defines an indexed `Event` enum field, allowing for more efficient queries and filtering of events |

Table B-5: Attributes

Table B-6 shows symbols that appear in the context of calling or defining macros.

| Symbol | Explanation |
| --- | --- |
| `print!` | Inline printing |
| `println!` | Print on a new line |
| `consteval_int!` | Declare a constant that is the result of a computation of integers |
| `array!` | Instantiate and fill arrays |
| `panic!` | Calls `panic` function and allows to provide a message error longer than 31 characters |
| `assert!` | Evaluates a Boolean and panics if `false` |
| `assert_eq!` | Evaluates an equality, and panics if not equal |
| `assert_ne!` | Evaluates an equality, and panics if equal |
| `assert_lt!` | Evaluates a comparison, and panics if greater or equal |
| `assert_le!` | Evaluates a comparison, and panics if greater |
| `assert_gt!` | Evaluates a comparison, and panics if lower or equal |
| `assert_ge!` | Evaluates a comparison, and panics if lower |
| `format!` | Format a string and returns a `ByteArray` with the contents |
| `write!` | Write formatted strings in a formatter |
| `writeln!` | Write formatted strings in a formatter on a new line |
| `get_dep_component!` | Returns the requested component state from a snapshot of the state inside a component |
| `get_dep_component_mut!` | Returns the requested component state from a reference of the state inside a component |
| `component!` | Macro used in Starknet contracts to embed a component inside a contract |

Table B-6: Macros

Table B-7 shows symbols that create comments.

| Symbol | Explanation |
| --- | --- |
| `//` | Line comment |

Table B-7: Comments

Table B-8 shows symbols that appear in the context of using tuples.

| Symbol | Explanation |
| --- | --- |
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct` s and tuple `enum` variants |

Table B-8: Tuples

Table B-9 shows the contexts in which curly braces are used.

| Context | Explanation |
| --- | --- |
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |

Table B-9: Curly Braces

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1455434592.1738498000&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1537683280)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1928364720.1738498002&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565~102558064&z=784240042)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/tr/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-01-arrays.md "Suggest an edit")

Bir dizi, aynÄ± tÃ¼rden elemanlarÄ±n bir koleksiyonudur. `ArrayTrait` trait'ini Ã§ekirdek kÃ¼tÃ¼phaneden kullanarak dizi metodlarÄ± oluÅŸturabilir ve kullanabilirsiniz.

Dikkat edilmesi gereken Ã¶nemli bir nokta, dizilerin sÄ±nÄ±rlÄ± modifikasyon seÃ§eneklerine sahip olmasÄ±dÄ±r. Diziler, aslÄ±nda deÄŸerleri deÄŸiÅŸtirilemeyen kuyruklardÄ±r. Bu, bir bellek yuvasÄ±na yazÄ±ldÄ±ktan sonra, Ã¼zerine yazÄ±lamayacaÄŸÄ± ancak ondan okunabileceÄŸi gerÃ§eÄŸiyle ilgilidir. Bir dizinin sonuna yalnÄ±zca eleman ekleyebilir ve Ã¶nÃ¼nden eleman Ã§Ä±karabilirsiniz.

Creating an array is done with the `ArrayTrait::new()` call. Here's an example of creating an array and appending 3 elements to it:

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

Gerekirse, dizi Ã¶rneÄŸini oluÅŸtururken dizinin iÃ§indeki elemanlarÄ±n beklenen tÃ¼rÃ¼nÃ¼ bu ÅŸekilde geÃ§irebilir veya deÄŸiÅŸkenin tÃ¼rÃ¼nÃ¼ aÃ§Ä±kÃ§a tanÄ±mlayabilirsiniz.

```cairo noplayground hljs

let mut arr = ArrayTrait::<u128>::new();

```

```cairo noplayground hljs

let mut arr:Array<u128> = ArrayTrait::new();

```

Bir dizinin sonuna bir eleman eklemek iÃ§in `append()` yÃ¶ntemini kullanabilirsiniz:

```cairo hljs hide-boring

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);
    a.append(2);
}

```

`pop_front()` metodunu kullanarak bir diziden yalnÄ±zca Ã¶n taraftaki elemanlarÄ± Ã§Ä±karabilirsiniz. Bu metod, kaldÄ±rÄ±lan elemanÄ± iÃ§eren bir `Option` veya dizi boÅŸsa `Option::None` dÃ¶ndÃ¼rÃ¼r.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(10);
    a.append(1);
    a.append(2);

    let first_value = a.pop_front().unwrap();
    println!("The first value is {}", first_value);
}

```

YukarÄ±daki kod, eklenen ilk elemanÄ± Ã§Ä±kardÄ±ÄŸÄ±mÄ±z iÃ§in `The first value is 10` yazdÄ±racaktÄ±r.

Cairo'da, bellek deÄŸiÅŸmezdir, bu da ekledikten sonra bir dizinin elemanlarÄ±nÄ± deÄŸiÅŸtirmenin mÃ¼mkÃ¼n olmadÄ±ÄŸÄ± anlamÄ±na gelir. Bir dizinin sonuna yalnÄ±zca eleman ekleyebilir ve bir dizinin Ã¶nÃ¼nden eleman Ã§Ä±karabilirsiniz. Bu iÅŸlemler, bellek hÃ¼crelerini doÄŸrudan deÄŸiÅŸtirmek yerine iÅŸaretÃ§ileri gÃ¼ncellemeyi iÃ§erdiÄŸinden, bellek mutasyonu gerektirmez.

Dizi elemanlarÄ±na eriÅŸmek iÃ§in, farklÄ± tÃ¼rler dÃ¶ndÃ¼ren `get()` veya `at()` dizi metodlarÄ±nÄ± kullanabilirsiniz. `arr.at(index)` kullanmak, alt dizin operatÃ¶rÃ¼ `arr[index]` kullanmakla eÅŸdeÄŸerdir.

The `get` function returns an `Option<Box<@T>>`, which means it returns an option to a Box type (Cairo's smart-pointer type) containing a snapshot to the element at the specified index if that element exists in the array. If the element doesn't exist, `get` returns `None`. This method is useful when you expect to access indices that may not be within the array's bounds and want to handle such cases gracefully without panics. Snapshots will be explained in more detail in the ["References and Snapshots"](https://book.cairo-lang.org/tr/ch04-02-references-and-snapshots.html#snapshots) chapter.

Ä°ÅŸte `get()` yÃ¶ntemiyle bir Ã¶rnek:

```cairo hljs

fn main() -> u128 {
    let mut arr = ArrayTrait::<u128>::new();
    arr.append(100);
    let index_to_access =
        1; // Change this value to see different results, what would happen if the index doesn't exist?
    match arr.get(index_to_access) {
        Option::Some(x) => {
            *x
                .unbox() // Don't worry about * for now, if you are curious see Chapter 4.2 #desnap operator
            // It basically means "transform what get(idx) returned into a real value"
        },
        Option::None => { panic!("out of bounds") },
    }
}

```

The `at` function, and its equivalent the subscripting operator, on the other hand, directly return a snapshot to the element at the specified index using the `unbox()` operator to extract the value stored in a box. If the index is out of bounds, a panic error occurs. You should only use `at` when you want the program to panic if the provided index is out of the array's bounds, which can prevent unexpected behavior.

```cairo hljs

fn main() {
    let mut a = ArrayTrait::new();
    a.append(0);
    a.append(1);

    // using the `at()` method
    let first = *a.at(0);
    assert!(first == 0);
    // using the subscripting operator
    let second = *a[1];
    assert!(second == 1);
}

```

Bu Ã¶rnekte, `first` adlÄ± deÄŸiÅŸken `0` deÄŸerini alacak Ã§Ã¼nkÃ¼ bu, dizide `0` indeksindeki deÄŸerdir. `second` adlÄ± deÄŸiÅŸken, dizide `1` indeksinden `1` deÄŸerini alacak.

Ã–zetle, sÄ±nÄ±rlarÄ±n dÄ±ÅŸÄ±ndaki eriÅŸim giriÅŸimlerinde paniklemek istiyorsanÄ±z `at` kullanÄ±n ve bu tÃ¼r durumlarÄ± panik olmadan zarif bir ÅŸekilde ele almak istiyorsanÄ±z `get` kullanÄ±n.

Bir dizideki eleman sayÄ±sÄ±nÄ± belirlemek iÃ§in `len()` metodunu kullanÄ±n. DÃ¶nÃ¼ÅŸ deÄŸeri `usize` tÃ¼rÃ¼ndedir.

Bir dizinin boÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek istiyorsanÄ±z, `is_empty()` metodunu kullanabilirsiniz, bu metod dizi boÅŸsa `true`, aksi takdirde `false` dÃ¶ndÃ¼rÃ¼r.

Bazen, derleme zamanÄ±nda zaten bilinen deÄŸerlere sahip diziler oluÅŸturmamÄ±z gerekiyor. Bunun temel yolu fazlalÄ±klÄ±dÄ±r. Ä°lk olarak diziyi tanÄ±mlar ve sonra her bir deÄŸeri tek tek eklerdiniz. `array!` bu gÃ¶revi iki adÄ±mÄ± birleÅŸtirerek daha basit bir ÅŸekilde yapmanÄ±n yoludur. Derleme zamanÄ±nda, derleyici makroyu geniÅŸleterek Ã¶ÄŸeleri sÄ±rayla ekleyen kodu oluÅŸturacaktÄ±r.

Without `array!`:

```cairo hljs

    let mut arr = ArrayTrait::new();
    arr.append(1);
    arr.append(2);
    arr.append(3);
    arr.append(4);
    arr.append(5);

```

With `array!`:

```cairo hljs

    let arr = array![1, 2, 3, 4, 5];

```

If you want to store elements of different types in an array, you can use an `Enum` to define a custom data type that can hold multiple types. Enums will be explained in more detail in the ["Enums and Pattern Matching"](https://book.cairo-lang.org/tr/ch06-00-enums-and-pattern-matching.html) chapter.

```cairo hljs

#[derive(Copy, Drop)]
enum Data {
    Integer: u128,
    Felt: felt252,
    Tuple: (u32, u32),
}

fn main() {
    let mut messages: Array<Data> = array![];
    messages.append(Data::Integer(100));
    messages.append(Data::Felt('hello world'));
    messages.append(Data::Tuple((10, 30)));
}

```

`Span` is a struct that represents a snapshot of an `Array`. It is designed to provide safe and controlled access to the elements of an array without modifying the original array. Span is particularly useful for ensuring data integrity and avoiding borrowing issues when passing arrays between functions or when performing read-only operations, as introduced in ["References and Snapshots"](https://book.cairo-lang.org/tr/ch04-02-references-and-snapshots.html).

All methods provided by `Array` can also be used with `Span`, except for the `append()` method.

Bir `Array`'in `Span`'ini oluÅŸturmak iÃ§in `span()` yÃ¶ntemini Ã§aÄŸÄ±rÄ±n:

```cairo hljs hide-boring

fn main() {
    let mut array: Array<u8> = ArrayTrait::new();
    array.span();
}

```

Start

ðŸ’¬

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1211423325.1738498002&gtm=45je51u0v873244154z89192743044za200zb9192743044&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=805285412)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch02-01-variables-and-mutability.md "Suggest an edit")

Cairo uses an immutable memory model, meaning that once a memory cell is written to,
it can't be overwritten but only read from. To reflect this immutable memory model,
variables in Cairo are immutable by default.
However, the language abstracts this model and gives you the option to make your
variables mutable. Letâ€™s explore how and why Cairo enforces immutability, and how
you can make your variables mutable.

When a variable is immutable, once a value is bound to a name, you canâ€™t change
that value. To illustrate this, generate a new project called _variables_ in
your _cairo\_projects_ directory by using `scarb new variables`.

Then, in your new _variables_ directory, open _src/lib.cairo_ and replace its
code with the following code, which wonâ€™t compile just yet:

Filename: src/lib.cairo

```cairo does_not_compile hljs

fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}

```

Save and run the program using `scarb cairo-run`. You should receive an error message
regarding an immutability error, as shown in this output:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_01_variables_are_immutable v0.1.0 (listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/Scarb.toml)
error: Cannot assign to an immutable variable.
 --> listings/ch02-common-programming-concepts/no_listing_01_variables_are_immutable/src/lib.cairo:6:5
    x = 6;
    ^***^

error: could not compile `no_listing_01_variables_are_immutable` due to previous error
error: `scarb metadata` exited with error

```

This example shows how the compiler helps you find errors in your programs.
Compiler errors can be frustrating, but they only mean your program
isnâ€™t safely doing what you want it to do yet; they do _not_ mean that youâ€™re
not a good programmer! Experienced Caironautes still get compiler errors.

You received the error message `Cannot assign to an immutable variable.`
because you tried to assign a second value to the immutable `x` variable.

Itâ€™s important that we get compile-time errors when we attempt to change a
value thatâ€™s designated as immutable because this specific situation can lead to
bugs. If one part of our code operates on the assumption that a value will
never change and another part of our code changes that value, itâ€™s possible
that the first part of the code wonâ€™t do what it was designed to do. The cause
of this kind of bug can be difficult to track down after the fact, especially
when the second piece of code changes the value only _sometimes_.

Cairo, unlike most other languages, has immutable memory. This makes a
whole class of bugs impossible, because values will never change unexpectedly.
This makes code easier to reason about.

But mutability can be very useful, and can make code more convenient to write.
Although variables are immutable by default, you can make them mutable by
adding `mut` in front of the variable name. Adding `mut` also conveys
intent to future readers of the code by indicating that other parts of the code
will be changing the value associated to this variable.

However, you might be wondering at this point what exactly happens when a variable
is declared as `mut`, as we previously mentioned that Cairo's memory is immutable.
The answer is that the _value_ is immutable, but the _variable_ isn't. The value
associated to the variable can be changed. Assigning to a mutable variable in Cairo
is essentially equivalent to redeclaring it to refer to another value in another memory cell,
but the compiler handles that for you, and the keyword `mut` makes it explicit.
Upon examining the low-level Cairo Assembly code, it becomes clear that
variable mutation is implemented as syntactic sugar, which translates mutation operations
into a series of steps equivalent to variable shadowing. The only difference is that at the Cairo
level, the variable is not redeclared so its type cannot change.

For example, letâ€™s change _src/lib.cairo_ to the following:

```cairo hljs

fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}

```

When we run the program now, we get this:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_02_adding_mut v0.1.0 (listings/ch02-common-programming-concepts/no_listing_02_adding_mut/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_02_adding_mut
The value of x is: 5
The value of x is: 6
Run completed successfully, returning []

```

Weâ€™re allowed to change the value bound to `x` from `5` to `6` when `mut` is
used. Ultimately, deciding whether to use mutability or not is up to you and
depends on what you think is clearest in that particular situation.

Like immutable variables, _constants_ are values that are bound to a name and
are not allowed to change, but there are a few differences between constants
and variables.

First, you arenâ€™t allowed to use `mut` with constants. Constants arenâ€™t just
immutable by defaultâ€”theyâ€™re always immutable. You declare constants using the
`const` keyword instead of the `let` keyword, and the type of the value _must_
be annotated. Weâ€™ll cover types and type annotations in the next section,
[â€œData Typesâ€](https://book.cairo-lang.org/ch02-02-data-types.html), so donâ€™t worry about the details
right now. Just know that you must always annotate the type.

Constant variables can be declared with any usual data type, including structs, enums and fixed-size arrays.

Constants can only be declared in the global scope, which makes
them useful for values that many parts of code need to know about.

The last difference is that constants may natively be set only to a constant expression,
not the result of a value that could only be computed at runtime.

Hereâ€™s an example of constants declaration:

```cairo noplayground hljs

struct AnyStruct {
    a: u256,
    b: u32,
}

enum AnyEnum {
    A: felt252,
    B: (usize, u256),
}

const ONE_HOUR_IN_SECONDS: u32 = 3600;
const STRUCT_INSTANCE: AnyStruct = AnyStruct { a: 0, b: 1 };
const ENUM_INSTANCE: AnyEnum = AnyEnum::A('any enum');
const BOOL_FIXED_SIZE_ARRAY: [bool; 2] = [true, false];

```

Nonetheless, it is possible to use the `consteval_int!` macro to create a `const` variable that is the result of some computation:

```cairo noplayground hljs

    const ONE_HOUR_IN_SECONDS: u32 = consteval_int!(60 * 60);

```

We will dive into more detail about macros in the [dedicated section](https://book.cairo-lang.org/ch12-05-macros.html).

Cairo's naming convention for constants is to use all uppercase with underscores between words.

Constants are valid for the entire time a program runs, within the scope in
which they were declared. This property makes constants useful for values in
your application domain that multiple parts of the program might need to know
about, such as the maximum number of points any player of a game is allowed to
earn, or the speed of light.

Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.

Variable shadowing refers to the declaration of a
new variable with the same name as a previous variable. Caironautes say that the
first variable is _shadowed_ by the second, which means that the second
variable is what the compiler will see when you use the name of the variable.
In effect, the second variable overshadows the first, taking any uses of the
variable name to itself until either it itself is shadowed or the scope ends.
We can shadow a variable by using the same variableâ€™s name and repeating the
use of the `let` keyword as follows:

```cairo hljs

fn main() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!("Inner scope x value is: {}", x);
    }
    println!("Outer scope x value is: {}", x);
}

```

This program first binds `x` to a value of `5`. Then it creates a new variable
`x` by repeating `let x =`, taking the original value and adding `1` so the
value of `x` is then `6`. Then, within an inner scope created with the curly
brackets, the third `let` statement also shadows `x` and creates a new
variable, multiplying the previous value by `2` to give `x` a value of `12`.
When that scope is over, the inner shadowing ends and `x` returns to being `6`.
When we run this program, it will output the following:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_03_shadowing v0.1.0 (listings/ch02-common-programming-concepts/no_listing_03_shadowing/Scarb.toml)
    Finished `dev` profile target(s) in 4 seconds
     Running no_listing_03_shadowing
Inner scope x value is: 12
Outer scope x value is: 6
Run completed successfully, returning []

```

Shadowing is different from marking a variable as `mut` because weâ€™ll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.

Another distinction between `mut` and shadowing is that when we use the `let` keyword again,
we are effectively creating a new variable, which allows us to change the type of the
value while reusing the same name. As mentioned before, variable shadowing and mutable variables
are equivalent at the lower level.
The only difference is that by shadowing a variable, the compiler will not complain
if you change its type. For example, say our program performs a type conversion between the
`u64` and `felt252` types.

```cairo hljs

fn main() {
    let x: u64 = 2;
    println!("The value of x is {} of type u64", x);
    let x: felt252 = x.into(); // converts x to a felt, type annotation is required.
    println!("The value of x is {} of type felt252", x);
}

```

The first `x` variable has a `u64` type while the second `x` variable has a `felt252` type.
Shadowing thus spares us from having to come up with different names, such as `x_u64`
and `x_felt252`; instead, we can reuse the simpler `x` name. However, if we try to use
`mut` for this, as shown here, weâ€™ll get a compile-time error:

```cairo does_not_compile hljs

fn main() {
    let mut x: u64 = 2;
    println!("The value of x is: {}", x);
    x = 5_u8;
    println!("The value of x is: {}", x);
}

```

The error says we were expecting a `u64` (the original type) but we got a different type:

```shell hljs

$ scarb cairo-run
   Compiling no_listing_05_mut_cant_change_type v0.1.0 (listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/Scarb.toml)
error: Unexpected argument type. Expected: "core::integer::u64", found: "core::integer::u8".
 --> listings/ch02-common-programming-concepts/no_listing_05_mut_cant_change_type/src/lib.cairo:6:9
    x = 5_u8;
        ^**^

error: could not compile `no_listing_05_mut_cant_change_type` due to previous error
error: `scarb metadata` exited with error

```

Start

Now that weâ€™ve explored how variables work, letâ€™s look at more data types they can have.

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch103-03-upgradeability.md "Suggest an edit")

Starknet separates contracts into classes and instances, making it simple to upgrade a contract's logic without affecting its state.

A contract class is the definition of the semantics of a contract. It includes the entire logic of a contract: the name of the entry points, the addresses of the storage variables, the events that can be emitted, etc. Each class is uniquely identified by its class hash. A class does not have its own storage: it's only a definition of logic.

Classes are typically identified by a [class hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash). When declaring a class, the network registers it and assigns a unique hash used to identify the class and deploy contract instances from it.

A contract instance is a deployed contract corresponding to a class, with its own storage.

Starknet natively supports upgradeable contracts through the `replace_class_syscall` [system call](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/), enabling simple contract upgrades without affecting the contract's state.

To upgrade a contract, expose an entry point that executes `replace_class_syscall` with the new class hash as an argument:

```cairo noplayground hljs

use core::starknet::{ClassHash, syscalls};
use core::starknet::class_hash::class_hash_const;
use core::num::traits::Zero;

fn _upgrade(new_class_hash: ClassHash) {
    assert(!new_class_hash.is_zero(), 'Class hash cannot be zero');
    syscalls::replace_class_syscall(new_class_hash).unwrap();
}

```

Listing 17-3: Exposing `replace_class_syscall` to update the contract's class

> Note: Thoroughly review changes and potential impacts before upgrading, as it's a delicate procedure with security implications. Don't allow arbitrary addresses to upgrade your contract.

OpenZeppelin Contracts for Cairo provides the `Upgradeable` component that can be embedded into your contract to make it upgradeable. This component is a simple way to add upgradeability to your contract while relying on an audited library. It can be combined with the `Ownable` component to restrict the upgradeability to a single address, so that the contract owner has the exclusive right to upgrade the contract.

```cairo noplayground hljs

#[starknet::contract]
mod UpgradeableContract {
    use openzeppelin::access::ownable::OwnableComponent;
    use openzeppelin::upgrades::UpgradeableComponent;
    use openzeppelin::upgrades::interface::IUpgradeable;
    use core::starknet::{ContractAddress, ClassHash};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    /// Ownable
    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    /// Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            // This function can only be called by the owner
            self.ownable.assert_only_owner();

            // Replace the class hash upgrading the contract
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}

```

Listing 17-4 Integrating OpenZeppelin's Upgradeable component in a contract

For more information, please refer to the [OpenZeppelin docs API reference](https://docs.openzeppelin.com/contracts-cairo/0.19.0/api/upgrades).

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=53309359.1738498003&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015666~102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=835958024)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch104-01-general-recommendations.md "Suggest an edit")

When developing software, ensuring it functions as intended is usually straightforward. However, preventing unintended usage and vulnerabilities can be more challenging.

In smart contract development, security is very important. A single error can result in the loss of valuable assets or the improper functioning of certain features.

Smart contracts are executed in a public environment where anyone can examine the code and interact with it. Any errors or vulnerabilities in the code can be exploited by malicious actors.

This chapter presents general recommendations for writing secure smart contracts. By incorporating these concepts during development, you can create robust and reliable smart contracts. This reduces the chance of unexpected behavior or vulnerabilities.

This chapter does not provide an exhaustive list of all possible security issues, and it does not guarantee that your contracts will be completely secure.

If you are developing smart contracts for production use, it is highly recommended to conduct external audits performed by security experts.

Cairo is a highly safe language inspired by Rust. It is designed in a way that forces you to cover all possible cases. Security issues on Starknet mostly arise from the way smart contract flows are designed, not much from the language itself.

Adopting a security mindset is the initial step in writing secure smart contracts. Try to always consider all possible scenarios when writing code.

Transactions in smart contracts are atomic, meaning they either succeed or fail without making any changes.

Think of smart contracts as state machines: they have a set of initial states defined by the constructor constraints, and external functions represent a set of possible state transitions. A transaction is nothing more than a state transition.

The `assert!` or `panic!` macros can be used to validate conditions before performing specific actions. You can learn more about these on the [Unrecoverable Errors with panic](https://book.cairo-lang.org/ch09-01-unrecoverable-errors-with-panic.html) page.

These validations can include:

- Inputs provided by the caller
- Execution requirements
- Invariants (conditions that must always be true)
- Return values from other function calls

For example, you could use the `assert!` macro to validate that a user has enough funds to perform a withdraw transaction. If the condition is not met, the transaction will fail and the state of the contract will not change.

```cairo noplayground hljs

    impl Contract of IContract<ContractState> {
        fn withdraw(ref self: ContractState, amount: u256) {
            let current_balance = self.balance.read();

            assert!(self.balance.read() >= amount, "Insufficient funds");

            self.balance.write(current_balance - amount);
        }

```

Using these functions to check conditions adds constraints that help clearly define the boundaries of possible state transitions for each function in your smart contract. These checks ensure that the behavior of the contract stays within the expected limits.

The Checks Effects Interactions pattern is a common design pattern used to prevent reentrancy attacks on Ethereum. While reentrancy is harder to achieve in Starknet, it is still recommended to use this pattern in your smart contracts.

The pattern consists of following a specific order of operations in your functions:

1. **Checks**: Validate all conditions and inputs before performing any state changes.
2. **Effects**: Perform all state changes.
3. **Interactions**: All external calls to other contracts should be made at the end of the function.

Access control is the process of restricting access to certain features or resources. It is a common security mechanism used to prevent unauthorized access to sensitive information or actions. In smart contracts, some functions may often be restricted to specific users or roles.

You can implement the access control pattern to easily manage permissions. This pattern consists of defining a set of roles and assigning them to specific users. Each function can then be restricted to specific roles.

```cairo noplayground hljs

#[starknet::contract]
mod access_control_contract {
    use core::starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, StorageMapReadAccess,
        StorageMapWriteAccess, Map,
    };
    use core::starknet::ContractAddress;
    use core::starknet::get_caller_address;

    trait IContract<TContractState> {
        fn is_owner(self: @TContractState) -> bool;
        fn is_role_a(self: @TContractState) -> bool;
        fn only_owner(self: @TContractState);
        fn only_role_a(self: @TContractState);
        fn only_allowed(self: @TContractState);
        fn set_role_a(ref self: TContractState, _target: ContractAddress, _active: bool);
        fn role_a_action(ref self: ContractState);
        fn allowed_action(ref self: ContractState);
    }

    #[storage]
    struct Storage {
        // Role 'owner': only one address
        owner: ContractAddress,
        // Role 'role_a': a set of addresses
        role_a: Map::<ContractAddress, bool>,
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.owner.write(get_caller_address());
    }

    // Guard functions to check roles

    impl Contract of IContract<ContractState> {
        #[inline(always)]
        fn is_owner(self: @ContractState) -> bool {
            self.owner.read() == get_caller_address()
        }

        #[inline(always)]
        fn is_role_a(self: @ContractState) -> bool {
            self.role_a.read(get_caller_address())
        }

        #[inline(always)]
        fn only_owner(self: @ContractState) {
            assert!(Self::is_owner(self), "Not owner");
        }

        #[inline(always)]
        fn only_role_a(self: @ContractState) {
            assert!(Self::is_role_a(self), "Not role A");
        }

        // You can easily combine guards to perform complex checks
        fn only_allowed(self: @ContractState) {
            assert!(Self::is_owner(self) || Contract::is_role_a(self), "Not allowed");
        }

        // Functions to manage roles

        fn set_role_a(ref self: ContractState, _target: ContractAddress, _active: bool) {
            Self::only_owner(@self);
            self.role_a.write(_target, _active);
        }

        // You can now focus on the business logic of your contract
        // and reduce the complexity of your code by using guard functions

        fn role_a_action(ref self: ContractState) {
            Self::only_role_a(@self);
            // ...
        }

        fn allowed_action(ref self: ContractState) {
            Self::only_allowed(@self);
            // ...
        }
    }
}

```

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=73293915.1738498003&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102556566&z=1211228509)

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch204-00-builtins.md "Suggest an edit")

The Cairo whitepaper defines builtins as "predefined optimized low-level execution units".

In other words, builtins are logic blocks embedded in the Cairo architecture
to significantly enhance performance compared to defining the same logic using
Cairo's instruction set.

Builtins can be compared to Ethereum precompiles, primitive operations implemented
in the client's implementation language rather than using EVM opcodes.

The Cairo architecture does not specify a specific set of builtins,
they can be added or removed depending on our needs, which is why
different layouts exist. Builtins are adding constraints to the CPU AIR,
which will increase the verification time.

In this chapter, we'll see how builtins work, the builtins that exist
and their purposes.

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch201-architecture.md "Suggest an edit")

Cairo is a STARK-friendly Von Neumann architecture capable of generating validity proofs
for arbitrary computations. Being STARK-friendly means that Cairo's design is optimized for the STARK
proof system, while remaining compatible with other proof system backends.
It implements a Turing-complete process virtual machine.

Cairo consists of three main components:

1. The Cairo compiler
2. The Cairo Virtual Machine (CairoVM)
3. The Cairo prover and verifier

The Cairo compiler transforms Cairo source code into Cairo bytecode (encoded instructions and metadata).
The compiler's output is commonly referred to as the _compilation artifacts_.

The CairoVM implements the theoretical _Cairo machine_,
processing the compilation artifacts and executing the instructions
to produce two key outputs required for proof generation and verification:
the _AIR (Arithmetic Intermediate Representation) private input_ (witness) and _AIR public input_:

- The AIR private input comprises the _execution trace_ (or simply "trace") and the _memory_.
- The AIR public input includes the _initial and final states_ (first and last entries of the trace),
the _public memory_ (a subset of the memory), and configuration data
(e.g., layout) of the execution.

The prover takes the AIR's private and public inputs to generate a proof
of the corresponding program execution.
The verifier can then verify the proof's correctness asynchronously,
given the proof and the AIR public input.

What are AIRs, though?

AIR stands for _Arithmetic Intermediate Representation_, which is an arithmetization
technique. Arithmetization is the foundation of every proof system: STARK uses AIRs,
while other proof systems might rely on different techniques (e.g., R1CS, PLONKish arithmetization).
It allows converting a computational statement into a set of polynomial equations.
These polynomial equations then represent the constraints of your system:
if they all hold while following the proof system protocol, then the proof is valid;
otherwise, it's invalid.

At its core, Cairo is a set of AIRs that represent a Turing-complete machine for the Cairo ISA: the _Cairo machine_.
This enables proving any statement (i.e., arbitrary code) through the Cairo machine.

The Cairo machine abstracts away the need to write AIRs for the program you would like to prove,
and Cairo, as a language, provides a human-readable interface to use the Cairo machine.

Each component of the Cairo machine has its corresponding AIR: the CPU, the Memory, the Builtins...

Good AIRs are critical to the performance of proof generation and verification.
While there can be many ways to express a computational statement into polynomials,
not all are equally efficient. Writing optimal AIRs is a strong factor of performance.

We won't go any further on AIRs here, but it's good to know that the CairoVM's purpose
is to provide the required inputs to the Cairo prover for it to generate proof of the given Cairo program.
In a nutshell, the Cairo prover and verifier job is to verify that the constraints
defined by the Cairo AIR holds for the CairoVM outputs.

The Cairo machine is the theoretical model that defines the Von Neumann architecture to
prove arbitrary computation.

The machine is defined by two core models:

- CPU, or Execution model - The Instruction Set Architecture (ISA)
- Memory model - Non-deterministic Read-only Memory

The Execution model specifies the ISA through three key components:

- The instruction set
- The registers ( `pc`, `ap`, `fp`)
- The state transition algorithm

Unlike general-purpose ISAs such as RISC-V, Cairo implements its own ISA specifically optimized
for proof generation and verificationâ€”a custom zero-knowledge ISA (ZK-ISA).
The Memory model defines how the CPU interacts with the memory.
Following Von Neumann architecture principles, a single memory stores both program and instruction data.

The Cairo machine exists in two versions:

1. The _deterministic machine_ (used by the prover)
2. The _non-deterministic machine_ (used by the verifier)

Why are there two versions of the Cairo machine, one for the prover and one for the verifier?

The deterministic machine takes a trace (a sequence of states) and the whole memory
(a memory function), and verifies that the transition between two consecutive states is valid.
It returns `accept` if all state transitions are valid and `reject` otherwise.
This machine does not perform any computation, it only asserts the validity of a trace
and its memory.

The non-deterministic machine relies on the deterministic one: it only takes the initial
state, the final state, and a partial memory function (i.e. the public memory)
and returns `accept` if there exists a sequence of states (a trace)
with the same initial and final states and a memory function that extends the partial memory
(a whole memory that includes the public-memory) which is accepted by the deterministic machine.

The deterministic machine allows the prover to generate a proof, while the non-deterministic
machine allows the verifier to verify the proof succinctly in a zero-knowledge way
(some data can be kept private from the verifier).

The CairoVM is the implementation of this theoretical machine,
including some functionalities to benefit from its design ( _builtins_ & _hints_).
Among the various implementations of the CairoVM, what we call the _Cairo Runner_ is the
entrypoint for running a Cairo program and generating the AIR inputs needed for proof.

When a Cairo program is executed by the CairoVM, we could view the memory model as a Write-Once one.

We could recap in a table the key differences between the deterministic Cairo machine,
and the non-deterministic one.

|  | Deterministic Cairo Machine | Non-Deterministic Cairo Machine |
| --- | --- | --- |
| Usage | Prover | Verifier |
| Hints | Executed | Not aware of them |
| Memory | Complete memory | Public memory only |
| Trace | Full execution trace | Initial & Final states only |

The following diagram represent the architecture of the CairoVM,
to generate the AIR inputs for the proof system.

![CairoVM architecture](https://book.cairo-lang.org/cairo-vm-architecture.png)

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1330389458.1738498004&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=1285621191)

ConnectedChatÃ—

SendLoading \[MathJax\]/extensions/MathZoom.js

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-10-procedural-macros.md "Suggest an edit")

Cairo provides macros as a fundamental feature that lets you write code that generates other code (known as metaprogramming). When you use macros, you can extend Cairo's capabilities beyond what regular functions offer. Throughout this book, we've used macros like `println!` and `assert!`, but haven't fully explored how we can create our own macros.

Before diving into procedural macros specifically, let's understand why we need macros when we already have functions:

Fundamentally, macros are a way of writing code that writes other code, which
is known as _metaprogramming_. In Appendix C, we discuss derivable traits and the `derive`
attribute, which generates an implementation of various traits for you. Weâ€™ve
also used the `println!` and `array!` macros throughout the book. All of these
macros _expand_ to produce more code than the code youâ€™ve written manually.

Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions donâ€™t.

A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call `println!("hello")` with one argument or
`println!("hello {}", name)` with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function canâ€™t, because it gets
called at runtime and a trait needs to be implemented at compile time.

Another important difference between macros and functions is that the design of Cairo macros is complex: they're written in Rust, but operate on Cairo code. Due to
this indirection and the combination of the two languages, macro definitions are generally more
difficult to read, understand, and maintain than function definitions.

We call _procedural macros_ macros that allow you to run code at compile time that operates over
Cairo syntax, both consuming and producing Cairo syntax. You can sort of think of procedural macros
as functions from an AST to another AST. The three kinds of procedural macros are _custom derive_,
_attribute-like_, and _function-like_, and all work in a similar fashion.

In this chapter, we'll explore what procedural macros are, how they're defined, and examine each of the three types in detail.

Just as the Cairo compiler is written in Rust, procedural macros are Rust functions that transform Cairo code. These functions take Cairo code as input and return modified Cairo code as output. To implement macros, you'll need a package with both a `Cargo.toml` and a `Scarb.toml` file. The `Cargo.toml` defines the macro implementation dependencies, while the `Scarb.toml` marks the package as a macro and defines its metadata.

The function that defines a procedural macro operates on two key types:

- `TokenStream`: A sequence of Cairo tokens representing your source code. Tokens are the smallest units of code that the compiler recognizes (like identifiers, keywords, and operators).
- `ProcMacroResult`: An enhanced version of TokenStream that includes both the generated code and any diagnostic messages (warnings or errors) that should be shown to the user during compilation.

The function implementing the macro must be decorated with one of three special attributes that tell the compiler how the macro should be used:

- `#[inline_macro]`: For macros that look like function calls (e.g., `println!()`)
- `#[attribute_macro]`: For macros that act as attributes (e.g., `#[generate_trait]`)
- `#[derive_macro]`: For macros that implement traits automatically

Each attribute type corresponds to a different use case and affects how the macro can be invoked in your code.

Here are the signatures for each types :

```rust ignore hljs

#[inline_macro]
pub fn inline(code: TokenStream) -> ProcMacroResult {}

#[attribute_macro]
pub fn attribute(attr: TokenStream, code: TokenStream) -> ProcMacroResult {}

#[derive_macro]
pub fn derive(code: TokenStream) -> ProcMacroResult {}
```

To use procedural macros, you need to have Rust toolchain (Cargo) installed on your machine. To install Rust using Rustup, you can run the following command in you terminal :

```bash hljs

curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

```

Creating a procedural macro requires setting up a specific project structure. Your macro project needs:

1. A Rust Project (where you implement the macro):
   - `Cargo.toml`: Defines Rust dependencies and build settings
   - `src/lib.rs`: Contains the macro implementation
2. A Cairo Project:
   - `Scarb.toml`: Declares the macro for Cairo projects
   - No Cairo source files needed

Let's walk through each component and understand its role:

```bash hljs

â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â””â”€â”€ lib.rs

```

The project contains a `Scarb.toml` and a `Cargo.toml` file in the root directory.

The Cargo manifest file needs to contain a `crate-type = ["cdylib"]` on the `[lib]` target, and the `cairo-lang-macro` crate on the `[dependencies]` target. Here is an example :

```toml hljs ini

[package]
name = "pow"
version = "0.1.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
bigdecimal = "0.4.5"
cairo-lang-macro = "0.1.1"
cairo-lang-parser = "2.9.2"
cairo-lang-syntax = "2.9.2"

[workspace]

```

The Scarb manifest file must define a `[cairo-plugin]` target type. Here is an example :

```toml hljs ini

[package]
name = "pow"
version = "0.1.0"

[cairo-plugin]

```

Finally the project needs to contain a Rust library ( `lib.rs`), inside the `src/` directory that implements the procedural macro API.

As you might have notice the project doesn't need any cairo code, it only requires the `Scarb.toml` manifest file mentioned.

From the user's perspective, you only need to add the package defining the macro in your dependencies. In the project using the macro you will have a Scarb manifest file with :

```toml hljs ini

[package]
name = "no_listing_15_procedural_macro"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
pow = { path = "../no_listing_16_procedural_macro_expression" }
hello_macro = { path = "../no_listing_17_procedural_macro_derive" }
rename_macro = { path = "../no_listing_18_procedural_macro_attribute" }

[dev-dependencies]
cairo_test = "2.9.2"

```

Expression macros provide functionality similar to function calls but with enhanced capabilities. Unlike regular functions, they can:

- Accept a variable number of arguments
- Handle arguments of different types
- Generate code at compile time
- Perform more complex code transformations

This flexibility makes them powerful tools for generic programming and code generation. Let's examine a practical example: implementing a compile-time power function.

To understand how to create an expression macro, we will look at a `pow` macro implementation from the [Alexandria](https://github.com/keep-starknet-strange/alexandria) library that computes the power of a number at compile time.

The core code of the macro implementation is a Rust code that uses three Rust crates : `cairo_lang_macro` specific to macros implementation, `cairo_lang_parser` crate with function related to the compiler parser and `cairo_lang_syntax` related to the compiler syntax. The two latters were initially created for the Cairo lang compiler, as macro functions operate at the Cairo syntax level, we can reuse the logic directly from the syntax functions created for the compiler to create macros.

> **Note:**
> To understand better the Cairo compiler and some of the concepts we only mention here such as the Cairo parser or the Cairo syntax, you can read the [Cairo compiler workshop](https://github.com/software-mansion-labs/cairo-compiler-workshop).

In the `pow` function example below the input is processed to extract the value of the base argument and the exponent argument to return the result of \\(base^{exponent}\\).

```rust noplayground hljs

use bigdecimal::{num_traits::pow, BigDecimal};
use cairo_lang_macro::{inline_macro, Diagnostic, ProcMacroResult, TokenStream};
use cairo_lang_parser::utils::SimpleParserDatabase;

#[inline_macro]
pub fn pow(token_stream: TokenStream) -> ProcMacroResult {
    let db = SimpleParserDatabase::default();
    let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);

    // extracting the args from the parsed input
    let macro_args: Vec<String> = parsed
        .descendants(&db)
        .next()
        .unwrap()
        .get_text(&db)
        .trim_matches(|c| c == '(' || c == ')')
        .split(',')
        .map(|s| s.trim().to_string())
        .collect();

    if macro_args.len() != 2 {
        return ProcMacroResult::new(TokenStream::empty()).with_diagnostics(
            Diagnostic::error(format!("Expected two arguments, got {:?}", macro_args)).into(),
        );
    }

    // getting the value from the base arg
    let base: BigDecimal = match macro_args[0].parse() {
        Ok(val) => val,
        Err(_) => {
            return ProcMacroResult::new(TokenStream::empty())
                .with_diagnostics(Diagnostic::error("Invalid base value").into());
        }
    };

    // getting the value from the exponent arg
    let exp: usize = match macro_args[1].parse() {
        Ok(val) => val,
        Err(_) => {
            return ProcMacroResult::new(TokenStream::empty())
                .with_diagnostics(Diagnostic::error("Invalid exponent value").into());
        }
    };

    // base^exp
    let result: BigDecimal = pow(base, exp);

    ProcMacroResult::new(TokenStream::new(result.to_string()))
}
```

Now that the macro is defined, we can use it. In a Cairo project we need to have `pow = { path = "path/to/pow" }` in the `[dependencies]` target of the `Scarb.toml` manifest file. And then we can use it without further import like this :

```cairo hljs hide-boring

fn main() {
    let a = SomeType {};
    a.hello();

    let res = pow!(10, 2);
    println!("res : {}", res);

    let _a = RenamedType {};
}

#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}

#[rename]
struct OldType {}

#[derive(Drop, Destruct)]
trait Hello<T> {
    fn hello(self: @T);
}

```

Derive macros let you define custom trait implementations that can be automatically applied to types. When you annotate a type with `#[derive(TraitName)]`, your derive macro:

1. Receives the type's structure as input
2. Contains your custom logic for generating the trait implementation
3. Outputs the implementation code that will be included in the crate

Writing derive macros eliminates repetitive trait implementation code by using a generic logic on how to generate the trait implementation.

In this example, we will implement a derive macro that will implement the `Hello` Trait. The `Hello` trait will have a `hello()` function that will print : `Hello, StructName!`, where _StructName_ is the name of the struct.

Here is the definition of the `Hello` trait :

```cairo hljs hide-boring

fn main() {
    let a = SomeType {};
    a.hello();

    let res = pow!(10, 2);
    println!("res : {}", res);

    let _a = RenamedType {};
}

#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}

#[rename]
struct OldType {}

#[derive(Drop, Destruct)]
trait Hello<T> {
    fn hello(self: @T);
}

```

Let's check the marcro implementation, first the `hello_derive` function parses the input token stream and then extracts the `struct_name` to implement the trait for that specific struct.

Then hello derived returns a hard-coded piece of code containing the implementation of `Hello` trait for the type _StructName_.

```rust noplayground hljs

use cairo_lang_macro::{derive_macro, ProcMacroResult, TokenStream};
use cairo_lang_parser::utils::SimpleParserDatabase;
use cairo_lang_syntax::node::kind::SyntaxKind::{TerminalStruct, TokenIdentifier};

#[derive_macro]
pub fn hello_macro(token_stream: TokenStream) -> ProcMacroResult {
    let db = SimpleParserDatabase::default();
    let (parsed, _diag) = db.parse_virtual_with_diagnostics(token_stream);
    let mut nodes = parsed.descendants(&db);

    let mut struct_name = String::new();
    for node in nodes.by_ref() {
        if node.kind(&db) == TerminalStruct {
            struct_name = nodes
                .find(|node| node.kind(&db) == TokenIdentifier)
                .unwrap()
                .get_text(&db);
            break;
        }
    }

    ProcMacroResult::new(TokenStream::new(indoc::formatdoc! {r#"
            impl SomeHelloImpl of Hello<{0}> {{
                fn hello(self: @{0}) {{
                    println!("Hello {0}!");
                }}
            }}
        "#, struct_name}))
}
```

Now that the macro is defined, we can use it. In a Cairo project we need to have `hello_macro = { path = "path/to/hello_macro" }` in the `[dependencies]` target of the `Scarb.toml` manifest file. And we can then use it without further import on any struct :

```cairo noplayground hljs

#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}

```

And now we can call the implemented function `hello` on an variable of the type _SomeType_.

```cairo noplayground hljs hide-boring

fn main() {
    let a = SomeType {};
    a.hello();

    let res = pow!(10, 2);
    println!("res : {}", res);

    let _a = RenamedType {};
}

#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}

#[rename]
struct OldType {}

#[derive(Drop, Destruct)]
trait Hello<T> {
    fn hello(self: @T);
}

```

Note that the `Hello` trait that is implemented in the macro has to be defined somewhere in the code or imported.

Attribute-like macros are similar to custom derive macros, but allowing more possibilities, they are not restricted to struct and enum and can be applied to other items as well, such as functions. They can be used for more diverse code generation than implementing trait. It could be used to modify the name of a struct, add fields in the structure, execute some code before a function, change the signature of a function and many other possibilities.

The extra possibilities also come from the fact that they are defined with a second argument `TokenStream`, indeed the signature looks like this :

```rust noplayground hljs

#[attribute_macro]
pub fn attribute(attr: TokenStream, code: TokenStream) -> ProcMacroResult {}
```

With the first attribute ( `attr`) for the attribute arguments (#\[macro(arguments)\]) and second for the actual code on which the attribute is applied to, the second attribute is the only one the two other macros have.

Now let's look at an example of a custom made attribute macro, in this example we will create a macro that will rename the struct.

```rust noplayground hljs

use cairo_lang_macro::attribute_macro;
use cairo_lang_macro::{ProcMacroResult, TokenStream};

#[attribute_macro]
pub fn rename(_attr: TokenStream, token_stream: TokenStream) -> ProcMacroResult {
    ProcMacroResult::new(TokenStream::new(
        token_stream
            .to_string()
            .replace("struct OldType", "#[derive(Drop)]\n struct RenamedType"),
    ))
}
```

Again, to use the macro in a Cairo project we need to have `rename_macro = { path = "path/to/rename_macro" }` in the `[dependencies]` target of the `Scarb.toml` manifest file. And we can then use it without further import on any struct.

The rename macro can be derived as follow :

```cairo hljs hide-boring

fn main() {
    let a = SomeType {};
    a.hello();

    let res = pow!(10, 2);
    println!("res : {}", res);

    let _a = RenamedType {};
}

#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}

#[rename]
struct OldType {}

#[derive(Drop, Destruct)]
trait Hello<T> {
    fn hello(self: @T);
}

```

Now the compiler knows the _RenamedType_ struct, therefore we can create an instance as such :

```cairo hljs hide-boring

fn main() {
    let a = SomeType {};
    a.hello();

    let res = pow!(10, 2);
    println!("res : {}", res);

    let _a = RenamedType {};
}

#[derive(HelloMacro, Drop, Destruct)]
struct SomeType {}

#[rename]
struct OldType {}

#[derive(Drop, Destruct)]
trait Hello<T> {
    fn hello(self: @T);
}

```

You can notice that the names _OldType_ and _RenamedType_ were hardcoded in the example but could be variables leveraging the second arg of rattribute macro. Also note that due to the order of compilation, the derive of other macro such as _Drop_ here as to be done in the code generated by the macro. Some deeper understanding of Cairo compilation can be required for custom macro creation.

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=551208598.1738498005&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1707110638)

ðŸ’¬

ConnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch00-00-introduction.md "Suggest an edit")

Cairo is a programming language designed to leverage the power of mathematical proofs for computational integrity. Just as C.S. Lewis defined integrity as "doing the right thing, even when no one is watching," Cairo enables programs to prove they've done the right computation, even when executed on untrusted machines.

The language is built on STARK technology, a modern evolution of PCP (Probabilistically Checkable Proofs) that transforms computational claims into constraint systems. While Cairo's ultimate purpose is to generate these mathematical proofs that can be verified efficiently and with absolute certainty.

Cairo enables a paradigm shift in how we think about trusted computation. Its primary application today is Starknet, a Layer 2 scaling solution for Ethereum that addresses one of blockchain's fundamental challenges: scalability without sacrificing security.

In the traditional blockchain model, every participant must verify every computation. Starknet changes this by using Cairo's proof system: computations are executed off-chain by a prover who generates a STARK proof, which is then verified by an Ethereum smart contract. This verification requires significantly less computational power than re-executing the computations, enabling massive scalability while maintaining security.

However, Cairo's potential extends beyond blockchain. Any scenario where computational integrity needs to be verified efficiently can benefit from Cairo's verifiable computation capabilities.

This book caters to three main audiences, each with their own learning path:

1. **General-Purpose Developers**: If you're interested in Cairo for its verifiable computation capabilities outside of blockchain, you'll want to focus on chapters 1-12. These chapters cover the core language features and programming concepts without diving deep into smart contract specifics.

2. **New Smart Contract Developers**: If you're new to both Cairo and smart contracts, we recommend reading the book front to back. This will give you a solid foundation in both the language fundamentals and smart contract development principles.

3. **Experienced Smart Contract Developers**: If you're already familiar with smart contract development in other languages, or Rust, you might want to follow this focused path:
   - Chapters 1-3 for Cairo basics
   - Chapter 8 for Cairo's trait and generics system
   - Skip to Chapter 15 for smart contract development
   - Reference other chapters as needed

Regardless of your background, this book assumes basic programming knowledge such as variables, functions, and common data structures. While prior experience with Rust can be helpful (as Cairo shares many similarities), it's not required.

- Arquitectura del CPU de Cairo: [https://eprint.iacr.org/2021/1063](https://eprint.iacr.org/2021/1063)
- Cairo, Sierra y Casm: [https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5](https://medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5)
- Estado no determinista: [https://twitter.com/PapiniShahar/status/1638203716535713798](https://twitter.com/PapiniShahar/status/1638203716535713798)

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=598932183.1738498023&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1269922667)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=869129039.1738498024&gtm=45je51u0v873244154za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556565&z=1234648120)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-02-smart-pointers.md "Suggest an edit")

A pointer is a general concept for a variable that contains a memory address. This address refers to, or â€œpoints at,â€ some other data. While pointers are a powerful feature, they can also be a source of bugs and security vulnerabilities. For example, a pointer can reference an unassigned memory cell, which means that attempting to access the data at that address would cause the program to crash, making it unprovable. To prevent such issues, Cairo uses _Smart Pointers_.

Smart pointers are data structures that act like a pointer, but also have additional metadata and capabilities. The concept of smart pointers isnâ€™t unique to Cairo: smart pointers originated in C++ and exist in other languages like Rust as well. In the specific case of Cairo, smart pointers ensure that memory is not addressed in an unsafe way that could cause a program to be unprovable, by providing a safe way to access memory through strict type checking and ownership rules.

Though we didnâ€™t call them as such at the time, weâ€™ve already encountered a few smart pointers in this book, including `Felt252Dict<T>` and `Array<T>` in Chapter 3. Both these types count as smart pointers because they own a memory segment and allow you to manipulate it. They also have metadata and extra capabilities or guarantees. Arrays keep track of their current length to ensure that existing elements are not overwritten, and that new elements are only appended to the end.

The Cairo VM memory is composed by multiple segments that can store data, each identified by a unique index. When you create an array, you allocate a new segment in the memory to store the future elements. The array itself is just a pointer to that segment where the elements are stored.

The principal smart pointer type in Cairo is a _box_, denoted as `Box<T>`. Manually defining boxes allow you to store data in a specific memory segment of the Cairo VM called the _boxed segment_. This segment is dedicated to store all boxed values, and what remains in the execution segment is only a pointer to the boxed segment. Whenever you instantiate a new pointer variable of type `Box<T>`, you append the data of type `T` to the boxed segment.

Boxes have very little performance overhead, other than writing their inner values to the boxed segment. But they donâ€™t have many extra capabilities either. Youâ€™ll use them most often in these situations:

- When you have a type whose size canâ€™t be known at compile time and you want to use a value of that type in a context that requires an exact size
- When you have a large amount of data and you want to transfer ownership but ensure the data wonâ€™t be copied when you do so

Weâ€™ll demonstrate the first situation in the [â€œEnabling Recursive Types with Boxesâ€](https://book.cairo-lang.org/ch12-02-smart-pointers.html#enabling-recursive-types-with-nullable-boxes) section.
In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around in memory. To improve performance in this situation, we can store the large amount of data in the boxed segment using a box type. Then, only the small amount of pointer data is copied around in memory, while the data it references stays in one place on the boxed segment.

Before we discuss the boxed segment storage use cases for `Box<T>`, weâ€™ll cover the syntax and how to interact with values stored within a `Box<T>`.

Listing 12-1 shows how to use a box to store a value in the boxed segment:

```cairo hljs

fn main() {
    let b = BoxTrait::new(5_u128);
    println!("b = {}", b.unbox())
}

```

Listing 12-1: Storing a `u128` value in the boxed segment using a box

We define the variable `b` to have the value of a `Box` that points to the value `5`, which is stored in the boxed segment. This program will print `b = 5`; in this case, we can access the data in the box similar to how we would if this data was simply in the execution memory. Putting a single value in a box isnâ€™t very useful, so you wonâ€™t use boxes by themselves in this way very often. Having values like a single `u128` in the execution memory, where theyâ€™re stored by default, is more appropriate in the majority of situations. Letâ€™s look at a case where boxes allow us to define types that we wouldnâ€™t be allowed to if we didnâ€™t have boxes.

A value of recursive type can have another value of the same type as part of itself. Recursive types pose an issue because at compile time because Cairo needs to know how much space a type takes up. However, the nesting of values of recursive types could theoretically continue infinitely, so Cairo canâ€™t know how much space the value needs. Because boxes have a known size, we can enable recursive types by inserting a box in the recursive type definition.

As an example of a recursive type, letâ€™s explore the implementation of a binary tree. The binary tree type weâ€™ll define is straightforward except for the recursion; therefore, the concepts in the example weâ€™ll work with will be useful any time you get into more complex situations involving recursive types.

A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. The last element of a branch is a leaf, which is a node without children.

Listing 12-2 shows an attempt to implement a binary tree of `u32` values. Note that this code wonâ€™t compile yet because the `BinaryTree` type doesnâ€™t have a known size, which weâ€™ll demonstrate.

```cairo noplayground hljs

#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, BinaryTree, BinaryTree),
}

fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, leaf2, leaf3));
    let _root = BinaryTree::Node((5, leaf1, node));
}

```

Listing 12-2: The first attempt at implementing a binary tree of `u32` values

> Note: Weâ€™re implementing a binary tree that holds only u32 values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 8, to define a binary tree that could store values of any type.

The root node contains 5 and two child nodes. The left child is a leaf containing 1. The right child is another node containing 4, which in turn has two leaf children: one containing 2 and another containing 3. This structure forms a simple binary tree with a depth of 2.

If we try to compile the code in listing 12-2, we get the following error:

```plaintext hljs

$ scarb build
   Compiling listing_recursive_types_wrong v0.1.0 (listings/ch12-advanced-features/listing_recursive_types_wrong/Scarb.toml)
error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --> listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:6:5
    Node: (u32, BinaryTree, BinaryTree),
    ^*********************************^

error: Recursive type "listing_recursive_types_wrong::BinaryTree" has infinite size.
 --> listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:10:17
    let leaf1 = BinaryTree::Leaf(1);
                ^*****************^

error: Recursive type "(core::integer::u32, listing_recursive_types_wrong::BinaryTree, listing_recursive_types_wrong::BinaryTree)" has infinite size.
 --> listings/ch12-advanced-features/listing_recursive_types_wrong/src/lib.cairo:13:33
    let node = BinaryTree::Node((4, leaf2, leaf3));
                                ^***************^

error: could not compile `listing_recursive_types_wrong` due to previous error

```

The error shows this type â€œhas infinite size.â€ The reason is that weâ€™ve defined `BinaryTree` with a variant that is recursive: it holds another value of itself directly. As a result, Cairo canâ€™t figure out how much space it needs to store a `BinaryTree` value.

Hopefully, we can fix this error by using a `Box<T>` to store the recursive variant of `BinaryTree`. Because a `Box<T>` is a pointer, Cairo always knows how much space a `Box<T>` needs: a pointerâ€™s size doesnâ€™t change based on the amount of data itâ€™s pointing to. This means we can put a `Box<T>` inside the `Node` variant instead of another `BinaryTree` value directly. The `Box<T>` will point to the child `BinaryTree` values that will be stored in their own segment, rather than inside the `Node` variant. Conceptually, we still have a binary tree, created with binary trees holding other binary trees, but this implementation is now more like placing the items next to one another rather than inside one another.

We can change the definition of the `BinaryTree` enum in Listing 12-2 and the usage of the `BinaryTree` in Listing 12-2 to the code in Listing 12-3, which will compile:

```cairo hljs

use core::box::{BoxTrait};

mod display;
use display::DebugBinaryTree;

#[derive(Copy, Drop)]
enum BinaryTree {
    Leaf: u32,
    Node: (u32, Box<BinaryTree>, Box<BinaryTree>),
}

fn main() {
    let leaf1 = BinaryTree::Leaf(1);
    let leaf2 = BinaryTree::Leaf(2);
    let leaf3 = BinaryTree::Leaf(3);
    let node = BinaryTree::Node((4, BoxTrait::new(leaf2), BoxTrait::new(leaf3)));
    let root = BinaryTree::Node((5, BoxTrait::new(leaf1), BoxTrait::new(node)));

    println!("{:?}", root);
}

```

Listing 12-3: Defining a recursive Binary Tree using Boxes

The `Node` variant now holds a `(u32, Box<BinaryTree>, Box<BinaryTree>)`, indicating that the `Node` variant will store a `u32` value, and two `Box<BinaryTree>` values. Now, we know that the `Node` variant will need a size of `u32` plus the size of the two `Box<BinaryTree>` values. By using a box, weâ€™ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a `BinaryTree` value.

Passing pointers between functions allows you to reference data without copying the data itself. Using boxes can improve performance as it allows you to pass a pointer to some data from one function to another, without the need to copy the entire data in memory before performing the function call. Instead of having to write `n` values into memory before calling a function, only a single value is written, corresponding to the pointer to the data. If the data stored in the box is very large, the performance improvement can be significant, as you would save `n-1` memory operations before each function call.

Let's take a look at the code in Listing 12-4, which shows two ways of passing data to a function: by value and by pointer.

```cairo hljs

#[derive(Drop)]
struct Cart {
    paid: bool,
    items: u256,
    buyer: ByteArray,
}

fn pass_data(cart: Cart) {
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

fn pass_pointer(cart: Box<Cart>) {
    let cart = cart.unbox();
    println!("{} is shopping today and bought {} items", cart.buyer, cart.items);
}

fn main() {
    let new_struct = Cart { paid: true, items: 1, buyer: "Eli" };
    pass_data(new_struct);

    let new_box = BoxTrait::new(Cart { paid: false, items: 2, buyer: "Uri" });
    pass_pointer(new_box);
}

```

Listing 12-4: Storing large amounts of data in a box for performance.

The `main` function includes 2 function calls:

- `pass_data` that takes a variable of type `Cart`.
- `pass_pointer` that takes a pointer of type `Box<Cart>`.

When passing data to a function, the entire data is copied into the last available memory cells right before the function call. Calling `pass_data` will copy all 3 fields of `Cart` to memory, while `pass_pointer` only requires the copy of the `new_box` pointer which is of size 1.

![box memory](https://book.cairo-lang.org/box_memory.png)

CairoVM Memory layout when using boxes

The illustration above demonstrates how the memory behaves in both cases. The first instance of `Cart` is stored in the execution segment, and we need to copy all its fields to memory before calling the `pass_data` function. The second instance of `Cart` is stored in the boxed segment, and the pointer to it is stored in the execution segment. When calling the `pass_pointer` function, only the pointer to the struct is copied to memory right before the function call. In both cases, however, instantiating the struct will store all its values in the execution segment: the boxed segment can only be filled with data taken from the execution segment.

`Nullable<T>` is another type of smart pointer that can either point to a value or be `null` in the absence of value. It is defined at the Sierra level. This type is mainly used in dictionaries that contain types that don't implement the `zero_default` method of the `Felt252DictValue<T>` trait (i.e., arrays and structs).

If we try to access an element that does not exist in a dictionary, the code will fail if the `zero_default` method cannot be called.

[Chapter 3](https://book.cairo-lang.org/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively) about dictionaries thoroughly explains how to store a `Span<felt252>` variable inside a dictionary using the `Nullable<T>` type. Please refer to it for further information.

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch204-02-builtins-list.md "Suggest an edit")

The following table lists the different builtins implemented
in the Cairo VM and gives a brief description of their purpose.
For each builtin, a specific section details how it works,
its cells organization if any, and references their actual
implementation in different implementations of the Cairo VM.

Additional resources related to the operation performed
by the builtin are provided if relevant.

| Builtin | Description |
| --- | --- |
| [Output](https://book.cairo-lang.org/ch204-02-00-output.html) | Stores all the public memory needed to generate a STARK proof (input & output values, builtin pointers...) |
| [Pedersen](https://book.cairo-lang.org/ch204-02-01-pedersen.html) | Computes the Pedersen hash `h` of two felts `a` and `b`. `h = Pedersen(a, b)` |
| [Range Check](https://book.cairo-lang.org/ch204-02-02-range-check.html) | Verify that a felt `x` is within the bounds `[0, 2**128)`. |\
| [ECDSA](https://book.cairo-lang.org/ch204-02-03-ecdsa.html) | Verify that the ECDSA signature of a given public key `pub` on a message `m` equals `sig`, previously stored. Only used by Cairo Zero. |\
| [Bitwise](https://book.cairo-lang.org/ch204-02-04-bitwise.html) | Computes the bitwise AND, XOR and OR of two felts `a` and `b`. `a & b`, `a ^ b` and `a | b`. |\
| [EC OP](https://book.cairo-lang.org/ch204-02-05-ec-op.html) | Performs Elliptic Curve OPerations - For two points on the STARK curve `P`, `Q` and a scalar `m`, computes `R = P + mQ`. |\
| [Keccak](https://book.cairo-lang.org/ch204-02-06-keccak.html) | Computes the new state `s'` after applying the 24 rounds of the keccak-f1600 block permutation on a given state `s`. |\
| [Poseidon](https://book.cairo-lang.org/ch204-02-07-poseidon.html) | Computes the new state `s'` after applying the 91 rounds of the hades block permutation on a given state `s`. |\
| [Range Check96](https://book.cairo-lang.org/ch204-02-08-range-check-96.html) | Verify that a felt `x` is within the bounds `[0, 2**96)`. |\
| [AddMod](https://book.cairo-lang.org/ch204-02-09-add-mod.html) | Arithmetic Circuit Support - Computes the modular addition `c` of two felts `a`, `b` by batches. `c â‰¡ a + b mod(p)` |\
| [MulMod](https://book.cairo-lang.org/ch204-02-10-mul-mod.html) | Arithmetic Circuit Support - Computes the modular multiplication `c` of two felts `a`, `b` by batches. `c â‰¡ a * b mod(p)` |\
| [Segment Arena](https://book.cairo-lang.org/ch204-02-11-segment-arena.html) | Manages the Cairo dictionaries Not used in Cairo Zero. |\
| [Gas](https://book.cairo-lang.org/ch204-02-12-gas.html) | Manages the available gas during the run. Used by Starknet to handle its gas usage and avoid DoS. |\
| [System](https://book.cairo-lang.org/ch204-02-13-system.html) | Manages the Starknet syscalls & cheatcodes. |\
\
ðŸ’¬\
\
[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=2011239735.1738498025&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102015666~102067808~102081485~102123608~102482433~102528644~102539968~102546754&z=1964954701)\
\
DisconnectedChatÃ—\
\
Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1644241301.1738498025&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754~102558064&z=351903498)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch03-02-dictionaries.md "Suggest an edit")

Cairo menyediakan dalam pustaka intinya tipe data yang mirip dengan kamus (dictionary-like type). Tipe data `Felt252Dict<T>` mewakili kumpulan pasangan kunci-nilai dimana setiap kunci bersifat unik dan terkait dengan nilai yang sesuai. Jenis struktur data ini dikenal dengan berbagai istilah dalam bahasa pemrograman yang berbeda, seperti maps, hash tables, associative arrays, dan banyak yang lainnya.

Tipe `Felt252Dict<T>` berguna ketika Anda ingin mengatur data Anda dengan cara tertentu di mana penggunaan `Array<T>` dan pengindeksan tidak mencukupi. Kamus Cairo juga memungkinkan programmer untuk dengan mudah mensimulasikan keberadaan memori yang dapat diubah (mutable memory) ketika memori tersebut sebenarnya tidak ada.

It is normal in other languages when creating a new dictionary to define the data types of both key and value. In Cairo, the key type is restricted to `felt252`, leaving only the possibility to specify the value data type, represented by `T` in `Felt252Dict<T>`.

Fungsi inti dari `Felt252Dict<T>` diimplementasikan dalam trait `Felt252DictTrait` yang mencakup semua operasi dasar. Di antara mereka, kita dapat menemukan:

1. `insert(felt252, T) -> ()` untuk menulis nilai ke sebuah contoh kamus (dictionary) dan
2. `get(felt252) -> T` untuk membaca nilai dari kamus tersebut.

Fungsi-fungsi ini memungkinkan kita untuk memanipulasi kamus seperti dalam bahasa pemrograman lainnya. Pada contoh berikut, kita membuat sebuah kamus untuk merepresentasikan hubungan antara individu dan saldo mereka:

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();

    balances.insert('Alex', 100);
    balances.insert('Maria', 200);

    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Balance is not 100");

    let maria_balance = balances.get('Maria');
    assert!(maria_balance == 200, "Balance is not 200");
}

```

We can create a new instance of `Felt252Dict<u64>` by using the `default` method of the `Default` trait and add two individuals, each one with their own balance, using the `insert` method. Finally, we check the balance of our users with the `get` method. These methods are defined in the `Felt252DictTrait` trait in the core library.

Throughout the book we have talked about how Cairo's memory is immutable, meaning you can only write to a memory cell once but the `Felt252Dict<T>` type represents a way to overcome this obstacle. We will explain how this is implemented later on in ["Dictionaries Underneath"](https://book.cairo-lang.org/id/ch03-02-dictionaries.html#dictionaries-underneath).

Mengembangkan dari contoh sebelumnya, mari tunjukkan contoh kode di mana saldo dari pengguna yang sama berubah:

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();

    // Insert Alex with 100 balance
    balances.insert('Alex', 100);
    // Check that Alex has indeed 100 associated with him
    let alex_balance = balances.get('Alex');
    assert!(alex_balance == 100, "Alex balance is not 100");

    // Insert Alex again, this time with 200 balance
    balances.insert('Alex', 200);
    // Check the new balance is correct
    let alex_balance_2 = balances.get('Alex');
    assert!(alex_balance_2 == 200, "Alex balance is not 200");
}

```

Notice how in this example we added the 'Alex' individual twice, each time using a different balance and each time that we checked for its balance it had the last value inserted! `Felt252Dict<T>` effectively allows us to "rewrite" the stored value for any given key.

Sebelum melanjutkan dan menjelaskan bagaimana kamus diimplementasikan, penting untuk disebutkan bahwa begitu Anda membuat sebuah `Felt252Dict<T>`, di balik layar semua kunci memiliki nilai terkait mereka diinisialisasi sebagai nol. Ini berarti bahwa jika misalnya, Anda mencoba untuk mendapatkan saldo dari pengguna yang tidak ada, Anda akan mendapatkan nilai 0 daripada sebuah kesalahan atau nilai yang tidak terdefinisi. Ini juga berarti bahwa tidak ada cara untuk menghapus data dari sebuah kamus. Hal yang perlu diperhatikan ketika menggabungkan struktur ini ke dalam kode Anda.

Hingga saat ini, kita telah melihat semua fitur dasar dari `Felt252Dict<T>` dan bagaimana ia meniru perilaku yang sama seperti struktur data yang sesuai dalam bahasa pemrograman lainnya, yaitu, secara eksternal tentunya. Cairo pada intinya adalah bahasa pemrograman yang non-deterministik dan lengkap secara Turing, sangat berbeda dari bahasa lain yang populer saat ini, yang sebagai konsekuensinya berarti bahwa kamus diimplementasikan dengan cara yang sangat berbeda juga!

Pada bagian-bagian berikutnya, kami akan memberikan beberapa wawasan tentang mekanisme internal `Felt252Dict<T>` dan kompromi yang diambil untuk membuatnya berfungsi. Setelah itu, kita akan melihat bagaimana menggunakan kamus dengan struktur data lain serta menggunakan metode `entry` sebagai cara lain untuk berinteraksi dengan mereka.

Salah satu batasan dari desain non-deterministik Cairo adalah sistem memorinya yang tidak dapat diubah, sehingga untuk mensimulasikan keberlangsungan, bahasa ini mengimplementasikan `Felt252Dict<T>` sebagai daftar entri. Setiap entri mewakili waktu ketika sebuah kamus diakses untuk tujuan membaca/memperbarui/menulis. Sebuah entri memiliki tiga bidang:

1. A `key` field that identifies the key for this key-value pair of the dictionary.
2. Bidang `previous_value` yang menunjukkan nilai sebelumnya yang dipegang oleh `key`.
3. Bidang `new_value` yang menunjukkan nilai baru yang dipegang oleh `key`.

Jika kita mencoba mengimplementasikan `Felt252Dict<T>` menggunakan struktur tingkat tinggi, kita akan mendefinisikannya secara internal sebagai `Array<Entry<T>>` di mana setiap `Entry<T>` memiliki informasi tentang pasangan kunci-nilai yang direpresentasikannya dan nilai-nilai sebelumnya dan baru yang dipegangnya. Definisi dari `Entry<T>` akan menjadi:

```cairo noplayground hljs

struct Entry<T> {
    key: felt252,
    previous_value: T,
    new_value: T,
}

```

For each time we interact with a `Felt252Dict<T>`, a new `Entry<T>` will be registered:

- Sebuah `get` akan mendaftarkan sebuah entri di mana tidak ada perubahan dalam keadaan, dan nilai-nilai sebelumnya dan baru disimpan dengan nilai yang sama.
- Sebuah `insert` akan mendaftarkan sebuah `Entry<T>` baru dimana `new_value` akan menjadi elemen yang sedang dimasukkan, dan `previous_value` akan menjadi elemen terakhir yang dimasukkan sebelum ini. Jika ini adalah entri pertama untuk sebuah kunci tertentu, maka nilai sebelumnya akan menjadi nol.

Penggunaan daftar entri ini menunjukkan bahwa tidak ada penulisan ulang (rewriting), hanya penciptaan sel memori baru setiap kali ada interaksi dengan `Felt252Dict<T>`. Mari tunjukkan contohnya dengan menggunakan kamus `balances` dari bagian sebelumnya dan memasukkan pengguna 'Alex' dan 'Maria':

```cairo hljs hide-boring

use core::dict::Felt252Dict;

struct Entry<T> {
    key: felt252,
    previous_value: T,
    new_value: T,
}

fn main() {
    let mut balances: Felt252Dict<u64> = Default::default();
    balances.insert('Alex', 100_u64);
    balances.insert('Maria', 50_u64);
    balances.insert('Alex', 200_u64);
    balances.get('Maria');
}

```

Instruksi-instruksi ini kemudian akan menghasilkan daftar entri berikut:

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 100 |
| Maria | 0 | 50 |
| Alex | 100 | 200 |
| Maria | 50 | 50 |

Perhatikan bahwa karena 'Alex' dimasukkan dua kali, ia muncul dua kali dan nilai `sebelumnya` dan `saat ini` diatur dengan benar. Juga membaca dari 'Maria' mendaftarkan sebuah entri tanpa perubahan dari nilai sebelumnya ke nilai saat ini.

Pendekatan ini dalam mengimplementasikan `Felt252Dict<T>` berarti bahwa untuk setiap operasi baca/tulis, terjadi pemindaian pada seluruh daftar entri untuk mencari entri terakhir dengan `kunci` yang sama. Setelah entri ditemukan, `nilai_baru`-nya diekstrak dan digunakan pada entri baru yang akan ditambahkan sebagai `nilai_sebelumnya`. Hal ini berarti berinteraksi dengan `Felt252Dict<T>` memiliki kompleksitas waktu kasus terburuk `O(n)` di mana `n` adalah jumlah entri dalam daftar.

Jika Anda memikirkan alternatif cara untuk mengimplementasikan `Felt252Dict<T>`, mungkin Anda akan menemukannya, bahkan mungkin benar-benar menghilangkan kebutuhan akan bidang `nilai_sebelumnya`. Namun, karena Cairo bukanlah bahasa yang biasa, hal ini tidak akan berhasil. Salah satu tujuan dari Cairo adalah, dengan sistem bukti STARK, untuk menghasilkan bukti integritas komputasi. Ini berarti Anda perlu memverifikasi bahwa eksekusi program adalah benar dan berada dalam batasan-batasan Cairo. Salah satu pemeriksaan batasan tersebut terdiri dari "dictionary squashing" dan hal itu membutuhkan informasi tentang nilai sebelumnya dan nilai baru untuk setiap entri.

To verify that the proof generated by a Cairo program execution that used a `Felt252Dict<T>` is correct, we need to check that there wasn't any illegal tampering with the dictionary. This is done through a method called `squash_dict` that reviews each entry of the entry list and checks that access to the dictionary remains coherent throughout the execution.

Proses merenggut (squashing) dilakukan sebagai berikut: diberikan semua entri dengan kunci tertentu `k`, diambil dalam urutan yang sama seperti saat mereka dimasukkan, verifikasi bahwa nilai `new_value` entri ke-i sama dengan nilai `previous_value` entri ke-(i+1).

Sebagai contoh, diberikan daftar entri berikut:

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 150 |
| Maria | 0 | 100 |
| Charles | 0 | 70 |
| Maria | 100 | 250 |
| Alex | 150 | 40 |
| Alex | 40 | 300 |
| Maria | 250 | 190 |
| Alex | 300 | 90 |

Setelah proses merenggut (squashing), daftar entri akan berkurang menjadi:

| key | previous | new |
| --- | --- | --- |
| Alex | 0 | 90 |
| Maria | 0 | 190 |
| Charles | 0 | 70 |

Dalam kasus perubahan pada salah satu nilai dari tabel pertama, proses merenggut (squashing) akan gagal selama runtime.

If you run the examples from ["Basic Use of Dictionaries"](https://book.cairo-lang.org/id/ch03-02-dictionaries.html#basic-use-of-dictionaries) section, you'd notice that there was never a call to squash dictionary, but the program compiled successfully nonetheless. What happened behind the scene was that squash was called automatically via the `Felt252Dict<T>` implementation of the `Destruct<T>` trait. This call occurred just before the `balance` dictionary went out of scope.

The `Destruct<T>` trait represents another way of removing instances out of scope apart from `Drop<T>`. The main difference between these two is that `Drop<T>` is treated as a no-op operation, meaning it does not generate new CASM while `Destruct<T>` does not have this restriction. The only type which actively uses the `Destruct<T>` trait is `Felt252Dict<T>`, for every other type `Destruct<T>` and `Drop<T>` are synonyms. You can read more about these traits in [Drop and Destruct](https://book.cairo-lang.org/id/appendix-03-derivable-traits.html#drop-and-destruct) section of Appendix C.

Later in ["Dictionaries as Struct Members"](https://book.cairo-lang.org/id/ch12-01-custom-data-structures.html#dictionaries-as-struct-members) section, we will have a hands-on example where we implement the `Destruct<T>` trait for a custom type.

Hingga saat ini, kami telah memberikan gambaran menyeluruh tentang fungsionalitas `Felt252Dict<T>` serta bagaimana dan mengapa ia diimplementasikan dengan cara tertentu. Jika Anda belum memahami semuanya, jangan khawatir karena dalam bagian ini kami akan memberikan beberapa contoh lebih lanjut menggunakan kamus.

We will start by explaining the `entry` method which is part of a dictionary basic functionality included in `Felt252DictTrait<T>` which we didn't mention at the beginning. Soon after, we will see examples of how to use `Felt252Dict<T>` with other [complex types](https://book.cairo-lang.org/id/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively) such as `Array<T>`.

In the ["Dictionaries Underneath"](https://book.cairo-lang.org/id/ch03-02-dictionaries.html#dictionaries-underneath) section, we explained how `Felt252Dict<T>` internally worked. It was a list of entries for each time the dictionary was accessed in any manner. It would first find the last entry given a certain `key` and then update it accordingly to whatever operation it was executing. The Cairo language gives us the tools to replicate this ourselves through the `entry` and `finalize` methods.

Metode `entry` disertakan sebagai bagian dari `Felt252DictTrait<T>` dengan tujuan untuk membuat entri baru berdasarkan suatu kunci tertentu. Setelah dipanggil, metode ini mengambil kepemilikan dari kamus dan mengembalikan entri untuk diperbarui. Tanda tangan metodenya adalah sebagai berikut:

```cairo noplayground hljs

fn entry(self: Felt252Dict<T>, key: felt252) -> (Felt252DictEntry<T>, T) nopanic

```

The first input parameter takes ownership of the dictionary while the second one is used to create the appropriate entry. It returns a tuple containing a `Felt252DictEntry<T>`, which is the type used by Cairo to represent dictionary entries, and a `T` representing the value held previously. The `nopanic` notation simply indicates that the function is guaranteed to never panic.

Langkah selanjutnya adalah memperbarui entri dengan nilai baru. Untuk ini, kita menggunakan metode `finalize` yang memasukkan entri dan mengembalikan kepemilikan dari kamus:

```cairo noplayground hljs

fn finalize(self: Felt252DictEntry<T>, new_value: T) -> Felt252Dict<T>

```

This method receives the entry and the new value as parameters, and returns the updated dictionary.

Mari kita lihat contoh penggunaan `entry` dan `finalize`. Bayangkan kita ingin mengimplementasikan versi kita sendiri dari metode `get` dari sebuah kamus. Maka kita harus melakukan hal berikut:

1. Create the new entry to add using the `entry` method.
2. Masukkan kembali entri di mana `nilai_baru` sama dengan `nilai_sebelumnya`.
3. Kembalikan value tersebut.

Implementasi custom `get` kita akan terlihat seperti ini:

```cairo noplayground hljs

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get<T, +Felt252DictValue<T>, +Drop<T>, +Copy<T>>(
    ref dict: Felt252Dict<T>, key: felt252,
) -> T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}

```

The `ref` keyword means that the ownership of the variable will be given back at the end of the function. This concept will be explained in more detail in the ["References and Snapshots"](https://book.cairo-lang.org/id/ch04-02-references-and-snapshots.html) section.

Mengimplementasikan metode `insert` akan mengikuti alur kerja yang serupa, kecuali untuk memasukkan nilai baru saat proses finalisasi. Jika kita hendak mengimplementasikannya, akan terlihat seperti berikut:

```cairo noplayground hljs

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_insert<T, +Felt252DictValue<T>, +Destruct<T>, +Drop<T>>(
    ref dict: Felt252Dict<T>, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}

```

Sebagai catatan penyelesaian, kedua metode ini diimplementasikan dengan cara yang mirip dengan bagaimana `insert` dan `get` diimplementasikan untuk `Felt252Dict<T>`. Kode ini menunjukkan contoh penggunaannya:

```cairo hljs hide-boring

use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn custom_get<T, +Felt252DictValue<T>, +Drop<T>, +Copy<T>>(
    ref dict: Felt252Dict<T>, key: felt252,
) -> T {
    // Get the new entry and the previous value held at `key`
    let (entry, prev_value) = dict.entry(key);

    // Store the value to return
    let return_value = prev_value;

    // Update the entry with `prev_value` and get back ownership of the dictionary
    dict = entry.finalize(prev_value);

    // Return the read value
    return_value
}

fn custom_insert<T, +Felt252DictValue<T>, +Destruct<T>, +Drop<T>>(
    ref dict: Felt252Dict<T>, key: felt252, value: T,
) {
    // Get the last entry associated with `key`
    // Notice that if `key` does not exist, `_prev_value` will
    // be the default value of T.
    let (entry, _prev_value) = dict.entry(key);

    // Insert `entry` back in the dictionary with the updated value,
    // and receive ownership of the dictionary
    dict = entry.finalize(value);
}

fn main() {
    let mut dict: Felt252Dict<u64> = Default::default();

    custom_insert(ref dict, '0', 100);

    let val = custom_get(ref dict, '0');

    assert!(val == 100, "Expecting 100");
}

```

One restriction of `Felt252Dict<T>` that we haven't talked about is the trait `Felt252DictValue<T>`. This trait defines the `zero_default` method which is the one that gets called when a value does not exist in the dictionary. This is implemented by some common data types, such as most unsigned integers, `bool` and `felt252` \- but it is not implemented for more complex types such as arrays, structs (including `u256`), and other types from the core library. This means that making a dictionary of types not natively supported is not a straightforward task, because you would need to write a couple of trait implementations in order to make the data type a valid dictionary value type. To compensate this, you can wrap your type inside a `Nullable<T>`.

`Nullable<T>` is a smart pointer type that can either point to a value or be `null` in the absence of value. It is usually used in Object Oriented Programming Languages when a reference doesn't point anywhere. The difference with `Option` is that the wrapped value is stored inside a `Box<T>` data type. The `Box<T>` type is a smart pointer that allows us to use a dedicated `boxed_segment` memory segment for our data, and access this segment using a pointer that can only be manipulated in one place at a time. See [Smart Pointers Chapter](https://book.cairo-lang.org/id/ch12-02-smart-pointers.html) for more information.

Mari kita tunjukkan dengan contoh. Kita akan mencoba menyimpan sebuah `Span<felt252>` di dalam sebuah kamus. Untuk itu, kita akan menggunakan `Nullable<T>` dan `Box<T>`. Selain itu, kita menyimpan sebuah `Span<T>` dan bukan sebuah `Array<T>` karena yang terakhir tidak mengimplementasikan trait `Copy<T>` yang diperlukan untuk membaca dari sebuah kamus.

```cairo noplayground hljs

use core::dict::Felt252Dict;
use core::nullable::{NullableTrait, match_nullable, FromNullableResult};

fn main() {
    // Create the dictionary
    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

//...

```

Dalam potongan kode ini, yang pertama kita lakukan adalah membuat kamus baru `d`. Kita ingin kamus ini menampung `Nullable<Span>`. Setelah itu, kita membuat sebuah array dan mengisinya dengan nilai-nilai.

The last step is inserting the array as a span inside the dictionary. Notice that we do this using the `new` function of the `NullableTrait`.

Setelah elemen berada di dalam kamus, dan kita ingin mengambilnya, kita mengikuti langkah yang sama namun dalam urutan terbalik. Berikut adalah contoh kode untuk mencapainya:

```cairo noplayground hljs

//...

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value found"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

```

Here we:

1. Baca nilai menggunakan `get`.
2. Verifikasi bahwa nilai tersebut tidak null menggunakan fungsi `match_nullable`.
3. Membuka nilai _wrapped_ di dalam kotak dan memastikan bahwa itu benar.

Skrip lengkap akan terlihat seperti ini:

```cairo hljs

use core::dict::Felt252Dict;
use core::nullable::{NullableTrait, match_nullable, FromNullableResult};

fn main() {
    // Create the dictionary
    let mut d: Felt252Dict<Nullable<Span<felt252>>> = Default::default();

    // Create the array to insert
    let a = array![8, 9, 10];

    // Insert it as a `Span`
    d.insert(0, NullableTrait::new(a.span()));

    // Get value back
    let val = d.get(0);

    // Search the value and assert it is not null
    let span = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value found"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };

    // Verify we are having the right values
    assert!(*span.at(0) == 8, "Expecting 8");
    assert!(*span.at(1) == 9, "Expecting 9");
    assert!(*span.at(2) == 10, "Expecting 10");
}

```

In the previous section, we explored how to store and retrieve complex types inside a dictionary using `Nullable<T>` and `Box<T>`. Now, let's take a look at how to store an array inside a dictionary and dynamically modify its contents.

Storing arrays in dictionaries in Cairo is slightly different from storing other types. This is because arrays are more complex data structures that require special handling to avoid issues with memory copying and references.

First, let's look at how to create a dictionary and insert an array into it. This process is pretty straightforward and follows a similar pattern to inserting other types of data:

```cairo hljs

use core::dict::Felt252Dict;

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array inserted successfully.");
}

```

However, attempting to read an array from the dictionary using the `get` method will result in a compiler error. This is because `get` tries to copy the array in memory, which is not possible for arrays (as we've already mentioned in the [previous section](https://book.cairo-lang.org/id/ch03-02-dictionaries.html#dictionaries-of-types-not-supported-natively), `Array<T>` does not implement the `Copy<T>` trait):

```cairo hljs

use core::nullable::{match_nullable, FromNullableResult};
use core::dict::Felt252Dict;

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Array: {:?}", get_array_entry(ref dict, 0));
}

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let val = dict.get(0); // This will cause a compiler error
    let arr = match match_nullable(val) {
        FromNullableResult::Null => panic!("No value!"),
        FromNullableResult::NotNull(val) => val.unbox(),
    };
    arr.span()
}

```

```shell hljs

$ scarb cairo-run
   Compiling no_listing_15_dict_of_array_attempt_get v0.1.0 (listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/Scarb.toml)
error: Trait has no implementation in context: core::traits::Copy::<core::nullable::Nullable::<core::array::Array::<core::integer::u8>>>.
 --> listings/ch03-common-collections/no_listing_15_dict_of_array_attempt_get/src/lib.cairo:13:20
    let val = dict.get(0); // This will cause a compiler error
                   ^*^

error: could not compile `no_listing_15_dict_of_array_attempt_get` due to previous error
error: `scarb metadata` exited with error

```

To correctly read an array from the dictionary, we need to use dictionary entries. This allows us to get a reference to the array value without copying it:

```cairo noplayground hljs

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

```

> Note: We must convert the array to a `Span` before finalizing the entry, because calling `NullableTrait::new(arr)` moves the array, thus making it impossible to return it from the function.

To modify the stored array, such as appending a new value, we can use a similar approach. The following `append_value` function demonstrates this:

```cairo noplayground hljs

fn append_value(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

```

In the `append_value` function, we access the dictionary entry, dereference the array, append the new value, and finalize the entry with the updated array.

> Note: Removing an item from a stored array can be implemented in a similar manner.

Below is the complete example demonstrating the creation, insertion, reading, and modification of an array in a dictionary:

```cairo hljs

use core::nullable::NullableTrait;
use core::dict::{Felt252Dict, Felt252DictEntryTrait};

fn append_value(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252, value: u8) {
    let (entry, arr) = dict.entry(index);
    let mut unboxed_val = arr.deref_or(array![]);
    unboxed_val.append(value);
    dict = entry.finalize(NullableTrait::new(unboxed_val));
}

fn get_array_entry(ref dict: Felt252Dict<Nullable<Array<u8>>>, index: felt252) -> Span<u8> {
    let (entry, _arr) = dict.entry(index);
    let mut arr = _arr.deref_or(array![]);
    let span = arr.span();
    dict = entry.finalize(NullableTrait::new(arr));
    span
}

fn main() {
    let arr = array![20, 19, 26];
    let mut dict: Felt252Dict<Nullable<Array<u8>>> = Default::default();
    dict.insert(0, NullableTrait::new(arr));
    println!("Before insertion: {:?}", get_array_entry(ref dict, 0));

    append_value(ref dict, 0, 30);

    println!("After insertion: {:?}", get_array_entry(ref dict, 0));
}

```

Start

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/es/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch104-01-general-recommendations.md "Suggest an edit")

Cuando se desarrolla software, asegurarse de que funciona segÃºn lo previsto suele ser sencillo. Sin embargo, evitar usos no previstos y vulnerabilidades puede ser mÃ¡s difÃ­cil.

En el desarrollo de contratos inteligentes, la seguridad es muy importante. Un solo error puede provocar la pÃ©rdida de activos valiosos o el funcionamiento incorrecto de determinadas caracterÃ­sticas.

Los Smart contracts se ejecutan en un entorno pÃºblico en el que cualquiera puede examinar el cÃ³digo e interactuar con Ã©l. Cualquier error o vulnerabilidad en el cÃ³digo puede ser explotado por actores maliciosos.

Este capÃ­tulo presenta recomendaciones generales para escribir contratos inteligentes seguros. Al incorporar estos conceptos durante el desarrollo, puedes crear contratos inteligentes robustos y confiables. Esto reduce las posibilidades de comportamientos inesperados o vulnerabilidades.

Este capÃ­tulo no proporciona una lista exhaustiva de todos los posibles problemas de seguridad, y no garantiza que sus contratos sean completamente seguros.

Si estÃ¡ desarrollando contratos inteligentes para su uso en producciÃ³n, es muy recomendable llevar a cabo auditorÃ­as externas realizadas por expertos en seguridad.

Cairo is a highly safe language inspired by Rust. It is designed in a way that forces you to cover all possible cases. Security issues on Starknet mostly arise from the way smart contract flows are designed, not much from the language itself.

Adoptar una mentalidad de seguridad es el paso inicial para escribir contratos inteligentes seguros. Intenta considerar siempre todos los escenarios posibles al escribir cÃ³digo.

Las transacciones en los smart contracts son atÃ³micas, lo que significa que tienen Ã©xito o fracasan sin realizar ningÃºn cambio.

Think of smart contracts as state machines: they have a set of initial states defined by the constructor constraints, and external functions represent a set of possible state transitions. A transaction is nothing more than a state transition.

The `assert!` or `panic!` macros can be used to validate conditions before performing specific actions. You can learn more about these on the [Unrecoverable Errors with panic](https://book.cairo-lang.org/es/ch09-01-unrecoverable-errors-with-panic.html) page.

Estas validaciones pueden incluir:

- Inputs provided by the caller
- Execution requirements
- Invariants (conditions that must always be true)
- Return values from other function calls

For example, you could use the `assert!` macro to validate that a user has enough funds to perform a withdraw transaction. If the condition is not met, the transaction will fail and the state of the contract will not change.

```cairo noplayground hljs

    impl Contract of IContract<ContractState> {
        fn withdraw(ref self: ContractState, amount: u256) {
            let current_balance = self.balance.read();

            assert!(self.balance.read() >= amount, "Insufficient funds");

            self.balance.write(current_balance - amount);
        }

```

El uso de estas funciones para comprobar condiciones aÃ±ade restricciones que ayudan a definir claramente los lÃ­mites de las posibles transiciones de estado para cada funciÃ³n de tu smart contract. Estas comprobaciones garantizan que el comportamiento del contrato se mantenga dentro de los lÃ­mites esperados.

El patrÃ³n Checks Effects Interactions es un patrÃ³n de diseÃ±o comÃºn utilizado para prevenir ataques de reentrada en Ethereum. Aunque la reentrada es mÃ¡s difÃ­cil de conseguir en Starknet, se recomienda utilizar este patrÃ³n en los smart contracts.

El patrÃ³n consiste en seguir un orden especÃ­fico de operaciones en sus funciones:

1. **Checks**: Validate all conditions and inputs before performing any state changes.
2. **Effects**: Perform all state changes.
3. **Interactions**: All external calls to other contracts should be made at the end of the function.

El Control de Acceso es el proceso de restringir el acceso a determinadas funciones o recursos. Es un mecanismo de seguridad comÃºn utilizado para evitar el acceso no autorizado a informaciÃ³n o acciones sensibles. En los contratos inteligentes, algunas funciones pueden a menudo estar restringidas a usuarios o roles especÃ­ficos.

Puede implementar el patrÃ³n de control de acceso para gestionar fÃ¡cilmente los permisos. Este patrÃ³n consiste en definir un conjunto de funciones y asignarlas a usuarios especÃ­ficos. Cada funciÃ³n puede entonces restringirse a roles especÃ­ficos.

```cairo noplayground hljs

#[starknet::contract]
mod access_control_contract {
    use core::starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, StorageMapReadAccess,
        StorageMapWriteAccess, Map,
    };
    use core::starknet::ContractAddress;
    use core::starknet::get_caller_address;

    trait IContract<TContractState> {
        fn is_owner(self: @TContractState) -> bool;
        fn is_role_a(self: @TContractState) -> bool;
        fn only_owner(self: @TContractState);
        fn only_role_a(self: @TContractState);
        fn only_allowed(self: @TContractState);
        fn set_role_a(ref self: TContractState, _target: ContractAddress, _active: bool);
        fn role_a_action(ref self: ContractState);
        fn allowed_action(ref self: ContractState);
    }

    #[storage]
    struct Storage {
        // Role 'owner': only one address
        owner: ContractAddress,
        // Role 'role_a': a set of addresses
        role_a: Map::<ContractAddress, bool>,
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.owner.write(get_caller_address());
    }

    // Guard functions to check roles

    impl Contract of IContract<ContractState> {
        #[inline(always)]
        fn is_owner(self: @ContractState) -> bool {
            self.owner.read() == get_caller_address()
        }

        #[inline(always)]
        fn is_role_a(self: @ContractState) -> bool {
            self.role_a.read(get_caller_address())
        }

        #[inline(always)]
        fn only_owner(self: @ContractState) {
            assert!(Self::is_owner(self), "Not owner");
        }

        #[inline(always)]
        fn only_role_a(self: @ContractState) {
            assert!(Self::is_role_a(self), "Not role A");
        }

        // You can easily combine guards to perform complex checks
        fn only_allowed(self: @ContractState) {
            assert!(Self::is_owner(self) || Contract::is_role_a(self), "Not allowed");
        }

        // Functions to manage roles

        fn set_role_a(ref self: ContractState, _target: ContractAddress, _active: bool) {
            Self::only_owner(@self);
            self.role_a.write(_target, _active);
        }

        // You can now focus on the business logic of your contract
        // and reduce the complexity of your code by using guard functions

        fn role_a_action(ref self: ContractState) {
            Self::only_role_a(@self);
            // ...
        }

        fn allowed_action(ref self: ContractState) {
            Self::only_allowed(@self);
            // ...
        }
    }
}

```

ðŸ’¬

[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1647330346.1738498026&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482433~102528644~102539968~102546754~102556566&z=1707821862)

DisconnectedChatÃ—

Send[iframe](https://td.doubleclick.net/td/ga/rul?tid=G-0ZJLBV4KE2&gacid=1050834441.1738498026&gtm=45je51u0v873244154z89192743044za200&dma=0&gcd=13l3l3l3l1l1&npa=0&pscdl=noapi&aip=1&fledge=1&frm=0&tag_exp=102067808~102081485~102123608~102482432~102528644~102539968~102546754&z=1636757201)

- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/id/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch01-02-hello-world.md "Suggest an edit")

Sekarang bahwa Anda telah menginstal Cairo melalui Scarb, saatnya untuk menulis program Cairo pertama Anda. Adalah tradisi ketika belajar bahasa baru untuk menulis program kecil yang mencetak teks Hello, world! ke layar, jadi kita akan melakukan hal yang sama di sini!

> Note: This book assumes basic familiarity with the command line. Cairo makes no specific demands about your editing or tooling or where your code lives, so if you prefer to use an integrated development environment (IDE) instead of the command line, feel free to use your favorite IDE. The Cairo team has developed a VSCode extension for the Cairo language that you can use to get the features from the language server and code highlighting. See [Appendix F](https://book.cairo-lang.org/id/appendix-06-useful-development-tools.html) for more details.

Anda akan memulai dengan membuat direktori untuk menyimpan kode Cairo Anda. Tidak masalah bagi Cairo di mana kode Anda berada, tetapi untuk latihan dan proyek dalam buku ini, kami menyarankan untuk membuat direktori cairo\_projects di direktori rumah Anda dan menyimpan semua proyek Anda di sana.

Open a terminal and enter the following commands to make a _cairo\_projects_ directory.

Untuk Linux, macOS, dan PowerShell di Windows, masukkan ini:

```shell hljs

mkdir ~/cairo_projects
cd ~/cairo_projects

```

Untuk Windows CMD, enter this:

```cmd hljs

> mkdir "%USERPROFILE%\cairo_projects"
> cd /d "%USERPROFILE%\cairo_projects"

```

> Catatan: Mulai dari sekarang, untuk setiap contoh yang ditunjukkan dalam buku ini, kami mengasumsikan bahwa Anda akan bekerja dari direktori proyek Scarb. Jika Anda tidak menggunakan Scarb, dan mencoba menjalankan contoh-contoh dari direktori yang berbeda, Anda mungkin perlu menyesuaikan perintah-perintahnya atau membuat proyek Scarb.

Mari membuat sebuah projek menggunakan Scarb.

Navigate to your _cairo\_projects_ directory (or wherever you decided to store your code). Then run the following:

```bash hljs

scarb new hello_world

```

Scarb will ask you about the dependencies you want to add. You will be given two options :

```text hljs plaintext

? Which test runner do you want to set up? â€º
â¯ Starknet Foundry (default)
  Cairo Test

```

In general, we'll prefer using the first one `â¯ Starknet Foundry (default)`.

This creates a new directory and project called _hello\_world_. Weâ€™ve named our project _hello\_world_, and Scarb creates its files in a directory of the same name.

Go into the _hello\_world_ directory with the command `cd hello_world`. Youâ€™ll see that Scarb has generated three files and two directory for us: a _Scarb.toml_ file, a _src_ directory with a _lib.cairo_ file inside and a _tests_ directory containing a _test\_contract.cairo_ file. For now, we can remove this _tests_ directory.

Scarb juga telah menginisialisasi repositori Git baru bersama dengan file `.gitignore`

> Note: Git is a common version control system. You can stop using version control system by using the `--no-vcs` flag. Run `scarb new --help` to see the available options.

Open _Scarb.toml_ in your text editor of choice. It should look similar to the code in Listing 1-1.

Filename: Scarb.toml

```toml hljs ini

[package]
name = "test"
version = "0.1.0"
edition = "2024_07"

# See more keys and their definitions at https://docs.swmansion.com/scarb/docs/reference/manifest.html

[dependencies]
starknet = "2.9.2"

[dev-dependencies]
snforge_std = "0.35.1"
assert_macros = "2.9.2"

[[target.starknet-contract]]
sierra = true

[scripts]
test = "snforge test"

# ...

```

Listing 1-1: Contents of _Scarb.toml_ generated by `scarb new`

File ini menggunakan format [TOML](https://toml.io/) (Tomâ€™s Obvious, Minimal Language), yang mana merupakan format konfigurasi Scarb.

Baris pertama, `[package]`, adalah judul bagian yang menunjukkan bahwa pernyataan berikut sedang mengonfigurasi sebuah paket. Saat kami menambahkan lebih banyak informasi ke file ini, kami akan menambahkan bagian lain.

The next three lines set the configuration information Scarb needs to compile your program: the name of the package and the version of Scarb to use, and the edition of the prelude to use. The prelude is the collection of the most commonly used items that are automatically imported into every Cairo program. You can learn more about the prelude in [Appendix D](https://book.cairo-lang.org/id/appendix-04-cairo-prelude.html).

The `[dependencies]` section, is the start of a section for you to list any of your projectâ€™s dependencies. In Cairo, packages of code are referred to as crates. We wonâ€™t need any other crates for this project.

The `[dev-dependencies]` section is about dependencies that are required for development, but are not needed for the actual production build of the project. `snforge_std` and `assert_macros` are two examples of such dependencies. If you want to test your project without using Starknet Foundry, you can use `cairo_test`.

The `[[target.starknet-contract]]` section allows to build Starknet smart contracts. We can remove it for now.

The `[script]` section allows to define custom scripts. By default, there is one script for running tests using `snforge` with the `scarb test` command. We can also remove it for now.

Starknet Foundry also have more options, check out [Starknet Foundry documentation](https://foundry-rs.github.io/starknet-foundry/appendix/scarb-toml.html) for more information.

By default, using Starknet Foundry adds the `starknet` dependency and the `[[target.starknet-contract]]` section, so that you can build contracts for Starknet out of the box. We will start with only Cairo programs, so you can edit your _Scarb.toml_ file to the following:

Filename: Scarb.toml

```toml hljs ini

[package]
name = "hello_world"
version = "0.1.0"
edition = "2024_07"

[dependencies]

```

Listing 1-2: Contents of modified _Scarb.toml_

The other file created by Scarb is _src/lib.cairo_, let's delete all the content and put in the following content, we will explain the reason later.

```cairo noplayground hljs

mod hello_world;

```

Then create a new file called _src/hello\_world.cairo_ and put the following code in it:

Filename: src/hello\_world.cairo

```cairo hljs

fn main() {
    println!("Hello, World!");
}

```

We have just created a file called _lib.cairo_, which contains a module declaration referencing another module named `hello_world`, as well as the file _hello\_world.cairo_, containing the implementation details of the `hello_world` module.

Scarb requires your source files to be located within the _src_ directory.

The top-level project directory is reserved for _README_ files, license information, configuration files, and any other non-code-related content. Scarb ensures a designated location for all project components, maintaining a structured organization.

If you started a project that doesnâ€™t use Scarb, you can convert it to a project that does use Scarb. Move the project code into the _src_ directory and create an appropriate _Scarb.toml_ file. You can also use `scarb init` command to generate the _src_ folder and the _Scarb.toml_ it contains.

```txt hljs plaintext

â”œâ”€â”€ Scarb.toml
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ lib.cairo
â”‚   â””â”€â”€ hello_world.cairo

```

A sample Scarb project structure

From your _hello\_world_ directory, build your project by entering the following command:

```bash hljs

$ scarb build
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 8 seconds

```

This command creates a `hello_world.sierra.json` file in _target/dev_, let's ignore the `sierra` file for now.

If you have installed Cairo correctly, you should be able to run the `main` function of your program with the `scarb cairo-run` command and see the following output:

```shell hljs

$ scarb cairo-run
   Compiling hello_world v0.1.0 (listings/ch01-getting-started/no_listing_01_hello_world/Scarb.toml)
    Finished `dev` profile target(s) in 15 seconds
     Running hello_world
Hello, World!
Run completed successfully, returning []

```

Regardless of your operating system, the string `Hello, world!` should be printed to the terminal.

If `Hello, world!` did print, congratulations! Youâ€™ve officially written a Cairo program. That makes you a Cairo programmer â€” welcome!

Mari kita ulas â€œHello, world!â€ program ini secara detail. Ini bagian pertama dari teka-teki:

```cairo noplayground hljs

fn main() {

}

```

Baris-baris ini mendefinisikan fungsi bernama `main`. Fungsi `main` adalah spesial: itu selalu menjadi kode pertama yang dijalankan di setiap program Cairo yang dapat dieksekusi.Di sini, baris pertama mendeklarasikan fungsi bernama `main` yang tidak memiliki parameterdan tidak mengembalikan apa pun. Jika ada parameter, parameter tersebut akan masuk ke dalam tanda kurung `()`.

Fungsi badan dibungkus dengan `{}`. Cairo memerlukan tanda kurung kurawal di sekelilingnya semua badan berfungsi. Sebaiknya letakkan tanda kurung kurawal pembuka di baris yang sama dengan deklarasi fungsi, menambahkan satu spasi di antaranya.

> Note: If you want to stick to a standard style across Cairo projects, you can use the automatic formatter tool available with `scarb fmt` to format your code in a particular style (more on `scarb fmt` in [Appendix F](https://book.cairo-lang.org/id/appendix-06-useful-development-tools.html)). The Cairo team has included this tool with the standard Cairo distribution, as `cairo-run` is, so it should already be installed on your computer!

Badan fungsi `main` berisi kode berikut:

```cairo noplayground hljs

    println!("Hello, World!");

```

Baris ini melakukan semua pekerjaan dalam program kecil ini: ia mencetak teks kelayar. Ada empat detail penting yang perlu diperhatikan di sini.

Pertama, gaya Cairo adalah membuat indentasi dengan empat spasi, bukan tab.

Second, `println!` calls a Cairo macro. If it had called a function instead, it would be entered as `println` (without the `!`). Weâ€™ll discuss Cairo macros in more detail in the ["Macros"](https://book.cairo-lang.org/id/ch12-05-macros.html) chapter. For now, you just need to know that using a `!` means that youâ€™re calling a macro instead of a normal function and that macros donâ€™t always follow the same rules as functions.

Third, you see the `"Hello, world!"` string. We pass this string as an argument to `println!`, and the string is printed to the screen.

Keempat, kita mengakhiri baris dengan titik koma ( `;`), yang menunjukkan bahwa Ekspresi ini sudah selesai dan yang berikutnya siap dimulai. Sebagian besar jalur di Cairokode diakhiri dengan titik koma.

Start

Mari kita rekap apa yang telah kita pelajari sejauh ini tentang Scarb:

- We can install one or multiple Scarb versions, either the latest stable or a specific one, using asdf.
- Kita dapat membuat proyek menggunakan `scarb new`.
- Kita dapat membangun proyek menggunakan `scarb build` untuk menghasilkan kode Sierra yang telah dikompilasi.
- We can execute a Cairo program using the `scarb cairo-run` command.

Keuntungan tambahan menggunakan Scarb adalah perintahnya sama, tidaktidak peduli sistem operasi apa yang sedang Anda gunakan. Jadi, pada titik ini, kami tidak akan melakukannyalagi memberikan instruksi khusus untuk Linux dan macOS versus Windows.

Youâ€™re already off to a great start on your Cairo journey! This is a great time to build a more substantial program to get used to reading and writing Cairo code.

ðŸ’¬

DisconnectedChatÃ—

Send- Light
- Rust
- Coal
- Navy
- Ayu

# The Cairo Programming Language

[![Cairo Logo](https://book.cairo-lang.org/icons/Cairo_logo_500x500.png)Cairo Home](https://cairo-lang.org/ "Cairo Home")

- English
- EspaÃ±ol
- FranÃ§ais
- ç®€ä½“ä¸­æ–‡
- Indonesian
- TurkÃ§e

[Print this book](https://book.cairo-lang.org/print.html "Print this book")[Git repository](https://github.com/cairo-book/cairo-book.github.io "Git repository")[Suggest an edit](https://github.com/cairo-book/cairo-book.github.io/edit/main/src/ch12-10-associated-items.md "Suggest an edit")

_Associated Items_ are the items declared in [traits](https://book.cairo-lang.org/ch08-02-traits-in-cairo.html) or defined in
[implementations](https://book.cairo-lang.org/ch08-02-traits-in-cairo.html#implementing-a-trait-on-a-type). Specifically, there are [associated functions](https://book.cairo-lang.org/ch05-03-method-syntax.html#associated-functions) (including methods, that we already covered in Chapter 5), [associated types](https://book.cairo-lang.org/ch12-10-associated-items.html#associated-types), [associated constants](https://book.cairo-lang.org/ch12-10-associated-items.html#associated-constants), and [associated implementations](https://book.cairo-lang.org/ch12-10-associated-items.html#associated-implementations).

Associated items are useful when they are logically related to the implementation. For example, the `is_some` method on `Option` is intrinsically related to Options, so should be associated.

Every associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions.

Associated types are _type aliases_ allowing you to define abstract type placeholders within traits. Instead of specifying concrete types in the trait definition, associated types let trait implementers choose the actual types to use.

Let's consider the following `Pack` trait:

```cairo noplayground hljs hide-boring

trait Pack<T> {
    type Result;

    fn pack(self: T, other: T) -> Self::Result;
}

impl PackU32Impl of Pack<u32> {
    type Result = u64;

    fn pack(self: u32, other: u32) -> Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn bar<T, impl PackImpl: Pack<T>>(self: T, b: T) -> PackImpl::Result {
    PackImpl::pack(self, b)
}

trait PackGeneric<T, U> {
    fn pack_generic(self: T, other: T) -> U;
}

impl PackGenericU32 of PackGeneric<u32, u64> {
    fn pack_generic(self: u32, other: u32) -> u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn foo<T, U, +PackGeneric<T, U>>(self: T, other: T) -> U {
    self.pack_generic(other)
}

fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}

```

The `Result` type in our `Pack` trait acts as placeholder for a type that will be filled in later. Think of associated types as leaving a blank space in your trait for each implementation to write in the specific type it needs. This approach keeps your trait definition clean and flexible. When you use the trait, you don't need to worry about specifying these types - they're already chosen for you by the implementation. In our `Pack` trait, the type `Result` is such a placeholder. The method's definition shows that it will return values of type `Self::Result`, but it doesn't specify what `Result` actually is. This is left to the implementers of the `Pack` trait, who will specify the concrete type for `Result`. When the `pack` method is called, it will return a value of that chosen concrete type, whatever it may be.

Let's see how associated types compare to a more traditional generic approach. Suppose we need a function `foo` that can pack two variables of type `T`. Without associated types, we might define a `PackGeneric` trait and an implementation to pack two `u32` like this:

```cairo noplayground hljs hide-boring

trait Pack<T> {
    type Result;

    fn pack(self: T, other: T) -> Self::Result;
}

impl PackU32Impl of Pack<u32> {
    type Result = u64;

    fn pack(self: u32, other: u32) -> Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn bar<T, impl PackImpl: Pack<T>>(self: T, b: T) -> PackImpl::Result {
    PackImpl::pack(self, b)
}

trait PackGeneric<T, U> {
    fn pack_generic(self: T, other: T) -> U;
}

impl PackGenericU32 of PackGeneric<u32, u64> {
    fn pack_generic(self: u32, other: u32) -> u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn foo<T, U, +PackGeneric<T, U>>(self: T, other: T) -> U {
    self.pack_generic(other)
}

fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}

```

With this approach, `foo` would be implemented as:

```cairo noplayground hljs hide-boring

trait Pack<T> {
    type Result;

    fn pack(self: T, other: T) -> Self::Result;
}

impl PackU32Impl of Pack<u32> {
    type Result = u64;

    fn pack(self: u32, other: u32) -> Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn bar<T, impl PackImpl: Pack<T>>(self: T, b: T) -> PackImpl::Result {
    PackImpl::pack(self, b)
}

trait PackGeneric<T, U> {
    fn pack_generic(self: T, other: T) -> U;
}

impl PackGenericU32 of PackGeneric<u32, u64> {
    fn pack_generic(self: u32, other: u32) -> u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn foo<T, U, +PackGeneric<T, U>>(self: T, other: T) -> U {
    self.pack_generic(other)
}

fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}

```

Notice how `foo` needs to specify both `T` and `U` as generic parameters. Now, let's compare this to our `Pack` trait with an associated type:

```cairo noplayground hljs hide-boring

trait Pack<T> {
    type Result;

    fn pack(self: T, other: T) -> Self::Result;
}

impl PackU32Impl of Pack<u32> {
    type Result = u64;

    fn pack(self: u32, other: u32) -> Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn bar<T, impl PackImpl: Pack<T>>(self: T, b: T) -> PackImpl::Result {
    PackImpl::pack(self, b)
}

trait PackGeneric<T, U> {
    fn pack_generic(self: T, other: T) -> U;
}

impl PackGenericU32 of PackGeneric<u32, u64> {
    fn pack_generic(self: u32, other: u32) -> u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn foo<T, U, +PackGeneric<T, U>>(self: T, other: T) -> U {
    self.pack_generic(other)
}

fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}

```

With associated types, we can define `bar` more concisely:

```cairo noplayground hljs hide-boring

trait Pack<T> {
    type Result;

    fn pack(self: T, other: T) -> Self::Result;
}

impl PackU32Impl of Pack<u32> {
    type Result = u64;

    fn pack(self: u32, other: u32) -> Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn bar<T, impl PackImpl: Pack<T>>(self: T, b: T) -> PackImpl::Result {
    PackImpl::pack(self, b)
}

trait PackGeneric<T, U> {
    fn pack_generic(self: T, other: T) -> U;
}

impl PackGenericU32 of PackGeneric<u32, u64> {
    fn pack_generic(self: u32, other: u32) -> u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn foo<T, U, +PackGeneric<T, U>>(self: T, other: T) -> U {
    self.pack_generic(other)
}

fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}

```

Finally, let's see both approaches in action, demonstrating that the end result is the same:

```cairo hljs hide-boring

trait Pack<T> {
    type Result;

    fn pack(self: T, other: T) -> Self::Result;
}

impl PackU32Impl of Pack<u32> {
    type Result = u64;

    fn pack(self: u32, other: u32) -> Self::Result {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn bar<T, impl PackImpl: Pack<T>>(self: T, b: T) -> PackImpl::Result {
    PackImpl::pack(self, b)
}

trait PackGeneric<T, U> {
    fn pack_generic(self: T, other: T) -> U;
}

impl PackGenericU32 of PackGeneric<u32, u64> {
    fn pack_generic(self: u32, other: u32) -> u64 {
        let shift: u64 = 0x100000000; // 2^32
        self.into() * shift + other.into()
    }
}

fn foo<T, U, +PackGeneric<T, U>>(self: T, other: T) -> U {
    self.pack_generic(other)
}

fn main() {
    let a: u32 = 1;
    let b: u32 = 1;

    let x = foo(a, b);
    let y = bar(a, b);

    // result is 2^32 + 1
    println!("x: {}", x);
    println!("y: {}", y);
}

```

As you can see, `bar` doesn't need to specify a second generic type for the packing result. This information is hidden in the implementation of the `Pack` trait, making the function signature cleaner and more flexible. Associated types allow us to express the same functionality with less verbosity, while still maintaining the flexibility of generic programming.

Associated constants are constants associated with a type. They are declared using the `const` keyword in a trait and defined in its implementation.
In our next example, we define a generic `Shape` trait that we implement for a `Triangle` and a `Square`. This trait includes an associated constant, defining the number of sides of the type that implements the trait.

```cairo noplayground hljs hide-boring

trait Shape<T> {
    const SIDES: u32;
    fn describe() -> ByteArray;
}

struct Triangle {}

impl TriangleShape of Shape<Triangle> {
    const SIDES: u32 = 3;
    fn describe() -> ByteArray {
        "I am a triangle."
    }
}

struct Square {}

impl SquareShape of Shape<Square> {
    const SIDES: u32 = 4;
    fn describe() -> ByteArray {
        "I am a square."
    }
}

fn print_shape_info<T, impl ShapeImpl: Shape<T>>() {
    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
}

fn main() {
    print_shape_info::<Triangle>();
    print_shape_info::<Square>();
}

```

After that, we create a `print_shape_info` generic function, which requires that the generic argument implements the `Shape` trait. This function will use the associated constant to retrieve the number of sides of the geometric figure, and print it along with its description.

```cairo noplayground hljs hide-boring

trait Shape<T> {
    const SIDES: u32;
    fn describe() -> ByteArray;
}

struct Triangle {}

impl TriangleShape of Shape<Triangle> {
    const SIDES: u32 = 3;
    fn describe() -> ByteArray {
        "I am a triangle."
    }
}

struct Square {}

impl SquareShape of Shape<Square> {
    const SIDES: u32 = 4;
    fn describe() -> ByteArray {
        "I am a square."
    }
}

fn print_shape_info<T, impl ShapeImpl: Shape<T>>() {
    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
}

fn main() {
    print_shape_info::<Triangle>();
    print_shape_info::<Square>();
}

```

Associated constants allow us to bind a constant number to the `Shape` trait rather than adding it to the struct or just hardcoding the value in the implementation. This approach provides several benefits:

1. It keeps the constant closely tied to the trait, improving code organization.
2. It allows for compile-time checks to ensure all implementors define the required constant.
3. It ensures two instances of the same type have the same number of sides.

Associated constants can also be used for type-specific behavior or configuration, making them a versatile tool in trait design.

We can ultimately run the `print_shape_info` and see the output for both `Triangle` and `Square`:

```cairo hljs hide-boring

trait Shape<T> {
    const SIDES: u32;
    fn describe() -> ByteArray;
}

struct Triangle {}

impl TriangleShape of Shape<Triangle> {
    const SIDES: u32 = 3;
    fn describe() -> ByteArray {
        "I am a triangle."
    }
}

struct Square {}

impl SquareShape of Shape<Square> {
    const SIDES: u32 = 4;
    fn describe() -> ByteArray {
        "I am a square."
    }
}

fn print_shape_info<T, impl ShapeImpl: Shape<T>>() {
    println!("I have {} sides. {}", ShapeImpl::SIDES, ShapeImpl::describe());
}

fn main() {
    print_shape_info::<Triangle>();
    print_shape_info::<Square>();
}

```

Associated implementations allow you to declare that a trait implementation must exist for an associated type. This feature is particularly useful when you want to enforce relationships between types and implementations at the trait level. It ensures type safety and consistency across different implementations of a trait, which is important in generic programming contexts.

To understand the utility of associated implementations, let's examine the `Iterator` and `IntoIterator` traits from the Cairo core library, with their respective implementations using `ArrayIter<T>` as the collection type:

```cairo noplayground hljs hide-boring

// Collection type that contains a simple array
#[derive(Drop)]
pub struct ArrayIter<T> {
    array: Array<T>,
}

// T is the collection type
pub trait Iterator<T> {
    type Item;
    fn next(ref self: T) -> Option<Self::Item>;
}

impl ArrayIterator<T> of Iterator<ArrayIter<T>> {
    type Item = T;
    fn next(ref self: ArrayIter<T>) -> Option<T> {
        self.array.pop_front()
    }
}

/// Turns a collection of values into an iterator
pub trait IntoIterator<T> {
    /// The iterator type that will be created
    type IntoIter;
    impl Iterator: Iterator<Self::IntoIter>;

    fn into_iter(self: T) -> Self::IntoIter;
}

impl ArrayIntoIterator<T> of IntoIterator<Array<T>> {
    type IntoIter = ArrayIter<T>;
    fn into_iter(self: Array<T>) -> ArrayIter<T> {
        ArrayIter { array: self }
    }
}

fn main() {
    let mut arr: Array<felt252> = array![1, 2, 3];

    // Converts the array into an iterator
    let mut iter = arr.into_iter();

    // Uses the iterator to print each element
    loop {
        match iter.next() {
            Option::Some(item) => println!("Item: {}", item),
            Option::None => { break; },
        };
    }
}

```

1. The `IntoIterator` trait is designed to convert a collection into an iterator.
2. The `IntoIter` associated type represents the specific iterator type that will be created. This allows different collections to define their own efficient iterator types.
3. The associated implementation `Iterator: Iterator<Self::IntoIter>` (the key feature we're discussing) declares that this `IntoIter` type must implement the `Iterator` trait.
4. This design allows for type-safe iteration without needing to specify the iterator type explicitly every time, improving code ergonomics.

The associated implementation creates a binding at the trait level, guaranteeing that:

- The `into_iter` method will always return a type that implements `Iterator`.
- This relationship is enforced for all implementations of `IntoIterator`, not just on a case-by-case basis.

The following `main` function demonstrates how this works in practice for an `Array<felt252>`:

```cairo hljs hide-boring

// Collection type that contains a simple array
#[derive(Drop)]
pub struct ArrayIter<T> {
    array: Array<T>,
}

// T is the collection type
pub trait Iterator<T> {
    type Item;
    fn next(ref self: T) -> Option<Self::Item>;
}

impl ArrayIterator<T> of Iterator<ArrayIter<T>> {
    type Item = T;
    fn next(ref self: ArrayIter<T>) -> Option<T> {
        self.array.pop_front()
    }
}

/// Turns a collection of values into an iterator
pub trait IntoIterator<T> {
    /// The iterator type that will be created
    type IntoIter;
    impl Iterator: Iterator<Self::IntoIter>;

    fn into_iter(self: T) -> Self::IntoIter;
}

impl ArrayIntoIterator<T> of IntoIterator<Array<T>> {
    type IntoIter = ArrayIter<T>;
    fn into_iter(self: Array<T>) -> ArrayIter<T> {
        ArrayIter { array: self }
    }
}

fn main() {
    let mut arr: Array<felt252> = array![1, 2, 3];

    // Converts the array into an iterator
    let mut iter = arr.into_iter();

    // Uses the iterator to print each element
    loop {
        match iter.next() {
            Option::Some(item) => println!("Item: {}", item),
            Option::None => { break; },
        };
    }
}

```

