# https://docs.openzeppelin.com/contracts-cairo/ llms-full.txt

Community Contracts - OpenZeppelin Docs

# Community Contracts


[Contracts for CairoA library for secure smart contract development written in Cairo for Starknet.](https://docs.openzeppelin.com/contracts-cairo/0.20.0/)



# Components

The following documentation provides reasoning and examples on how to use Contracts for Cairo components.

Starknet components are separate modules that contain storage, events, and implementations that can be integrated into a contract.
Components themselves cannot be declared or deployed.
Another way to think of components is that they are abstract modules that must be instantiated.

|     |     |
| --- | --- |
|  | For more information on the construction and design of Starknet components, see the [Starknet Shamans post](https://community.starknet.io/t/cairo-components/101136#components-1) and the [Cairo book](https://book.cairo-lang.org/ch99-01-05-00-components.html). |

## Building a contract

### Setup

The contract should first import the component and declare it with the `component!` macro:

```cairo hljs
#[starknet::contract]
mod MyContract {
    // Import the component
    use openzeppelin_security::InitializableComponent;

    // Declare the component
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);
}
```

The `path` argument should be the imported component itself (in this case, [InitializableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/security#initializable)).
The `storage` and `event` arguments are the variable names that will be set in the `Storage` struct and `Event` enum, respectively.
Note that even if the component doesn’t define any events, the compiler will still create an empty event enum inside the component module.

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }
}
```

The `#[substorage(v0)]` attribute must be included for each component in the `Storage` trait.
This allows the contract to have indirect access to the component’s storage.
See [Accessing component storage](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#accessing_component_storage) for more on this.

The `#[flat]` attribute for events in the `Event` enum, however, is not required.
For component events, the first key in the event log is the component ID.
Flattening the component event removes it, leaving the event ID as the first key.

### Implementations

Components come with granular implementations of different interfaces.
This allows contracts to integrate only the implementations that they’ll use and avoid unnecessary bloat.
Integrating an implementation looks like this:

```cairo hljs
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    // Gives the contract access to the implementation methods
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
```

Defining an `impl` gives the contract access to the methods within the implementation from the component.
For example, `is_initialized` is defined in the `InitializableImpl`.
A function on the contract level can expose it like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;

    #[external(v0)]
    fn is_initialized(ref self: ContractState) -> bool {
        self.initializable.is_initialized()
    }
}
```

While there’s nothing wrong with manually exposing methods like in the previous example, this process can be tedious for implementations with many methods.
Fortunately, a contract can embed implementations which will expose all of the methods of the implementation.
To embed an implementation, add the `#[abi(embed_v0)]` attribute above the `impl`:

```cairo hljs
#[starknet::contract]
mod MyContract {
    (...)

    // This attribute exposes the methods of the `impl`
    #[abi(embed_v0)]
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
```

`InitializableImpl` defines the `is_initialized` method in the component.
By adding the embed attribute, `is_initialized` becomes a contract entrypoint for `MyContract`.

|     |     |
| --- | --- |
|  | Embeddable implementations, when available in this library’s components, are segregated from the internal component implementation which makes it easier to safely expose.<br>Components also separate granular implementations from [mixin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins) implementations.<br>The API documentation design reflects these groupings.<br>See [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component) as an example which includes:<br>- **Embeddable Mixin Implementation**<br>  <br>- **Embeddable Implementations**<br>  <br>- **Internal Implementations**<br>  <br>- **Events** |

### Mixins

Mixins are impls made of a combination of smaller, more specific impls.
While separating components into granular implementations offers flexibility,
integrating components with many implementations can appear crowded especially if the contract uses all of them.
Mixins simplify this by allowing contracts to embed groups of implementations with a single directive.

Compare the following code blocks to see the benefit of using a mixin when creating an account contract.

#### Account without mixin

```cairo hljs
component!(path: AccountComponent, storage: account, event: AccountEvent);
component!(path: SRC5Component, storage: src5, event: SRC5Event);

#[abi(embed_v0)]
impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;
#[abi(embed_v0)]
impl DeclarerImpl = AccountComponent::DeclarerImpl<ContractState>;
#[abi(embed_v0)]
impl DeployableImpl = AccountComponent::DeployableImpl<ContractState>;
#[abi(embed_v0)]
impl PublicKeyImpl = AccountComponent::PublicKeyImpl<ContractState>;
#[abi(embed_v0)]
impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;
#[abi(embed_v0)]
impl PublicKeyCamelImpl = AccountComponent::PublicKeyCamelImpl<ContractState>;
impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

#[abi(embed_v0)]
impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
```

#### Account with mixin

```cairo hljs
component!(path: AccountComponent, storage: account, event: AccountEvent);
component!(path: SRC5Component, storage: src5, event: SRC5Event);

#[abi(embed_v0)]
impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;
```

The rest of the setup for the contract, however, does not change.
This means that component dependencies must still be included in the `Storage` struct and `Event` enum.
Here’s a full example of an account contract that embeds the `AccountMixinImpl`:

```cairo hljs
#[starknet::contract]
mod Account {
    use openzeppelin_account::AccountComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // This embeds all of the methods from the many AccountComponent implementations
    // and also includes `supports_interface` from `SRC5Impl`
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
    }
}
```

### Initializers

|     |     |
| --- | --- |
|  | Failing to use a component’s `initializer` can result in irreparable contract deployments.<br>Always read the API documentation for each integrated component. |

Some components require some sort of setup upon construction.
Usually, this would be a job for a constructor; however, components themselves cannot implement constructors.
Components instead offer `initializer` s within their `InternalImpl` to call from the contract’s constructor.
Let’s look at how a contract would integrate [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent):

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Invoke ownable's `initializer`
        self.ownable.initializer(owner);
    }
}
```

### Immutable Config

While initializers help set up the component’s initial state, some require configuration that may be defined
as constants, saving gas by avoiding the necessity of reading from storage each time the variable needs to be used. The
Immutable Component Config pattern helps with this matter by allowing the implementing contract to define a set of
constants declared in the component, customizing its functionality.

|     |     |
| --- | --- |
|  | The Immutable Component Config standard is defined in the [SRC-107](https://github.com/starknet-io/SNIPs/blob/963848f0752bde75c7087c2446d83b7da8118b25/SNIPS/snip-107.md). |

Here’s an example of how to use the Immutable Component Config pattern with the [ERC2981Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component):

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::common::erc2981::ERC2981Component;
    use starknet::contract_address_const;

    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = ERC2981Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc2981: ERC2981Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC2981Event: ERC2981Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    // Define the immutable config
    pub impl ERC2981ImmutableConfig of ERC2981Component::ImmutableConfig {
        const FEE_DENOMINATOR: u128 = 10_000;
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let default_receiver = contract_address_const::<'RECEIVER'>();
        let default_royalty_fraction = 1000;
        // Invoke erc2981's `initializer`
        self.erc2981.initializer(default_receiver, default_royalty_fraction);
    }
}
```

#### Default config

Sometimes, components implementing the Immutable Component Config pattern provide a default configuration that can be
directly used without implementing the `ImmutableConfig` trait locally. When provided, this implementation will be named
`DefaultConfig` and will be available in the same module containing the component, as a sibling.

In the following example, the `DefaultConfig` trait is used to define the `FEE_DENOMINATOR` config constant.

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;
    // Bring the DefaultConfig trait into scope
    use openzeppelin_token::common::erc2981::{ERC2981Component, DefaultConfig};
    use starknet::contract_address_const;

    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = ERC2981Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        (...)
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        (...)
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let default_receiver = contract_address_const::<'RECEIVER'>();
        let default_royalty_fraction = 1000;
        // Invoke erc2981's `initializer`
        self.erc2981.initializer(default_receiver, default_royalty_fraction);
    }
}
```

#### `validate` function

The `ImmutableConfig` trait may also include a `validate` function with a default implementation, which
asserts that the configuration is correct, and must not be overridden by the implementing contract. For more information
on how to use this function, refer to the [validate section of the SRC-107](https://github.com/starknet-io/SNIPs/blob/963848f0752bde75c7087c2446d83b7da8118b25/SNIPS/snip-107.md#validate-function).

### Dependencies

Some components include dependencies of other components.
Contracts that integrate components with dependencies must also include the component dependency.
For instance, [AccessControlComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) depends on [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component).
Creating a contract with `AccessControlComponent` should look like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    #[abi(embed_v0)]
    impl AccessControlCamelImpl =
        AccessControlComponent::AccessControlCamelImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    (...)
}
```

## Customization

|     |     |
| --- | --- |
|  | Customizing implementations and accessing component storage can potentially corrupt the state, bypass security checks, and undermine the component logic.<br>**Exercise extreme caution**. See [Security](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#security). |

### Hooks

Hooks are entrypoints to the business logic of a token component that are accessible at the contract level.
This allows contracts to insert additional behaviors before and/or after token transfers (including mints and burns).
Prior to hooks, extending functionality required contracts to create [custom implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#custom_implementations).

All token components include a generic hooks trait that include empty default functions.
When creating a token contract, the using contract must create an implementation of the hooks trait.
Suppose an ERC20 contract wanted to include Pausable functionality on token transfers.
The following snippet leverages the `before_update` hook to include this behavior.

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_security::pausable::PausableComponent::InternalTrait;
    use openzeppelin_security::pausable::PausableComponent;
    use openzeppelin_token::erc20::ERC20Component;
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    // Create the hooks implementation
    impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {
        // Occurs before token transfers
        fn before_update(
            ref self: ERC20Component::ComponentState<ContractState>,
            from: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) {
            // Access local state from component state
            let contract_state = self.get_contract();
            // Call function from integrated component
            contract_state.pausable.assert_not_paused();
        }

        // Omitting the `after_update` hook because the default behavior
        // is already implemented in the trait
    }

    (...)
}
```

Notice that the `self` parameter expects a component state type.
Instead of passing the component state, the using contract’s state can be passed which simplifies the syntax.
The hook then moves the scope up with the Cairo-generated `get_contract` through the `HasComponent` trait (as illustrated with ERC20Component in this example).
From here, the hook can access the using contract’s integrated components, storage, and implementations.

Be advised that even if a token contract does not require hooks, the hooks trait must still be implemented.
The using contract may instantiate an empty impl of the trait;
however, the Contracts for Cairo library already provides the instantiated impl to abstract this away from contracts.
The using contract just needs to bring the implementation into scope like this:

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::ERC20Component;
    use openzeppelin_token::erc20::ERC20HooksEmptyImpl;

    (...)
}
```

|     |     |
| --- | --- |
|  | For a more in-depth guide on hooks, see [Extending Cairo Contracts with Hooks](https://fleming-andrew.medium.com/extending-cairo-contracts-with-hooks-c3ca21d1d6b8). |

### Custom implementations

There are instances where a contract requires different or amended behaviors from a component implementation.
In these scenarios, a contract must create a custom implementation of the interface.
Let’s break down a pausable ERC20 contract to see what that looks like.
Here’s the setup:

```cairo hljs
#[starknet::contract]
mod ERC20Pausable {
    use openzeppelin_security::pausable::PausableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    // Import the ERC20 interfaces to create custom implementations
    use openzeppelin_token::erc20::interface::{IERC20, IERC20CamelOnly};
    use starknet::ContractAddress;

    component!(path: PausableComponent, storage: pausable, event: PausableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    // `ERC20MetadataImpl` can keep the embed directive because the implementation
    // will not change
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    // Do not add the embed directive to these implementations because
    // these will be customized
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    impl ERC20CamelOnlyImpl = ERC20Component::ERC20CamelOnlyImpl<ContractState>;

    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)
}
```

The first thing to notice is that the contract imports the interfaces of the implementations that will be customized.
These will be used in the next code example.

Next, the contract includes the [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component) implementations; however, `ERC20Impl` and `ERC20CamelOnlyImplt` are **not** embedded.
Instead, we want to expose our custom implementation of an interface.
The following example shows the pausable logic integrated into the ERC20 implementations:

```cairo hljs
#[starknet::contract]
mod ERC20Pausable {
    (...)

    // Custom ERC20 implementation
    #[abi(embed_v0)]
    impl CustomERC20Impl of IERC20<ContractState> {
        fn transfer(
            ref self: ContractState, recipient: ContractAddress, amount: u256
        ) -> bool {
            // Add the custom logic
            self.pausable.assert_not_paused();
            // Add the original implementation method from `IERC20Impl`
            self.erc20.transfer(recipient, amount)
        }

        fn total_supply(self: @ContractState) -> u256 {
            // This method's behavior does not change from the component
            // implementation, but this method must still be defined.
            // Simply add the original implementation method from `IERC20Impl`
            self.erc20.total_supply()
        }

        (...)
    }

    // Custom ERC20CamelOnly implementation
    #[abi(embed_v0)]
    impl CustomERC20CamelOnlyImpl of IERC20CamelOnly<ContractState> {
        fn totalSupply(self: @ContractState) -> u256 {
            self.erc20.total_supply()
        }

        fn balanceOf(self: @ContractState, account: ContractAddress) -> u256 {
            self.erc20.balance_of(account)
        }

        fn transferFrom(
            ref self: ContractState,
            sender: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) -> bool {
            self.pausable.assert_not_paused();
            self.erc20.transfer_from(sender, recipient, amount)
        }
    }
}
```

Notice that in the `CustomERC20Impl`, the `transfer` method integrates `pausable.assert_not_paused` as well as `erc20.transfer` from `PausableImpl` and `ERC20Impl` respectively.
This is why the contract defined the `ERC20Impl` from the component in the previous example.

Creating a custom implementation of an interface must define **all** methods from that interface.
This is true even if the behavior of a method does not change from the component implementation (as `total_supply` exemplifies in this example).

|     |     |
| --- | --- |
|  | The ERC20 documentation provides another custom implementation guide for [Customizing decimals](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20#customizing_decimals). |

### Accessing component storage

There may be cases where the contract must read or write to an integrated component’s storage.
To do so, use the same syntax as calling an implementation method except replace the name of the method with the storage variable like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    (...)

    fn write_to_comp_storage(ref self: ContractState) {
        self.initializable.Initializable_initialized.write(true);
    }

    fn read_from_comp_storage(self: @ContractState) -> bool {
        self.initializable.Initializable_initialized.read()
    }
}
```

## Security

The maintainers of OpenZeppelin Contracts for Cairo are mainly concerned with the correctness and security of the code as published in the library.

Customizing implementations and manipulating the component state may break some important assumptions and introduce vulnerabilities.
While we try to ensure the components remain secure in the face of a wide range of potential customizations, this is done in a best-effort manner.
Any and all customizations to the component logic should be carefully reviewed and checked against the source code of the component they are customizing so as to fully understand their impact and guarantee their security.

[← Wizard](https://docs.openzeppelin.com/contracts-cairo/0.20.0/wizard)

[Presets →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)Command Line Interface (CLI) - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Command Line Interface (CLI)

|     |     |
| --- | --- |
|  | If you’re using Truffle or Buidler, check out the new [Upgrades plugins](https://github.com/OpenZeppelin/openzeppelin-upgrades) to integrate upgradeability into your existing workflow. |

**Develop, deploy and operate upgradeable smart contract projects**. Support for Ethereum and every other EVM-powered blockchain.

- **Interactive commands**: Send transactions, query balances, and interact with your contracts directly from the command line, using commands like `oz send-tx`, `oz call`, `oz balance`, and `oz transfer`.

- **Deploy & upgrade your contracts**: You can develop your smart contracts iteratively, speeding up development locally, or squashing bugs in production. Run `oz deploy` to deploy your contracts, followed by `oz upgrade` any time you want to change their code.

- **Link Ethereum Packages**: Use code from contracts already deployed to the blockchain directly on your project, saving gas on deployments and managing your dependencies securely, just with an `oz link` command.

- **Bootstrap your dapp**: Jumpstart your dapp by unpacking one of our starter kits, pre-configured with OpenZeppelin Contracts, React, and Infura. Run `oz unpack` to start!


## Overview

### Installation

```console hljs language-shell
$ npm install @openzeppelin/cli
```

### Usage

All CLI commands are fully interactive: you can call them with no or incomplete arguments and they will prompt you for options as they proceed.

Below is a short list of the most used commands:

- [`oz init`](https://docs.openzeppelin.com/cli/2.8/commands#init): initialize your OpenZeppelin project

- [`oz compile`](https://docs.openzeppelin.com/cli/2.8/commands#compile): compile all Solidity smart contracts in your project

- [`oz deploy`](https://docs.openzeppelin.com/cli/2.8/commands#deploy): deploy an upgradeable smart contract

- [`oz send-tx`](https://docs.openzeppelin.com/cli/2.8/commands#send): send a transaction to a contract and execute a function

- [`oz call`](https://docs.openzeppelin.com/cli/2.8/commands#call): read data from the blockchain by calling `view` and `pure` functions

- [`oz upgrade`](https://docs.openzeppelin.com/cli/2.8/commands#upgrade): upgrade a deployed contract to a new version without changing the address or state

- [`oz unpack`](https://docs.openzeppelin.com/cli/2.8/commands#unpack): bootstrap a project with a [Starter Kit](https://docs.openzeppelin.com/starter-kits/)

- [`oz link`](https://docs.openzeppelin.com/cli/2.8/commands#link): reuse on-chain code by to a [linking to Ethereum Packages](https://docs.openzeppelin.com/cli/2.8/dependencies)


## Learn More

- Head to [Getting Started](https://docs.openzeppelin.com/cli/2.8/getting-started) to see the CLI in action by deploying and upgrading a smart contract!

- [Using Dependencies](https://docs.openzeppelin.com/cli/2.8/dependencies) showcases a more complex project being built, including leveraging the [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/) library.

- If you are a Truffle user, go to [Using With Truffle](https://docs.openzeppelin.com/cli/2.8/truffle) for information on using both tools on the same project.

- Take a look at the API reference for all [CLI commands](https://docs.openzeppelin.com/cli/2.8/commands).

- For an overview of the internals of the CLI, you can read on the [Contracts Architecture](https://docs.openzeppelin.com/cli/2.8/contracts-architecture) and different [Configuration Files](https://docs.openzeppelin.com/cli/2.8/configuration).


|     |     |
| --- | --- |
|  | Looking for the documentation for version 2.4 or earlier? You can find it [here](https://docs.zeppelinos.org/versions). |

[Getting Started →](https://docs.openzeppelin.com/cli/2.8/getting-started)Governor - OpenZeppelin Docs

# Governor

Decentralized protocols are in constant evolution from the moment they are publicly released. Often,
the initial team retains control of this evolution in the first stages, but eventually delegates it
to a community of stakeholders. The process by which this community makes decisions is called
on-chain governance, and it has become a central component of decentralized protocols, fueling
varied decisions such as parameter tweaking, smart contract upgrades, integrations with other
protocols, treasury management, grants, etc.

This governance protocol is generally implemented in a special-purpose contract called “Governor”. In
OpenZeppelin Contracts for Cairo, we set out to build a modular system of Governor components where different
requirements can be accommodated by implementing specific traits. You will find the most common requirements out of the box,
but writing additional ones is simple, and we will be adding new features as requested by the community in future releases.

## Usage and setup

### Token

The voting power of each account in our governance setup will be determined by an ERC20 or an ERC721 token. The token has
to implement the [VotesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent) extension. This extension will keep track of historical balances so that voting power
is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.

If your project already has a live token that does not include Votes and is not upgradeable, you can wrap it in a
governance token by using a wrapper. This will allow token holders to participate in governance by wrapping their tokens 1-to-1.

|     |     |
| --- | --- |
|  | The library currently does not include a wrapper for tokens, but it will be added in a future release. |

|     |     |
| --- | --- |
|  | Currently, the clock mode is fixed to block timestamps, since the Votes component uses the block timestamp to track<br>checkpoints. We plan to add support for more flexible clock modes in Votes in a future release, allowing to use, for example,<br>block numbers instead. |

### Governor

We will initially build a Governor without a timelock. The core logic is given by the [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent), but we
still need to choose:

1) how voting power is determined,

2) how many votes are needed for quorum,

3) what options people have when casting a vote and how those votes are counted, and

4) the execution mechanism that should be used.

Each of these aspects is customizable by writing your own extensions,
or more easily choosing one from the library.

**For 1)** we will use the [GovernorVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent) extension, which hooks to an [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) instance to determine the voting power
of an account based on the token balance they hold when a proposal becomes active.
This module requires the address of the token to be passed as an argument to the initializer.

**For 2)** we will use [GovernorVotesQuorumFraction](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent). This works together with the [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) instance to define the quorum as a
percentage of the total supply at the block when a proposal’s voting power is retrieved. This requires an initializer
parameter to set the percentage besides the votes token address. Most Governors nowadays use 4%. Since the quorum denominator
is 1000 for precision, we initialize the module with a numerator of 40, resulting in a 4% quorum (40/1000 = 0.04 or 4%).

**For 3)** we will use [GovernorCountingSimple](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent), an extension that offers 3 options to voters: For, Against, and Abstain,
and where only For and Abstain votes are counted towards quorum.

**For 4)** we will use [GovernorCoreExecution](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent), an extension that allows proposal execution directly through the governor.

|     |     |
| --- | --- |
|  | Another option is [GovernorTimelockExecution](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent). An example can be found in the next section. |

Besides these, we also need an implementation for the [GovernorSettingsTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) defining the voting delay, voting period,
and proposal threshold. While we can use the [GovernorSettings](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent) extension which allows to set these parameters by the
governor itself, we will implement the trait locally in the contract and set the voting delay, voting period,
and proposal threshold as constant values.

_voting\_delay_: How long after a proposal is created should voting power be fixed. A large voting delay gives
users time to unstake tokens if necessary.

_voting\_period_: How long does a proposal remain open to votes.

|     |     |
| --- | --- |
|  | These parameters are specified in the unit defined in the token’s clock, which is for now always timestamps. |

_proposal\_threshold_: This restricts proposal creation to accounts who have enough voting power.

An implementation of `GovernorComponent::ImmutableConfig` is also required. For the example below, we have used
the `DefaultConfig`. Check the [Immutable Component Config](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#immutable_config) guide for more details.

The last missing step is to add an `SNIP12Metadata` implementation used to retrieve the name and version of the governor.

```cairo hljs
#[starknet::contract]
mod MyGovernor {
    use openzeppelin_governance::governor::GovernorComponent::InternalTrait as GovernorInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorVotesQuorumFractionComponent::InternalTrait;
    use openzeppelin_governance::governor::extensions::{
        GovernorVotesQuorumFractionComponent, GovernorCountingSimpleComponent,
        GovernorCoreExecutionComponent,
    };
    use openzeppelin_governance::governor::{GovernorComponent, DefaultConfig};
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    pub const VOTING_DELAY: u64 = 86400; // 1 day
    pub const VOTING_PERIOD: u64 = 432_000; // 1 week
    pub const PROPOSAL_THRESHOLD: u256 = 10;
    pub const QUORUM_NUMERATOR: u256 = 40; // 4%

    component!(path: GovernorComponent, storage: governor, event: GovernorEvent);
    component!(
        path: GovernorVotesQuorumFractionComponent,
        storage: governor_votes,
        event: GovernorVotesEvent
    );
    component!(
        path: GovernorCountingSimpleComponent,
        storage: governor_counting_simple,
        event: GovernorCountingSimpleEvent
    );
    component!(
        path: GovernorCoreExecutionComponent,
        storage: governor_core_execution,
        event: GovernorCoreExecutionEvent
    );
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Governor
    #[abi(embed_v0)]
    impl GovernorImpl = GovernorComponent::GovernorImpl<ContractState>;

    // Extensions external
    #[abi(embed_v0)]
    impl QuorumFractionImpl =
        GovernorVotesQuorumFractionComponent::QuorumFractionImpl<ContractState>;

    // Extensions internal
    impl GovernorQuorumImpl = GovernorVotesQuorumFractionComponent::GovernorQuorum<ContractState>;
    impl GovernorVotesImpl = GovernorVotesQuorumFractionComponent::GovernorVotes<ContractState>;
    impl GovernorCountingSimpleImpl =
        GovernorCountingSimpleComponent::GovernorCounting<ContractState>;
    impl GovernorCoreExecutionImpl =
        GovernorCoreExecutionComponent::GovernorExecution<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        pub governor: GovernorComponent::Storage,
        #[substorage(v0)]
        pub governor_votes: GovernorVotesQuorumFractionComponent::Storage,
        #[substorage(v0)]
        pub governor_counting_simple: GovernorCountingSimpleComponent::Storage,
        #[substorage(v0)]
        pub governor_core_execution: GovernorCoreExecutionComponent::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        GovernorEvent: GovernorComponent::Event,
        #[flat]
        GovernorVotesEvent: GovernorVotesQuorumFractionComponent::Event,
        #[flat]
        GovernorCountingSimpleEvent: GovernorCountingSimpleComponent::Event,
        #[flat]
        GovernorCoreExecutionEvent: GovernorCoreExecutionComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, votes_token: ContractAddress) {
        self.governor.initializer();
        self.governor_votes.initializer(votes_token, QUORUM_NUMERATOR);
    }

    //
    // SNIP12 Metadata
    //

    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }

        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    //
    // Locally implemented extensions
    //

    pub impl GovernorSettings of GovernorComponent::GovernorSettingsTrait<ContractState> {
        /// See `GovernorComponent::GovernorSettingsTrait::voting_delay`.
        fn voting_delay(self: @GovernorComponent::ComponentState<ContractState>) -> u64 {
            VOTING_DELAY
        }

        /// See `GovernorComponent::GovernorSettingsTrait::voting_period`.
        fn voting_period(self: @GovernorComponent::ComponentState<ContractState>) -> u64 {
            VOTING_PERIOD
        }

        /// See `GovernorComponent::GovernorSettingsTrait::proposal_threshold`.
        fn proposal_threshold(self: @GovernorComponent::ComponentState<ContractState>) -> u256 {
            PROPOSAL_THRESHOLD
        }
    }
}
```

### Timelock

It is good practice to add a timelock to governance decisions. This allows users to exit the system if they disagree
with a decision before it is executed. We will use OpenZeppelin’s [TimelockController](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/timelock) in combination with the
GovernorTimelockExecution extension.

|     |     |
| --- | --- |
|  | When using a timelock, it is the timelock that will execute proposals and thus the timelock that should<br>hold any funds, ownership, and access control roles. |

TimelockController uses an [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access#role_based_accesscontrol) setup that we need to understand in order to set up roles.

The Proposer role is in charge of queueing operations: this is the role the Governor instance must be granted,
and it MUST be the only proposer (and canceller) in the system.

The Executor role is in charge of executing already available operations: we can assign this role to the special
zero address to allow anyone to execute (if operations can be particularly time sensitive, the Governor should be made Executor instead).

The Canceller role is in charge of canceling operations: the Governor instance must be granted this role,
and it MUST be the only canceller in the system.

Lastly, there is the Admin role, which can grant and revoke the two previous roles: this is a very sensitive role that will be granted automatically to the timelock itself, and optionally to a second account, which can be used for ease of setup but should promptly renounce the role.

The following example uses the GovernorTimelockExecution extension, together with GovernorSettings, and uses a
fixed quorum value instead of a percentage:

```cairo hljs
#[starknet::contract]
pub mod MyTimelockedGovernor {
    use openzeppelin_governance::governor::GovernorComponent::InternalTrait as GovernorInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorSettingsComponent::InternalTrait as GovernorSettingsInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorTimelockExecutionComponent::InternalTrait as GovernorTimelockExecutionInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorVotesComponent::InternalTrait as GovernorVotesInternalTrait;
    use openzeppelin_governance::governor::extensions::{
        GovernorVotesComponent, GovernorSettingsComponent, GovernorCountingSimpleComponent,
        GovernorTimelockExecutionComponent
    };
    use openzeppelin_governance::governor::{GovernorComponent, DefaultConfig};
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    pub const VOTING_DELAY: u64 = 86400; // 1 day
    pub const VOTING_PERIOD: u64 = 432_000; // 1 week
    pub const PROPOSAL_THRESHOLD: u256 = 10;
    pub const QUORUM: u256 = 100_000_000;

    component!(path: GovernorComponent, storage: governor, event: GovernorEvent);
    component!(path: GovernorVotesComponent, storage: governor_votes, event: GovernorVotesEvent);
    component!(
        path: GovernorSettingsComponent, storage: governor_settings, event: GovernorSettingsEvent
    );
    component!(
        path: GovernorCountingSimpleComponent,
        storage: governor_counting_simple,
        event: GovernorCountingSimpleEvent
    );
    component!(
        path: GovernorTimelockExecutionComponent,
        storage: governor_timelock_execution,
        event: GovernorTimelockExecutionEvent
    );
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Governor
    #[abi(embed_v0)]
    impl GovernorImpl = GovernorComponent::GovernorImpl<ContractState>;

    // Extensions external
    #[abi(embed_v0)]
    impl VotesTokenImpl = GovernorVotesComponent::VotesTokenImpl<ContractState>;
    #[abi(embed_v0)]
    impl GovernorSettingsAdminImpl =
        GovernorSettingsComponent::GovernorSettingsAdminImpl<ContractState>;
    #[abi(embed_v0)]
    impl TimelockedImpl =
        GovernorTimelockExecutionComponent::TimelockedImpl<ContractState>;

    // Extensions internal
    impl GovernorVotesImpl = GovernorVotesComponent::GovernorVotes<ContractState>;
    impl GovernorSettingsImpl = GovernorSettingsComponent::GovernorSettings<ContractState>;
    impl GovernorCountingSimpleImpl =
        GovernorCountingSimpleComponent::GovernorCounting<ContractState>;
    impl GovernorTimelockExecutionImpl =
        GovernorTimelockExecutionComponent::GovernorExecution<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        pub governor: GovernorComponent::Storage,
        #[substorage(v0)]
        pub governor_votes: GovernorVotesComponent::Storage,
        #[substorage(v0)]
        pub governor_settings: GovernorSettingsComponent::Storage,
        #[substorage(v0)]
        pub governor_counting_simple: GovernorCountingSimpleComponent::Storage,
        #[substorage(v0)]
        pub governor_timelock_execution: GovernorTimelockExecutionComponent::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        GovernorEvent: GovernorComponent::Event,
        #[flat]
        GovernorVotesEvent: GovernorVotesComponent::Event,
        #[flat]
        GovernorSettingsEvent: GovernorSettingsComponent::Event,
        #[flat]
        GovernorCountingSimpleEvent: GovernorCountingSimpleComponent::Event,
        #[flat]
        GovernorTimelockExecutionEvent: GovernorTimelockExecutionComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState, votes_token: ContractAddress, timelock_controller: ContractAddress
    ) {
        self.governor.initializer();
        self.governor_votes.initializer(votes_token);
        self.governor_settings.initializer(VOTING_DELAY, VOTING_PERIOD, PROPOSAL_THRESHOLD);
        self.governor_timelock_execution.initializer(timelock_controller);
    }

    //
    // SNIP12 Metadata
    //

    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }

        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    //
    // Locally implemented extensions
    //

    impl GovernorQuorum of GovernorComponent::GovernorQuorumTrait<ContractState> {
        /// See `GovernorComponent::GovernorQuorumTrait::quorum`.
        fn quorum(self: @GovernorComponent::ComponentState<ContractState>, timepoint: u64) -> u256 {
            QUORUM
        }
    }
}
```

## Interface

This is the full interface of the `Governor` implementation:

```cairo hljs
#[starknet::interface]
pub trait IGovernor<TState> {
    fn name(self: @TState) -> felt252;
    fn version(self: @TState) -> felt252;
    fn COUNTING_MODE(self: @TState) -> ByteArray;
    fn hash_proposal(self: @TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn state(self: @TState, proposal_id: felt252) -> ProposalState;
    fn proposal_threshold(self: @TState) -> u256;
    fn proposal_snapshot(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_deadline(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_proposer(self: @TState, proposal_id: felt252) -> ContractAddress;
    fn proposal_eta(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_needs_queuing(self: @TState, proposal_id: felt252) -> bool;
    fn voting_delay(self: @TState) -> u64;
    fn voting_period(self: @TState) -> u64;
    fn quorum(self: @TState, timepoint: u64) -> u256;
    fn get_votes(self: @TState, account: ContractAddress, timepoint: u64) -> u256;
    fn get_votes_with_params(
        self: @TState, account: ContractAddress, timepoint: u64, params: Span<felt252>
    ) -> u256;
    fn has_voted(self: @TState, proposal_id: felt252, account: ContractAddress) -> bool;
    fn propose(ref self: TState, calls: Span<Call>, description: ByteArray) -> felt252;
    fn queue(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn execute(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn cancel(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn cast_vote(ref self: TState, proposal_id: felt252, support: u8) -> u256;
    fn cast_vote_with_reason(
        ref self: TState, proposal_id: felt252, support: u8, reason: ByteArray
    ) -> u256;
    fn cast_vote_with_reason_and_params(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        reason: ByteArray,
        params: Span<felt252>
    ) -> u256;
    fn cast_vote_by_sig(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        voter: ContractAddress,
        signature: Span<felt252>
    ) -> u256;
    fn cast_vote_with_reason_and_params_by_sig(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        voter: ContractAddress,
        reason: ByteArray,
        params: Span<felt252>,
        signature: Span<felt252>
    ) -> u256;
    fn nonces(self: @TState, voter: ContractAddress) -> felt252;
    fn relay(ref self: TState, call: Call);
}
```

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance)

[Multisig →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/multisig)Governance - OpenZeppelin Docs

# Governance

This crate includes primitives for on-chain governance.

## Governor

This modular system of Governor components allows the deployment of easily customizable on-chain voting protocols.

|     |     |
| --- | --- |
|  | For a walkthrough of how to implement a Governor, check the [Governor](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/governor) page. |

### `IGovernor`

```cairo hljs
use openzeppelin_governance::governor::interface::IGovernor;
```

Interface of a governor contract.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x1100a1f8546595b5bd75a6cd8fcc5b015370655e66f275963321c5cd0357ac9

Functions

- [`name()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-name)

- [`version()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-version)

- [`COUNTING_MODE()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-COUNTING_MODE)

- [`hash_proposal(calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-hash_proposal)

- [`state(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-state)

- [`proposal_threshold()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_threshold)

- [`proposal_snapshot(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_snapshot)

- [`proposal_deadline(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_deadline)

- [`proposal_proposer(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_proposer)

- [`proposal_eta(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_eta)

- [`proposal_needs_queuing(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_needs_queuing)

- [`voting_delay()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-voting_delay)

- [`voting_period()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-voting_period)

- [`quorum(timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-quorum)

- [`get_votes(account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-get_votes)

- [`get_votes_with_params(account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-get_votes_with_params)

- [`has_voted(proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-has_voted)

- [`propose(calls, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-propose)

- [`queue(calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-queue)

- [`execute(calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-execute)

- [`cancel(proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cancel)

- [`cast_vote(proposal_id, support)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote)

- [`cast_vote_with_reason(proposal_id, support, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_with_reason)

- [`cast_vote_with_reason_and_params(proposal_id, support, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_with_reason_and_params)

- [`cast_vote_by_sig(proposal_id, support, reason, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_by_sig)

- [`cast_vote_with_reason_and_params_by_sig(proposal_id, support, reason, params, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_with_reason_and_params_by_sig)

- [`nonces(voter)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-nonces)

- [`relay(call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-relay)


Events

- [`ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalCreated)

- [`ProposalQueued(proposal_id, eta_seconds)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalQueued)

- [`ProposalExecuted(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalExecuted)

- [`ProposalCanceled(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalCanceled)

- [`VoteCast(voter, proposal_id, support, weight, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-VoteCast)

- [`VoteCastWithParams(voter, proposal_id, support, weight, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-VoteCastWithParams)


#### Functions

#### `name() → felt252` external

Name of the governor instance (used in building the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `version() → felt252` external

Version of the governor instance (used in building [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `COUNTING_MODE() → ByteArray` external

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs
to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs
that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in
`GovernorBravo`.

- `quorum=bravo` means that only For votes are counted towards quorum.

- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.


If a counting module makes use of encoded `params`, it should include this under a `params`
key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between
for/against/abstain.

- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.


|     |     |
| --- | --- |
|  | The string can be decoded by the standard [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)<br>JavaScript class. |

#### `hash_proposal(calls: Span<Call>, description_hash: felt252) → felt252` external

Hashing function used to (re)build the proposal id from the proposal details.

#### `state(proposal_id: felt252) → ProposalState` external

Returns the state of a proposal, given its id.

#### `proposal_threshold() → u256` external

The number of votes required in order for a voter to become a proposer.

#### `proposal_snapshot(proposal_id: felt252) → u64` external

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot is performed at the
end of this block. Hence, voting for this proposal starts at the beginning of the following block.

#### `proposal_deadline(proposal_id: felt252) → u64` external

Timepoint at which votes close. If using block number, votes close at the end of this block, so
it is possible to cast a vote during this block.

#### `proposal_proposer(proposal_id: felt252) → ContractAddress` external

The account that created a proposal.

#### `proposal_eta(proposal_id: felt252) → u64` external

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and
`proposal_deadline`, this doesn’t use the governor clock, and instead relies on the
executor’s clock which may be different. In most cases this will be a timestamp.

#### `proposal_needs_queuing(proposal_id: felt252) → bool` external

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

#### `voting_delay() → u64` external

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in
depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

#### `voting_period() → u64` external

Delay between when a vote starts and when it ends. The unit this duration is expressed in depends on
the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

|     |     |
| --- | --- |
|  | The `voting_delay` can delay the start of the vote. This must be considered when<br>setting the voting duration compared to the voting delay. |

|     |     |
| --- | --- |
|  | This value is stored when the proposal is submitted so that possible changes to the<br>value do not affect proposals that have already been submitted. |

#### `quorum(timepoint: u64) → u256` external

Minimum number of votes required for a proposal to be successful.

|     |     |
| --- | --- |
|  | The `timepoint` parameter corresponds to the snapshot used for counting vote. This<br>allows the quorum to scale depending on values such as the total supply of a token at this<br>timepoint. |

#### `get_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the voting power of an `account` at a specific `timepoint`.

|     |     |
| --- | --- |
|  | This can be implemented in a number of ways, for example by reading the delegated<br>balance from one (or multiple) `ERC20Votes` tokens. |

#### `get_votes_with_params(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` external

Returns the voting power of an `account` at a specific `timepoint`, given additional encoded parameters.

#### `has_voted(proposal_id: felt252, account: ContractAddress) → bool` external

Returns whether an `account` has cast a vote on a proposal.

#### `propose(calls: Span<Call>, description: ByteArray) → felt252` external

Creates a new proposal. Vote starts after a delay specified by `voting_delay` and lasts for a duration specified by `voting_period`.

|     |     |
| --- | --- |
|  | The state of the Governor and targets may change between the proposal creation and its execution.<br>This may be the result of third party actions on the targeted contracts, or other governor proposals.<br>For example, the balance of this contract could be updated or its access control permissions may be<br>modified, possibly compromising the proposal’s ability to execute successfully (e.g. the governor<br>doesn’t have enough value to cover a proposal with multiple transfers). |

Returns the id of the proposal.

#### `queue(calls: Span<Call>, description_hash: felt252) → felt252` external

Queue a proposal. Some governors require this step to be performed before execution can
happen. If queuing is not necessary, this function may revert.

Queuing a proposal requires the quorum to be reached, the vote to be successful, and the
deadline to be reached.

Returns the id of the proposal.

#### `execute(calls: span<Call>, description_hash: felt252) → felt252` external

Execute a successful proposal. This requires the quorum to be reached, the vote to be
successful, and the deadline to be reached. Depending on the governor it might also be
required that the proposal was queued and that some delay passed.

|     |     |
| --- | --- |
|  | Some modules can modify the requirements for execution, for example by adding an<br>additional timelock (See `timelock_controller`). |

Returns the id of the proposal.

#### `cancel(calls: Span<Call>, description_hash: felt252) → felt252` external

Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending
state, i.e. before the vote starts.

Returns the id of the proposal.

#### `cast_vote(proposal_id: felt252, support: u8) → u256` external

Cast a vote on a proposal.

Returns the weight of the vote.

#### `cast_vote_with_reason(proposal_id: felt252, support: u8, reason: ByteArray) → u256` external

Cast a vote on a proposal with a `reason`.

Returns the weight of the vote.

#### `cast_vote_with_reason_and_params(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256` external

Cast a vote on a proposal with a reason and additional encoded parameters.

Returns the weight of the vote.

#### `cast_vote_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256` external

Cast a vote on a proposal using the voter’s signature.

Returns the weight of the vote.

#### `cast_vote_with_reason_and_params_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256` external

Cast a vote on a proposal with a reason and additional encoded parameters using the `voter`'s signature.

Returns the weight of the vote.

#### `nonces(voter: ContractAddress) → felt252` external

Returns the next unused nonce for an address.

#### `relay(call: Call)` external

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like
when using a timelock, this function can be invoked in a governance proposal to recover
tokens that were sent to the governor contract by mistake.

|     |     |
| --- | --- |
|  | If the executor is simply the governor itself, use of `relay` is redundant. |

#### Events

#### `ProposalCreated(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)` event

Emitted when a proposal is created.

#### `ProposalQueued(proposal_id: felt252, eta_seconds: u64)` event

Emitted when a proposal is queued.

#### `ProposalExecuted(proposal_id: felt252)` event

Emitted when a proposal is executed.

#### `ProposalCanceled(proposal_id: felt252)` event

Emitted when a proposal is canceled.

#### `VoteCast(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)` event

Emitted when a vote is cast.

#### `VoteCastWithParams(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)` event

Emitted when a vote is cast with params.

### `GovernorComponent`

```cairo hljs
use openzeppelin_governance::governor::GovernorComponent;
```

Core of the governance system.

|     |     |
| --- | --- |
|  | The extension traits presented below are what make the GovernorComponent a modular and configurable system. The embeddable<br>and internal implementations depends on these trait. They can be implemented locally in the contract, or through the provided library<br>[component extensions](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#governor_extensions). |

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

Extensions traits

GovernorSettingsTrait

- [`voting_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorSettingsTrait-voting_delay)

- [`voting_period(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorSettingsTrait-voting_period)

- [`proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorSettingsTrait-proposal_threshold)


GovernorQuorumTrait

- [`quorum(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorQuorumTrait-quorum)


GovernorCountingTrait

- [`counting_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-counting_mode)

- [`count_vote(self, proposal_id, account, support, total_weight, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-count_vote)

- [`has_voted(self, proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-has_voted)

- [`quorum_reached(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-quorum_reached)

- [`vote_succeeded(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-vote_succeeded)


GovernorVotesTrait

- [`clock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorVotesTrait-clock)

- [`clock_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorVotesTrait-clock_mode)

- [`get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorVotesTrait-get_votes)


GovernorExecutionTrait

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-state)

- [`executor(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-executor)

- [`execute_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-execute_operations)

- [`queue_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-queue_operations)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-proposal_needs_queuing)

- [`cancel_operations(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-cancel_operations)


Embeddable Implementations

GovernorImpl

- [`name(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-name)

- [`version(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-version)

- [`COUNTING_MODE(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-COUNTING_MODE)

- [`hash_proposal(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-hash_proposal)

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-state)

- [`proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_threshold)

- [`proposal_snapshot(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_snapshot)

- [`proposal_deadline(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_deadline)

- [`proposal_proposer(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_proposer)

- [`proposal_eta(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_eta)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_needs_queuing)

- [`voting_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-voting_delay)

- [`voting_period(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-voting_period)

- [`quorum(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-quorum)

- [`get_votes(self, account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-get_votes)

- [`get_votes_with_params(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-get_votes_with_params)

- [`has_voted(self, proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-has_voted)

- [`propose(self, calls, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-propose)

- [`queue(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-queue)

- [`execute(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-execute)

- [`cancel(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cancel)

- [`cast_vote(self, proposal_id, support)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote)

- [`cast_vote_with_reason(self, proposal_id, support, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_with_reason)

- [`cast_vote_with_reason_and_params(self, proposal_id, support, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_with_reason_and_params)

- [`cast_vote_by_sig(self, proposal_id, support, reason, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_by_sig)

- [`cast_vote_with_reason_and_params_by_sig(self, proposal_id, support, reason, params, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_with_reason_and_params_by_sig)

- [`nonces(self, voter)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-nonces)

- [`relay(self, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-relay)


Internal Implementations

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-initializer)

- [`get_proposal(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-get_proposal)

- [`is_valid_description_for_proposer(self, proposer, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-is_valid_description_for_proposer)

- [`_hash_proposal(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_hash_proposal)

- [`_proposal_snapshot(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_snapshot)

- [`_proposal_deadline(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_deadline)

- [`_proposal_proposer(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_proposer)

- [`_proposal_eta(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_eta)


InternalExtendedImpl

- [`assert_only_governance(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-assert_only_governance)

- [`validate_state(self, proposal_id, allowed_states)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-validate_state)

- [`use_nonce(self, voter)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-use_nonce)

- [`_get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_get_votes)

- [`_proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_threshold)

- [`_state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_state)

- [`_propose(self, calls, description, proposer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_propose)

- [`_cancel(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_cancel)

- [`_count_vote(self, proposal_id, account, support, total_weight, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_count_vote)

- [`_cast_vote(self, proposal_id, voter, support, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_cast_vote)


Events

- [`ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCreated)

- [`ProposalQueued(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalQueued)

- [`ProposalExecuted(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalExecuted)

- [`ProposalCanceled(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCanceled)

- [`VoteCast(voter, proposal_id, support, weight, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast)

- [`VoteCastWithParams(voter, proposal_id, support, weight, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams)


#### Extensions traits functions

#### `voting_delay(self: @ContractState) → u64` extension

Must return the delay, in number of timepoints, between when the proposal is created and when the vote starts. This can be
increased to leave time for users to buy voting power, or delegate it, before the voting of a
proposal starts.

#### `voting_period(self: @ContractState) → u64` extension

Must return the delay, in number of timepoints, between the vote start and vote end.

#### `proposal_threshold(self: @ContractState) → u256` extension

Must return the minimum number of votes that an account must have to create a proposal.

#### `quorum(self: @ContractState, timepoint: u64) → u256` extension

Must return the minimum number of votes required for a proposal to succeed.

#### `counting_mode(self: @ContractState) → ByteArray` extension

Must return a description of the possible `support` values for `cast_vote` and the way these votes are counted,
meant to be consumed by UIs to show correct vote options and interpret the results.
See [COUNTING\_MODE](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-COUNTING_MODE) for more details.

#### `count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256` extension

Must register a vote for `proposal_id` by `account` with a given `support`, voting `weight` and voting `params`.

|     |     |
| --- | --- |
|  | Support is generic and can represent various things depending on the voting system used. |

#### `has_voted(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool` extension

Must return whether an account has cast a vote on a proposal.

#### `quorum_reached(self: @ContractState, proposal_id: felt252) → bool` extension

Must return whether the minimum quorum has been reached for a proposal.

#### `vote_succeeded(self: @ContractState, proposal_id: felt252) → bool` extension

Must return whether a proposal has succeeded or not.

#### `clock(self: @ContractState) → u64` extension

Must return the current timepoint according to the clock mode the governor is operating in.

|     |     |
| --- | --- |
|  | For now, only timestamp is supported. |

#### `clock_mode(self: @ContractState) → ByteArray` extension

Must return the clock mode the governor is operating in.

|     |     |
| --- | --- |
|  | For now, only timestamp is supported. |

#### `get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` extension

Must return the voting power of an account at a specific timepoint with the given parameters.

#### `state(self: @ContractState, proposal_id: felt252) → ProposalState` extension

Must return the state of a proposal at the current time.

The state can be either:

- `Pending`: The proposal does not exist yet.

- `Active`: The proposal is active.

- `Canceled`: The proposal has been canceled.

- `Defeated`: The proposal has been defeated.

- `Succeeded`: The proposal has succeeded.

- `Queued`: The proposal has been queued.

- `Executed`: The proposal has been executed.


#### `executor(self: @ContractState) → ContractAddress` internal

Must return the address through which the governor executes action.
Should be used to specify whether the module execute actions through another contract
such as a timelock.

|     |     |
| --- | --- |
|  | MUST be the governor itself, or an instance of TimelockController with the<br>governor as the only proposer, canceller, and executor. |

|     |     |
| --- | --- |
|  | When the executor is not the governor itself (i.e. a timelock), it can call<br>functions that are restricted with the `assert_only_governance` guard, and also<br>potentially execute transactions on behalf of the governor. Because of this, this module<br>is designed to work with the TimelockController as the unique potential external<br>executor. |

#### `execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Execution mechanism. Can be used to modify the way operations are executed (for example adding a vault/timelock).

#### `queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Queuing mechanism. Can be used to modify the way queuing is
performed (for example adding a vault/timelock).

Requirements:

- Must return a timestamp that describes the expected ETA for execution. If the returned
value is 0, the core will consider queueing did not succeed, and the public `queue`
function will revert.


#### `proposal_needs_queuing(self: @ContractState) → bool` internal

Must return whether proposals need to be queued before execution. This usually indicates if the proposal needs to go through a timelock.

#### `cancel_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Cancel mechanism. Can be used to modify the way canceling is
performed (for example adding a vault/timelock).

#### Embeddable functions

#### `name() → felt252` external

Name of the governor instance (used in building the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `version() → felt252` external

Version of the governor instance (used in building [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `COUNTING_MODE() → ByteArray` external

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs
to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs
that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in
`GovernorBravo`.

- `quorum=bravo` means that only For votes are counted towards quorum.

- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.


If a counting module makes use of encoded `params`, it should include this under a `params`
key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between
for/against/abstain.

- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.


|     |     |
| --- | --- |
|  | The string can be decoded by the standard [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)<br>JavaScript class. |

#### `hash_proposal(calls: Span<Call>, description_hash: felt252) → felt252` external

Hashing function used to (re)build the proposal id from the proposal details.

#### `state(proposal_id: felt252) → ProposalState` external

Returns the state of a proposal, given its id.

#### `proposal_threshold() → u256` external

The number of votes required in order for a voter to become a proposer.

#### `proposal_snapshot(proposal_id: felt252) → u64` external

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot is performed at the
end of this block. Hence, voting for this proposal starts at the beginning of the following block.

#### `proposal_deadline(proposal_id: felt252) → u64` external

Timepoint at which votes close. If using block number, votes close at the end of this block, so
it is possible to cast a vote during this block.

#### `proposal_proposer(proposal_id: felt252) → ContractAddress` external

The account that created a proposal.

#### `proposal_eta(proposal_id: felt252) → u64` external

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and
`proposal_deadline`, this doesn’t use the governor clock, and instead relies on the
executor’s clock which may be different. In most cases this will be a timestamp.

#### `proposal_needs_queuing(proposal_id: felt252) → bool` external

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

#### `voting_delay() → u64` external

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in
depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

#### `voting_period() → u64` external

Delay between the vote start and vote end. The unit this duration is expressed in depends on
the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

|     |     |
| --- | --- |
|  | The `voting_delay` can delay the start of the vote. This must be considered when<br>setting the voting duration compared to the voting delay. |

|     |     |
| --- | --- |
|  | This value is stored when the proposal is submitted so that possible changes to the<br>value do not affect proposals that have already been submitted. |

#### `quorum(timepoint: u64) → u256` external

Minimum number of votes required for a proposal to be successful.

|     |     |
| --- | --- |
|  | The `timepoint` parameter corresponds to the snapshot used for counting vote. This<br>allows the quorum to scale depending on values such as the total supply of a token at this<br>timepoint. |

#### `get_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the voting power of an `account` at a specific `timepoint`.

|     |     |
| --- | --- |
|  | This can be implemented in a number of ways, for example by reading the delegated<br>balance from one (or multiple) `ERC20Votes` tokens. |

#### `get_votes_with_params(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` external

Returns the voting power of an account at a specific timepoint, given additional encoded parameters.

#### `has_voted(proposal_id: felt252, account: ContractAddress) → bool` external

Returns whether an account has cast a vote on a proposal.

#### `propose(calls: Span<Call>, description: ByteArray) → felt252` external

Creates a new proposal. Voting starts after the delay specified by `voting_delay` and
lasts for a duration specified by `voting_period`. Returns the id of the proposal.

This function has opt-in frontrunning protection, described in
`is_valid_description_for_proposer`.

|     |     |
| --- | --- |
|  | The state of the Governor and targets may change between the proposal creation<br>and its execution. This may be the result of third party actions on the targeted<br>contracts, or other governor proposals. For example, the balance of this contract could<br>be updated or its access control permissions may be modified, possibly compromising the<br>proposal’s ability to execute successfully (e.g. the governor doesn’t have enough value<br>to cover a proposal with multiple transfers). |

Requirements:

- The proposer must be authorized to submit the proposal.

- The proposer must have enough votes to submit the proposal if `proposal_threshold` is
greater than zero.

- The proposal must not already exist.


Emits a [ProposalCreated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCreated) event.

#### `queue(calls: Span<Call>, description_hash: felt252) → felt252` external

Queues a proposal. Some governors require this step to be performed before execution can
happen. If queuing is not necessary, this function may revert.
Queuing a proposal requires the quorum to be reached, the vote to be successful, and the
deadline to be reached.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` state.

- The queue operation must return a non-zero ETA.


Emits a [ProposalQueued](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalQueued) event.

#### `execute(calls: span<Call>, description_hash: felt252) → felt252` external

Executes a successful proposal. This requires the quorum to be reached, the vote to be
successful, and the deadline to be reached. Depending on the governor it might also be
required that the proposal was queued and that some delay passed.

|     |     |
| --- | --- |
|  | Some modules can modify the requirements for execution, for example by adding an<br>additional timelock (See `timelock_controller`). |

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` or `Queued` state.


Emits a [ProposalExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalExecuted) event.

#### `cancel(calls: Span<Call>, description_hash: felt252) → felt252` external

Cancels a proposal. A proposal is cancellable by the proposer, but only while it is
Pending state, i.e. before the vote starts.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Pending` state.

- The caller must be the proposer of the proposal.


Emits a [ProposalCanceled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCanceled) event.

#### `cast_vote(proposal_id: felt252, support: u8) → u256` external

Cast a vote.

Requirements:

- The proposal must be active.


Emits a [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event.

#### `cast_vote_with_reason(proposal_id: felt252, support: u8, reason: ByteArray) → u256` external

Cast a vote with a `reason`.

Requirements:

- The proposal must be active.


Emits a [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event.

#### `cast_vote_with_reason_and_params(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256` external

Cast a vote with a `reason` and additional serialized `params`.

Requirements:

- The proposal must be active.


Emits either:

- [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event if no params are provided.

- [VoteCastWithParams](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams) event otherwise.


#### `cast_vote_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256` external

Cast a vote using the `voter`'s signature.

Requirements:

- The proposal must be active.

- The nonce in the signed message must match the account’s current nonce.

- `voter` must implement `SRC6::is_valid_signature`.

- `signature` must be valid for the message hash.


Emits a [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event.

#### `cast_vote_with_reason_and_params_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256` external

Cast a vote with a `reason` and additional serialized `params` using the `voter`'s
signature.

Requirements:

- The proposal must be active.

- The nonce in the signed message must match the account’s current nonce.

- `voter` must implement `SRC6::is_valid_signature`.

- `signature` must be valid for the message hash.


Emits either:

- [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event if no params are provided.

- [VoteCastWithParams](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams) event otherwise.


#### `nonces(voter: ContractAddress) → felt252` external

Returns the next unused nonce for an address.

#### `relay(call: Call)` external

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like
when using a timelock, this function can be invoked in a governance proposal to recover
tokens that were sent to the governor contract by mistake.

|     |     |
| --- | --- |
|  | If the executor is simply the governor itself, use of `relay` is redundant. |

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Initializes the contract by registering the supported interface id.

#### `get_proposal(self: @ContractState, proposal_id: felt252) → ProposalCore` internal

Returns the proposal object given its id.

#### `is_valid_description_for_proposer(self: @ContractState, proposer: ContractAddress, description: ByteArray) → bool` internal

Checks if the proposer is authorized to submit a proposal with the given description.

If the proposal description ends with `#proposer=0x???`, where `0x???` is an address
written as a hex string (case insensitive), then the submission of this proposal will
only be authorized to said address.

This is used for frontrunning protection. By adding this pattern at the end of their
proposal, one can ensure that no other address can submit the same proposal. An attacker
would have to either remove or change that part, which would result in a different
proposal id.

|     |     |
| --- | --- |
|  | In Starknet, the Sequencer ensures the order of transactions, but frontrunning<br>can still be achieved by nodes, and potentially other actors in the future with<br>sequencer decentralization. |

If the description does not match this pattern, it is unrestricted and anyone can submit
it. This includes:

- If the `0x???` part is not a valid hex string.

- If the `0x???` part is a valid hex string, but does not contain exactly 64 hex digits.

- If it ends with the expected suffix followed by newlines or other whitespace.

- If it ends with some other similar suffix, e.g. `#other=abc`.

- If it does not end with any such suffix.


#### `_hash_proposal(self: @ContractState, calls: Span<Call>, description_hash: felt252) → felt252` internal

Returns the proposal id computed from the given parameters.

The proposal id is computed as a Pedersen hash of:

- The array of calls being proposed

- The description hash


#### `_proposal_snapshot(self: @ContractState, proposal_id: felt252) → u64` internal

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot
is performed at the end of this block. Hence, voting for this proposal starts at the
beginning of the following block.

#### `_proposal_deadline(self: @ContractState, proposal_id: felt252) → u64` internal

Timepoint at which votes close. If using block number, votes close at the end of this
block, so it is possible to cast a vote during this block.

#### `_proposal_proposer(self: @ContractState, proposal_id: felt252) → ContractAddress` internal

The account that created a proposal.

#### `_proposal_eta(self: @ContractState, proposal_id: felt252) → u64` internal

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot`
and `proposal_deadline`, this doesn’t use the governor clock, and instead relies on the
executor’s clock which may be different. In most cases this will be a timestamp.

#### `assert_only_governance(self: @ContractState)` internal

Asserts that the caller is the governance executor.

|     |     |
| --- | --- |
|  | When the executor is not the governor itself (i.e. a timelock), it can call<br>functions that are restricted with this modifier, and also potentially execute<br>transactions on behalf of the governor. Because of this, this module is designed to work<br>with the TimelockController as the unique potential external executor. The timelock<br>MUST have the governor as the only proposer, canceller, and executor. |

#### `validate_state(self: @ContractState, proposal_id: felt252, state: ProposalState)` internal

Validates that a proposal is in the expected state. Otherwise it panics.

#### `use_nonce(ref self: ContractState) → felt252` internal

Consumes a nonce, returns the current value, and increments nonce.

#### `_get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Internal wrapper for `GovernorVotesTrait::get_votes`.

#### `_proposal_threshold(self: @ContractState) → u256` internal

Internal wrapper for `GovernorProposeTrait::proposal_threshold`.

#### `_state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal, given its id.

Requirements:

- The proposal must exist.


#### `_propose(ref self: ContractState, calls: Span<Call>, description_hash: felt252) → felt252` internal

Internal propose mechanism. Returns the proposal id.

Requirements:

- The proposal must not already exist.


Emits a [ProposalCreated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCreated) event.

#### `_cancel(ref self: ContractState, proposal_id: felt252)` internal

Internal cancel mechanism with minimal restrictions.

A proposal can be cancelled in any state other than Canceled or Executed.

|     |     |
| --- | --- |
|  | Once cancelled, a proposal can’t be re-submitted. |

#### `_count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, weight: u256, params: Span<felt252>)` internal

Internal wrapper for `GovernorCountingTrait::count_vote`.

#### `_cast_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, reason: ByteArray, params: Span<felt252>) → u256` internal

Internal vote-casting mechanism.

Checks that the vote is pending and that it has not been cast yet.
This function retrieves the voting weight using `get_votes` and then calls
the `_count_vote` internal function.

Emits either:

- [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event if no params are provided.

- [VoteCastWithParams](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams) event otherwise.


#### Events

#### `ProposalCreated(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)` event

Emitted when a proposal is created.

#### `ProposalQueued(proposal_id: felt252, eta_seconds: u64)` event

Emitted when a proposal is queued.

#### `ProposalExecuted(proposal_id: felt252)` event

Emitted when a proposal is executed.

#### `ProposalCanceled(proposal_id: felt252)` event

Emitted when a proposal is canceled.

#### `VoteCast(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)` event

Emitted when a vote is cast.

#### `VoteCastWithParams(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)` event

Emitted when a vote is cast with params.

## Governor extensions

The Governor component can (and must) be extended by implementing the [extensions traits](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-Extensions-Traits-Traits) to add the desired functionality.
This can be achieved by directly implementing the traits on your contract, or by using a set of ready-to-use extensions
provided by the library, which are presented below.

### `GovernorCoreExecutionComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorCoreExecutionComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) providing an execution mechanism directly through
the Governor itself. For a timelocked execution mechanism, see
[GovernorTimelockExecutionComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent).

Extension traits implementations

GovernorExecution

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-state)

- [`executor(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-executor)

- [`execute_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-execute_operations)

- [`queue_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-queue_operations)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-proposal_needs_queuing)

- [`cancel_operations(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-cancel_operations)


#### Extension traits functions

#### `state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.


#### `executor(self: @ContractState) → ContractAddress` internal

Returns the executor address.

In this case, it returns the governor contract address since execution is performed directly through it.

#### `execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)` internal

Executes the proposal’s operations directly through the governor contract.

#### `queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64` internal

In this implementation, queuing is not required so it returns 0.

#### `proposal_needs_queuing(self: @ContractState, proposal_id: felt252) → bool` internal

In this implementation, it always returns false.

#### `cancel_operations(ref self: ContractState, proposal_id: felt252, description_hash: felt252)` internal

Cancels a proposal’s operations.

### `GovernorCountingSimpleComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorCountingSimpleComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for simple vote counting with three options.

Extension traits implementations

GovernorCounting

- [`counting_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-counting_mode)

- [`count_vote(self, proposal_id, account, support, total_weight, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-count_vote)

- [`has_voted(self, proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-has_voted)

- [`quorum_reached(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-quorum_reached)

- [`vote_succeeded(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-vote_succeeded)


#### Extension traits functions

#### `counting_mode(self: @ContractState) → ByteArray` internal

Returns `"support=bravo&quorum=for,abstain"`.

- `support=bravo` indicates that the support follows the Governor Bravo format where voters can vote For, Against, or Abstain

- `quorum=for,abstain` indicates that both For and Abstain votes count toward quorum


#### `count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256` internal

Records a vote for a proposal.

The support value follows the `VoteType` enum (0=Against, 1=For, 2=Abstain).

Returns the weight that was counted.

#### `has_voted(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool` internal

Returns whether an account has cast a vote on a proposal.

#### `quorum_reached(self: @ContractState, proposal_id: felt252) → bool` internal

Returns whether a proposal has reached quorum.

In this implementation, both For and Abstain votes count toward quorum.

#### `vote_succeeded(self: @ContractState, proposal_id: felt252) → bool` internal

Returns whether a proposal has succeeded.

In this implementation, the For votes must be strictly greater than Against votes.

### `GovernorSettingsComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorSettingsComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for settings that are updatable through governance.

Extension traits implementations

GovernorSettings

- [`voting_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-voting_delay)

- [`voting_period(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-voting_period)

- [`proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-proposal_threshold)


Embeddable implementations

GovernorSettingsAdminImpl

- [`set_voting_delay(self, new_voting_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-set_voting_delay)

- [`set_voting_period(self, new_voting_period)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-set_voting_period)

- [`set_proposal_threshold(self, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-set_proposal_threshold)


Internal implementations

InternalImpl

- [`initializer(self, new_voting_delay, new_voting_period, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-initializer)

- [`assert_only_governance(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-assert_only_governance)

- [`_set_voting_delay(self, new_voting_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-_set_voting_delay)

- [`_set_voting_period(self, new_voting_period)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-_set_voting_period)

- [`_set_proposal_threshold(self, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-_set_proposal_threshold)


Events

- [`VotingDelayUpdated(old_voting_delay, new_voting_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated)

- [`VotingPeriodUpdated(old_voting_period, new_voting_period)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated)

- [`ProposalThresholdUpdated(old_proposal_threshold, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated)


#### Extension traits functions

#### `voting_delay(self: @ContractState) → u64` internal

Returns the delay, between when a proposal is created and when voting starts.

#### `voting_period(self: @ContractState) → u64` internal

Returns the time period, during which votes can be cast.

#### `proposal_threshold(self: @ContractState) → u256` internal

Returns the minimum number of votes required for an account to create a proposal.

#### Embeddable functions

#### `set_voting_delay(ref self: ContractState, new_voting_delay: u64)` external

Sets the voting delay.

Requirements:

- Caller must be the governance executor.


|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting delay is the same as the old one. |

May emit a [VotingDelayUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated) event.

#### `set_voting_period(ref self: ContractState, new_voting_period: u64)` external

Sets the voting period.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting period is the same as the<br>old one. |

Requirements:

- Caller must be the governance executor.

- `new_voting_period` must be greater than 0.


May emit a [VotingPeriodUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated) event.

#### `set_proposal_threshold(ref self: ContractState, new_proposal_threshold: u256)` external

Sets the proposal threshold.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new proposal threshold is the same as<br>the old one. |

Requirements:

- Caller must be the governance executor.


May emit a [ProposalThresholdUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### Internal functions

#### `initializer(ref self: ContractState, initial_voting_delay: u64, initial_voting_period: u64, initial_proposal_threshold: u256)` internal

Initializes the component by setting the default values.

Requirements:

- `new_voting_period` must be greater than 0.


Emits a [VotingDelayUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated), [VotingPeriodUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated), and [ProposalThresholdUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### `assert_only_governance(ref self: ContractState)` internal

Asserts that the caller is the governance executor.

#### `_set_voting_delay(ref self: ContractState, new_voting_delay: u64)` internal

Internal function to update the voting delay.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting delay is the same as the<br>old one. |

May emit a [VotingDelayUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated) event.

#### `_set_voting_period(ref self: ContractState, new_voting_period: u64)` internal

Internal function to update the voting period.

Requirements:

- `new_voting_period` must be greater than 0.


|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting period is the same as the old one. |

May emit a [VotingPeriodUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated) event.

#### `_set_proposal_threshold(ref self: ContractState, new_proposal_threshold: u256)` internal

Internal function to update the proposal threshold.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new proposal threshold is the same as the old one. |

May emit a [ProposalThresholdUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### Events

#### `VotingDelayUpdated(old_voting_delay: u64, new_voting_delay: u64)` event

Emitted when the voting delay is updated.

#### `VotingPeriodUpdated(old_voting_period: u64, new_voting_period: u64)` event

Emitted when the voting period is updated.

#### `ProposalThresholdUpdated(old_proposal_threshold: u256, new_proposal_threshold: u256)` event

Emitted when the proposal threshold is updated.

### `GovernorVotesComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorVotesComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for voting weight extraction from a token with the [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes)
extension.

Extension traits implementations

GovernorVotes

- [`clock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-clock)

- [`clock_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-clock_mode)

- [`get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-get_votes)


Embeddable implementations

VotesTokenImpl

- [`token(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-token)


Internal implementations

InternalImpl

- [`initializer(self, votes_token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-initializer)


#### Extension traits functions

#### `clock(self: @ContractState) → u64` internal

Returns the current timepoint according to the time mode the contract is operating in.

In this implementation, returns the current block timestamp.

|     |     |
| --- | --- |
|  | [VotesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent) always uses the block timestamp for tracking checkpoints.<br>This must be updated in order to allow for more flexible clock modes. |

#### `clock_mode(self: @ContractState) → ByteArray` internal

Returns `"mode=timestamp&from=starknet::SN_MAIN"`.

See [https://eips.ethereum.org/EIPS/eip-6372#clock\_mode](https://eips.ethereum.org/EIPS/eip-6372#clock_mode)

#### `get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Returns the voting power of `account` at a specific `timepoint` using the votes token.

#### Embeddable functions

#### `token(self: @ContractState) → ContractAddress` external

Returns the votes token that voting power is sourced from.

#### Internal functions

#### `initializer(ref self: ContractState, votes_token: ContractAddress)` internal

Initializes the component by setting the votes token.

Requirements:

- `votes_token` must not be zero.


### `GovernorVotesQuorumFractionComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorVotesQuorumFractionComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for voting weight extraction from a token with the
[IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) extension and a quorum expressed as a fraction of the total supply.

Extension traits implementations

GovernorQuorum

- [`quorum(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-quorum)


GovernorVotes

- [`clock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-clock)

- [`clock_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-clock_mode)

- [`get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-get_votes)


Embeddable implementations

QuorumFractionImpl

- [`token(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-token)

- [`current_quorum_numerator(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-current_quorum_numerator)

- [`quorum_numerator(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-quorum_numerator)

- [`quorum_denominator(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-quorum_denominator)


Internal implementations

InternalImpl

- [`initializer(self, votes_token, quorum_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-initializer)

- [`update_quorum_numerator(self, new_quorum_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-update_quorum_numerator)


Events

- [`QuorumNumeratorUpdated(old_quorum_numerator, new_quorum_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated)


#### Extension traits functions

#### `quorum(self: @ContractState, timepoint: u64) → u256` internal

It is computed as a percentage of the votes token total supply at a given `timepoint` in the past.

#### `clock(self: @ContractState) → u64` internal

Returns the current timepoint according to the time mode the contract is operating in.

In this implementation, returns the current block timestamp.

#### `clock_mode(self: @ContractState) → ByteArray` internal

Returns `"mode=timestamp&from=starknet::SN_MAIN"`.

See [https://eips.ethereum.org/EIPS/eip-6372#clock\_mode](https://eips.ethereum.org/EIPS/eip-6372#clock_mode)

#### `get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Returns the voting power of `account` at a specific `timepoint` using the votes token.

#### Embeddable functions

#### `token(self: @ContractState) → ContractAddress` external

Returns the address of the votes token used for voting power extraction.

#### `current_quorum_numerator(self: @ContractState) → u256` external

Returns the current quorum numerator value.

#### `quorum_numerator(self: @ContractState, timepoint: u64) → u256` external

Returns the quorum numerator value at a specific `timepoint` in the past.

#### `quorum_denominator(self: @ContractState) → u256` external

Returns the quorum denominator value.

#### Internal functions

#### `initializer(self: @ComponentState<TContractState>, votes_token: ContractAddress, quorum_numerator: u256)` internal

Initializes the component by setting the votes token and the initial quorum numerator value.

Requirements:

- `votes_token` must not be zero.

- `quorum_numerator` must be less than `quorum_denominator`.


Emits a [QuorumNumeratorUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated) event.

#### `update_quorum_numerator(self: @ComponentState<TContractState>, new_quorum_numerator: u256)` internal

Updates the quorum numerator.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new quorum numerator is the same as the old one. |

Requirements:

- `new_quorum_numerator` must be less than `quorum_denominator`.


May emit a [QuorumNumeratorUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated) event.

#### Events

#### `QuorumNumeratorUpdated(old_quorum_numerator: u256, new_quorum_numerator: u256)` event

Emitted when the quorum numerator is updated.

### `GovernorTimelockExecutionComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorTimelockExecutionComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) that binds the execution process to an instance of a contract
implementing [TimelockControllerComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent). This adds a delay, enforced by the timelock
to all successful proposals (in addition to the voting duration).

|     |     |
| --- | --- |
|  | The Governor needs the [PROPOSER, EXECUTOR, and CANCELLER roles](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/timelock#roles) to work properly. |

Using this model means the proposal will be operated by the timelock and not by the
governor. Thus, the assets and permissions must be attached to the timelock. Any asset
sent to the governor will be inaccessible from a proposal, unless executed via
`Governor::relay`.

|     |     |
| --- | --- |
|  | Setting up the timelock to have additional proposers or cancellers besides<br>the governor is very risky, as it grants them the ability to: 1) execute operations as the<br>timelock, and thus possibly performing operations or accessing funds that are expected to only<br>be accessible through a vote, and 2) block governance proposals that have been approved by the<br>voters, effectively executing a Denial of Service attack. |

Extension traits implementations

GovernorExecution

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-state)

- [`executor(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-executor)

- [`execute_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-execute_operations)

- [`queue_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-queue_operations)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-proposal_needs_queuing)

- [`cancel_operations(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-cancel_operations)


Embeddable implementations

TimelockedImpl

- [`timelock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-timelock)

- [`get_timelock_id(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-get_timelock_id)

- [`update_timelock(self, new_timelock)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-update_timelock)


Internal implementations

InternalImpl

- [`initializer(self, timelock_controller)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-initializer)

- [`assert_only_governance(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-assert_only_governance)

- [`timelock_salt(self, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-timelock_salt)

- [`get_timelock_dispatcher(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-get_timelock_dispatcher)

- [`_update_timelock(self, new_timelock)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-_update_timelock)


Events

- [`TimelockUpdated(old_timelock, new_timelock)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-TimelockUpdated)


#### Extension traits functions

#### `state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.


#### `executor(self: @ContractState) → ContractAddress` internal

Returns the executor address.

In this module, the executor is the timelock controller.

#### `execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)` internal

Runs the already queued proposal through the timelock.

#### `queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64` internal

Queue a proposal to the timelock.

Returns the eta for the execution of the queued proposal.

#### `proposal_needs_queuing(self: @ContractState, proposal_id: felt252) → bool` internal

In this implementation, it always returns true.

#### `cancel_operations(ref self: ContractState, proposal_id: felt252, description_hash: felt252)` internal

Cancels the timelocked proposal if it has already been queued.

#### Embeddable functions

#### `timelock(self: @ContractState) → ContractAddress` external

Returns the timelock controller address.

#### `get_timelock_id(self: @ContractState) → felt252` external

Returns the timelock proposal id for a given proposal id.

#### `update_timelock(ref self: ContractState, new_timelock: ContractAddress)` external

Updates the associated timelock.

Requirements:

- The caller must be the governance.


Emits a [TimelockUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-TimelockUpdated) event.

#### Internal functions

#### `initializer(ref self: ContractState, timelock: ContractAddress)` internal

Initializes the timelock controller.

Requirements:

- The timelock must not be the zero address.


#### `assert_only_governance(self: @ContractState)` internal

Ensures the caller is the executor (the timelock controller in this case).

#### `timelock_salt(self: @ContractState, description_hash: felt252) → felt252` internal

Computes the `TimelockController` operation salt as the XOR of
the governor address and `description_hash`.

It is computed with the governor address itself to avoid collisions across
governor instances using the same timelock.

#### `get_timelock_dispatcher(self: @ContractState) → ITimelockDispatcher` internal

Returns a dispatcher for interacting with the timelock controller.

#### `_update_timelock(ref self: ContractState, new_timelock: ContractAddress)` internal

Internal function to update the timelock controller address.

Emits a [TimelockUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-TimelockUpdated) event.

#### Events

#### `TimelockUpdated(old_timelock: ContractAddress, new_timelock: ContractAddress)` event

Emitted when the timelock controller is updated.

## Multisig

A Multisig module enhances security and decentralization by requiring multiple signers to
approve and execute transactions. Features include configurable quorum, signer management,
and self-administration, ensuring collective decision-making and transparency for critical
operations.

### `IMultisig`

```cairo hljs
use openzeppelin_governance::multisig::interface::IMultisig;
```

Interface of a multisig contract.

Functions

- [`get_quorum()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_quorum)

- [`is_signer(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_signer)

- [`get_signers()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_signers)

- [`is_confirmed(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_confirmed)

- [`is_confirmed_by(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_confirmed_by)

- [`is_executed(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_executed)

- [`get_submitted_block(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_submitted_block)

- [`get_transaction_state(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_transaction_state)

- [`get_transaction_confirmations(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_transaction_confirmations)

- [`hash_transaction(to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-hash_transaction)

- [`hash_transaction_batch(calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-hash_transaction_batch)

- [`add_signers(new_quorum, signers_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-add_signers)

- [`remove_signers(new_quorum, signers_to_remove)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-remove_signers)

- [`replace_signer(signer_to_remove, signer_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-replace_signer)

- [`change_quorum(new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-change_quorum)

- [`submit_transaction(to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-submit_transaction)

- [`submit_transaction_batch(calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-submit_transaction_batch)

- [`confirm_transaction(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-confirm_transaction)

- [`revoke_confirmation(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-revoke_confirmation)

- [`execute_transaction(to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-execute_transaction)

- [`execute_transaction_batch(calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-execute_transaction_batch)


Events

- [`SignerAdded(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerAdded)

- [`SignerRemoved(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerRemoved)

- [`QuorumUpdated(old_quorum, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated)

- [`TransactionSubmitted(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionSubmitted)

- [`TransactionConfirmed(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionConfirmed)

- [`ConfirmationRevoked(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-ConfirmationRevoked)

- [`TransactionExecuted(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-CallSalt)


#### Functions

#### `get_quorum() → u32` external

Returns the current quorum value. The quorum is the minimum number of confirmations required to approve a transaction.

#### `is_signer(signer: ContractAddress) → bool` external

Returns whether the given `signer` is registered. Only registered signers can submit, confirm, or execute transactions.

#### `get_signers() → Span<ContractAddress>` external

Returns the list of all current signers.

#### `is_confirmed(id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been confirmed.

#### `is_confirmed_by(id: TransactionID, signer: ContractAddress) → bool` external

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

#### `is_executed(id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been executed.

#### `get_submitted_block(id: TransactionID) → u64` external

Returns the block number when the transaction with the given `id` was submitted.

#### `get_transaction_state(id: TransactionID) → TransactionState` external

Returns the current state of the transaction with the given `id`.

#### `get_transaction_confirmations(id: TransactionID) → u32` external

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

#### `hash_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID` external

Returns the computed identifier of a transaction containing a single call.

#### `hash_transaction_batch(calls: Span<Call>, salt: felt252) → TransactionID` external

Returns the computed identifier of a transaction containing a batch of calls.

#### `add_signers(new_quorum: u32, signers_to_add: Span<ContractAddress>)` external

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after addition.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated) event if the quorum changes.

#### `remove_signers(new_quorum: u32, signers_to_remove: Span<ContractAddress>)` external

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after removal.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated) event if the quorum changes.

#### `replace_signer(signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` external

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.

- `signer_to_remove` must be an existing signer.

- `signer_to_add` must not be an existing signer.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerAdded) event for the new signer.

#### `change_quorum(new_quorum: u32)` external

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be non-zero.

- `new_quorum` must be less than or equal to the total number of signers.


Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated) event if the quorum changes.

#### `submit_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID` external

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-CallSalt) event if `salt` is not zero.

#### `submit_transaction_batch(calls: Span<Call>, salt: felt252) → TransactionID` external

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-CallSalt) event if `salt` is not zero.

#### `confirm_transaction(id: TransactionID)` external

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.

- The transaction must exist and not be executed.

- The caller must not have already confirmed the transaction.


Emits a [TransactionConfirmed](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionConfirmed) event.

#### `revoke_confirmation(id: TransactionID)` external

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.

- The caller must have previously confirmed the transaction.


Emits a [ConfirmationRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-ConfirmationRevoked) event.

#### `execute_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionExecuted) event.

#### `execute_transaction_batch(calls: Span<Call>, salt: felt252)` external

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionExecuted) event.

#### Events

#### `SignerAdded(signer: ContractAddress)` event

Emitted when a new `signer` is added.

#### `SignerRemoved(signer: ContractAddress)` event

Emitted when a `signer` is removed.

#### `QuorumUpdated(old_quorum: u32, new_quorum: u32)` event

Emitted when the `quorum` value is updated.

#### `TransactionSubmitted(id: TransactionID, signer: ContractAddress)` event

Emitted when a new transaction is submitted by a `signer`.

#### `TransactionConfirmed(id: TransactionID, signer: ContractAddress)` event

Emitted when a transaction is confirmed by a `signer`.

#### `ConfirmationRevoked(id: TransactionID, signer: ContractAddress)` event

Emitted when a `signer` revokes his confirmation.

#### `TransactionExecuted(id: TransactionID)` event

Emitted when a transaction is executed.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new transaction is submitted with non-zero salt.

### `MultisigComponent`

```cairo hljs
use openzeppelin_governance::multisig::MultisigComponent;
```

Component that implements [IMultisig](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig) and provides functionality for multisignature wallets,
including transaction management, quorum handling, and signer operations.

Embeddable Implementations

MultisigImpl

- [`get_quorum(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_quorum)

- [`is_signer(self, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_signer)

- [`get_signers(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_signers)

- [`is_confirmed(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_confirmed)

- [`is_confirmed_by(self, id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_confirmed_by)

- [`is_executed(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_executed)

- [`get_submitted_block(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_submitted_block)

- [`get_transaction_state(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_transaction_state)

- [`get_transaction_confirmations(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_transaction_confirmations)

- [`hash_transaction(self, to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-hash_transaction)

- [`hash_transaction_batch(self, calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-hash_transaction_batch)

- [`add_signers(ref self, new_quorum, signers_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-add_signers)

- [`remove_signers(ref self, new_quorum, signers_to_remove)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-remove_signers)

- [`replace_signer(ref self, signer_to_remove, signer_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-replace_signer)

- [`change_quorum(ref self, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-change_quorum)

- [`submit_transaction(ref self, to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-submit_transaction)

- [`submit_transaction_batch(ref self, calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-submit_transaction_batch)

- [`confirm_transaction(ref self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-confirm_transaction)

- [`revoke_confirmation(ref self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-revoke_confirmation)

- [`execute_transaction(ref self, to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-execute_transaction)

- [`execute_transaction_batch(ref self, calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-execute_transaction_batch)


Internal Implementations

InternalImpl

- [`initializer(ref self, quorum, signers)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-initializer)

- [`resolve_tx_state(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-resolve_tx_state)

- [`assert_one_of_signers(self, caller)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-assert_one_of_signers)

- [`assert_tx_exists(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-assert_tx_exists)

- [`assert_only_self(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-assert_only_self)

- [`_add_signers(ref self, new_quorum, signers_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_add_signers)

- [`_remove_signers(ref self, new_quorum, signers_to_remove)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_remove_signers)

- [`_replace_signer(ref self, signer_to_remove, signer_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_replace_signer)

- [`_change_quorum(ref self, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_change_quorum)


Events

- [`SignerAdded(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded)

- [`SignerRemoved(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved)

- [`QuorumUpdated(old_quorum, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated)

- [`TransactionSubmitted(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionSubmitted)

- [`TransactionConfirmed(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionConfirmed)

- [`ConfirmationRevoked(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-ConfirmationRevoked)

- [`TransactionExecuted(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-CallSalt)


#### Embeddable functions

#### `get_quorum(self: @ContractState) → u32` external

Returns the current quorum value.

#### `is_signer(self: @ContractState, signer: ContractAddress) → bool` external

Checks if a given `signer` is registered.

#### `get_signers(self: @ContractState) → Span<ContractAddress>` external

Returns a list of all current signers.

#### `is_confirmed(self: @ContractState, id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been confirmed. A confirmed transaction has received the required number of confirmations (quorum).

#### `is_confirmed_by(self: @ContractState, id: TransactionID, signer: ContractAddress) → bool` external

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

#### `is_executed(self: @ContractState, id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been executed.

#### `get_submitted_block(self: @ContractState, id: TransactionID) → u64` external

Returns the block number when the transaction with the given `id` was submitted.

#### `get_transaction_state(self: @ContractState, id: TransactionID) → TransactionState` external

Returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.

- `Pending`: the transaction exists but hasn’t reached the required confirmations.

- `Confirmed`: the transaction has reached the required confirmations but hasn’t been executed.

- `Executed`: the transaction has been executed.


#### `get_transaction_confirmations(self: @ContractState, id: TransactionID) → u32` external

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

#### `hash_transaction(self: @ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Returns the computed identifier of a transaction containing a single call.

#### `hash_transaction_batch(self: @ContractState, calls: Span<Call>, salt: felt252)` external

Returns the computed identifier of a transaction containing a batch of calls.

#### `add_signers(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)` external

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after addition.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `remove_signers(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)` external

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after removal.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `replace_signer(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` external

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.

- `signer_to_remove` must be an existing signer.

- `signer_to_add` must not be an existing signer.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for the new signer.

#### `change_quorum(ref self: ContractState, new_quorum: u32)` external

Updates the quorum value to `new_quorum`.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be non-zero.

- `new_quorum` must be less than or equal to the total number of signers.


Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `submit_transaction(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-CallSalt) event if `salt` is not zero.

#### `submit_transaction_batch(ref self: ContractState, calls: Span<Call>, salt: felt252)` external

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-CallSalt) event if `salt` is not zero.

#### `confirm_transaction(ref self: ContractState, id: TransactionID)` external

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.

- The transaction must exist and not be executed.

- The caller must not have already confirmed the transaction.


Emits a [TransactionConfirmed](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionConfirmed) event.

#### `revoke_confirmation(ref self: ContractState, id: TransactionID)` external

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.

- The caller must have previously confirmed the transaction.


Emits a [ConfirmationRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-ConfirmationRevoked) event.

#### `execute_transaction(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionExecuted) event.

#### `execute_transaction_batch(ref self: ContractState, calls: Span<Call>, salt: felt252)` external

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionExecuted) event.

#### Internal functions

#### `initializer(ref self: ContractState, quorum: u32, signers: Span<ContractAddress>)` internal

Initializes the Multisig component with the initial `quorum` and `signers`.
This function must be called during contract initialization to set up the initial state.

Requirements:

- `quorum` must be non-zero and less than or equal to the number of `signers`.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event.

#### `resolve_tx_state(self: @ContractState, id: TransactionID) → TransactionState` internal

Resolves and returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.

- `Pending`: the transaction exists but hasn’t reached the required confirmations.

- `Confirmed`: the transaction has reached the required confirmations but hasn’t been executed.

- `Executed`: the transaction has been executed.


#### `assert_one_of_signers(self: @ContractState, caller: ContractAddress)` internal

Asserts that the `caller` is one of the registered signers.

Requirements:

- The `caller` must be a registered signer.


#### `assert_tx_exists(self: @ContractState, id: TransactionID)` internal

Asserts that a transaction with the given `id` exists.

Requirements:

- The transaction with the given `id` must have been submitted.


#### `assert_only_self(self: @ContractState)` internal

Asserts that the caller is the contract itself.

Requirements:

- The caller must be the contract’s own address.


#### `_add_signers(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)` internal

Adds new signers and updates the quorum.

Requirements:

- Each signer address must be non-zero.

- `new_quorum` must be non-zero and less than or equal to the total number of signers after addition.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for each new signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `_remove_signers(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)` internal

Removes existing signers and updates the quorum.

Requirements:

- `new_quorum` must be non-zero and less than or equal to the total number of signers
after removal.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `_replace_signer(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` internal

Replaces an existing signer with a new signer.

Requirements:

- `signer_to_remove` must be an existing signer.

- `signer_to_add` must not be an existing signer.

- `signer_to_add` must be a non-zero address.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for the new signer.

#### `_change_quorum(ref self: ContractState, new_quorum: u32)` internal

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- `new_quorum` must be non-zero.

- `new_quorum` must be less than or equal to the total number of signers.


Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### Events

#### `SignerAdded(signer: ContractAddress)` event

Emitted when a new `signer` is added.

#### `SignerRemoved(signer: ContractAddress)` event

Emitted when a `signer` is removed.

#### `QuorumUpdated(old_quorum: u32, new_quorum: u32)` event

Emitted when the `quorum` value is updated.

#### `TransactionSubmitted(id: TransactionID, signer: ContractAddress)` event

Emitted when a new transaction is submitted by a `signer`.

#### `TransactionConfirmed(id: TransactionID, signer: ContractAddress)` event

Emitted when a transaction is confirmed by a `signer`.

#### `ConfirmationRevoked(id: TransactionID, signer: ContractAddress)` event

Emitted when a `signer` revokes his confirmation.

#### `TransactionExecuted(id: TransactionID)` event

Emitted when a transaction is executed.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new transaction is submitted with non-zero salt.

## Timelock

In a governance system, `TimelockControllerComponent` is in charge of introducing a delay between a proposal and its execution.

### `ITimelock`

```cairo hljs
use openzeppelin_governance::timelock::interface::ITimelock;
```

Interface of a timelock contract.

Functions

- [`is_operation(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation)

- [`is_operation_pending(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation_pending)

- [`is_operation_ready(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation_ready)

- [`is_operation_done(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation_done)

- [`get_timestamp(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_timestamp)

- [`get_operation_state(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_operation_state)

- [`get_min_delay()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_min_delay)

- [`hash_operation(call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-hash_operation)

- [`hash_operation_batch(calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-hash_operation_batch)

- [`schedule(call, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-schedule)

- [`schedule_batch(calls, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-schedule_batch)

- [`cancel(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-cancel)

- [`execute(call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-execute)

- [`execute_batch(calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-execute_batch)

- [`update_delay(new_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-update_delay)


Events

- [`CallScheduled(id, index, call, predecessor, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled)

- [`CallExecuted(id, index, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt)

- [`CallCancelled(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallCancelled)

- [`MinDelayChanged(old_duration, new_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged)


#### Functions

#### `is_operation(id: felt252) → bool` external

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

#### `is_operation_pending(id: felt252) → bool` external

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

#### `is_operation_ready(id: felt252) → bool` external

Returns whether the `id` OperationState is `Ready` or not.

#### `is_operation_done(id: felt252) → bool` external

Returns whether the `id` OperationState is `Done` or not.

#### `get_timestamp(id: felt252) → u64` external

Returns the timestamp at which `id` becomes `Ready`.

|     |     |
| --- | --- |
|  | `0` means the OperationState is `Unset` and `1` means the OperationState<br>is `Done`. |

#### `get_operation_state(id: felt252) → OperationState` external

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.

- `Waiting`: the operation has been scheduled and is pending the scheduled delay.

- `Ready`: the timer has expired, and the operation is eligible for execution.

- `Done`: the operation has been executed.


#### `get_min_delay() → u64` external

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

#### `hash_operation(call: Call, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a single transaction.

#### `hash_operation_batch(calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a batch of transactions.

#### `schedule(call: Call, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.


Emits [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `schedule_batch(calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.


Emits one [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event for each transaction in the batch.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `cancel(id: felt252)` external

Cancel an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.

- `id` must be a pending operation.


Emits a [CallCancelled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallCancelled) event.

#### `execute(call: Call, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because [`_after_call(self: @ContractState, id: felt252)` internal](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_after_call)<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `execute_batch(calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event for each Call.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because `_after_call`<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `update_delay(new_delay: u64)` external

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.


Emits a [MinDelayChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged) event.

#### Events

#### `CallScheduled(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)` event

Emitted when `call` is scheduled as part of operation `id`.

#### `CallExecuted(id: felt252, index: felt252, call: Call)` event

Emitted when `call` is performed as part of operation `id`.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new proposal is scheduled with non-zero salt.

#### `CallCancelled(id: felt252)` event

Emitted when operation `id` is cancelled.

#### `MinDelayChanged(old_duration: u64, new_duration: u64)` event

Emitted when the minimum delay for future operations is modified.

### `TimelockControllerComponent`

```cairo hljs
use openzeppelin_governance::timelock::TimelockControllerComponent;
```

Component that implements [ITimelock](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock) and enables the implementing contract to act as a timelock controller.

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

TimelockMixinImpl

- [`TimelockImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-Embeddable-Impls-TimelockImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)

- [`AccessControlImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls)

- [`AccessControlCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls)


Embeddable Implementations

TimelockImpl

- [`is_operation(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation)

- [`is_operation_pending(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation_pending)

- [`is_operation_ready(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation_ready)

- [`is_operation_done(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation_done)

- [`get_timestamp(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-get_timestamp)

- [`get_operation_state(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-get_operation_state)

- [`get_min_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-get_min_delay)

- [`hash_operation(self, call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-hash_operation)

- [`hash_operation_batch(self, calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-hash_operation_batch)

- [`schedule(self, call, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-schedule)

- [`schedule_batch(self, calls, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-schedule_batch)

- [`cancel(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-cancel)

- [`execute(self, call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-execute)

- [`execute_batch(self, calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-execute_batch)

- [`update_delay(self, new_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-update_delay)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


AccessControlImpl

- [`has_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-has_role)

- [`get_role_admin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-get_role_admin)

- [`grant_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role)

- [`revoke_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role)

- [`renounce_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-renounce_role)


AccessControlCamelImpl

- [`hasRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-hasRole)

- [`getRoleAdmin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-getRoleAdmin)

- [`grantRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grantRole)

- [`revokeRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revokeRole)

- [`renounceRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-renounceRole)


Internal Implementations

InternalImpl

- [`initializer(self, min_delay, proposers, executors, admin)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-initializer)

- [`assert_only_role(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-assert_only_role)

- [`assert_only_role_or_open_role(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-assert_only_role_or_open_role)

- [`assert_only_self(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-assert_only_self)

- [`_before_call(self, id, predecessor)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_before_call)

- [`_after_call(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_after_call)

- [`_schedule(self, id, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_schedule)

- [`_execute(self, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_execute)


Events

- [`CallScheduled(id, index, call, predecessor, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallScheduled)

- [`CallExecuted(id, index, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallSalt)

- [`CallCancelled(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallCancelled)

- [`MinDelayChanged(old_duration, new_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-MinDelayChanged)


#### Embeddable functions

#### `is_operation(self: @ContractState, id: felt252) → bool` external

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

#### `is_operation_pending(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

#### `is_operation_ready(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is `Ready` or not.

#### `is_operation_done(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is `Done` or not.

#### `get_timestamp(self: @ContractState, id: felt252) → u64` external

Returns the timestamp at which `id` becomes `Ready`.

|     |     |
| --- | --- |
|  | `0` means the OperationState is `Unset` and `1` means the OperationState<br>is `Done`. |

#### `get_operation_state(self: @ContractState, id: felt252) → OperationState` external

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.

- `Waiting`: the operation has been scheduled and is pending the scheduled delay.

- `Ready`: the timer has expired, and the operation is eligible for execution.

- `Done`: the operation has been executed.


#### `get_min_delay(self: @ContractState) → u64` external

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

#### `hash_operation(self: @ContractState, call: Call, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a single transaction.

#### `hash_operation_batch(self: @ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a batch of transactions.

#### `schedule(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

- The proposal must not already exist.

- `delay` must be greater than or equal to the min delay.


Emits [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `schedule_batch(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

- The proposal must not already exist.

- `delay` must be greater than or equal to the min delay.


Emits one [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event for each transaction in the batch.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `cancel(ref self: ContractState, id: felt252)` external

Cancels an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.

- `id` must be a pending operation.


Emits a [CallCancelled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallCancelled) event.

#### `execute(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because [`_after_call(self: @ContractState, id: felt252)` internal](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_after_call)<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `execute_batch(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event for each Call.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because `_after_call`<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `update_delay(ref self: ContractState, new_delay: u64)` external

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.


Emits a [MinDelayChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged) event.

#### Internal functions

#### `initializer(ref self: ContractState, min_delay: u64, proposers: Span<ContractAddress>, executors: Span<ContractState>, admin: ContractAddress)` internal

Initializes the contract by registering support for SRC5 and AccessControl.

This function also configures the contract with the following parameters:

- `min_delay`: initial minimum delay in seconds for operations.

- `proposers`: accounts to be granted proposer and canceller roles.

- `executors`: accounts to be granted executor role.

- `admin`: optional account to be granted admin role; disable with zero address.


|     |     |
| --- | --- |
|  | The optional admin can aid with initial configuration of roles after deployment<br>without being subject to delay, but this role should be subsequently renounced in favor of<br>administration through timelocked proposals. |

Emits two [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) events for each account in `proposers` with `PROPOSER_ROLE` and
`CANCELLER_ROLE` roles.

Emits a [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event for each account in `executors` with `EXECUTOR_ROLE` role.

May emit a [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event for `admin` with `DEFAULT_ADMIN_ROLE` role (if `admin` is
not zero).

Emits [MinDelayChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged) event.

#### `assert_only_role(self: @ContractState, role: felt252)` internal

Validates that the caller has the given `role`.
Otherwise it panics.

#### `assert_only_role_or_open_role(self: @ContractState, role: felt252)` internal

Validates that the caller has the given `role`.
If `role` is granted to the zero address, then this is considered an open role which allows anyone to be the caller.

#### `assert_only_self(self: @ContractState)` internal

Validates that the caller is the timelock contract itself.
Otherwise it panics.

#### `_before_call(self: @ContractState, id: felt252, predecessor: felt252)` internal

Private function that checks before execution of an operation’s calls.

Requirements:

- `id` must be in the `Ready` OperationState.

- `predecessor` must either be zero or be in the `Done` OperationState.


#### `_after_call(self: @ContractState, id: felt252)` internal

Private function that checks after execution of an operation’s calls
and sets the OperationState of `id` to `Done`.

Requirements:

- `id` must be in the Ready OperationState.


#### `_schedule(ref self: ContractState, id: felt252, delay: u64)` internal

Private function that schedules an operation that is to become valid after a given `delay`.

#### `_execute(ref self: ContractState, call: Call)` internal

Private function that executes an operation’s calls.

#### Events

#### `CallScheduled(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)` event

Emitted when `call` is scheduled as part of operation `id`.

#### `CallExecuted(id: felt252, index: felt252, call: Call)` event

Emitted when `call` is performed as part of operation `id`.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new proposal is scheduled with non-zero salt.

#### `CallCancelled(id: felt252)` event

Emitted when operation `id` is cancelled.

#### `MinDelayChanged(old_duration: u64, new_duration: u64)` event

Emitted when the minimum delay for future operations is modified.

## Votes

The `VotesComponent` provides a flexible system for tracking and delegating voting power. This system allows users to delegate their voting power to other addresses, enabling more active participation in governance.

### `IVotes`

```cairo hljs
use openzeppelin_governance::votes::interface::IVotes;
```

Common interface for Votes-enabled contracts.

Functions

- [`get_votes(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-get_votes)

- [`get_past_votes(account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-get_past_votes)

- [`get_past_total_supply(timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-get_past_total_supply)

- [`delegates(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-delegates)

- [`delegate(delegatee)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-delegate)

- [`delegate_by_sig(delegator, delegatee, nonce, expiry, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-delegate_by_sig)


#### Functions

#### `get_votes(account: ContractAddress) → u256` external

Returns the current amount of votes that `account` has.

#### `get_past_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the amount of votes that `account` had at a specific moment in the past.

#### `get_past_total_supply(timepoint: u64) → u256` external

Returns the total supply of votes available at a specific moment in the past.

|     |     |
| --- | --- |
|  | This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.<br>Votes that have not been delegated are still part of total supply, even though they would not participate in a<br>vote. |

#### `delegates(account: ContractAddress) → ContractAddress` external

Returns the delegate that `account` has chosen.

#### `delegate(delegatee: ContractAddress)` external

Delegates votes from the sender to `delegatee`.

#### `delegate_by_sig(delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)` external

Delegates votes from `delegator` to `delegatee` through a [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message signature validation.

### `VotesComponent`

```cairo hljs
use openzeppelin_governance::votes::VotesComponent;
```

Component that implements the [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) interface and provides a flexible system for tracking and delegating voting power.

By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.

|     |     |
| --- | --- |
|  | When using this module, your contract must implement the [VotingUnitsTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotingUnitsTrait). For convenience, this is done automatically for `ERC20` and `ERC721` tokens. |

Voting Units Trait Implementations

ERC20VotesImpl

- [`get_voting_units(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-ERC20VotesImpl-get_voting_units)


ERC721VotesImpl

- [`get_voting_units(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-ERC721VotesImpl-get_voting_units)


Embeddable Implementations

VotesImpl

- [`get_votes(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_votes)

- [`get_past_votes(self, account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_past_votes)

- [`get_past_total_supply(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_past_total_supply)

- [`delegates(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegates)

- [`delegate(self, delegatee)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegate)

- [`delegate_by_sig(self, delegator, delegatee, nonce, expiry, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegate_by_sig)


Internal implementations

InternalImpl

- [`get_total_supply(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_total_supply)

- [`move_delegate_votes(self, from, to, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-move_delegate_votes)

- [`transfer_voting_units(self, from, to, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-transfer_voting_units)

- [`num_checkpoints(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-num_checkpoints)

- [`checkpoints(self, account, pos)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-checkpoints)

- [`_delegate(self, account, delegatee)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-_delegate)


Events

- [`DelegateChanged(delegator, from_delegate, to_delegate)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged)

- [`DelegateVotesChanged(delegate, previous_votes, new_votes)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged)


#### ERC20VotesImpl

#### `get_voting_units(self: @ContractState, account: ContractAddress) → u256` internal

Returns the number of voting units for a given account.

This implementation is specific to ERC20 tokens, where the balance
of tokens directly represents the number of voting units.

|     |     |
| --- | --- |
|  | This implementation will work out of the box if the ERC20 component<br>is implemented in the final contract. |

|     |     |
| --- | --- |
|  | This implementation assumes tokens map to voting units 1:1.<br>Any deviation from this formula when transferring voting units (e.g. by using hooks)<br>may compromise the internal vote accounting. |

#### ERC721VotesImpl

#### `get_voting_units(self: @ContractState, account: ContractAddress) → u256` internal

Returns the number of voting units for a given account.

This implementation is specific to ERC721 tokens, where each token
represents one voting unit. The function returns the balance of
ERC721 tokens for the specified account.

|     |     |
| --- | --- |
|  | This implementation will work out of the box if the ERC721 component<br>is implemented in the final contract. |

|     |     |
| --- | --- |
|  | This implementation assumes tokens map to voting units 1:1.<br>Any deviation from this formula when transferring voting units (e.g. by using hooks)<br>may compromise the internal vote accounting. |

#### Embeddable functions

#### `get_votes(self: @ContractState, account: ContractAddress) → u256` external

Returns the current amount of votes that `account` has.

#### `get_past_votes(self: @ContractState, account: ContractAddress, timepoint: u64) → u256` external

Returns the amount of votes that `account` had at a specific moment in the past.

Requirements:

- `timepoint` must be in the past.


#### `get_past_total_supply(self: @ContractState, timepoint: u64) → u256` external

Returns the total supply of votes available at a specific moment in the past.

|     |     |
| --- | --- |
|  | This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.<br>Votes that have not been delegated are still part of total supply, even though they would not participate in a<br>vote. |

Requirements:

- `timepoint` must be in the past.


#### `delegates(self: @ContractState, account: ContractAddress) → ContractAddress` external

Returns the delegate that `account` has chosen.

#### `delegate(ref self: ContractState, delegatee: ContractAddress)` external

Delegates votes from the sender to `delegatee`.

Emits a [DelegateChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### `delegate_by_sig(ref self: ContractState, delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)` external

Delegates votes from `delegator` to `delegatee` through a [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message signature validation.

Requirements:

- `expiry` must not be in the past.

- `nonce` must match the account’s current nonce.

- `delegator` must implement `SRC6::is_valid_signature`.

- `signature` should be valid for the message hash.


Emits a [DelegateChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### Internal functions

#### `get_total_supply(self: @ContractState) → u256` internal

Returns the current total supply of votes.

#### `move_delegate_votes(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)` internal

Moves delegated votes from one delegate to another.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### `transfer_voting_units(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)` internal

Transfers, mints, or burns voting units.

To register a mint, `from` should be zero. To register a burn, `to`
should be zero. Total supply of voting units will be adjusted with mints and burns.

|     |     |
| --- | --- |
|  | If voting units are based on an underlying transferable asset (like a token), you must call this function every time the asset is transferred to keep the internal voting power accounting in sync. For ERC20 and ERC721 tokens, this is typically handled using hooks. |

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### `num_checkpoints(self: @ContractState, account: ContractAddress) → u64` internal

Returns the number of checkpoints for `account`.

#### `checkpoints(self: @ContractState, account: ContractAddress, pos: u64) → Checkpoint` internal

Returns the `pos`-th checkpoint for `account`.

#### `_delegate(ref self: ContractState, account: ContractAddress, delegatee: ContractAddress)` internal

Delegates all of `account`'s voting units to `delegatee`.

Emits a [DelegateChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### Events

#### `DelegateChanged(delegator: ContractAddress, from_delegate: ContractAddress, to_delegate: ContractAddress)` event

Emitted when an account changes their delegate.

#### `DelegateVotesChanged(delegate: ContractAddress, previous_votes: u256, new_votes: u256)` event

Emitted when a token transfer or delegate change results in changes to a delegate’s number of votes.

### `VotingUnitsTrait`

```cairo hljs
pub trait VotingUnitsTrait<TState> {
    fn get_voting_units(self: @TState, account: ContractAddress) -> u256;
}
```

A trait that must be implemented when integrating [VotesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent) into a contract. It offers a mechanism to retrieve the number of voting units for a given account at the current time.

Functions

- [`get_voting_units(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotingUnitsTrait-get_voting_units)


#### Functions

#### `get_voting_units(self: @TState, account: ContractAddress) → u256` external

Returns the number of voting units for a given account. For ERC20, this is typically the token balance. For ERC721, this is typically the number of tokens owned.

|     |     |
| --- | --- |
|  | While any formula can be used as a measure of voting units, the internal vote accounting of the contract may be<br>compromised if voting units are transferred in any external flow by following a different formula.<br>For example, when implementing the hook for ERC20, the number of voting units transferred should match the formula given by the<br>`get_voting_units` implementation. |

[← Votes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/votes)

[Introspection →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection)Compiling - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Compiling

The OpenZeppelin CLI integrates the Solidity compiler to seamlessly compile your Solidity contracts into Ethereum Virtual Machine (EVM) bytecode.

This guide covers how compiling works, its different options, and the output format.

## Running the Compiler

Most CLI commands, like `oz create` or `oz upgrade`, will automatically compile your projects smart contracts when required, so you don’t need to worry about doing this yourself.

However, you can also just run the compilation by itself, using the [`oz compile`](https://docs.openzeppelin.com/cli/2.7/commands#compile) command:

```console hljs language-shell
$ npx oz compile
```

When executed for the first time, all smart contracts in the `contracts` directory will be compiled at once. Further invocations of `compile` however will _only_ compile contracts that have changed (along with their dependents), speeding up the process.

## Settings

All compilation settings are passed directly to the Solidity compiler. Check out its [documentation](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html) for more info on how each setting affects compilation.

### Picking a Compiler Version

Each Solidity source files should be annotated with a [version pragma](https://solidity.readthedocs.io/en/v0.5.15/layout-of-source-files.html#version-pragma) that indicates which compiler versions can be used to compile it.

The CLI will parse all of these declarations and automatically select the latest compiler version that matches all your version pragmas. This single version will be the one used to compile _all_ of your contracts.

|     |     |
| --- | --- |
|  | It is often best to use permissive pragmas, such as `^0.5.0` or `^0.6.0` (which select the 0.5.x and 0.6.x lines of the compiler, respectively), and let the CLI do the rest. |

Alternatively, you can also specify a compiler version when calling `oz compile` by using the `--solc-version` option:

```console hljs language-shell
$ npx oz compile --solc-version 0.5.14
```

In all cases, the selected Solidity compiler version will be automatically downloaded and saved to cache from the [official distribution list](https://solc-bin.ethereum.org/bin/list.json). Once the version is set, subsequent compilations will [use that same version](https://docs.openzeppelin.com/cli/2.7/compiling#saving-your-settings).

|     |     |
| --- | --- |
|  | For enhanced performance, you can [install the native Solidity binaries](https://solidity.readthedocs.io/en/v0.5.15/installing-solidity.html#binary-packages) on your machine: the CLI will automatically pick it up when compiling if it matches the target version. Massive speedups can be achieved by doing this, specially on large projects. Just make sure it’s available on your [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable))!. |

### Picking an EVM Version

Each version of the Solidity compiler ships with a default [EVM version](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html#setting-the-evm-version-to-target), which corresponds to the mainnet EVM version at the time of release. The CLI will respect these defaults unless otherwise instructed.

In some occasions, it may be necessary to select a specific EVM version. This is achieved via the `--evm-version` flag:

```console hljs language-shell
$ npx oz compile --evm-version berlin
```

### Using the Optimizer

The Solidity compiler features an optional optimizer: it can produce smaller and more gas-efficient EVM bytecode, at the cost of making it harder to understand.

The optimizer is enabled or disabled with the `--optimizer` option:

```console hljs language-shell
$ npx oz compile --optimizer on
```

For fine tuning, you can also pass the `--optimizer-runs` option. This number should be an estimate of how many times you expect your smart contract to be called: pass 1 for one-offs, or a higher number for regularly used contracts. The default value is 200.

```console hljs language-shell
$ npx oz compile --optimizer on --optimizer-runs 100
```

|     |     |
| --- | --- |
|  | Don’t worry if you’re not sure what value to pass to `--optimizer-runs`: the gains achieved by using this parameter correctly are very limited. |

### Saving Your Settings

All compilation settings, including compiler version, EVM version and optimizer configuration are stored in your [project configuration file](https://docs.openzeppelin.com/cli/2.7/configuration#project.json), will be used in all successive compilations.

To modify these settings, run `oz compile` with the newly desired values, or simply edit the configuration file manually.

## Compilation Results

### Storing Compiled Artifacts

The output of the compiler is a number of `.json` files (one per compiled contract), which hold all relevant information: compiler settings, copies of the source, and most importantly, the resulting ABI and bytecode. These files are stored in the `build/contracts` directory, which the CLI will create for you automatically.

|     |     |
| --- | --- |
|  | These files can be large, and since compilation is a fast process it’s often a good idea to add this directory to your `.gitignore`:<br>```diff hljs<br> // .gitignore<br>+build/contracts<br>``` |

### Loading Your Contracts

The format of the `.json` artifacts is standard, and compatible with all major smart contract tools out there, such as Truffle, Buidler, and Etherlime.

If you want to load your compiled contracts and interact with them from JavaScript code, we recommend using the [**OpenZeppelin Contract Loader**](https://docs.openzeppelin.com/contract-loader/0.6/):

```javascript hljs
const { setupLoader } = require('@openzeppelin/contract-loader');

const loader = setupLoader({
  provider,        // either a web3 provider or a web3 instance
  defaultSender,   // optional
});

// Load build/contracts/ERC20.json
const ERC20 = loader.web3.fromArtifact('ERC20');

// Deploy contract
const token = await ERC20.deploy().send();

// Query state and send transaction
const balance = await token.methods.balanceOf(sender).call();
await token.methods.transfer(receiver, balance).send({ from: sender });
```

[← Using Dependencies](https://docs.openzeppelin.com/cli/2.7/dependencies)

[Deploying With `CREATE2` →](https://docs.openzeppelin.com/cli/2.7/deploying-with-create2)Contracts for Cairo - OpenZeppelin Docs

# Contracts for Cairo

**A library for secure smart contract development** written in Cairo for [Starknet](https://starkware.co/product/starknet/). This library consists of a set of [reusable components](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components) to build custom smart contracts, as well as
ready-to-deploy [presets](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets). You can also find other [utilities](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities) including [interfaces and dispatchers](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces) and [test utilities](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing)
that facilitate testing with Starknet Foundry.

|     |     |
| --- | --- |
|  | This repo contains highly experimental code. Expect rapid iteration. **Use at your own risk.** |

|     |     |
| --- | --- |
|  | You can track our roadmap and future milestones in our [Github Project](https://github.com/orgs/OpenZeppelin/projects/29/). |

## Installation

The library is available as a [Scarb](https://docs.swmansion.com/scarb) package. Follow [this guide](https://docs.swmansion.com/scarb/download.html) for installing Cairo and Scarb on your machine
before proceeding, and run the following command to check that the installation was successful:

```bash hljs
$ scarb --version

scarb 2.9.1 (aba4f604a 2024-11-29)
cairo: 2.9.1 (https://crates.io/crates/cairo-lang-compiler/2.9.1)
sierra: 1.6.0
```

### Set up your project

Create an empty directory, and `cd` into it:

```bash hljs
mkdir my_project/ && cd my_project/
```

Initialize a new Scarb project:

```bash hljs
scarb init
```

The contents of `my_project/` should now look like this:

```bash hljs
$ ls

Scarb.toml src
```

### Install the library

Install the library by declaring it as a dependency in the project’s `Scarb.toml` file:

```text hljs
[dependencies]
openzeppelin = "0.20.0"
```

|     |     |
| --- | --- |
|  | Make sure the tag matches the target release. |

## Basic usage

This is how it looks to build an ERC20 contract using the [ERC20 component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20).
Copy the code into `src/lib.cairo`.

```cairo hljs
#[starknet::contract]
mod MyERC20Token {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress
    ) {
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }
}
```

You can now compile it:

```bash hljs
scarb build
```

[Wizard →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/wizard)Migrating ERC165 to SRC5 - OpenZeppelin Docs

# Migrating ERC165 to SRC5

In the smart contract ecosystem, having the ability to query if a contract supports a given interface is an extremely important feature.
The initial introspection design for Contracts for Cairo before version v0.7.0 followed Ethereum’s [EIP-165](https://eips.ethereum.org/EIPS/eip-165).
Since the Cairo language evolved introducing native types, we needed an introspection solution tailored to the Cairo ecosystem: the [SNIP-5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md) standard.
SNIP-5 allows interface ID calculations to use Cairo types and the Starknet keccak ( `sn_keccak`) function.
For more information on the decision, see the [Starknet Shamans proposal](https://community.starknet.io/t/starknet-standard-interface-detection/92664) or the [Dual Introspection Detection](https://github.com/OpenZeppelin/cairo-contracts/discussions/640) discussion.

## How to migrate

Migrating from ERC165 to SRC5 involves four major steps:

1. Integrate SRC5 into the contract.

2. Register SRC5 IDs.

3. Add a `migrate` function to apply introspection changes.

4. Upgrade the contract and call `migrate`.


The following guide will go through the steps with examples.

### Component integration

The first step is to integrate the necessary components into the new contract.
The contract should include the new introspection mechanism, [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component).
It should also include the [InitializableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#InitializableComponent) which will be used in the `migrate` function.
Here’s the setup:

```cairo hljs
#[starknet::contract]
mod MigratingContract {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_security::initializable::InitializableComponent;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;

    // Initializable
    impl InitializableInternalImpl = InitializableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }
}
```

### Interface registration

To successfully migrate ERC165 to SRC5, the contract needs to register the interface IDs that the contract supports with SRC5.

For this example, let’s say that this contract supports the [IERC721](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721) and [IERC721Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata) interfaces.
The contract should implement an `InternalImpl` and add a function to register those interfaces like this:

```cairo hljs
#[starknet::contract]
mod MigratingContract {
    use openzeppelin_token::erc721::interface::{IERC721_ID, IERC721_METADATA_ID};

    (...)

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        // Register SRC5 interfaces
        fn register_src5_interfaces(ref self: ContractState) {
            self.src5.register_interface(IERC721_ID);
            self.src5.register_interface(IERC721_METADATA_ID);
        }
    }
}
```

Since the new contract integrates `SRC5Component`, it can leverage SRC5’s [register\_interface](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-register_interface) function to register the supported interfaces.

### Migration initializer

Next, the contract should define and expose a migration function that will invoke the `register_src5_interfaces` function.
Since the `migrate` function will be publicly callable, it should include some sort of [Access Control](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access) so that only permitted addresses can execute the migration.
Finally, `migrate` should include a reinitialization check to ensure that it cannot be called more than once.

|     |     |
| --- | --- |
|  | If the original contract implemented `Initializable` at any point and called the `initialize` method, the `InitializableComponent` will not be usable at this time.<br>Instead, the contract can take inspiration from `InitializableComponent` and create its own initialization mechanism. |

```cairo hljs
#[starknet::contract]
mod MigratingContract {
    (...)

    #[external(v0)]
    fn migrate(ref self: ContractState) {
        // WARNING: Missing Access Control mechanism. Make sure to add one

        // WARNING: If the contract ever implemented `Initializable` in the past,
        // this will not work. Make sure to create a new initialization mechanism
        self.initializable.initialize();

        // Register SRC5 interfaces
        self.register_src5_interfaces();
    }
}
```

### Execute migration

Once the new contract is prepared for migration and **rigorously tested**, all that’s left is to migrate!
Simply upgrade the contract and then call `migrate`.

[← Introspection](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection)Presets - OpenZeppelin Docs

# Presets

Presets are ready-to-deploy contracts provided by the library. Since presets are intended to be very simple
and as generic as possible, there’s no support for custom or complex contracts such as `ERC20Pausable` or `ERC721Mintable`.

|     |     |
| --- | --- |
|  | For contract customization and combination of modules you can use [Wizard for Cairo](https://wizard.openzeppelin.com/), our code-generation tool. |

## Available presets

List of available presets and their corresponding [Sierra class hashes](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash).

|     |     |
| --- | --- |
|  | Class hashes were computed using [cairo 2.9.1](https://crates.io/crates/cairo-lang-compiler/2.9.1). |

| Name | Sierra Class Hash |
| --- | --- |
| `AccountUpgradeable` | `0x02b31e19e45c06f29234e06e2ee98a9966479ba3067f8785ed972794fdb0065c` |
| `ERC20Upgradeable` | `0x041385cd42de9877180b006fc01d613c70e2429fc2e660df6a791b4cc0e747de` |
| `ERC721Upgradeable` | `0x015922a7436b4ee45120d5f6442bcfd8dd407fa2283dfa2276ccb9db10a9deda` |
| `ERC1155Upgradeable` | `0x046ec13b3dc855cddbaad504c5d3526f34134541f04207c7cfa7b6919f5fd2be` |
| `EthAccountUpgradeable` | `0x02ba7c42372cf971c8ee60166544e7ff72c2e38bc2835d7edd89b327b1000d8b` |
| `UniversalDeployer` | `0x06b79a175c8be9fb2acf40a1b0289018c95d04092dd4f080a133d83f9e9c696b` |
| `VestingWallet` | `0x0386b4e438105ef2ba52b12dae76e6afef54a234083137d32c57d06693a8c7c7` |

|     |     |
| --- | --- |
|  | [starkli](https://book.starkli.rs/introduction) class-hash command can be used to compute the class hash from a Sierra artifact. |

## Usage

These preset contracts are ready-to-deploy which means they should already be declared on the Sepolia network.
Simply deploy the preset class hash and add the appropriate constructor arguments.
Deploying the ERC20Upgradeable preset with [starkli](https://book.starkli.rs/introduction), for example, will look like this:

```bash hljs
starkli deploy 0x041385cd42de9877180b006fc01d613c70e2429fc2e660df6a791b4cc0e747de \
  <CONSTRUCTOR_ARGS> \
  --network="sepolia"
```

If a class hash has yet to be declared, copy/paste the preset contract code and declare it locally.
Start by [setting up a project](https://docs.openzeppelin.com/contracts-cairo/0.20.0/#set_up_your_project) and [installing the Contracts for Cairo library](https://docs.openzeppelin.com/contracts-cairo/0.20.0/#install%20the_library).
Copy the target preset contract from the [presets directory](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.20.0/packages/presets/src) and paste it in the new project’s `src/lib.cairo` like this:

```cairo hljs
// src/lib.cairo

#[starknet::contract]
mod ERC20Upgradeable {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ContractAddress, ClassHash};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress,
        owner: ContractAddress
    ) {
        self.ownable.initializer(owner);
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.ownable.assert_only_owner();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

Next, compile the contract.

```bash hljs
scarb build
```

Finally, declare the preset.

```bash hljs
starkli declare target/dev/my_project_ERC20Upgradeable.contract_class.json \
  --network="sepolia"
```

[← Components](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components)

[Interfaces and Dispatchers →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces)Common (Token) - OpenZeppelin Docs

# Common (Token)

This module provides extensions and utilities that are common to multiple token standards.

## ERC2981

### `IERC2981`

```cairo hljs
use openzeppelin_token::common::erc2981::interface::IERC2981;
```

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x2d3414e45a8700c29f119a54b9f11dca0e29e06ddcb214018fc37340e165ed6

Interface of the ERC2981 standard as defined in [EIP-2981](https://eips.ethereum.org/EIPS/eip-2981).

Functions

- [`royalty_info(token_id, sale_price)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981-royalty_info)


#### Functions

#### `royalty_info(token_id: u256, sale_price: u256) → (ContractAddress, u256)` external

Returns how much royalty is owed and to whom, based on a sale price that may be denominated
in any unit of exchange. The royalty amount is denominated and must be paid in that same
unit of exchange.

### `IERC2981Info`

```cairo hljs
use openzeppelin_token::common::erc2981::interface::IERC2981Info;
```

Interface providing external read functions for discovering the state of ERC2981 component.

Functions

- [`default_royalty()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Info-default_royalty)

- [`token_royalty(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Info-token_royalty)


#### Functions

#### `default_royalty() → (ContractAddress, u128, u128)` external

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `token_royalty(token_id: u256) → (ContractAddress, u128, u128)` external

Returns the royalty information specific to a token.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


### `IERC2981Admin`

```cairo hljs
use openzeppelin_token::common::erc2981::interface::IERC2981Admin;
```

Interface providing external admin functions for managing the settings of ERC2981 component.

Functions

- [`set_default_royalty(receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-set_default_royalty)

- [`delete_default_royalty()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-delete_default_royalty)

- [`set_token_royalty(token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-set_token_royalty)

- [`reset_token_royalty(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-reset_token_royalty)


#### Functions

#### `set_default_royalty(receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information that all ids in this contract will default to.

#### `delete_default_royalty()` external

Sets the default royalty percentage and receiver to zero.

#### `set_token_royalty(token_id: u256, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information for a specific token id that takes precedence over the global default.

#### `reset_token_royalty(token_id: u256)` external

Resets royalty information for the token id back to unset.

### `ERC2981Component`

```cairo hljs
use openzeppelin_token::common::erc2981::ERC2981Component;
```

ERC2981 component extending [IERC2981](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981).

[Immutable Component Config](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#immutable_config)

constants

- [`FEE_DENOMINATOR`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-IC-FEE_DENOMINATOR)


functions

- [`validate()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-IC-validate)


Embeddable Implementations

ERC2981Impl

- [`royalty_info(self, token_id, sale_price)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-royalty_info)


ERC2981InfoImpl

- [`default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981InfoImpl-default_royalty)

- [`token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981InfoImpl-token_royalty)


ERC2981AdminOwnableImpl

- [`set_default_royalty(self, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-set_default_royalty)

- [`delete_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-delete_default_royalty)

- [`set_token_royalty(self, token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-set_token_royalty)

- [`reset_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-reset_token_royalty)


ERC2981AdminAccessControlImpl

- [`set_default_royalty(self, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-set_default_royalty)

- [`delete_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-delete_default_royalty)

- [`set_token_royalty(self, token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-set_token_royalty)

- [`reset_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-reset_token_royalty)


Internal implementations

InternalImpl

- [`initializer(self, default_receiver, default_royalty_fraction)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-initializer)

- [`_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_default_royalty)

- [`_set_default_royalty(self, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_set_default_royalty)

- [`_delete_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_delete_default_royalty)

- [`_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_token_royalty)

- [`_set_token_royalty(self, token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_set_token_royalty)

- [`_reset_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_reset_token_royalty)


#### Immutable Config constants

#### `FEE_DENOMINATOR: u128` constant

The denominator with which to interpret the fee set in
`_set_token_royalty` and `_set_default_royalty` as a fraction of the sale price.

#### `validate()` internal

Validates the given implementation of the contract’s configuration.

Requirements:

- `FEE_DENOMINATOR` must be greater than 0.


|     |     |
| --- | --- |
|  | This function is called by the contract’s initializer. |

#### Embeddable functions

#### `royalty_info(@self: ContractState, token_id: u256, sale_price: u256) → (ContractAddress, u256)` external

Returns how much royalty is owed and to whom, based on a sale price that may be
denominated in any unit of exchange. The royalty amount is denominated and should be
paid in that same unit of exchange.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The amount of royalty payment.


#### `default_royalty(@self: ContractState) → (ContractAddress, u128, u128)` external

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `token_royalty(self: @ContractState, token_id: u256) → (ContractAddress, u128, u128)` external

Returns the royalty information specific to a token.
If no specific royalty information is set for the token, the default is returned.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### ERC2981AdminOwnableImpl

Provides admin functions for managing royalty settings that are restricted to be called only by the contract’s owner.
Requires the contract to implement [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent).

#### `set_default_royalty(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information that all ids in this contract will default to.

Requirements:

- The caller is the contract owner.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `delete_default_royalty(ref self: ContractState)` external

Sets the default royalty percentage and receiver to zero.

Requirements:

- The caller is the contract owner.


#### `set_token_royalty(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- The caller is the contract owner.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `reset_token_royalty(ref self: ContractState, token_id: u256)` external

Resets royalty information for the token id back to unset.

Requirements:

- The caller is the contract owner.


#### ERC2981AdminAccessControlImpl

Provides admin functions for managing royalty settings that require `ROYALTY_ADMIN_ROLE` to be granted to the caller.
Requires the contract to implement [AccessControlComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent).

#### `ROYALTY_ADMIN_ROLE: felt252` constant

Role for the admin responsible for managing royalty settings.

#### `set_default_royalty(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information that all ids in this contract will default to.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `delete_default_royalty(ref self: ContractState)` external

Sets the default royalty percentage and receiver to zero.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.


#### `set_token_royalty(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `reset_token_royalty(ref self: ContractState, token_id: u256)` external

Resets royalty information for the token id back to unset.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.


#### Internal functions

#### `initializer(ref self: ContractState, default_receiver: ContractAddress, default_royalty_fraction: u128)` internal

Initializes the contract by setting the default royalty and registering the supported interface.

Requirements:

- `default_receiver` cannot be the zero address.

- `default_royalty_fraction` cannot be greater than the fee denominator.

- The fee denominator must be greater than 0.


|     |     |
| --- | --- |
|  | The fee denominator is set by the contract using the [Immutable Component Config](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#immutable_config). |

#### `_default_royalty(self: @ContractState) → (ContractAddress, u128, u128)` internal

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `_set_default_royalty(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)` internal

Sets the royalty information that all ids in this contract will default to.

Requirements:

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `_delete_default_royalty(ref self: ContractState)` internal

Sets the default royalty percentage and receiver to zero.

#### `_token_royalty(self: @ContractState, token_id: u256) → (ContractAddress, u256, u256)` internal

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `_set_token_royalty(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)` internal

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `_reset_token_royalty(ref self: ContractState, token_id: u256)` internal

Resets royalty information for the token id back to unset.

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155)

[Universal Deployer Contract →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc)Publishing an Ethereum Package - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Publishing an Ethereum Package

In [Using Dependencies](https://docs.openzeppelin.com/cli/2.6/dependencies), we showed how to use the [`oz link`](https://docs.openzeppelin.com/cli/2.6/commands#link) command to use the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) as a dependency, taking advantage of its contracts being _already deployed on the blockchain_.

In this guide we’ll describe how you can create your own Ethereum Package, and make it available to everyone via the OpenZeppelin CLI.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with using public networks, upgradeable contracts, and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying to a Public Test Network](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::public-staging.adoc) and [Upgrades](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::on-upgrades.adoc). |

## Storing Your Project On-chain

So far, we’ve mostly limited ourselves to depoying contracts using [`oz create`](https://docs.openzeppelin.com/cli/2.6/commands#create), which creates _upgradeable instances_ by deploying _proxies_ to an existing implementation contract (refer to [How Upgrades Work](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::on-upgrades.adoc#how-upgrades-work) to brush up on this). Here, we will instead deploy just the implementations, so that other people can create new proxies pointing to them.

To achieve this, we’ll use two low-level CLI commands: [`oz add`](https://docs.openzeppelin.com/cli/2.6/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.6/commands#push). These work simmilarly to `git add` and `git push`: they will register contracts in your project and deploy them to a network.

In your [OpenZeppelin project](https://docs.openzeppelin.com/cli/2.6/getting-started#setting-up-your-project), run:

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add <contract-1>, <contract-2>
✓ Added contract <contract-1>
✓ Added contract <contract-2>
All the selected contracts have been added to the project
$ npx oz push
? Pick a network mainnet
✓ Contract <contract-1> deployed
✓ Contract <contract-2> deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | For your Ethereum Pacakge to be used by others, it needs to be deployed on a real network instead of a local one. Take a look at [Deploying to a Public Test Network](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::public-staging.adoc) for detailed instructions for this process. |

Ethereum Packages are upgradeable, which means they track the different implementation contracts that correspond to each version of the package. We’ll use the [`oz publish`](https://docs.openzeppelin.com/cli/2.6/commands#publish) command for this, which will deploy an [`App`](https://docs.openzeppelin.com/cli/2.6/contracts-architecture#app.sol) contract and register the implementations there:

```console hljs language-shell
$ npx oz publish
? Pick a network mainnet
✓ Project structure deployed
✓ Registering <contract-1> at 0x2c2eB5B599C2C4Bb2cA7e43179585aFec0D97D51 in directory
✓ Registering <contract-2> at 0x6389e6409Ad106aF5e7e6bE8D95Fca637980fB63 in directory
✓ Published to mainnet!
```

The Ethereum Package is complete! But we’re still lacking something: a convenient way to tell people about its existence.

## Distributing With `npm`

For your Ethereum Package to [usable from other projects](https://docs.openzeppelin.com/cli/2.6/dependencies), it needs to be published on the [npm registry](https://www.npmjs.com/). If you havent’t published an npm package before, go ahead and [sign up for a free npm account](https://www.npmjs.com/signup).

First, add your contract sources, compiled artifacts and OpenZeppelin project files to your package by including the following entries in your project’s `package.json`:

```diff hljs
 // package.json
 {
   ...,
   "files": [\
+    "build",\
+    "contracts",\
+    ".openzeppelin/*.json"\
   ]
 }
```

|     |     |
| --- | --- |
|  | The files in your `.openzeppelin` directory that [should not be tracked in version control](https://docs.openzeppelin.com/cli/2.6/configuration#configuration-files-in-version-control) are not required to be part of your published npm package: remove them before publishing to the registry. |

Almost done! Log into npm and upload your package with:

```console hljs language-shell
$ npm login
$ npm publish
```

Success! The Ethereum Package is now live on the blockchain, and accessible to everyone via the npm registry.

Any OpenZeppelin project can now [link](https://docs.openzeppelin.com/cli/2.6/commands#link) to your package:

```console hljs language-shell
$ npx oz link <your-project-name>
```

|     |     |
| --- | --- |
|  | Your Ethereum Package’s name is the same one you provided [during initialization](https://docs.openzeppelin.com/cli/2.6/getting-started#setting-up-your-project). |Introspection - OpenZeppelin Docs

# Introspection

To smooth interoperability, often standards require smart contracts to implement [introspection mechanisms](https://en.wikipedia.org/wiki/Type_introspection).

In Ethereum, the [EIP165](https://eips.ethereum.org/EIPS/eip-165) standard defines how contracts should declare
their support for a given interface, and how other contracts may query this support.

Starknet offers a similar mechanism for interface introspection defined by the [SRC5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md) standard.

## SRC5

Similar to its Ethereum counterpart, the [SRC5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md) standard requires contracts to implement the `supports_interface` function,
which can be used by others to query if a given interface is supported.

### Usage

To expose this functionality, the contract must implement the [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component), which defines the `supports_interface` function.
Here is an example contract:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.src5.register_interface(selector!("some_interface"));
    }
}
```

### Interface

```cairo hljs
#[starknet::interface]
pub trait ISRC5 {
    /// Query if a contract implements an interface.
    /// Receives the interface identifier as specified in SRC-5.
    /// Returns `true` if the contract implements `interface_id`, `false` otherwise.
    fn supports_interface(interface_id: felt252) -> bool;
}
```

## Computing the interface ID

The interface ID, as specified in the standard, is the [XOR](https://en.wikipedia.org/wiki/Exclusive_or) of all the
[Extended Function Selectors](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#extended-function-selector)
of the interface. We strongly advise reading the SNIP to understand the specifics of computing these
extended function selectors. There are tools such as [src5-rs](https://github.com/ericnordelo/src5-rs) that can help with this process.

## Registering interfaces

For a contract to declare its support for a given interface, we recommend using the SRC5 component to register support upon contract deployment through a constructor either directly or indirectly (as an initializer) like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_account::interface;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl InternalImpl = SRC5Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        // Register the contract's support for the ISRC6 interface
        self.src5.register_interface(interface::ISRC6_ID);
    }

    (...)
}
```

## Querying interfaces

Use the `supports_interface` function to query a contract’s support for a given interface.

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_account::interface;
    use openzeppelin_introspection::interface::ISRC5DispatcherTrait;
    use openzeppelin_introspection::interface::ISRC5Dispatcher;
    use starknet::ContractAddress;

    #[storage]
    struct Storage {}

    #[external(v0)]
    fn query_is_account(self: @ContractState, target: ContractAddress) -> bool {
        let dispatcher = ISRC5Dispatcher { contract_address: target };
        dispatcher.supports_interface(interface::ISRC6_ID)
    }
}
```

|     |     |
| --- | --- |
|  | If you are unsure whether a contract implements SRC5 or not, you can follow the process described in<br>[here](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#how-to-detect-if-a-contract-implements-src-5). |

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance)

[Migrating ERC165 to SRC5 →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/src5-migration)Accounts - OpenZeppelin Docs

# Accounts

Unlike Ethereum where accounts are derived from a private key, all Starknet accounts are contracts. This means there’s no Externally Owned Account (EOA)
concept on Starknet.

Instead, the network features native account abstraction and signature validation happens at the contract level.

For a general overview of account abstraction, see
[Starknet’s documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Accounts/introduction/).
A more detailed discussion on the topic can be found in
[Starknet Shaman’s forum](https://community.starknet.io/t/starknet-account-abstraction-model-part-1/781).

|     |     |
| --- | --- |
|  | For detailed information on the usage and implementation check the [API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account) section. |

## What is an account?

Accounts in Starknet are smart contracts, and so they can be deployed and interacted
with like any other contract, and can be extended to implement any custom logic. However, an account is a special type
of contract that is used to validate and execute transactions. For this reason, it must implement a set of entrypoints
that the protocol uses for this execution flow. The [SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md) proposal defines a standard interface for accounts,
supporting this execution flow and interoperability with DApps in the ecosystem.

### ISRC6 Interface

```cairo hljs
/// Represents a call to a target contract function.
struct Call {
    to: ContractAddress,
    selector: felt252,
    calldata: Span<felt252>
}

/// Standard Account Interface
#[starknet::interface]
pub trait ISRC6 {
    /// Executes a transaction through the account.
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;

    /// Asserts whether the transaction is valid to be executed.
    fn __validate__(calls: Array<Call>) -> felt252;

    /// Asserts whether a given signature for a given hash is valid.
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;
}
```

|     |     |
| --- | --- |
|  | The `calldata` member of the `Call` struct in the accounts has been updated to `Span<felt252>` for optimization<br>purposes, but the interface ID remains the same for backwards compatibility. This inconsistency will be fixed in future releases. |

[SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md) adds the `is_valid_signature` method. This method is not used by the protocol, but it’s useful for
DApps to verify the validity of signatures, supporting features like Sign In with Starknet.

SNIP-6 also defines that compliant accounts must implement the SRC5 interface following [SNIP-5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md), as
a mechanism for detecting whether a contract is an account or not through introspection.

### ISRC5 Interface

```cairo hljs
/// Standard Interface Detection
#[starknet::interface]
pub trait ISRC5 {
    /// Queries if a contract implements a given interface.
    fn supports_interface(interface_id: felt252) -> bool;
}
```

[SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md) compliant accounts must return `true` when queried for the ISRC6 interface ID.

Even though these interfaces are not enforced by the protocol, it’s recommended to implement them for enabling
interoperability with the ecosystem.

### Protocol-level methods

The Starknet protocol uses a few entrypoints for abstracting the accounts. We already mentioned the first two
as part of the ISRC6 interface, and both are required for enabling accounts to be used for executing transactions. The rest are optional:

1. `__validate__` verifies the validity of the transaction to be executed. This is usually used to validate signatures,
but the entrypoint implementation can be customized to feature any validation mechanism [with some limitations](https://docs.starknet.io/documentation/architecture_and_concepts/Accounts/validate_and_execute/#validate_limitations).

2. `__execute__` executes the transaction if the validation is successful.

3. `__validate_declare__` optional entrypoint similar to `__validate__` but for transactions
meant to declare other contracts.

4. `__validate_deploy__` optional entrypoint similar to `__validate__` but meant for [counterfactual deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment).


|     |     |
| --- | --- |
|  | Although these entrypoints are available to the protocol for its regular transaction flow, they can also be called like any other method. |

## Starknet Account

Starknet native account abstraction pattern allows for the creation of custom accounts with different validation schemes, but
usually most account implementations validate transactions using the [Stark curve](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/stark-curve) which is the most efficient way
of validating signatures since it is a STARK-friendly curve.

OpenZeppelin Contracts for Cairo provides [AccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent) for implementing this validation scheme.

### Usage

Constructing an account contract requires integrating both [AccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent) and [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component). The contract should also set up the constructor to initialize the public key that will be used as the account’s signer. Here’s an example of a basic contract:

```cairo hljs
#[starknet::contract(account)]
mod MyAccount {
    use openzeppelin_account::AccountComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Account Mixin
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
    }
}
```

### Interface

This is the full interface of the `AccountMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait AccountABI {
    // ISRC6
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;
    fn __validate__(calls: Array<Call>) -> felt252;
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IDeclarer
    fn __validate_declare__(class_hash: felt252) -> felt252;

    // IDeployable
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: felt252
    ) -> felt252;

    // IPublicKey
    fn get_public_key() -> felt252;
    fn set_public_key(new_public_key: felt252, signature: Span<felt252>);

    // ISRC6CamelOnly
    fn isValidSignature(hash: felt252, signature: Array<felt252>) -> felt252;

    // IPublicKeyCamel
    fn getPublicKey() -> felt252;
    fn setPublicKey(newPublicKey: felt252, signature: Span<felt252>);
}
```

## Ethereum Account

Besides the Stark-curve account, OpenZeppelin Contracts for Cairo also offers Ethereum-flavored accounts that use the [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) curve for signature validation.
For this the [EthAccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent) must be used.

### Usage

Constructing a secp256k1 account contract also requires integrating both [EthAccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent) and [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component).
The contract should also set up the constructor to initialize the public key that will be used as the account’s signer.
Here’s an example of a basic contract:

```cairo hljs
#[starknet::contract(account)]
mod MyEthAccount {
    use openzeppelin_account::EthAccountComponent;
    use openzeppelin_account::interface::EthPublicKey;
    use openzeppelin_introspection::src5::SRC5Component;
    use starknet::ClassHash;

    component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // EthAccount Mixin
    #[abi(embed_v0)]
    impl EthAccountMixinImpl =
        EthAccountComponent::EthAccountMixinImpl<ContractState>;
    impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        eth_account: EthAccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        EthAccountEvent: EthAccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: EthPublicKey) {
        self.eth_account.initializer(public_key);
    }
}
```

### Interface

This is the full interface of the `EthAccountMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait EthAccountABI {
    // ISRC6
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;
    fn __validate__(calls: Array<Call>) -> felt252;
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IDeclarer
    fn __validate_declare__(class_hash: felt252) -> felt252;

    // IEthDeployable
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: EthPublicKey
    ) -> felt252;

    // IEthPublicKey
    fn get_public_key() -> EthPublicKey;
    fn set_public_key(new_public_key: EthPublicKey, signature: Span<felt252>);

    // ISRC6CamelOnly
    fn isValidSignature(hash: felt252, signature: Array<felt252>) -> felt252;

    // IEthPublicKeyCamel
    fn getPublicKey() -> EthPublicKey;
    fn setPublicKey(newPublicKey: EthPublicKey, signature: Span<felt252>);
}
```

## Deploying an account

In Starknet there are two ways of deploying smart contracts: using the `deploy_syscall` and doing
counterfactual deployments.
The former can be easily done with the [Universal Deployer Contract (UDC)](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc), a contract that
wraps and exposes the `deploy_syscall` to provide arbitrary deployments through regular contract calls.
But if you don’t have an account to invoke it, you will probably want to use the latter.

To do counterfactual deployments, you need to implement another protocol-level entrypoint named
`__validate_deploy__`. Check the [counterfactual deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment) guide to learn how.

## Sending transactions

Let’s now explore how to send transactions through these accounts.

### Starknet Account

First, let’s take the example account we created before and deploy it:

```[ hljs language-rust\
#[starknet::contract(account)]\
mod MyAccount {\
    use openzeppelin_account::AccountComponent;\
    use openzeppelin_introspection::src5::SRC5Component;\
\
    component!(path: AccountComponent, storage: account, event: AccountEvent);\
    component!(path: SRC5Component, storage: src5, event: SRC5Event);\
\
    // Account Mixin\
    #[abi(embed_v0)]\
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;\
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;\
\
    #[storage]\
    struct Storage {\
        #[substorage(v0)]\
        account: AccountComponent::Storage,\
        #[substorage(v0)]\
        src5: SRC5Component::Storage\
    }\
\
    #[event]\
    #[derive(Drop, starknet::Event)]\
    enum Event {\
        #[flat]\
        AccountEvent: AccountComponent::Event,\
        #[flat]\
        SRC5Event: SRC5Component::Event\
    }\
\
    #[constructor]\
    fn constructor(ref self: ContractState, public_key: felt252) {\
        self.account.initializer(public_key);\
    }\
}\
```\
\
To deploy the account variant, compile the contract and declare the class hash because custom accounts are likely not declared.\
This means that you’ll need an account already deployed.\
\
Next, create the account JSON with Starknet Foundry’s [custom account setup](https://foundry-rs.github.io/starknet-foundry/starknet/account.html#custom-account-contract) and include the `--class-hash` flag with the declared class hash.\
The flag enables custom account variants.\
\
|     |     |\
| --- | --- |\
|  | The following examples use `sncast` [v0.23.0](https://github.com/foundry-rs/starknet-foundry/releases/tag/v0.23.0). |\
\
```[ hljs language-solidity\
$ sncast \\
  --url http://127.0.0.1:5050 \\
  account create \\
  --name my-custom-account \\
  --class-hash 0x123456...\
```\
\
This command will output the precomputed contract address and the recommended `max-fee`.\
To counterfactually deploy the account, send funds to the address and then deploy the custom account.\
\
```[ hljs language-solidity\
$ sncast \\
  --url http://127.0.0.1:5050 \\
  account deploy \\
  --name my-custom-account\
```\
\
Once the account is deployed, set the `--account` flag with the custom account name to send transactions from that account.\
\
```[ hljs language-javascript\
$ sncast \\
  --account my-custom-account \\
  --url http://127.0.0.1:5050 \\
  invoke \\
  --contract-address 0x123... \\
  --function "some_function" \\
  --calldata 1 2 3\
```\
\
### Ethereum Account\
\
First, let’s take the example account we created before and deploy it:\
\
```[ hljs language-rust\
#[starknet::contract(account)]\
mod MyEthAccount {\
    use openzeppelin_account::EthAccountComponent;\
    use openzeppelin_account::interface::EthPublicKey;\
    use openzeppelin_introspection::src5::SRC5Component;\
\
    component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);\
    component!(path: SRC5Component, storage: src5, event: SRC5Event);\
\
    // EthAccount Mixin\
    #[abi(embed_v0)]\
    impl EthAccountMixinImpl =\
        EthAccountComponent::EthAccountMixinImpl<ContractState>;\
    impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;\
\
    #[storage]\
    struct Storage {\
        #[substorage(v0)]\
        eth_account: EthAccountComponent::Storage,\
        #[substorage(v0)]\
        src5: SRC5Component::Storage\
    }\
\
    #[event]\
    #[derive(Drop, starknet::Event)]\
    enum Event {\
        #[flat]\
        EthAccountEvent: EthAccountComponent::Event,\
        #[flat]\
        SRC5Event: SRC5Component::Event\
    }\
\
    #[constructor]\
    fn constructor(ref self: ContractState, public_key: EthPublicKey) {\
        self.eth_account.initializer(public_key);\
    }\
}\
```\
\
Special tooling is required in order to deploy and send transactions with an Ethereum-flavored account contract.\
The following examples utilize the [StarknetJS](https://www.starknetjs.com/) library.\
\
Compile and declare the contract on the target network.\
Next, precompute the EthAccount contract address using the declared class hash.\
\
|     |     |\
| --- | --- |\
|  | The following examples use unreleased features from StarknetJS ( `starknetjs@next`) at commit [d002baea0abc1de3ac6e87a671f3dec3757437b3](https://github.com/starknet-io/starknet.js/commit/d002baea0abc1de3ac6e87a671f3dec3757437b3). |\
\
```[ hljs language-solidity\
import * as dotenv from 'dotenv';\
import { CallData, EthSigner, hash } from 'starknet';\
import { ABI as ETH_ABI } from '../abis/eth_account.js';\
dotenv.config();\
\
// Calculate EthAccount address\
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);\
const ethPubKey = await ethSigner.getPubKey();\
const ethAccountClassHash = '<ETH_ACCOUNT_CLASS_HASH>';\
const ethCallData = new CallData(ETH_ABI);\
const ethAccountConstructorCalldata = ethCallData.compile('constructor', {\
    public_key: ethPubKey\
})\
const salt = '0x12345';\
const deployerAddress = '0x0';\
const ethContractAddress = hash.calculateContractAddressFromHash(\
    salt,\
    ethAccountClassHash,\
    ethAccountConstructorCalldata,\
    deployerAddress\
);\
console.log('Pre-calculated EthAccount address: ', ethContractAddress);\
```\
\
Send funds to the pre-calculated EthAccount address and deploy the contract.\
\
```[ hljs language-solidity\
import * as dotenv from 'dotenv';\
import { Account, CallData, EthSigner, RpcProvider, stark } from 'starknet';\
import { ABI as ETH_ABI } from '../abis/eth_account.js';\
dotenv.config();\
\
// Prepare EthAccount\
const provider = new RpcProvider({ nodeUrl: process.env.API_URL });\
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);\
const ethPubKey = await ethSigner.getPubKey();\
const ethAccountAddress = '<ETH_ACCOUNT_ADDRESS>'\
const ethAccount = new Account(provider, ethAccountAddress, ethSigner);\
\
// Prepare payload\
const ethAccountClassHash = '<ETH_ACCOUNT_CLASS_HASH>'\
const ethCallData = new CallData(ETH_ABI);\
const ethAccountConstructorCalldata = ethCallData.compile('constructor', {\
    public_key: ethPubKey\
})\
const salt = '0x12345';\
const deployPayload = {\
    classHash: ethAccountClassHash,\
    constructorCalldata: ethAccountConstructorCalldata,\
    addressSalt: salt,\
};\
\
// Deploy\
const { suggestedMaxFee: feeDeploy } = await ethAccount.estimateAccountDeployFee(deployPayload);\
const { transaction_hash, contract_address } = await ethAccount.deployAccount(\
    deployPayload,\
    { maxFee: stark.estimatedFeeToMaxFee(feeDeploy, 100) }\
);\
await provider.waitForTransaction(transaction_hash);\
console.log('EthAccount deployed at: ', contract_address);\
```\
\
Once deployed, connect the EthAccount instance to the target contract which enables calls to come from the EthAccount.\
Here’s what an ERC20 transfer from an EthAccount looks like.\
\
```[ hljs language-solidity\
import * as dotenv from 'dotenv';\
import { Account, RpcProvider, Contract, EthSigner } from 'starknet';\
dotenv.config();\
\
// Prepare EthAccount\
const provider = new RpcProvider({ nodeUrl: process.env.API_URL });\
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);\
const ethAccountAddress = '<ETH_ACCOUNT_CONTRACT_ADDRESS>'\
const ethAccount = new Account(provider, ethAccountAddress, ethSigner);\
\
// Prepare target contract\
const erc20 = new Contract(compiledErc20.abi, erc20Address, provider);\
\
// Connect EthAccount with the target contract\
erc20.connect(ethAccount);\
\
// Execute ERC20 transfer\
const transferCall = erc20.populate('transfer', {\
    recipient: recipient.address,\
    amount: 50n\
});\
const tx = await erc20.transfer(\
    transferCall.calldata, { maxFee: 900_000_000_000_000 }\
);\
await provider.waitForTransaction(tx.transaction_hash);\
```\
\
[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access)\
\
[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account)Proxy - OpenZeppelin Docs

# Proxy

|     |     |
| --- | --- |
|  | This document is better viewed at [https://docs.openzeppelin.com/community-contracts/proxy](https://docs.openzeppelin.com/community-contracts/proxy) |

Variants of proxy patterns, which are contracts that allow to forward a call to an implementation contract by using `delegatecall`. This contracts include:

- [`HybridProxy`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/proxy#HybridProxy): An ERC-1967 proxy that uses the implementation slot as a beacon in a way that a user can upgrade to an implementation of their choice.


## General

### `HybridProxy`

```solidity hljs
import "@openzeppelin/community-contracts/proxy/HybridProxy.sol";
```

A version of an ERC-1967 proxy that uses the address stored in the implementation slot as a beacon.

The design allows to set an initial beacon that the contract may quit by upgrading to its own implementation
afterwards. Transition between the "beacon mode" and the "direct mode" require implementation that expose an
upgrade mechanism that writes to the ERC-1967 implementation slot. Note that UUPSUpgradable includes security
checks that are not compatible with this proxy design.

|     |     |
| --- | --- |
|  | The fallback mechanism relies on the implementation not to define the {IBeacon-implementation} function.<br>Consider that if your implementation has this function, it’ll be assumed as the beacon address, meaning that<br>the returned address will be used as this proxy’s implementation. |

Functions

- `constructor(implementation, data)`

- `_implementation()`


Proxy

- `_delegate(implementation)`

- `_fallback()`

- `fallback()`


#### `constructor(address implementation, bytes data)` public

Initializes the proxy with an initial implementation. If data is present, it will be used to initialize the
implementation using a delegate call.

#### `_implementation() → address` internal

Returns the current implementation address according to ERC-1967’s implementation slot.

|     |     |
| --- | --- |
|  | The way this function identifies whether the implementation is a beacon, is by checking<br>if it implements the {IBeacon-implementation} function. Consider that an actual implementation could<br>define this function, mistakenly identifying it as a beacon. |

[← Account](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account)

[Token →](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token)ERC-721 Consecutive - OpenZeppelin Docs

# ERC-721 Consecutive

Consecutive extension for [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) is useful for efficiently minting multiple tokens in a single transaction. This can significantly reduce gas costs and improve performance when creating a large number of tokens at once.

## Usage

In order to make [`ERC-721 Consecutive`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/consecutive/index.html) methods “external” so that other contracts can call them, you need to add the following code to your contract:

```rust hljs
use openzeppelin_stylus::token::erc721::extensions::consecutive::{
    Erc721Consecutive, Error,
};

sol_storage! {
    #[entrypoint]
    struct Erc721ConsecutiveExample {
        #[borrow]
        Erc721Consecutive erc721_consecutive;
    }
}

#[public]
#[inherit(Erc721Consecutive)]
impl Erc721ConsecutiveExample {
    pub fn burn(&mut self, token_id: U256) -> Result<(), Error> {
        self.erc721_consecutive._burn(token_id)
    }

    pub fn mint(&mut self, to: Address, token_id: U256) -> Result<(), Error> {
        self.erc721_consecutive._mint(to, token_id)
    }
}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy). Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc721ConsecutiveExample {
    mapping(uint256 tokenId => address) private _owners;
    mapping(address owner => uint256) private _balances;
    mapping(uint256 tokenId => address) private _tokenApprovals;
    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;

    Checkpoint160[] private _checkpoints; // _sequentialOwnership
    mapping(uint256 bucket => uint256) private _data; // _sequentialBurn
    uint96 private _firstConsecutiveId;
    uint96 private _maxBatchSize;

    error ERC721InvalidReceiver(address receiver);
    error ERC721ForbiddenBatchMint();
    error ERC721ExceededMaxBatchMint(uint256 batchSize, uint256 maxBatch);
    error ERC721ForbiddenMint();
    error ERC721ForbiddenBatchBurn();
    error CheckpointUnorderedInsertion();

    event ConsecutiveTransfer(
        uint256 indexed fromTokenId,
        uint256 toTokenId,
        address indexed fromAddress,
        address indexed toAddress
    );

    struct Checkpoint160 {
        uint96 _key;
        uint160 _value;
    }

    constructor(
        address[] memory receivers,
        uint96[] memory amounts,
        uint96 firstConsecutiveId,
        uint96 maxBatchSize)
    {
        _firstConsecutiveId = firstConsecutiveId;
        _maxBatchSize = maxBatchSize;
        for (uint256 i = 0; i < receivers.length; ++i) {
            _mintConsecutive(receivers[i], amounts[i]);
        }
    }

    function latestCheckpoint() internal view returns (bool exists, uint96 _key, uint160 _value) {
        uint256 pos = _checkpoints.length;
        if (pos == 0) {
            return (false, 0, 0);
        } else {
            Checkpoint160 storage ckpt = _checkpoints[pos - 1];
            return (true, ckpt._key, ckpt._value);
        }
    }

    function push(uint96 key, uint160 value) internal returns (uint160, uint160) {
        return _insert(key, value);
    }

    function _insert(uint96 key, uint160 value) private returns (uint160, uint160) {
        uint256 pos = _checkpoints.length;

        if (pos > 0) {
            Checkpoint160 storage last = _checkpoints[pos - 1];
            uint96 lastKey = last._key;
            uint160 lastValue = last._value;

            // Checkpoint keys must be non-decreasing.
            if (lastKey > key) {
                revert CheckpointUnorderedInsertion();
            }

            // Update or push new checkpoint.
            if (lastKey == key) {
                _checkpoints[pos - 1]._value = value;
            } else {
                _checkpoints.push(Checkpoint160({_key: key, _value: value}));
            }
            return (lastValue, value);
        } else {
            _checkpoints.push(Checkpoint160({_key: key, _value: value}));
            return (0, value);
        }
    }

    function _mintConsecutive(address to, uint96 batchSize) internal virtual returns (uint96) {
        uint96 next = _nextConsecutiveId();

        // minting a batch of size 0 is a no-op.
        if (batchSize > 0) {
            if (address(this).code.length > 0) {
                revert ERC721ForbiddenBatchMint();
            }
            if (to == address(0)) {
                revert ERC721InvalidReceiver(address(0));
            }

            uint256 maxBatchSize = _maxBatchSize;
            if (batchSize > maxBatchSize) {
                revert ERC721ExceededMaxBatchMint(batchSize, maxBatchSize);
            }

            // push an ownership checkpoint & emit event.
            uint96 last = next + batchSize - 1;
            push(last, uint160(to));

            // The invariant required by this function is preserved because the new sequentialOwnership checkpoint
            // is attributing ownership of `batchSize` new tokens to account `to`.
            _increaseBalance(to, batchSize);

            emit ConsecutiveTransfer(next, last, address(0), to);
        }

        return next;
    }

    function _nextConsecutiveId() private view returns (uint96) {
        (bool exists, uint96 latestId,) = latestCheckpoint();
        return exists ? latestId + 1 : _firstConsecutiveId;
    }

    function _increaseBalance(address account, uint128 value) internal virtual {
        unchecked {
            _balances[account] += value;
        }
    }
}
```ERC20 - OpenZeppelin Docs

# ERC20

The ERC20 token standard is a specification for [fungible tokens](https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens), a type of token where all the units are exactly equal to each other.
`token::erc20::ERC20Component` provides an approximation of [EIP-20](https://eips.ethereum.org/EIPS/eip-20) in Cairo for Starknet.

|     |     |
| --- | --- |
|  | Prior to [Contracts v0.7.0](https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.7.0), ERC20 contracts store and read `decimals` from storage; however, this implementation returns a static `18`.<br>If upgrading an older ERC20 contract that has a decimals value other than `18`, the upgraded contract **must** use a custom `decimals` implementation.<br>See the [Customizing decimals](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20#customizing_decimals) guide. |

## Usage

Using Contracts for Cairo, constructing an ERC20 contract requires setting up the constructor and instantiating the token implementation.
Here’s what that looks like:

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }
}
```

`MyToken` integrates both the `ERC20Impl` and `ERC20MetadataImpl` with the embed directive which marks the implementations as external in the contract.
While the `ERC20MetadataImpl` is optional, it’s generally recommended to include it because the vast majority of ERC20 tokens provide the metadata methods.
The above example also includes the `ERC20InternalImpl` instance.
This allows the contract’s constructor to initialize the contract and create an initial supply of tokens.

|     |     |
| --- | --- |
|  | For a more complete guide on ERC20 token mechanisms, see [Creating ERC20 Supply](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/erc20-supply). |

## Interface

The following interface represents the full ABI of the Contracts for Cairo [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component).
The interface includes the [IERC20](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20) standard interface as well as the optional [IERC20Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata).

To support older token deployments, as mentioned in [Dual interfaces](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces#dual_interfaces), the component also includes an implementation of the interface written in camelCase.

```cairo hljs
#[starknet::interface]
pub trait ERC20ABI {
    // IERC20
    fn total_supply() -> u256;
    fn balance_of(account: ContractAddress) -> u256;
    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(spender: ContractAddress, amount: u256) -> bool;

    // IERC20Metadata
    fn name() -> ByteArray;
    fn symbol() -> ByteArray;
    fn decimals() -> u8;

    // IERC20Camel
    fn totalSupply() -> u256;
    fn balanceOf(account: ContractAddress) -> u256;
    fn transferFrom(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
}
```

## ERC20 compatibility

Although Starknet is not EVM compatible, this component aims to be as close as possible to the ERC20 token standard.
Some notable differences, however, can still be found, such as:

- The `ByteArray` type is used to represent strings in Cairo.

- The component offers a [dual interface](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces#dual_interfaces) which supports both snake\_case and camelCase methods, as opposed to just camelCase in Solidity.

- `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

- Function selectors are calculated differently between [Cairo](https://github.com/starkware-libs/cairo/blob/7dd34f6c57b7baf5cd5a30c15e00af39cb26f7e1/crates/cairo-lang-starknet/src/contract.rs#L39-L48) and [Solidity](https://solidity-by-example.org/function-selector/).


## Customizing decimals

Cairo, like Solidity, does not support [floating-point numbers](https://en.wikipedia.org//wiki/Floating-point_arithmetic).
To get around this limitation, ERC20 token contracts may offer a `decimals` field which communicates to outside interfaces (wallets, exchanges, etc.) how the token should be displayed.
For instance, suppose a token had a `decimals` value of `3` and the total token supply was `1234`.
An outside interface would display the token supply as `1.234`.
In the actual contract, however, the supply would still be the integer `1234`.
In other words, **the decimals field in no way changes the actual arithmetic** because all operations are still performed on integers.

Most contracts use `18` decimals and this was even proposed to be compulsory (see the [EIP discussion](https://github.com/ethereum/EIPs/issues/724)).
The Contracts for Cairo `ERC20` component includes a `decimals` function that returns `18` by default to save on gas fees.
For those who want an ERC20 token with a configurable number of decimals, the following guide shows two ways to achieve this.

|     |     |
| --- | --- |
|  | Both approaches require creating a custom implementation of the `IERC20Metadata` interface. |

### The static approach

The simplest way to customize `decimals` consists of returning the target value from the `decimals` method.
For example:

```cairo hljs
#[abi(embed_v0)]
impl ERC20MetadataImpl of interface::IERC20Metadata<ContractState> {
    fn decimals(self: @ContractState) -> u8 {
        // Change the `3` below to the desired number of decimals
        3
    }

    (...)
}
```

### The storage approach

For more complex scenarios, such as a factory deploying multiple tokens with differing values for decimals, a flexible solution might be appropriate.

|     |     |
| --- | --- |
|  | Note that we are not using the MixinImpl in this case, since we need to customize the IERC20Metadata implementation. |

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20CamelOnlyImpl = ERC20Component::ERC20CamelOnlyImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        // The decimals value is stored locally
        decimals: u8
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        decimals: u8,
        initial_supply: u256,
        recipient: ContractAddress,
    ) {
        // Call the internal function that writes decimals to storage
        self._set_decimals(decimals);

        // Initialize ERC20
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }

    #[abi(embed_v0)]
    impl ERC20MetadataImpl of interface::IERC20Metadata<ContractState> {
        fn name(self: @ContractState) -> ByteArray {
            self.erc20.name()
        }

        fn symbol(self: @ContractState) -> ByteArray {
            self.erc20.symbol()
        }

        fn decimals(self: @ContractState) -> u8 {
            self.decimals.read()
        }
    }

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        fn _set_decimals(ref self: ContractState, decimals: u8) {
            self.decimals.write(decimals);
        }
    }
}
```

This contract expects a `decimals` argument in the constructor and uses an internal function to write the decimals to storage.
Note that the `decimals` state variable must be defined in the contract’s storage because this variable does not exist in the component offered by OpenZeppelin Contracts for Cairo.
It’s important to include a custom ERC20 metadata implementation and NOT use the Contracts for Cairo `ERC20MetadataImpl` in this specific case since the `decimals` method will always return `18`.

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security)

[Creating Supply →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/erc20-supply)Tokens - OpenZeppelin Docs

# Tokens

Ah, the "token": blockchain’s most powerful and most misunderstood tool.

A token is a _representation of something in the blockchain_. This something can be money, time, services, shares in a company, a virtual pet, anything. By representing things as tokens, we can allow smart contracts to interact with them, exchange them, create or destroy them.

## But First, Coffee a Primer on Token Contracts

Much of the confusion surrounding tokens comes from two concepts getting mixed up: _token contracts_ and the actual _tokens_.

A _token contract_ is simply an Ethereum smart contract. "Sending tokens" actually means "calling a method on a smart contract that someone wrote and deployed". At the end of the day, a token contract is not much more than a mapping of addresses to balances, plus some methods to add and subtract from those balances.

It is these balances that represent the _tokens_ themselves. Someone "has tokens" when their balance in the token contract is non-zero. That’s it! These balances could be considered money, experience points in a game, deeds of ownership, or voting rights, and each of these tokens would be stored in different token contracts.

## Different Kinds of Tokens

Note that there’s a big difference between having two voting rights and two deeds of ownership: each vote is equal to all others, but houses usually are not! This is called [fungibility](https://en.wikipedia.org/wiki/Fungibility). _Fungible goods_ are equivalent and interchangeable, like Ether, fiat currencies, and voting rights. _Non-fungible_ goods are unique and distinct, like deeds of ownership, or collectibles.

In a nutshell, when dealing with non-fungibles (like your house) you care about _which ones_ you have, while in fungible assets (like your bank account statement) what matters is _how much_ you have.

## Standards

Even though the concept of a token is simple, they have a variety of complexities in the implementation. Because everything in Ethereum is just a smart contract, and there are no rules about what smart contracts have to do, the community has developed a variety of **standards** (called EIPs or ERCs) for documenting how a contract can interoperate with other contracts.

You’ve probably heard of the ERC-20 or ERC-721 token standards, and that’s why you’re here. Head to our specialized guides to learn more about these:

- [ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20): the most widespread token standard for fungible assets, albeit somewhat limited by its simplicity.

- [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721): the de-facto solution for non-fungible tokens, often used for collectibles and games.


[← Deploying Contracts](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy)

[ERC-20 →](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20)ERC721 - OpenZeppelin Docs

# ERC721

This module provides interfaces, presets, and utilities related to ERC721 contracts.

|     |     |
| --- | --- |
|  | For an overview of ERC721, read our [ERC721 guide](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc721). |

## Core

### `IERC721`

```cairo hljs
use openzeppelin_token::erc721::interface::IERC721;
```

Interface of the IERC721 standard as defined in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x33eb2f84c309543403fd69f0d0f363781ef06ef6faeb0131ff16ea3175bd943

Functions

- [`balance_of(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of)

- [`owner_of(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-owner_of)

- [`safe_transfer_from(from, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from)

- [`transfer_from(from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-transfer_from)

- [`approve(to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-approve)

- [`set_approval_for_all(operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-set_approval_for_all)

- [`get_approved(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-get_approved)

- [`is_approved_for_all(owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-is_approved_for_all)


Events

- [`Approval(owner, approved, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-ApprovalForAll)

- [`Transfer(from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer)


#### Functions

#### `balance_of(account: ContractAddress) → u256` external

Returns the number of NFTs owned by `account`.

#### `owner_of(token_id: u256) → ContractAddress` external

Returns the owner address of `token_id`.

#### `safe_transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` external

Transfer ownership of `token_id` from `from` to `to`, checking first that `to` is aware of the ERC721 protocol to prevent tokens being locked forever.
For information regarding how contracts communicate their awareness of the ERC721 protocol, see [Receiving Tokens](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc721#receiving_tokens).

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256)` external

Transfer ownership of `token_id` from `from` to `to`.

Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 transfers or else they may be permanently lost.
Usage of [IERC721::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from) prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `approve(to: ContractAddress, token_id: u256)` external

Change or reaffirm the approved address for an NFT.

Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `set_approval_for_all(operator: ContractAddress, approved: bool)` external

Enable or disable approval for `operator` to manage all of the caller’s assets.

Emits an [ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-ApprovalForAll) event.

#### `get_approved(token_id: u256) -> u256` external

Returns the address approved for `token_id`.

#### `is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool` external

Query if `operator` is an authorized operator for `owner`.

#### Events

#### `Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)` event

Emitted when `owner` enables `approved` to manage the `token_id` token.

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

Emitted when `owner` enables or disables `operator` to manage the `token_id` token.

#### `Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)` event

Emitted when `token_id` token is transferred from `from` to `to`.

### `IERC721Metadata`

```cairo hljs
use openzeppelin_token::erc721::interface::IERC721Metadata;
```

Interface for the optional metadata functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0xabbcd595a567dce909050a1038e055daccb3c42af06f0add544fa90ee91f25

Functions

- [`name()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-name)

- [`symbol()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-symbol)

- [`token_uri(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-token_uri)


#### Functions

#### `name() -> ByteArray` external

Returns the NFT name.

#### `symbol() -> ByteArray` external

Returns the NFT ticker symbol.

#### `token_uri(token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

### `ERC721Component`

```cairo hljs
use openzeppelin_token::erc721::ERC721Component;
```

ERC721 component implementing [IERC721](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721) and [IERC721Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

|     |     |
| --- | --- |
|  | See [Hooks](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Hooks) to understand how are hooks used. |

Hooks

ERC721HooksTrait

- [`before_update(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-before_update)

- [`after_update(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-after_update)


[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERC721MixinImpl

- [`ERC721Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721Impl)

- [`ERC721MetadataImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721MetadataImpl)

- [`ERC721CamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl)

- [`ERC721MetadataCamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

ERC721Impl

- [`balance_of(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-balance_of)

- [`owner_of(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-owner_of)

- [`safe_transfer_from(self, from, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_transfer_from)

- [`transfer_from(self, from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transfer_from)

- [`approve(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-approve)

- [`set_approval_for_all(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-set_approval_for_all)

- [`get_approved(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-get_approved)

- [`is_approved_for_all(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-is_approved_for_all)


ERC721MetadataImpl

- [`name(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-name)

- [`symbol(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-symbol)

- [`token_uri(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-token_uri)


ERC721CamelOnlyImpl

- [`balanceOf(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-balanceOf)

- [`ownerOf(self, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-ownerOf)

- [`safeTransferFrom(self, from, to, tokenId, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safeTransferFrom)

- [`transferFrom(self, from, to, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transferFrom)

- [`setApprovalForAll(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-setApprovalForAll)

- [`getApproved(self, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-getApproved)

- [`isApprovedForAll(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-isApprovedForAll)


ERC721MetadataCamelOnlyImpl

- [`tokenURI(self, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-tokenURI)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


Internal functions

InternalImpl

- [`initializer(self, name, symbol, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-initializer)

- [`exists(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-exists)

- [`transfer(self, from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transfer)

- [`mint(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-mint)

- [`safe_transfer(self, from, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_transfer)

- [`safe_mint(self, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_mint)

- [`burn(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-burn)

- [`update(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-update)

- [`_owner_of(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_owner_of)

- [`_require_owned(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_require_owned)

- [`_approve(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_approve)

- [`_approve_with_optional_event(self, to, token_id, auth, emit_event)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_approve_with_optional_event)

- [`_set_approval_for_all(self, owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_set_approval_for_all)

- [`_set_base_uri(self, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_set_base_uri)

- [`_base_uri(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_base_uri)

- [`_is_authorized(self, owner, spender, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_is_authorized)

- [`_check_authorized(self, owner, spender, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_check_authorized)


Events

IERC721

- [`Approval(owner, approved, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Approval)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-ApprovalForAll)

- [`Transfer(from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Transfer)


#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC721Component is expected to provide an implementation of the ERC721HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

|     |     |
| --- | --- |
|  | You can use `openzeppelin_token::erc721::ERC721HooksEmptyImpl` which is already available as part of the library<br>for this purpose. |

#### `before_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` hook

Function executed at the beginning of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-update) function prior to any other logic.

#### `after_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` hook

Function executed at the end of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-update) function.

#### Embeddable functions

#### `balance_of(self: @ContractState, account: ContractAddress) → u256` external

See [IERC721::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of).

#### `owner_of(self: @ContractState, token_id: u256) → ContractAddress` external

See [IERC721::owner\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-owner_of).

Requirements:

- `token_id` exists.


#### `safe_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` external

See [IERC721::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from).

Requirements:

- Caller is either approved or the `token_id` owner.

- `to` is not the zero address.

- `from` is not the zero address.

- `token_id` exists.

- `to` is either an account contract or supports the [IERC721Receiver](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver) interface.


#### `transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)` external

See [IERC721::transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-transfer_from).

Requirements:

- Caller either approved or the `token_id` owner.

- `to` is not the zero address.

- `from` is not the zero address.

- `token_id` exists.


#### `approve(ref self: ContractState, to: ContractAddress, token_id: u256)` external

See [IERC721::approve](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-approve).

Requirements:

- The caller is either an approved operator or the `token_id` owner.

- `to` cannot be the token owner or the zero address.

- `token_id` exists.


#### `set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [IERC721::set\_approval\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-set_approval_for_all).

Requirements:

- `operator` is not the zero address.


#### `get_approved(self: @ContractState, token_id: u256) -> u256` external

See [IERC721::get\_approved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-get_approved).

Requirements:

- `token_id` exists.


#### `is_approved_for_all(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [IERC721::is\_approved\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-is_approved_for_all).

#### `name(self: @ContractState) -> ByteArray` external

See [IERC721Metadata::name](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-name).

#### `symbol(self: @ContractState) -> ByteArray` external

See [IERC721Metadata::symbol](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-symbol).

#### `token_uri(self: @ContractState, token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If a base URI is set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
For example, the base URI `https://token-cdn-domain/` would be returned as `https://token-cdn-domain/123` for token ID `123`.

If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

#### `balanceOf(self: @ContractState, account: ContractAddress) -> u256` external

See [ERC721Component::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-balance_of).

#### `ownerOf(self: @ContractState, tokenId: u256) -> ContractAddress` external

See [ERC721Component::owner\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-owner_of).

#### `safeTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, data: Span<felt252>)` external

See [ERC721Component::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_transfer_from).

#### `transferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256)` external

See [ERC721Component::transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transfer_from).

#### `setApprovalForAll(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [ERC721Component::set\_approval\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-set_approval_for_all).

#### `getApproved(self: @ContractState, tokenId: u256) -> ContractAddress` external

See [ERC721Component::get\_approved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-get_approved).

#### `isApprovedForAll(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [ERC721Component::is\_approved\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-is_approved_for_all).

#### `tokenURI(self: @ContractState, tokenId: u256) -> ByteArray` external

See [ERC721Component::token\_uri](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-token_uri).

#### Internal functions

#### `initializer(ref self: ContractState, name: ByteArray, symbol: ByteArray, base_uri: ByteArray)` internal

Initializes the contract by setting the token name and symbol.
This should be used inside the contract’s constructor.

#### `exists(self: @ContractState, token_id: u256) -> bool` internal

Internal function that returns whether `token_id` exists.

Tokens start existing when they are minted ( [mint](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721-mint)), and stop existing when they are burned ( [burn](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721-burn)).

#### `transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)` internal

Transfers `token_id` from `from` to `to`.

Internal function without access restriction.

|     |     |
| --- | --- |
|  | This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol. |

Requirements:

- `to` is not the zero address.

- `from` is the token owner.

- `token_id` exists.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `mint(ref self: ContractState, to: ContractAddress, token_id: u256)` internal

Mints `token_id` and transfers it to `to`.
Internal function without access restriction.

|     |     |
| --- | --- |
|  | This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol. |

Requirements:

- `to` is not the zero address.

- `token_id` does not exist.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `safe_transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` internal

Transfers ownership of `token_id` from `from` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

|     |     |
| --- | --- |
|  | This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities. |

Requirements:

- `to` cannot be the zero address.

- `from` must be the token owner.

- `token_id` exists.

- `to` is either an account contract or supports the `IERC721Receiver` interface.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `safe_mint(ref self: ContractState, to: ContractAddress, token_id: u256, data: Span<felt252>)` internal

Mints `token_id` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

|     |     |
| --- | --- |
|  | This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities. |

Requirements:

- `token_id` does not exist.

- `to` is either an account contract or supports the `IERC721Receiver` interface.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `burn(ref self: ContractState, token_id: u256)` internal

Destroys `token_id`. The approval is cleared when the token is burned.

This internal function does not check if the caller is authorized
to operate on the token.

Requirements:

- `token_id` exists.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` internal

Transfers `token_id` from its current owner to `to`, or alternatively mints (or burns) if the current owner
(or `to`) is the zero address. Returns the owner of the `token_id` before the update.

The `auth` argument is optional. If the value passed is non-zero, then this function will check that
`auth` is either the owner of the token, or approved to operate on the token (by the owner).

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

|     |     |
| --- | --- |
|  | This function can be extended using the `ERC721HooksTrait`, to add<br>functionality before and/or after the transfer, mint, or burn. |

#### `_owner_of(self: @ContractState, token_id: felt252) -> ContractAddress` internal

Internal function that returns the owner address of `token_id`.

#### `_require_owned(self: @ContractState, token_id: felt252) -> ContractAddress` internal

Version of [\_owner\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_owner_of) that panics if owner is the zero address.

#### `_approve(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` internal

Approve `to` to operate on `token_id`

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is
either the owner of the token, or approved to operate on all tokens held by this owner.

Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `_approve_with_optional_event(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress, emit_event: bool)` internal

Variant of [\_approve](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_approve) with an optional flag to enable or disable the `Approval` event.
The event is not emitted in the context of transfers.

|     |     |
| --- | --- |
|  | If `auth` is zero and `emit_event` is false, this function will not check that the token exists. |

Requirements:

- if `auth` is non-zero, it must be either the owner of the token or approved to
operate on all of its tokens.


May emit an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `_set_approval_for_all(ref self: ContractState, owner: ContractAddress, operator: ContractAddress, approved: bool)` internal

Enables or disables approval for `operator` to manage
all of the `owner` assets.

Requirements:

- `operator` is not the zero address.


Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `_set_base_uri(ref self: ContractState, base_uri: ByteArray)` internal

Internal function that sets the `base_uri`.

#### `_base_uri(self: @ContractState) -> ByteArray` internal

Base URI for computing [token\_uri](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-token_uri).

If set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
Returns an empty `ByteArray` if not set.

#### `_is_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool` internal

Returns whether `spender` is allowed to manage `owner`'s tokens, or `token_id` in
particular (ignoring whether it is owned by `owner`).

|     |     |
| --- | --- |
|  | This function assumes that `owner` is the actual owner of `token_id` and does not verify this<br>assumption. |

#### `_check_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool` internal

Checks if `spender` can operate on `token_id`, assuming the provided `owner` is the actual owner.

Requirements:

- `owner` cannot be the zero address.

- `spender` cannot be the zero address.

- `spender` must be the owner of `token_id` or be approved to operate on it.


|     |     |
| --- | --- |
|  | This function assumes that `owner` is the actual owner of `token_id` and does not verify this<br>assumption. |

#### Events

#### `Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)` event

See [IERC721::Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval).

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

See [IERC721::ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-ApprovalForAll).

#### `Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)` event

See [IERC721::Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer).

## Receiver

### `IERC721Receiver`

```cairo hljs
use openzeppelin_token::erc721::interface::IERC721Receiver;
```

Interface for contracts that support receiving `safe_transfer_from` transfers.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x3a0dff5f70d80458ad14ae37bb182a728e3c8cdda0402a5daa86620bdf910bc

Functions

- [`on_erc721_received(operator, from, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver-on_erc721_received)


#### Functions

#### `on_erc721_received(operator: ContractAddress, from: ContractAddress, token_id: u256, data: Span<felt252>) -> felt252` external

Whenever an IERC721 `token_id` token is transferred to this non-account contract via [IERC721::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from) by `operator` from `from`, this function is called.

### `ERC721ReceiverComponent`

```cairo hljs
use openzeppelin_token::erc721::ERC721ReceiverComponent;
```

ERC721Receiver component implementing [IERC721Receiver](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERCReceiverMixinImpl

- [`ERC721ReceiverImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl)

- [`ERC721ReceiverCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

ERC721ReceiverImpl

- [`on_erc721_received(self, operator, from, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-on_erc721_received)


ERC721ReceiverCamelImpl

- [`onERC721Received(self, operator, from, tokenId, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-onERC721Received)


Internal Functions

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-initializer)


#### Embeddable functions

#### `on_erc721_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252` external

Returns the `IERC721Receiver` interface ID.

#### `onERC721Received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252` external

See [ERC721ReceiverComponent::on\_erc721\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-on_erc721_received).

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Registers the `IERC721Receiver` interface ID as supported through introspection.

## Extensions

### `IERC721Enumerable`

Interface for the optional enumerable functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x16bc0f502eeaf65ce0b3acb5eea656e2f26979ce6750e8502a82f377e538c87

Functions

- [`total_supply()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-total_supply)

- [`token_by_index(index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_by_index)

- [`token_of_owner_by_index(owner, index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_of_owner_by_index)


#### Functions

#### `total_supply() -> u256` external

Returns the total amount of tokens stored by the contract.

#### `token_by_index(index: u256) -> u256` external

Returns a token id at a given `index` of all the tokens stored by the contract.
Use along with [IERC721Enumerable::total\_supply](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-total_supply) to enumerate all tokens.

#### `token_of_owner_by_index(owner: ContractAddress, index: u256) -> u256` external

Returns the token id owned by `owner` at a given `index` of its token list.
Use along with [IERC721::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of) to enumerate all of `owner`'s tokens.

### `ERC721EnumerableComponent`

```cairo hljs
use openzeppelin_token::erc721::extensions::ERC721EnumerableComponent;
```

Extension of ERC721 as defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account.
This extension allows contracts to publish their entire list of NFTs and make them discoverable.

|     |     |
| --- | --- |
|  | Implementing [ERC721Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component) is a requirement for this component to be implemented. |

To properly track token ids, this extension requires that the [ERC721EnumerableComponent::before\_update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-before_update) function is called before every transfer, mint, or burn operation.
For this, the [ERC721HooksTrait::before\_update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-before_update) hook must be used.
Here’s how the hook should be implemented in a contract:

```[ hljs language-cairo\
#[starknet::contract]\
mod ERC721EnumerableContract {\
    (...)\
\
    component!(path: ERC721Component, storage: erc721, event: ERC721Event);\
    component!(path: ERC721EnumerableComponent, storage: erc721_enumerable, event: ERC721EnumerableEvent);\
    component!(path: SRC5Component, storage: src5, event: SRC5Event);\
\
    impl ERC721HooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {\
        fn before_update(\
            ref self: ERC721Component::ComponentState<ContractState>,\
            to: ContractAddress,\
            token_id: u256,\
            auth: ContractAddress\
        ) {\
            let mut contract_state = self.get_contract_mut();\
            contract_state.erc721_enumerable.before_update(to, token_id);\
        }\
    }\
}\
```\
\
Embeddable Implementations\
\
ERC721EnumerableImpl\
\
- [`total_supply(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-total_supply)\
\
- [`token_by_index(self, index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-token_by_index)\
\
- [`token_of_owner_by_index(self, address, index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-token_of_owner_by_index)\
\
\
Internal functions\
\
InternalImpl\
\
- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-initializer)\
\
- [`before_update(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-before_update)\
\
- [`all_tokens_of_owner(self, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-all_tokens_of_owner)\
\
- [`_add_token_to_owner_enumeration(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_add_token_to_owner_enumeration)\
\
- [`_add_token_to_all_tokens_enumeration(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration)\
\
- [`_remove_token_from_owner_enumeration(self, from, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_remove_token_from_owner_enumeration)\
\
- [`_remove_token_from_all_tokens_enumeration(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration)\
\
\
#### Embeddable functions\
\
#### `total_supply(self: @ContractState) → u256` external\
\
Returns the current amount of votes that `account` has.\
\
#### `token_by_index(self: @ContractState, index: u256) → u256` external\
\
See [IERC721Enumerable::token\_by\_index](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_by_index).\
\
Requirements:\
\
- `index` is less than the total token supply.\
\
\
#### `token_of_owner_by_index(self: @ContractState, owner: ContractAddress, index: u256) → u256` external\
\
See [IERC721Enumerable::token\_of\_owner\_by\_index](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_of_owner_by_index).\
\
Requirements:\
\
- `index` is less than `owner`'s token balance.\
\
- `owner` is not the zero address.\
\
\
#### Internal functions\
\
#### `initializer(ref self: ContractState)` internal\
\
Registers the `IERC721Enumerable` interface ID as supported through introspection.\
\
#### `before_update(ref self: ContractState, to: ContractAddress, token_id: u256)` internal\
\
Updates the ownership and token-tracking data structures.\
\
When a token is minted (or burned), `token_id` is added to (or removed from) the token-tracking structures.\
\
When a token is transferred, minted, or burned, the ownership-tracking data structures reflect the change in ownership of `token_id`.\
\
This must be added to the implementing contract’s [ERC721HooksTrait::before\_update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-before_update) hook.\
\
#### `all_tokens_of_owner(self: @ContractState, owner: ContractAddress) → Span<u256>` internal\
\
Returns a list of all token ids owned by the specified `owner`.\
This function provides a more efficient alternative to calling `ERC721::balance_of`\
and iterating through tokens with `ERC721Enumerable::token_of_owner_by_index`.\
\
Requirements:\
\
- `owner` is not the zero address.\
\
\
#### `_add_token_to_owner_enumeration(ref self: ContractState, to: ContractAddress, token_id: u256)` internal\
\
Adds token to this extension’s ownership-tracking data structures.\
\
#### `_add_token_to_all_tokens_enumeration(ref self: ContractState, token_id: u256)` internal\
\
Adds token to this extension’s token-tracking data structures.\
\
#### `_remove_token_from_owner_enumeration(ref self: ContractState, from: ContractAddress, token_id: u256)` internal\
\
Removes a token from this extension’s ownership-tracking data structures.\
\
This has 0(1) time complexity but alters the indexed order of owned tokens by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.\
\
#### `_remove_token_from_all_tokens_enumeration(ref self: ContractState, token_id: u256)` internal\
\
Removes `token_id` from this extension’s token-tracking data structures.\
\
This has 0(1) time complexity but alters the indexed order by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.\
\
## Presets\
\
### `ERC721Upgradeable`\
\
```cairo hljs\
use openzeppelin_presets::ERC721Upgradeable;\
```\
\
Upgradeable ERC721 contract leveraging [ERC721Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component).\
\
[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)\
\
0x015922a7436b4ee45120d5f6442bcfd8dd407fa2283dfa2276ccb9db10a9deda\
\
Constructor\
\
- [`constructor(self, name, symbol, recipient, token_ids, base_uri, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Upgradeable-constructor)\
\
\
Embedded Implementations\
\
ERC721MixinImpl\
\
- [`ERC721MixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Mixin-Impl)\
\
\
OwnableMixinImpl\
\
- [`OwnableMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Mixin-Impl)\
\
\
External Functions\
\
- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Upgradeable-upgrade)\
\
\
#### Constructor\
\
#### `constructor(ref self: ContractState, name: ByteArray, symbol: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, base_uri: ByteArray, owner: ContractAddress)` constructor\
\
Sets the `name` and `symbol`.\
Mints `token_ids` tokens to `recipient` and sets the `base_uri`.\
Assigns `owner` as the contract owner with permissions to upgrade.\
\
#### External functions\
\
#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` external\
\
Upgrades the contract to a new implementation given by `new_class_hash`.\
\
Requirements:\
\
- The caller is the contract owner.\
\
- `new_class_hash` cannot be zero.\
\
\
[← ERC721](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc721)\
\
[ERC1155 →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc1155)Publishing an Ethereum Package - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Publishing an Ethereum Package

In [Using Dependencies](https://docs.openzeppelin.com/cli/2.8/dependencies), we showed how to use the [`oz link`](https://docs.openzeppelin.com/cli/2.8/commands#link) command to use the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) as a dependency, taking advantage of its contracts being _already deployed on the blockchain_.

In this guide we’ll describe how you can create your own Ethereum Package, and make it available to everyone via the OpenZeppelin CLI.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with using public networks, upgradeable contracts, and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying to a Public Test Network](https://docs.openzeppelin.com/learn/connecting-to-public-test-networks) and [Upgrades](https://docs.openzeppelin.com/learn/upgrading-smart-contracts). |

## Storing Your Project On-chain

So far, we’ve mostly limited ourselves to depoying contracts using [`oz deploy`](https://docs.openzeppelin.com/cli/2.8/commands#create), which creates _upgradeable instances_ by deploying _proxies_ to an existing implementation contract (refer to [How Upgrades Work](https://docs.openzeppelin.com/learn/upgrading-smart-contracts#how-upgrades-work) to brush up on this). Here, we will instead deploy just the implementations, so that other people can create new proxies pointing to them.

To achieve this, we’ll use two low-level CLI commands: [`oz add`](https://docs.openzeppelin.com/cli/2.8/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.8/commands#push). These work simmilarly to `git add` and `git push`: they will register contracts in your project and deploy them to a network.

In your [OpenZeppelin project](https://docs.openzeppelin.com/cli/2.8/getting-started#setting-up-your-project), run:

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add <contract-1>, <contract-2>
✓ Added contract <contract-1>
✓ Added contract <contract-2>
All the selected contracts have been added to the project
$ npx oz push
? Pick a network mainnet
✓ Contract <contract-1> deployed
✓ Contract <contract-2> deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | For your Ethereum Pacakge to be used by others, it needs to be deployed on a real network instead of a local one. Take a look at [Deploying to a Public Test Network](https://docs.openzeppelin.com/learn/connecting-to-public-test-networks) for detailed instructions for this process. |

Ethereum Packages are upgradeable, which means they track the different implementation contracts that correspond to each version of the package. We’ll use the [`oz publish`](https://docs.openzeppelin.com/cli/2.8/commands#publish) command for this, which will deploy an [`App`](https://docs.openzeppelin.com/cli/2.8/contracts-architecture#app.sol) contract and register the implementations there:

```console hljs language-shell
$ npx oz publish
? Pick a network mainnet
✓ Project structure deployed
✓ Registering <contract-1> at 0x2c2eB5B599C2C4Bb2cA7e43179585aFec0D97D51 in directory
✓ Registering <contract-2> at 0x6389e6409Ad106aF5e7e6bE8D95Fca637980fB63 in directory
✓ Published to mainnet!
```

The Ethereum Package is complete! But we’re still lacking something: a convenient way to tell people about its existence.

## Distributing With `npm`

For your Ethereum Package to [usable from other projects](https://docs.openzeppelin.com/cli/2.8/dependencies), it needs to be published on the [npm registry](https://www.npmjs.com/). If you havent’t published an npm package before, go ahead and [sign up for a free npm account](https://www.npmjs.com/signup).

First, add your contract sources, compiled artifacts and OpenZeppelin project files to your package by including the following entries in your project’s `package.json`:

```diff hljs
 // package.json
 {
   ...,
   "files": [\
+    "build",\
+    "contracts",\
+    ".openzeppelin/*.json"\
   ]
 }
```

|     |     |
| --- | --- |
|  | The files in your `.openzeppelin` directory that [should not be tracked in version control](https://docs.openzeppelin.com/cli/2.8/configuration#configuration-files-in-version-control) are not required to be part of your published npm package: remove them before publishing to the registry. |

Almost done! Log into npm and upload your package with:

```console hljs language-shell
$ npm login
$ npm publish
```

Success! The Ethereum Package is now live on the blockchain, and accessible to everyone via the npm registry.

Any OpenZeppelin project can now [link](https://docs.openzeppelin.com/cli/2.8/commands#link) to your package:

```console hljs language-shell
$ npx oz link <your-project-name>
```

|     |     |
| --- | --- |
|  | Your Ethereum Package’s name is the same one you provided [during initialization](https://docs.openzeppelin.com/cli/2.8/getting-started#setting-up-your-project). |Command Line Interface (CLI) - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Command Line Interface (CLI)

**Develop, deploy and operate upgradeable smart contract projects**. Support for Ethereum and every other EVM-powered blockchain.

- **Interactive commands**: Send transactions, query balances, and interact with your contracts directly from the command line, using commands like `oz send-tx`, `oz call`, `oz balance`, and `oz transfer`.

- **Deploy & upgrade your contracts**: You can develop your smart contracts iteratively, speeding up development locally, or squashing bugs in production. Run `oz create` to deploy your contracts, followed by `oz upgrade` any time you want to change their code.

- **Link Ethereum Packages**: Use code from contracts already deployed to the blockchain directly on your project, saving gas on deployments and managing your dependencies securely, just with an `oz link` command.

- **Bootstrap your dapp**: Jumpstart your dapp by unpacking one of our starter kits, pre-configured with OpenZeppelin Contracts, React, and Infura. Run `oz unpack` to start!


## Overview

### Installation

```console hljs language-shell
$ npm install @openzeppelin/cli
```

### Usage

All CLI commands are fully interactive: you can call them with no or incomplete arguments and they will prompt you for options as they proceed.

Below is a short list of the most used commands:

- [`oz init`](https://docs.openzeppelin.com/cli/2.7/commands#init): initialize your OpenZeppelin project

- [`oz compile`](https://docs.openzeppelin.com/cli/2.7/commands#compile): compile all Solidity smart contracts in your project

- [`oz create`](https://docs.openzeppelin.com/cli/2.7/commands#create): deploy an upgradeable smart contract

- [`oz send-tx`](https://docs.openzeppelin.com/cli/2.7/commands#send): send a transaction to a contract and execute a function

- [`oz call`](https://docs.openzeppelin.com/cli/2.7/commands#call): read data from the blockchain by calling `view` and `pure` functions

- [`oz upgrade`](https://docs.openzeppelin.com/cli/2.7/commands#upgrade): upgrade a deployed contract to a new version without changing the address or state

- [`oz unpack`](https://docs.openzeppelin.com/cli/2.7/commands#unpack): bootstrap a project with a [Starter Kit](https://docs.openzeppelin.com/starter-kits/)

- [`oz link`](https://docs.openzeppelin.com/cli/2.7/commands#link): reuse on-chain code by to a [linking to Ethereum Packages](https://docs.openzeppelin.com/cli/2.7/dependencies)


## Learn More

- Head to [Getting Started](https://docs.openzeppelin.com/cli/2.7/getting-started) to see the CLI in action by deploying and upgrading a smart contract!

- [Using Dependencies](https://docs.openzeppelin.com/cli/2.7/dependencies) showcases a more complex project being built, including leveraging the [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/) library.

- If you are a Truffle user, go to [Using With Truffle](https://docs.openzeppelin.com/cli/2.7/truffle) for information on using both tools on the same project.

- Take a look at the API reference for all [CLI commands](https://docs.openzeppelin.com/cli/2.7/commands).

- For an overview of the internals of the CLI, you can read on the [Contracts Architecture](https://docs.openzeppelin.com/cli/2.7/contracts-architecture) and different [Configuration Files](https://docs.openzeppelin.com/cli/2.7/configuration).


|     |     |
| --- | --- |
|  | Looking for the documentation for version 2.4 or earlier? You can find it [here](https://docs.zeppelinos.org/versions). |

[Getting Started →](https://docs.openzeppelin.com/cli/2.7/getting-started)Access Control - OpenZeppelin Docs

# Access Control

This crate provides ways to restrict who can access the functions of a contract or when they can do it.

- [Ownable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent) is a simple mechanism with a single "owner" role that can be assigned to a single account.
This mechanism can be useful in simple scenarios, but fine grained access needs are likely to outgrow it.

- [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) provides a general role based access control mechanism. Multiple hierarchical roles can be created and
assigned each to multiple accounts.


## Authorization

### `OwnableComponent`

```cairo hljs
use openzeppelin_access::ownable::OwnableComponent;
```

`Ownable` provides a basic access control mechanism where an account
(an owner) can be granted exclusive access to specific functions.

This module includes the internal `assert_only_owner` to restrict a function to be used only by the owner.

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

OwnableMixinImpl

- [`OwnableImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableImpl)

- [`OwnableCamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableCamelOnlyImpl)


OwnableTwoStepMixinImpl

- [`OwnableTwoStepImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableTwoStepImpl)

- [`OwnableTwoStepCamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableTwoStepCamelOnlyImpl)


Embeddable Implementations

OwnableImpl

- [`owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-owner)

- [`transfer_ownership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-transfer_ownership)

- [`renounce_ownership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-renounce_ownership)


OwnableTwoStepImpl

- [`owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-owner)

- [`pending_owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-pending_owner)

- [`accept_ownership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-accept_ownership)

- [`transfer_ownership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-transfer_ownership)

- [`renounce_ownership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-renounce_ownership)


OwnableCamelOnlyImpl

- [`transferOwnership(self, newOwner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-transferOwnership)

- [`renounceOwnership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-renounceOwnership)


OwnableTwoStepCamelOnlyImpl

- [`pendingOwner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-pendingOwner)

- [`acceptOwnership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-acceptOwnership)

- [`transferOwnership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-transferOwnership)

- [`renounceOwnership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-renounceOwnership)


Internal Implementations

InternalImpl

- [`initializer(self, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-initializer)

- [`assert_only_owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-assert_only_owner)

- [`_transfer_ownership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-_transfer_ownership)

- [`_propose_owner(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-_propose_owner)


Events

- [`OwnershipTransferStarted(previous_owner, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferStarted)

- [`OwnershipTransferred(previous_owner, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred)


#### Embeddable functions

#### `owner(self: @ContractState) → ContractAddress` external

Returns the address of the current owner.

#### `transfer_ownership(ref self: ContractState, new_owner: ContractAddress)` external

Transfers ownership of the contract to a new account ( `new_owner`).
Can only be called by the current owner.

Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `renounce_ownership(ref self: ContractState)` external

Leaves the contract without owner. It will not be possible to call
`assert_only_owner` functions anymore. Can only be called by the current owner.

|     |     |
| --- | --- |
|  | Renouncing ownership will leave the contract without an owner,<br>thereby removing any functionality that is only available to the owner. |

#### Embeddable functions (two step transfer)

#### `owner(self: @ContractState) → ContractAddress` external

Returns the address of the current owner.

#### `pending_owner(self: @ContractState) → ContractAddress` external

Returns the address of the pending owner.

#### `accept_ownership(ref self: ContractState)` external

Transfers ownership of the contract to the pending owner.
Can only be called by the pending owner.
Resets pending owner to zero address.

Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `transfer_ownership(ref self: ContractState, new_owner: ContractAddress)` external

Starts the two step ownership transfer process, by setting the pending owner. Setting `new_owner` to the zero address is allowed, this can be used to cancel an initiated ownership transfer.

Can only be called by the current owner.

Emits an [OwnershipTransferStarted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferStarted) event.

#### `renounce_ownership(ref self: ContractState)` external

Leaves the contract without owner. It will not be possible to call
`assert_only_owner` functions anymore. Can only be called by the current owner.

|     |     |
| --- | --- |
|  | Renouncing ownership will leave the contract without an owner,<br>thereby removing any functionality that is only available to the owner. |

#### `transferOwnership(ref self: ContractState, newOwner: ContractAddress)` external

See [transfer\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-transfer_ownership).

#### `renounceOwnership(ref self: ContractState)` external

See [renounce\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-renounce_ownership).

#### `pendingOwner(self: @ContractState)` external

See [pending\_owner](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-pending_owner).

#### `acceptOwnership(self: @ContractState)` external

See [accept\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-accept_ownership).

#### `transferOwnership(self: @ContractState)` external

See [transfer\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-transfer_ownership).

#### `renounceOwnership(self: @ContractState)` external

See [renounce\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-renounce_ownership).

#### Internal functions

#### `initializer(ref self: ContractState, owner: ContractAddress)` internal

Initializes the contract and sets `owner` as the initial owner.

Requirements:

- `owner` cannot be the zero address.


Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `assert_only_owner(self: @ContractState)` internal

Panics if called by any account other than the owner.

#### `_transfer_ownership(ref self: ContractState, new_owner: ContractAddress)` internal

Transfers ownership of the contract to a new account ( `new_owner`).
Internal function without access restriction.

Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `_propose_owner(ref self: ContractState, new_owner: ContractAddress)` internal

Sets a new pending owner in a two step transfer.

Internal function without access restriction.

Emits an [OwnershipTransferStarted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferStarted) event.

#### Events

#### `OwnershipTransferStarted(previous_owner: ContractAddress, new_owner: ContractAddress)` event

Emitted when the pending owner is updated.

#### `OwnershipTransferred(previous_owner: ContractAddress, new_owner: ContractAddress)` event

Emitted when the ownership is transferred.

### `IAccessControl`

```cairo hljs
use openzeppelin_access::accesscontrol::interface::IAccessControl;
```

External interface of AccessControl.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x23700be02858dbe2ac4dc9c9f66d0b6b0ed81ec7f970ca6844500a56ff61751

Functions

- [`has_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-has_role)

- [`get_role_admin(role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-get_role_admin)

- [`grant_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role)

- [`revoke_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role)

- [`renounce_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-renounce_role)


Events

- [`RoleAdminChanged(role, previous_admin_role, new_admin_role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged)

- [`RoleGranted(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted)

- [`RoleRevoked(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked)


#### Functions

#### `has_role(role: felt252, account: ContractAddress) → bool` external

Returns `true` if `account` has been granted `role`.

#### `get_role_admin(role: felt252) → felt252` external

Returns the admin role that controls `role`. See [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role) and
[revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role).

To change a role’s admin, use [set\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin).

#### `grant_role(role: felt252, account: ContractAddress)` external

Grants `role` to `account`.

If `account` had not been already granted `role`, emits a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted)
event.

Requirements:

- the caller must have `role`'s admin role.


#### `revoke_role(role: felt252, account: ContractAddress)` external

Revokes `role` from `account`.

If `account` had been granted `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

Requirements:

- the caller must have `role`'s admin role.


#### `renounce_role(role: felt252, account: ContractAddress)` external

Revokes `role` from the calling account.

Roles are often managed via [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role) and [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role). This function’s
purpose is to provide a mechanism for accounts to lose their privileges
if they are compromised (such as when a trusted device is misplaced).

If the calling account had been granted `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked)
event.

Requirements:

- the caller must be `account`.


#### Events

#### `RoleAdminChanged(role: felt252, previous_admin_role: ContractAddress, new_admin_role: ContractAddress)` event

Emitted when `new_admin_role` is set as `role`'s admin role, replacing `previous_admin_role`

`DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
[RoleAdminChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged) not being emitted signaling this.

#### `RoleGranted(role: felt252, account: ContractAddress, sender: ContractAddress)` event

Emitted when `account` is granted `role`.

`sender` is the account that originated the contract call, an admin role
bearer.

#### `RoleRevoked(role: felt252, account: ContractAddress, sender: ContractAddress)` event

Emitted when `account` is revoked `role`.

`sender` is the account that originated the contract call:

- if using `revoke_role`, it is the admin role bearer.

- if using `renounce_role`, it is the role bearer (i.e. `account`).


### `AccessControlComponent`

```cairo hljs
use openzeppelin_access::accesscontrol::AccessControlComponent;
```

Component that allows contracts to implement role-based access control mechanisms.
Roles are referred to by their `felt252` identifier:

```cairo hljs
const MY_ROLE: felt252 = selector!("MY_ROLE");
```

Roles can be used to represent a set of permissions. To restrict access to a
function call, use [`assert_only_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role):

```cairo hljs
(...)

#[external(v0)]
fn foo(ref self: ContractState) {
    self.accesscontrol.assert_only_role(MY_ROLE);

    // Do something
}
```

Roles can be granted and revoked dynamically via the [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and
[revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role) functions. Each role has an associated admin role, and only
accounts that have a role’s admin role can call [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role).

By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
that only accounts with this role will be able to grant or revoke other
roles. More complex role relationships can be created by using
[set\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin).

|     |     |
| --- | --- |
|  | The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to<br>grant and revoke this role. Extra precautions should be taken to secure<br>accounts that have been granted it. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

AccessControlMixinImpl

- [`AccessControlImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls-AccessControlImpl)

- [`AccessControlCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls-AccessControlCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

AccessControlImpl

- [`has_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-has_role)

- [`get_role_admin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-get_role_admin)

- [`grant_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role)

- [`revoke_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role)

- [`renounce_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-renounce_role)


AccessControlCamelImpl

- [`hasRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-hasRole)

- [`getRoleAdmin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-getRoleAdmin)

- [`grantRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grantRole)

- [`revokeRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revokeRole)

- [`renounceRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-renounceRole)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


Internal Implementations

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-initializer)

- [`assert_only_role(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role)

- [`set_role_admin(self, role, admin_role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin)

- [`_grant_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-_grant_role)

- [`_revoke_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-_revoke_role)


Events

IAccessControl

- [`RoleAdminChanged(role, previous_admin_role, new_admin_role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-RoleAdminChanged)

- [`RoleGranted(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-RoleGranted)

- [`RoleRevoked(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-RoleRevoked)


#### Embeddable functions

#### `has_role(self: @ContractState, role: felt252, account: ContractAddress) → bool` external

Returns `true` if `account` has been granted `role`.

#### `get_role_admin(self: @ContractState, role: felt252) → felt252` external

Returns the admin role that controls `role`. See [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and
[revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role).

To change a role’s admin, use [set\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin).

#### `grant_role(ref self: ContractState, role: felt252, account: ContractAddress)` external

Grants `role` to `account`.

If `account` had not been already granted `role`, emits a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted)
event.

Requirements:

- the caller must have `role`'s admin role.


May emit a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event.

#### `revoke_role(ref self: ContractState, role: felt252, account: ContractAddress)` external

Revokes `role` from `account`.

If `account` had been granted `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

Requirements:

- the caller must have `role`'s admin role.


May emit a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

#### `renounce_role(ref self: ContractState, role: felt252, account: ContractAddress)` external

Revokes `role` from the calling account.

Roles are often managed via [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role). This function’s
purpose is to provide a mechanism for accounts to lose their privileges
if they are compromised (such as when a trusted device is misplaced).

If the calling account had been revoked `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked)
event.

Requirements:

- the caller must be `account`.


May emit a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

#### `supports_interface(self: @ContractState, interface_id: felt252) → bool` external

See [ISRC5::supports\_interface](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface).

#### `hasRole(self: @ContractState, role: felt252, account: ContractAddress) → bool` external

See [has\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-has_role).

#### `getRoleAdmin(self: @ContractState, role: felt252) → felt252` external

See [get\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-get_role_admin).

#### `grantRole(ref self: ContractState, role: felt252, account: ContractAddress)` external

See [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role).

#### `revokeRole(ref self: ContractState, role: felt252, account: ContractAddress)` external

See [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role).

#### `renounceRole(ref self: ContractState, role: felt252, account: ContractAddress)` external

See [renounce\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-renounce_role).

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Initializes the contract by registering the [IAccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl) interface ID.

#### `assert_only_role(self: @ContractState, role: felt252)` internal

Panics if called by any account without the given `role`.

#### `set_role_admin(ref self: ContractState, role: felt252, admin_role: felt252)` internal

Sets `admin_role` as `role`'s admin role.

Internal function without access restriction.

Emits a [RoleAdminChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged) event.

#### `_grant_role(ref self: ContractState, role: felt252, account: ContractAddress)` internal

Grants `role` to `account`.

Internal function without access restriction.

May emit a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event.

#### `_revoke_role(ref self: ContractState, role: felt252, account: ContractAddress)` internal

Revokes `role` from `account`.

Internal function without access restriction.

May emit a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

#### Events

#### `RoleAdminChanged(role: felt252, previous_admin_role: ContractAddress, new_admin_role: ContractAddress)` event

See [IAccessControl::RoleAdminChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged).

#### `RoleGranted(role: felt252, account: ContractAddress, sender: ContractAddress)` event

See [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted).

#### `RoleRevoked(role: felt252, account: ContractAddress, sender: ContractAddress)` event

See [IAccessControl::RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked).

[← Access](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access)

[Accounts →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/accounts)OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


## openzeppelin\|oz

Usage: `openzeppelin|oz <command> [options]`

where <command> is one of: accounts, add, balance, bump, call, check, compile, create, create2, deploy, freeze, init, link, publish, push, remove, send-tx, session, set-admin, transfer, unlink, unpack, upgrade, verify

`--version`

output the version number

`-v, --verbose`

verbose mode on: output errors stacktrace and detailed log.

`-s, --silent`

silent mode: no output sent to stderr.

## accounts

Usage: `accounts [options]`

list the accounts of the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## add

Usage: `add [contractName1[:contractAlias1] …​ contractNameN[:contractAliasN]] [options]`

add contract to your project. Provide a list of whitespace-separated contract names

`--all`

add all contracts in your build directory

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## balance

Usage: `balance --network <network> [options]`

query the balance of the specified account

`--erc20 <contractAddress>`

query the balance of an ERC20 token instead of ETH

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## bump

Usage: `bump <version> [options]`

bump your project to a new <version>

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## call

Usage: `call --to <to> --method <method> [options]`

call a method of the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the call

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## check

Usage: `check [contract] [options]`

checks your contracts for potential issues

`--skip-compile`

skips contract compilation

## compile

Usage: `compile [options]`

compiles all contracts in the current project

`--solc-version [version]`

version of the solc compiler to use (value is written to configuration file for future runs, defaults to most recent release that satisfies contract pragmas)

`--optimizer [on|off]`

enables compiler optimizer (value is written to configuration file for future runs, defaults to off)

`--optimizer-runs [runs]`

specify number of runs if optimizer enabled (value is written to configuration file for future runs, defaults to 200)

`--evm-version [evm]`

choose target evm version (value is written to configuration file for future runs, defaults depends on compiler: byzantium prior to 0.5.5, petersburg from 0.5.5)

`--typechain [web3-v1|truffle|ethers]`

enables typechain generation of typescript wrappers for contracts using the chosen target

`--typechain-outdir [path]`

path where typechain artifacts are written (defaults to ./types/contracts/)

`--no-interactive`

force to run the command in non-interactive mode

## create

Usage: `create [alias] --network <network> [options]`

deploys a new upgradeable contract instance. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package.

`--init [function]`

call function after creating contract. If none is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--force`

ignore contracts validation errors

`--minimal`

creates a cheaper but non-upgradeable instance instead, using a minimal proxy

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## create2

Usage: `create2 [alias] --network <network> --salt <salt> [options]`

deploys a new upgradeable contract instance using CREATE2 at a predetermined address given a numeric <salt> and a <from> address. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package. A <signature> can be provided to derive the deployment address from a signer different to the <from> address. Warning: support for this feature is experimental.

`--salt <salt>`

salt used to determine the deployment address (required)

`--query [sender]`

do not create the contract and just return the deployment address, optionally specifying the sender used to derive the deployment address (defaults to 'from')

`--init [function]`

initialization function to call after creating contract (defaults to 'initialize', skips initialization if not set)

`--args <arg1, arg2, …​>`

arguments to the initialization function

`--admin <admin>`

admin of the proxy (uses the project’s proxy admin if not set)

`--signature <signature>`

signature of the request, uses the signer to derive the deployment address (uses the sender to derive deployment address if not set)

`--force`

force creation even if contracts have local modifications

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## deploy

Usage: `deploy [options] [contract] [arguments…​]`

deploy a contract instance

`--skip-compile`

use existing compilation artifacts

`-k, --kind <kind>`

the kind of deployment (regular, upgradeable, minimal)

`-n, --network <network>`

network to use

`--timeout <timeout>`

timeout in seconds for each transaction (default: 750)

`-f, --from <address>`

sender for the contract creation transaction

`--migrate-manifest`

enable automatic migration of manifest format

`--no-interactive`

disable interactive prompts

## freeze

Usage: `freeze --network <network> [options]`

freeze current release version of your published project

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## init

Usage: `init <project-name> [version]`

initialize your OpenZeppelin project. Provide a <project-name> and optionally an initial \[version\] name

`--publish`

automatically publish your project upon pushing it to a network

`--force`

overwrite existing project if there is one

`--typechain <target>`

enable typechain support with specified target (web3-v1, ethers, or truffle)

`--typechain-outdir <path>`

set output directory for typechain compilation (defaults to types/contracts)

`--link <dependency>`

link to a dependency

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## link

Usage: `link [dependencyName1 …​ dependencyNameN] [options]`

links project with a list of dependencies each located in its npm package

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## publish

Usage: `publish --network <network> [options]`

publishes your project to the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## push

Usage: `push --network <network> [options]`

deploys your project to the specified <network>

`--skip-compile`

skips contract compilation

`-d, --deploy-dependencies`

deploys dependencies to the network if there is no existing deployment

`--reset`

redeploys all contracts (not only the ones that changed)

`--force`

ignores validation errors and deploys contracts

`--deploy-proxy-admin`

eagerly deploys the project’s proxy admin (if not deployed yet on the provided network)

`--deploy-proxy-factory`

eagerly deploys the project’s proxy factory (if not deployed yet on the provided network)

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## remove

Usage: `remove [contract1 …​ contractN] [options]`

removes one or more contracts from your project. Provide a list of whitespace-separated contract names.

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## send-tx

Usage: `send-tx --to <to> --method <method> [options]`

send a transaction to the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the transaction

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`--value <value>`

optional value in wei to send with the transaction

`--gas <gas>`

gas limit of the transaction, will default to the limit specified in the configuration file, or use gas estimation if not set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## session

Usage: `session [options]`

by providing network options, commands like create, freeze, push, and update will use them unless overridden. Use --close to undo.

`--expires <expires>`

expiration of the session in seconds (defaults to 900, 15 minutes)

`--close`

closes the current session, removing all network options set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## set-admin

Usage: `set-admin [alias-or-address] [new-admin-address] --network <network> [options]`

change upgradeability admin of a contract instance, all instances or proxy admin. Provide the \[alias\] or \[package\]/\[alias\] of the contract to change the ownership of all its instances, or its \[address\] to change a single one, or none to change all contract instances to a new admin. Note that if you transfer to an incorrect address, you may irreversibly lose control over upgrading your contract.

`--force`

bypass a manual check

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## transfer

Usage: `transfer --network <network> [options]`

send funds to a given address

`--to <to>`

specify recipient address

`--value <value>`

the amount of ether units to be transferred

`--unit <unit>`

unit name. Wei, kwei, gwei, milli and ether are supported among others. If none is given, 'ether' will be used.

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## unlink

Usage: `unlink [dependencyName1…​ dependencyNameN]`

unlinks dependencies from the project. Provide a list of whitespace-separated dependency names

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## unpack

Usage: `unpack [kit]`

download and install an OpenZeppelin Starter Kit to the current directory

`--no-interactive`

force to run the command in non-interactive mode

## upgrade

Usage: `upgrade [alias-or-address] --network <network> [options]`

upgrade contract to a new logic. Provide the \[alias\] or \[package\]/\[alias\] you added your contract with, its \[address\], or use --all flag to upgrade all contracts in your project.

`--init [function]`

call function after upgrading contract. If no name is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--all`

upgrade all contracts in the application

`--force`

ignore contracts validation errors

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## verify

Usage: `verify [options] [contract]`

verify a contract’s source with Etherscan or Etherchain

`-n, --network <network>`

network to verify contracts in

`-o, --optimizer <enabled>`

whether compilation optimizations were enabled

`--optimizer-runs <runs>`

the number of runs for the optimizer

`--remote <remote>`

the remote endpoint to use for verification (etherscan, etherchain)

`--api-key <key>`

Etherscan API key (get one at [https://etherscan.io/myapikey](https://etherscan.io/myapikey))

`--no-interactive`

disable interactive prompts

[← Upgrades Library](https://docs.openzeppelin.com/upgrades/2.8/)

[Configuration Files →](https://docs.openzeppelin.com/cli/2.8/configuration)Getting Started - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Getting Started

This tutorial will showcase usage of the OpenZeppelin CLI, giving you a taste of its capabilities and serving as a starting point for your own projects.

We will cover:
\\* Create a new OpenZeppelin project with a smart contract
\\* Deploying our contract to a local development network
\\* Interacting with our contract from the terminal
\\* Upgrading the deployed contract to a new version

## Prerequisites

The CLI is installed as a dependency to your Node project:

```console hljs language-shell
$ npm install @openzeppelin/cli
```

|     |     |
| --- | --- |
|  | If you’re unfamiliar with Node and npm, head to our guide on [Setting Up a Development Environment](https://docs.openzeppelin.com/cli/2.6/getting-started#learn::set-up-dev-environment). |

We are installing the CLI [locally](https://docs.npmjs.com/downloading-and-installing-packages-locally) instead of [globally](https://docs.npmjs.com/downloading-and-installing-packages-globally), which means usage of the CLI will be prefixed with `npx`. This will avoid issues that arise from having global dependencies, and will let you have different versions of the CLI in each of your projects, if you so desire.

## Setting up Your Project

Inside your Node project, use the CLI to initialize an OpenZeppelin project:

```console hljs language-shell
$ npx openzeppelin init
```

The CLI will prompt you for a project name and version, defaulting to the ones from the `package.json`, and then set up a few files and directories for running your OpenZeppelin project.

|     |     |
| --- | --- |
|  | If you’d rather type less, you can use the `oz` command alias, so `openzeppelin init` becomes just `oz init`. We’ll use this throughout the tutorial. |

We are now ready to begin working on our project.

|     |     |
| --- | --- |
|  | Should you get lost at any point during this tutorial, you can refer to the full code for this project in our [`Github repo`](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.4.0/examples/first-project). |

## Your First Contract

We will write a simple contract in [Solidity](https://solidity.readthedocs.io/), the most popular language for Ethereum smart contracts. Create a new file `contracts/Counter.sol` in your project with the following content:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
    uint256 public value;

    function increase() public {
      value++;
    }
}
```

This contract stores a numeric `value` that is increased by one every time we send a transaction to the `increase()` function.

You can run `oz compile` to compile the contract and check for any errors. Once that’s done, we’ll be ready to deploy it.

|     |     |
| --- | --- |
|  | You don’t have to worry if you forget to compile your contract. The CLI will automatically check if your contract changed when you run any command, and compile it if needed. |

## Deploying to a Development Network

We will use [Ganache](https://truffleframework.com/ganache) as a _development network_ to deploy our contract. If you don’t have Ganache installed, do so now by running `npm install ganache-cli`.

Development networks are mini blockchains that run just on your computer, and are much faster than the actual Ethereum network. We will use one for coding and testing.

|     |     |
| --- | --- |
|  | Head to [Setting up a Local Blockchain](https://docs.openzeppelin.com/cli/2.6/getting-started#learn::deploy-and-interact.adoc#local-blockchain) to learn more about using Ganache. |

Open a separate terminal and start a new Ganache process:

```console hljs language-shell
$ npx ganache-cli --deterministic
```

This will start a new development network using a deterministic set of accounts, instead of random ones. We can now deploy our contract there, running `oz create`, and choosing to deploy the `Counter` contract to the `development` network.

```console hljs language-shell
$ npx oz create
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
? Pick a contract to instantiate: Counter
? Pick a network: development
✓ Added contract Counter
✓ Contract Counter deployed
? Call a function to initialize the instance after creating it?: No
✓ Setting everything up to create contract instances
✓ Instance created at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
```

|     |     |
| --- | --- |
|  | The addresses where your contracts are created and the transaction identifiers you see may differ from the ones listed here. |

Our `Counter` contract is deployed to the local development network and ready to go! We can test it out by interacting with it from the terminal. Let’s try incrementing the counter, by sending a transaction to call the `increase` function through `oz send-tx`.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase()
✓ Transaction successful. Transaction hash: 0x20bef6583ea32cc57fe179e34dd57a5494db3c403e441624e56a886898cb52bd
```

We can now use `oz call` to query the contract’s public `value`, and check that it was indeed increased from zero to one.

```console hljs language-shell
$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
✓ Method 'value()' returned: 1
```

## Upgrading Your Contract

We will now modify our `Counter` contract to make the `increase` function more interesting. Instead of increasing the counter by one, we will allow the caller to increase the counter by any value. Let’s modify the code in `contracts/Counter.sol` to the following:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
  uint256 public value;

  function increase(uint256 amount) public {
    value += amount;
  }
}
```

We can now upgrade the instance we created earlier to this new version:

```console hljs language-shell
$ npx oz upgrade
? Pick a network: development
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
✓ Contract Counter deployed
? Which proxies would you like to upgrade?: All proxies
Instance upgraded at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601.
```

Done! Our `Counter` instance has been upgraded to the latest version, and **neither its address nor its state have changed**. Let’s check it out by increasing the counter by ten, which should yield eleven, since we had already increased it by one:

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase(amount: uint256)
? amount (uint256): 10
Transaction successful: 0x9c84faf32a87a33f517b424518712f1dc5ba0bdac4eae3a67ca80a393c555ece

$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
Returned "11"
```

|     |     |
| --- | --- |
|  | That smart contracts are immutable, so you may be wondering how the OpenZeppelin CLI achieved this feat. To learn about this, head to the docomentation for [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/), in particular the guide about [Proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies).<br>You will note that there are some changes that are not supported during upgrades. For instance, you cannot [remove or change the type of a contract state variable](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts). Nevertheless, you can change, add, or remove all the functions you want. |

That’s it! You now know how to start a simple OpenZeppelin project, create a contract, deploy it to a local network, and even upgrade it as you develop. Head over to the next tutorial to learn how to interact with your contract from your code.

[← Overview](https://docs.openzeppelin.com/cli/2.6/)

[Using Dependencies →](https://docs.openzeppelin.com/cli/2.6/dependencies)Security - OpenZeppelin Docs

# Security

The following documentation provides context, reasoning, and examples of modules found under `openzeppelin_security`.

|     |     |
| --- | --- |
|  | Expect these modules to evolve. |

## Initializable

The [Initializable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#InitializableComponent) component provides a simple mechanism that mimics
the functionality of a constructor.
More specifically, it enables logic to be performed once and only once which is useful to set up a contract’s initial state when a constructor cannot be used, for example when there are circular dependencies at construction time.

### Usage

You can use the component in your contracts like this:

```cairo hljs
#[starknet::contract]
mod MyInitializableContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    impl InternalImpl = InitializableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage,
        param: felt252
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }

    fn initializer(ref self: ContractState, some_param: felt252) {
        // Makes the method callable only once
        self.initializable.initialize();

        // Initialization logic
        self.param.write(some_param);
    }
}
```

|     |     |
| --- | --- |
|  | This Initializable pattern should only be used in one function. |

### Interface

The component provides the following external functions as part of the `InitializableImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait InitializableABI {
    fn is_initialized() -> bool;
}
```

## Pausable

The [Pausable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent) component allows contracts to implement an emergency stop mechanism.
This can be useful for scenarios such as preventing trades until the end of an evaluation period or having an emergency switch to freeze all transactions in the event of a large bug.

To become pausable, the contract should include `pause` and `unpause` functions (which should be protected).
For methods that should be available only when paused or not, insert calls to `assert_paused` and `assert_not_paused`
respectively.

### Usage

For example (using the [Ownable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent) component for access control):

```cairo hljs
#[starknet::contract]
mod MyPausableContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_security::PausableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // Pausable
    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        pausable: PausableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        PausableEvent: PausableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[external(v0)]
    fn pause(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.pausable.pause();
    }

    #[external(v0)]
    fn unpause(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.pausable.unpause();
    }

    #[external(v0)]
    fn when_not_paused(ref self: ContractState) {
        self.pausable.assert_not_paused();
        // Do something
    }

    #[external(v0)]
    fn when_paused(ref self: ContractState) {
        self.pausable.assert_paused();
        // Do something
    }
}
```

### Interface

The component provides the following external functions as part of the `PausableImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait PausableABI {
    fn is_paused() -> bool;
}
```

## Reentrancy Guard

A [reentrancy attack](https://gus-tavo-guim.medium.com/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4) occurs when the caller is able to obtain more resources than allowed by recursively calling a target’s function.

### Usage

Since Cairo does not support modifiers like Solidity, the [ReentrancyGuard](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#ReentrancyGuardComponent)
component exposes two methods `start` and `end` to protect functions against reentrancy attacks.
The protected function must call `start` before the first function statement, and `end` before the return statement, as shown below:

```cairo hljs
#[starknet::contract]
mod MyReentrancyContract {
    use openzeppelin_security::ReentrancyGuardComponent;

    component!(
        path: ReentrancyGuardComponent, storage: reentrancy_guard, event: ReentrancyGuardEvent
    );

    impl InternalImpl = ReentrancyGuardComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        reentrancy_guard: ReentrancyGuardComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ReentrancyGuardEvent: ReentrancyGuardComponent::Event
    }

    #[external(v0)]
    fn protected_function(ref self: ContractState) {
        self.reentrancy_guard.start();

        // Do something

        self.reentrancy_guard.end();
    }

    #[external(v0)]
    fn another_protected_function(ref self: ContractState) {
        self.reentrancy_guard.start();

        // Do something

        self.reentrancy_guard.end();
    }
}
```

|     |     |
| --- | --- |
|  | The guard prevents the execution flow occurring inside `protected_function`<br>to call itself or `another_protected_function`, and vice versa. |

[← Merkle Tree](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security)ERC1155 - OpenZeppelin Docs

# ERC1155

The ERC1155 multi token standard is a specification for [fungibility-agnostic](https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens) token contracts.
The ERC1155 library implements an approximation of [EIP-1155](https://eips.ethereum.org/EIPS/eip-1155) in Cairo for StarkNet.

## Multi Token Standard

The distinctive feature of ERC1155 is that it uses a single smart contract to represent multiple tokens at once. This
is why its [balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of) function differs from ERC20’s and ERC777’s: it has an additional ID argument for the
identifier of the token that you want to query the balance of.

This is similar to how ERC721 does things, but in that standard a token ID has no concept of balance: each token is
non-fungible and exists or doesn’t. The ERC721 [balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of) function refers to how many different tokens an account
has, not how many of each. On the other hand, in ERC1155 accounts have a distinct balance for each token ID, and
non-fungible tokens are implemented by simply minting a single one of them.

This approach leads to massive gas savings for projects that require multiple tokens. Instead of deploying a new
contract for each token type, a single ERC1155 token contract can hold the entire system state, reducing deployment
costs and complexity.

## Usage

Using Contracts for Cairo, constructing an ERC1155 contract requires integrating both `ERC1155Component` and `SRC5Component`.
The contract should also set up the constructor to initialize the token’s URI and interface support.
Here’s an example of a basic contract:

```cairo hljs
#[starknet::contract]
mod MyERC1155 {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc1155::{ERC1155Component, ERC1155HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC1155Component, storage: erc1155, event: ERC1155Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC1155 Mixin
    #[abi(embed_v0)]
    impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;
    impl ERC1155InternalImpl = ERC1155Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc1155: ERC1155Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC1155Event: ERC1155Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        token_uri: ByteArray,
        recipient: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>
    ) {
        self.erc1155.initializer(token_uri);
        self
            .erc1155
            .batch_mint_with_acceptance_check(recipient, token_ids, values, array![].span());
    }
}
```

## Interface

The following interface represents the full ABI of the Contracts for Cairo [ERC1155Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component).
The interface includes the [IERC1155](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155) standard interface and the optional [IERC1155MetadataURI](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155MetadataURI) interface together with [ISRC5](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5).

To support older token deployments, as mentioned in [Dual interfaces](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces#dual_interfaces), the component also includes implementations of the interface written in camelCase.

```cairo hljs
#[starknet::interface]
pub trait ERC1155ABI {
    // IERC1155
    fn balance_of(account: ContractAddress, token_id: u256) -> u256;
    fn balance_of_batch(
        accounts: Span<ContractAddress>, token_ids: Span<u256>
    ) -> Span<u256>;
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        value: u256,
        data: Span<felt252>
    );
    fn safe_batch_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    );
    fn is_approved_for_all(
        owner: ContractAddress, operator: ContractAddress
    ) -> bool;
    fn set_approval_for_all(operator: ContractAddress, approved: bool);

    // IERC1155MetadataURI
    fn uri(token_id: u256) -> ByteArray;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IERC1155Camel
    fn balanceOf(account: ContractAddress, tokenId: u256) -> u256;
    fn balanceOfBatch(
        accounts: Span<ContractAddress>, tokenIds: Span<u256>
    ) -> Span<u256>;
    fn safeTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenId: u256,
        value: u256,
        data: Span<felt252>
    );
    fn safeBatchTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenIds: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    );
    fn isApprovedForAll(owner: ContractAddress, operator: ContractAddress) -> bool;
    fn setApprovalForAll(operator: ContractAddress, approved: bool);
}
```

## ERC1155 Compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC1155 standard but some differences can still be found, such as:

- The optional `data` argument in both `safe_transfer_from` and `safe_batch_transfer_from` is implemented as `Span<felt252>`.

- `IERC1155Receiver` compliant contracts must implement SRC5 and register the `IERC1155Receiver` interface ID.

- `IERC1155Receiver::on_erc1155_received` must return that interface ID on success.


## Batch operations

Because all state is held in a single contract, it is possible to operate over multiple tokens in a single transaction very efficiently. The standard provides two functions, [balance\_of\_batch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of_batch) and [safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from), that make querying multiple balances and transferring multiple tokens simpler and less gas-intensive. We also have [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) for non-batch operations.

In the spirit of the standard, we’ve also included batch operations in the non-standard functions, such as
[batch\_mint\_with\_acceptance\_check](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-batch_mint_with_acceptance_check).

|     |     |
| --- | --- |
|  | While [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) and [safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from) prevent loss by checking the receiver can handle the<br>tokens, this yields execution to the receiver which can result in a [reentrant call](https://docs.openzeppelin.com/contracts-cairo/0.20.0/security#reentrancy_guard). |

## Receiving tokens

In order to be sure a non-account contract can safely accept ERC1155 tokens, said contract must implement the `IERC1155Receiver` interface.
The recipient contract must also implement the [SRC5](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#src5) interface which supports interface introspection.

### IERC1155Receiver

```cairo hljs
#[starknet::interface]
pub trait IERC1155Receiver {
    fn on_erc1155_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        value: u256,
        data: Span<felt252>
    ) -> felt252;
    fn on_erc1155_batch_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    ) -> felt252;
}
```

Implementing the `IERC1155Receiver` interface exposes the [on\_erc1155\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_received) and [on\_erc1155\_batch\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_batch_received) methods.
When [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) and [safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from) are called, they invoke the recipient contract’s `on_erc1155_received` or `on_erc1155_batch_received` methods respectively which **must** return the [IERC1155Receiver interface ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver).
Otherwise, the transaction will fail.

|     |     |
| --- | --- |
|  | For information on how to calculate interface IDs, see [Computing the interface ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#computing_the_interface_id). |

### Creating a token receiver contract

The Contracts for Cairo [ERC1155ReceiverComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent) already returns the correct interface ID for safe token transfers.
To integrate the `IERC1155Receiver` interface into a contract, simply include the ABI embed directive to the implementations and add the `initializer` in the contract’s constructor.
Here’s an example of a simple token receiver contract:

```cairo hljs
#[starknet::contract]
mod MyTokenReceiver {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc1155::ERC1155ReceiverComponent;
    use starknet::ContractAddress;

    component!(path: ERC1155ReceiverComponent, storage: erc1155_receiver, event: ERC1155ReceiverEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC1155Receiver Mixin
    #[abi(embed_v0)]
    impl ERC1155ReceiverMixinImpl = ERC1155ReceiverComponent::ERC1155ReceiverMixinImpl<ContractState>;
    impl ERC1155ReceiverInternalImpl = ERC1155ReceiverComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc1155_receiver: ERC1155ReceiverComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC1155ReceiverEvent: ERC1155ReceiverComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc1155_receiver.initializer();
    }
}
```

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155)ERC1155 - OpenZeppelin Docs

# ERC1155

This module provides interfaces, presets, and utilities related to ERC1155 contracts.

|     |     |
| --- | --- |
|  | For an overview of ERC1155, read our [ERC1155 guide](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc1155). |

## Core

### `IERC1155`

```cairo hljs
use openzeppelin_token::erc1155::interface::IERC1155;
```

Interface of the IERC1155 standard as defined in [EIP1155](https://eips.ethereum.org/EIPS/eip-1155).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x6114a8f75559e1b39fcba08ce02961a1aa082d9256a158dd3e64964e4b1b52

Functions

- [`balance_of(account, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of)

- [`balance_of_batch(accounts, token_ids)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of_batch)

- [`safe_transfer_from(from, to, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from)

- [`safe_batch_transfer_from(from, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from)

- [`set_approval_for_all(operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-set_approval_for_all)

- [`is_approved_for_all(owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-is_approved_for_all)


Events

- [`TransferSingle(operator, from, to, id, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferSingle)

- [`TransferBatch(operator, from, to, ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferBatch)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-ApprovalForAll)

- [`URI(value, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-URI)


#### Functions

#### `balance_of(account: ContractAddress, token_id: u256) → u256` external

Returns the amount of `token_id` tokens owned by `account`.

#### `balance_of_batch(accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>` external

Returns a list of balances derived from the `accounts` and `token_ids` pairs.

#### `safe_transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256,  value: u256, data: Span<felt252>)` external

Transfers ownership of `value` amount of `token_id` from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferSingle) event.

#### `safe_batch_transfer_from(from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` external

Transfers ownership of `token_ids` and `values` pairs from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferBatch) event.

#### `set_approval_for_all(operator: ContractAddress, approved: bool)` external

Enables or disables approval for `operator` to manage all of the caller’s assets.

Emits an [ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-ApprovalForAll) event.

#### `is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool` external

Queries if `operator` is an authorized operator for `owner`.

#### Events

#### `TransferSingle(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)` event

Emitted when `value` amount of `id` token is transferred from `from` to `to` through `operator`.

#### `TransferBatch(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)` event

Emitted when a batch of `values` amount of `ids` tokens are transferred from `from` to `to` through `operator`.

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

Emitted when `owner` enables or disables `operator` to manage all of the owner’s assets.

#### `URI(value: ByteArray, id: u256)` event

Emitted when the token URI is updated to `value` for the `id` token.

### `IERC1155MetadataURI`

```cairo hljs
use openzeppelin_token::erc1155::interface::IERC1155MetadataURI;
```

Interface for the optional metadata function in [EIP1155](https://eips.ethereum.org/EIPS/eip-1155#metadata).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0xcabe2400d5fe509e1735ba9bad205ba5f3ca6e062da406f72f113feb889ef7

Functions

- [`uri(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155MetadataURI-uri)


#### Functions

#### `uri(token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token.

### `ERC1155Component`

```cairo hljs
use openzeppelin_token::erc1155::ERC1155Component;
```

ERC1155 component implementing [IERC1155](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155) and [IERC1155MetadataURI](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155MetadataURI).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

|     |     |
| --- | --- |
|  | See [Hooks](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Hooks) to understand how are hooks used. |

Hooks

ERC1155HooksTrait

- [`before_update(self, from, to, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-before_update)

- [`after_update(self, from, to, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-after_update)


[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERC1155MixinImpl

- [`ERC1155Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Impls-ERC1155Impl)

- [`ERC1155MetadataURIImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Impls-ERC1155MetadataURIImpl)

- [`ER1155CamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Impls-ER1155CamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls-SRC5Impl)


Embeddable Implementations

ERC1155Impl

- [`balance_of(self, account, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of)

- [`balance_of_batch(self, accounts, token_ids)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of_batch)

- [`safe_transfer_from(self, from, to, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_transfer_from)

- [`safe_batch_transfer_from(self, from, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_batch_transfer_from)

- [`set_approval_for_all(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-set_approval_for_all)

- [`is_approved_for_all(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-is_approved_for_all)


ERC1155MetadataURIImpl

- [`uri(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-uri)


ER1155CamelImpl

- [`balanceOf(self, account, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balanceOf)

- [`balanceOfBatch(self, accounts, tokenIds)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balanceOfBatch)

- [`safeTransferFrom(self, from, to, tokenId, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safeTransferFrom)

- [`safeBatchTransferFrom(self, from, to, tokenIds, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safeBatchTransferFrom)

- [`setApprovalForAll(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-setApprovalForAll)

- [`isApprovedForAll(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-isApprovedForAll)


Internal Functions

InternalImpl

- [`initializer(self, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-initializer)

- [`mint_with_acceptance_check(self, to, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-mint_with_acceptance_check)

- [`batch_mint_with_acceptance_check(self, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-batch_mint_with_acceptance_check)

- [`burn(self, from, token_id, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-burn)

- [`batch_burn(self, from, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-batch_burn)

- [`update_with_acceptance_check(self, from, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update_with_acceptance_check)

- [`update(self, from, to, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update)

- [`_set_base_uri(self, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-_set_base_uri)


Events

IERC1155

- [`TransferSingle(operator, from, to, id, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle)

- [`TransferBatch(operator, from, to, ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-ApprovalForAll)

- [`URI(value, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-URI)


#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC1155Component is expected to provide an implementation of the ERC1155HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

|     |     |
| --- | --- |
|  | You can use `openzeppelin_token::erc1155::ERC1155HooksEmptyImpl` which is already available as part of the library<br>for this purpose. |

#### `before_update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` hook

Function executed at the beginning of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update) function prior to any other logic.

#### `after_update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` hook

Function executed at the end of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update) function.

#### Embeddable functions

#### `balance_of(self: @ContractState, account: ContractAddress, token_id: u256) → u256` external

Returns the amount of `token_id` tokens owned by `account`.

#### `balance_of_batch(self: @ContractState, accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>` external

Returns a list of balances derived from the `accounts` and `token_ids` pairs.

Requirements:

- `token_ids` and `accounts` must have the same length.


#### `safe_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256,  value: u256, data: Span<felt252>)` external

Transfers ownership of `value` amount of `token_id` from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

|     |     |
| --- | --- |
|  | This function can potentially allow a reentrancy attack when transferring tokens<br>to an untrusted contract, when invoking `on_ERC1155_received` on the receiver.<br>Ensure to follow the checks-effects-interactions pattern and consider employing<br>reentrancy guards when interacting with untrusted contracts. |

Requirements:

- Caller is either approved or the `token_id` owner.

- `from` is not the zero address.

- `to` is not the zero address.

- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_received`
and return the required magic value.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event.

#### `safe_batch_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` external

Transfers ownership of `values` and `token_ids` pairs from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

|     |     |
| --- | --- |
|  | This function can potentially allow a reentrancy attack when transferring tokens<br>to an untrusted contract, when invoking `on_ERC1155_batch_received` on the receiver.<br>Ensure to follow the checks-effects-interactions pattern and consider employing<br>reentrancy guards when interacting with untrusted contracts. |

Requirements:

- Caller is either approved or the `token_id` owner.

- `from` is not the zero address.

- `to` is not the zero address.

- `token_ids` and `values` must have the same length.

- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received`
and return the acceptance magic value.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event if the arrays contain one element,
and [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) otherwise.

#### `set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool)` external

Enables or disables approval for `operator` to manage all of the callers assets.

Requirements:

- `operator` cannot be the caller.


Emits an [ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-ApprovalForAll) event.

#### `is_approved_for_all(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

Queries if `operator` is an authorized operator for `owner`.

#### `uri(self: @ContractState, token_id: u256) -> ByteArray` external

This implementation returns the same URI for **all** token types. It relies
on the token type ID substitution mechanism
[specified in the EIP](https://eips.ethereum.org/EIPS/eip-1155#metadata).

Clients calling this function must replace the `{id}` substring with the
actual token type ID.

#### `balanceOf(self: @ContractState, account: ContractAddress, tokenId: u256) → u256` external

See [ERC1155Component::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of).

#### `balanceOfBatch(self: @ContractState, accounts: Span<ContractAddress>, tokenIds: Span<u256>) → Span<u256>` external

See [ERC1155Component::balance\_of\_batch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of_batch).

#### `safeTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256,  value: u256, data: Span<felt252>)` external

See [ERC1155Component::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_transfer_from).

#### `safeBatchTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data: Span<felt252>)` external

See [ERC1155Component::safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_batch_transfer_from).

#### `setApprovalForAll(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [ERC1155Component::set\_approval\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-set_approval_for_all).

#### `isApprovedForAll(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [ERC1155Component::is\_approved\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-is_approved_for_all).

#### Internal functions

#### `initializer(ref self: ContractState, base_uri: ByteArray)` internal

Initializes the contract by setting the token’s base URI as `base_uri`, and registering the supported interfaces.
This should only be used inside the contract’s constructor.

#### `mint_with_acceptance_check(ref self: ContractState, to: ContractAddress, token_id: u256, value: u256, data: Span<felt252>)` internal

Creates a `value` amount of tokens of type `token_id`, and assigns them to `to`.

Requirements:

- `to` cannot be the zero address.

- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_received`
and return the acceptance magic value.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event.

#### `batch_mint_with_acceptance_check(ref self: ContractState, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` internal

Batched version of [mint\_with\_acceptance\_check](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-mint_with_acceptance_check).

Requirements:

- `to` cannot be the zero address.

- `token_ids` and `values` must have the same length.

- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received`
and return the acceptance magic value.


Emits a [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) event.

#### `burn(ref self: ContractState, from: ContractAddress, token_id: u256, value: u256)` internal

Destroys a `value` amount of tokens of type `token_id` from `from`.

Requirements:

- `from` cannot be the zero address.

- `from` must have at least `value` amount of tokens of type `token_id`.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event.

#### `batch_burn(ref self: ContractState, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` internal

Batched version of [burn](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-burn).

Requirements:

- `from` cannot be the zero address.

- `from` must have at least `value` amount of tokens of type `token_id`.

- `token_ids` and `values` must have the same length.


Emits a [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) event.

#### `update_with_acceptance_check(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` internal

Version of `update` that performs the token acceptance check by calling
`onERC1155Received` or `onERC1155BatchReceived` in the receiver if
it implements `IERC1155Receiver`, otherwise by checking if it is an account.

Requirements:

- `to` is either an account contract or supports the `IERC1155Receiver` interface.

- `token_ids` and `values` must have the same length.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event if the arrays contain one element,
and [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) otherwise.

#### `update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` internal

Transfers a `value` amount of tokens of type `id` from `from` to `to`.
Will mint (or burn) if `from` (or `to`) is the zero address.

Requirements:

- `token_ids` and `values` must have the same length.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event if the arrays contain one element,
and [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) otherwise.

|     |     |
| --- | --- |
|  | This function can be extended using the [ERC1155HooksTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-ERC1155HooksTrait), to add<br>functionality before and/or after the transfer, mint, or burn. |

|     |     |
| --- | --- |
|  | The ERC1155 acceptance check is not performed in this function.<br>See [update\_with\_acceptance\_check](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update_with_acceptance_check) instead. |

#### `_set_base_uri(ref self: ContractState, base_uri: ByteArray)` internal

Sets a new URI for all token types, by relying on the token type ID
substitution mechanism
[specified in the EIP](https://eips.ethereum.org/EIPS/eip-1155#metadata).

By this mechanism, any occurrence of the `{id}` substring in either the
URI or any of the values in the JSON file at said URI will be replaced by
clients with the token type ID.

For example, the `https://token-cdn-domain/\{id\}.json` URI would be
interpreted by clients as
`https://token-cdn-domain/000000000000...000000000000004cce0.json`
for token type ID `0x4cce0`.

Because these URIs cannot be meaningfully represented by the `URI` event,
this function emits no events.

#### Events

#### `TransferSingle(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)` event

See [IERC1155::TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferSingle).

#### `TransferBatch(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)` event

See [IERC1155::TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferBatch).

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

See [IERC1155::ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-ApprovalForAll).

#### `URI(value: ByteArray, id: u256)` event

See [IERC1155::URI](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-URI).

## Receiver

### `IERC1155Receiver`

```cairo hljs
use openzeppelin_token::erc1155::interface::IERC1155Receiver;
```

Interface for contracts that support receiving token transfers from `ERC1155` contracts.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x15e8665b5af20040c3af1670509df02eb916375cdf7d8cbaf7bd553a257515e

Functions

- [`on_erc1155_received(operator, from, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_received)

- [`on_erc1155_batch_received(operator, from, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_batch_received)


#### Functions

#### `on_erc1155_received(operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252` external

This function is called whenever an ERC1155 `token_id` token is transferred to this `IERC1155Receiver` implementer
via [IERC1155::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) by `operator` from `from`.

#### `on_erc1155_batch_received(operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252` external

This function is called whenever multiple ERC1155 `token_ids` tokens are transferred to this `IERC1155Receiver` implementer
via [IERC1155::safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from) by `operator` from `from`.

### `ERC1155ReceiverComponent`

```cairo hljs
use openzeppelin_token::erc1155::ERC1155ReceiverComponent;
```

ERC1155Receiver component implementing [IERC1155Receiver](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERC1155MixinImpl

- [`ERC1155ReceiverImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverImpl)

- [`ERC1155ReceiverCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls-SRC5Impl)


Embeddable Implementations

ERC1155ReceiverImpl

- [`on_erc1155_received(self, operator, from, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_received)

- [`on_erc1155_batch_received(self, operator, from, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_batch_received)


ERC1155ReceiverCamelImpl

- [`onERC1155Received(self, operator, from, tokenId, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-onERC1155Received)

- [`onERC1155BatchReceived(self, operator, from, tokenIds, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-onERC1155BatchReceived)


Internal Functions

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-initializer)


#### Embeddable functions

#### `on_erc1155_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252` external

Returns the `IERC1155Receiver` interface ID.

#### `on_erc1155_batch_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252` external

Returns the `IERC1155Receiver` interface ID.

#### `onERC1155Received(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenId: u256, value: u256, data Span<felt252>) -> felt252` external

See [ERC1155ReceiverComponent::on\_erc1155\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_received).

#### `onERC1155BatchReceived(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252` external

See [ERC1155ReceiverComponent::on\_erc1155\_batch\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_batch_received).

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Registers the `IERC1155Receiver` interface ID as supported through introspection.

## Presets

### `ERC1155Upgradeable`

```cairo hljs
use openzeppelin_presets::ERC1155;
```

Upgradeable ERC1155 contract leveraging [ERC1155Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component).

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x046ec13b3dc855cddbaad504c5d3526f34134541f04207c7cfa7b6919f5fd2be

Constructor

- [`constructor(self, base_uri, recipient, token_ids, values, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Upgradeable-constructor)


Embedded Implementations

ERC1155Component

- [`ERC1155MixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Mixin-Impl)


OwnableMixinImpl

- [`OwnableMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Mixin-Impl)


External Functions

- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Upgradeable-upgrade)


#### Constructor

#### `constructor(ref self: ContractState, base_uri: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, values: Span<u256>, owner: ContractAddress)` constructor

Sets the `base_uri` for all tokens and registers the supported interfaces.
Mints the `values` for `token_ids` tokens to `recipient`.
Assigns `owner` as the contract owner with permissions to upgrade.

Requirements:

- `to` is either an account contract (supporting ISRC6) or
supports the `IERC1155Receiver` interface.

- `token_ids` and `values` must have the same length.


#### External Functions

#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` external

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.

- `new_class_hash` cannot be zero.


[← ERC1155](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc1155)

[Common →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common)Finance - OpenZeppelin Docs

# Finance

This crate includes primitives for financial systems.

## Vesting

### `IVesting`

```cairo hljs
use openzeppelin_finance::vesting::interface::IVesting;
```

Common interface for contracts implementing the vesting functionality.

Functions

- [`start()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-start)

- [`cliff()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-cliff)

- [`duration()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-duration)

- [`end()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-end)

- [`released(token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-released)

- [`releasable(token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-releasable)

- [`vested_amount(token, timestamp)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-vested_amount)

- [`release(token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-release)


Events

- [`AmountReleased(token, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-AmountReleased)


#### Functions

#### `start() → u64` external

Returns the timestamp marking the beginning of the vesting period.

#### `cliff() → u64` external

Returns the timestamp marking the end of the cliff period.

#### `duration() → u64` external

Returns the total duration of the vesting period.

#### `end() → u64` external

Returns the timestamp marking the end of the vesting period.

#### `released(token: ContractAddress) → u256` external

Returns the already released amount for a given `token`.

#### `releasable(token: ContractAddress) → u256` external

Returns the amount of a given `token` that can be released at the time of the call.

#### `vested_amount(token: ContractAddress, timestamp: u64) → u256` external

Returns the total vested amount of a specified `token` at a given `timestamp`.

#### `release(token: ContractAddress) → u256` external

Releases the amount of a given `token` that has already vested and returns that amount.

May emit an [AmountReleased](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-AmountReleased) event.

#### Events

#### `AmountReleased(token: ContractAddress, amount: u256)` event

Emitted when vested tokens are released to the beneficiary.

### `VestingComponent`

```cairo hljs
use openzeppelin_finance::vesting::VestingComponent;
```

Vesting component implementing the [`IVesting`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting) interface.

Vesting Schedule Trait Implementations

functions

- [`calculate_vested_amount(self, token, total_allocation,\\
timestamp, start, duration, cliff)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-calculate_vested_amount)


Embeddable Implementations

VestingImpl

- [`start(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-start)

- [`cliff(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-cliff)

- [`duration(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-duration)

- [`end(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-end)

- [`released(self, token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-released)

- [`releasable(self, token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-releasable)

- [`vested_amount(self, token, timestamp)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-vested_amount)

- [`release(self, token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-release)


Internal implementations

InternalImpl

- [`initializer(self, start, duration, cliff_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-initializer)

- [`resolve_vested_amount(self, token, timestamp)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-resolve_vested_amount)


#### VestingSchedule trait

A trait that defines the logic for calculating the vested amount based on a given timestamp.

|     |     |
| --- | --- |
|  | You can read more about the trait’s purpose and how to use it [here](https://docs.openzeppelin.com/contracts-cairo/0.20.0/finance#vesting_schedule). |

#### `calculate_vested_amount(self: @ContractState, token: ContractAddress, total_allocation: u256, timestamp: u64, start: u64, duration: u64, cliff: u64) → u256` internal

Calculates and returns the vested amount at a given `timestamp` based on the core vesting parameters.

#### Functions

#### `start(self: @ContractState) → u64` external

Returns the timestamp marking the beginning of the vesting period.

#### `cliff(self: @ContractState) → u64` external

Returns the timestamp marking the end of the cliff period.

#### `duration(self: @ContractState) → u64` external

Returns the total duration of the vesting period.

#### `end(self: @ContractState) → u64` external

Returns the timestamp marking the end of the vesting period.

#### `released(self: @ContractState, token: ContractAddress) → u256` external

Returns the already released amount for a given `token`.

#### `releasable(self: @ContractState, token: ContractAddress) → u256` external

Returns the amount of a given `token` that can be released at the time of the call.

#### `vested_amount(self: @ContractState, token: ContractAddress, timestamp: u64) → u256` external

Returns the total vested amount of a specified `token` at a given `timestamp`.

#### `release(ref self: ContractState, token: ContractAddress) → u256` external

Releases the amount of a given `token` that has already vested and returns that amount.

|     |     |
| --- | --- |
|  | If the releasable amount is zero, this function won’t emit the event<br>or attempt to transfer the tokens. |

Requirements:

- `transfer` call to the `token` must return `true` indicating a successful transfer.


May emit an [AmountReleased](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-AmountReleased) event.

#### Internal functions

#### `initializer(ref self: ContractState, start: u64, duration: u64, cliff_duration: u64)` internal

Initializes the component by setting the vesting `start`, `duration` and `cliff_duration`. To prevent
reinitialization, this should only be used inside of a contract’s constructor.

Requirements:

- `cliff_duration` must be less than or equal to `duration`.


#### `resolve_vested_amount(self: @ContractState, token: ContractAddress, timestamp: u64) → u256` internal

Returns the vested amount that’s calculated using the [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) trait implementation.

### `LinearVestingSchedule`

```cairo hljs
use openzeppelin_finance::vesting::LinearVestingSchedule;
```

Defines the logic for calculating the vested amount, incorporating a cliff period.
It returns 0 before the cliff ends. After the cliff period, the vested amount returned
is directly proportional to the time passed since the start of the vesting schedule.

## Presets

### `VestingWallet`

```cairo hljs
use openzeppelin::presets::VestingWallet;
```

A non-upgradable contract leveraging [VestingComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent) and [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent).

|     |     |
| --- | --- |
|  | The contract is intentionally designed to be non-upgradable to ensure that neither the vesting initiator<br>nor the vesting beneficiary can modify the vesting schedule without the consent of the other party. |

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x0386b4e438105ef2ba52b12dae76e6afef54a234083137d32c57d06693a8c7c7

Constructor

- [`constructor(self, beneficiary, start, duration, cliff_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingWallet-constructor)


Embedded Implementations

VestingComponent

- [`VestingImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Embeddable-Impls-VestingImpl)


OwnableComponent

- [`OwnableMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Mixin-Impl)


#### Constructor

#### `constructor(ref self: ContractState, beneficiary: ContractAddress, start: u64, duration: u64, cliff_duration: u64)` constructor

Initializes the vesting component by setting the vesting `start`, `duration` and `cliff_duration`. Assigns `beneficiary` as the contract owner and the vesting beneficiary.

Requirements:

- `cliff_duration` must be less than or equal to `duration`.


[← Finance](https://docs.openzeppelin.com/contracts-cairo/0.20.0/finance)

[Governor →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/governor)Configuration Files - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Configuration Files

The OpenZeppelin CLI stores your project’s configuration in the `.openzeppelin` directory, inside a number of JSON files. Those are described here.

|     |     |
| --- | --- |
|  | You can skip ahead to see which files you should [track using version control](https://docs.openzeppelin.com/cli/2.8/configuration#configuration-files-in-version-control). |

## `project.json`

This stores the project’s general configuration, and is created by the `oz init` command. It has the following structure:

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": <projectName>,
  "version": <version>,
  "publish": <publishFlag>,
  "contracts": {
    <contract-1-alias>: <contract-1-name>,
    <contract-2-alias>: <contract-2-name>,
    ...
    <contract-N-alias>: <contract-N-name>
  },
  "dependencies": {
    <dependency-1-name>: <dependency-1-version>,
    <dependency-2-name>: <dependency-2-version>,
    ...
    <dependency-N-name>: <dependency-N-version>
  }
}
```

Here, `<projectName>` is the name of the project, and `<version>` is the current semver number. The boolean value `<publish>` indicates whether the project should be automatically published to the network upon being pushed, allowing it to be reused as an Ethereum Package by other projects. The field `manifestVersion` indicates the version of the configuration file.

Once you start adding your contracts via `oz add`, they will be recorded under the `"contracts"` field, with the contract aliases as the keys (which default to the contract names), and the contract names as the values. Finally, if you link a dependency with `oz link`, this will be reflected in the `"dependencies"` field, where `<dependency-name>` is the name of the linked Ethereum Package, and `<dependency-version>` is its semver required version.

## `<network_name>.json`

The OpenZeppelin CLI will also generate a file for each of the networks you work on ( `local`, `ropsten`, `mainnet`, etc). These should be configured in your `networks.js` file, but note that `oz init` already configures a `local` network for `localhost:8545`. These files share the same structure:

```json hljs
// .openzeppelin/<network_name>.json
{
  "manifestVersion": "2.2",
  "version": <app-version>,
  "contracts": {
    <contract-N-name>: {
      "address": <contract-N-address>,
      "constructorCode": <contract-N-constructor>,
      "bodyBytecodeHash": <contract-N-body>,
      "localBytecodeHash": <contract-N-local>,
      "deployedBytecodeHash": <contract-N-deployed>,
      "types": { ... },
      "storage": [ ... ],
      "warnings": { ... }
    },
    ...
  },
  "solidityLibs": {
    ...
  },
  "proxies": {
    <package-name>/<contract-name>: [\
      {\
        "address": <proxy-1-address>,\
        "version": <proxy-1-version>,\
        "implementation": <implementation-1-address>\
      },\
      ...\
    ],
    ...
  },
  "proxyAdmin": {
    "address": <proxyAdmin-address>
  },
  "app": {
    "address": <app-address>
  },
  "package": {
    "address": <package-address>
  },
  "provider": {
    "address": <provider-address>
  },
  "dependencies": {
    <dependency-name>: {
      "package": <dependency-address>,
      "version": <dependency-version>,
      "customDeploy": <dependency-custom-deploy>
    },
    ...
  }
}
```

The most important things to see here are the proxies and contracts' addresses, `<proxy-i-address>` and `<contract-i-address>` respectively. What will happen is that each time you upload new versions of your logic contracts, `<contract-i-address>` will change. The proxy addresses, however, will stay the same, so you can interact seamlessly with the same addresses as if no change has taken place. Note that `<implementation-i-address>` will always point to the current contract address `<contract-i-address>` if the proxies are `update`-ed. Proxies are grouped by the name of the package and contract they are backed by.

For every logic contract, besides the deployment address, the following info is also tracked:

- `constructorCode` is the SHA256 hash of the bytecode used to `CREATE` the logic contract

- `bodyBytecodeHash` is the SHA256 hash of the same bytecode as above, stripped of its constructor

- `localBytecodeHash` is the SHA256 hash of the bytecode, including any Solidity library placeholders

- `deployedBytecodeHash` is the SHA256 hash of the bytecode, with all Solidity library placeholders replaced by their corresponding addresses

- `types` keeps track of all the types used in the contract or its ancestors, from basic types like `uint256` to custom `struct` types

- `storage` tracks the storage layout of the linearized contract, referencing the types defined in the `types` section, and is used for verifying that any storage layout changes between subsequent versions are compatible

- `warnings` tracks any existing warnings for the contract, such as whether it has a constructor or `selfdestruct` operations


Any Solidity libraries used by the project’s contracts are tracked in the `solidityLibs` node, which has the same structure as the `contracts` item.

Another thing to notice in these files are the version numbers. The `<app-version>` keeps track of the latest app version, and matches `<version>` from `project.json`. The `<proxy-i-version>`, on the other hand, keeps track of which version of the contracts the proxies are pointing to. Say you deploy a contract in your app version 1.0.0, and then bump the version to 1.1.0 and push some upgraded code for that same contract. This will be reflected in the `<contract-i-address>`, but not yet in the proxy, which will display 1.0.0 in `<proxy-i-version>` and the old logic contract address in `<implementation-i-address>`. Once you run `oz update` to your contract, `<proxy-i-version>` will show the new 1.1.0 version, and `<implementation-i-address>` will point to the new `<contract-i-address>`. Note that this version identifier will refer to the version of the dependency (and not the app) if the proxy points to a dependent Ethereum Package.

The field `<proxyAdmin>` contains the address of the ProxyAdmin contract, used to manage the [transparent proxy pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes) in the project’s proxies.

Also, notice the fields `<app>`, `<package>`, and `<provider>`. These contain the addresses of contracts the OpenZeppelin CLI uses to facilitate the creation of proxies and the management of different versions of your contracts. These contracts will only be deployed once you `publish` your project to a desired network. That is, your project will not have an `app`, `package`, or `provider` unless explicitly running the `publish` command, or if the project was created with the `--publish` flag. Note that this step is required for projects that produce an Ethereum Package. To read more about the architecture of contracts we are using to publish your project on-chain please refer to the [Contract Architecture](https://docs.openzeppelin.com/cli/2.8/contracts-architecture) section.

Finally, the `dependencies` field stores information about linked Ethereum Packages. For each dependency, the `<dependency-address>` tracks the address of the deployed `package` in the network, and `<dependency-version>` is the exact semver identifier being used for the dependency. The `custom-deploy` field will be present only when a version of the Ethereum Package is deployed using the `--deploy-dependencies` flag of the `push` command, in which case `<custom-deploy>` will be `true`.

The naming of the file will be `<network_name>.json`, but note that `<network_name>` is not taken from the name of the network’s entry in the network file, but is instead inferred from the canonical network id associated to the entry. For example, given the following network configuration:

```json hljs
// networks.js
module.exports = {
  networks: {
     geth_ropsten: {
      host: 'localhost',
      port: 8555,
      network_id: 3
    },
     parity_ropsten: {
      host: 'localhost',
      port: 8565,
      network_id: 3
    },
     local: {
      host: 'localhost',
      port: 8545,
      network_id: *
    }
  }
};
```

Using `oz push --network geth_ropsten` or `oz push --network parity_ropsten` will both produce a file named `ropsten.json` no matter which method was used to connect to the ropsten network. The OpenZeppelin CLI will automatically detect which public network is being referred to (using web3.network.getVersion()) and use this information for determining the file name. When dealing with local networks, the OpenZeppelin CLI will generate files with `dev-<network_id>`, given that these networks are not public and don’t have a canonical name. Using `oz push --network local` will produce a file named `dev-1540303312049.json` (or some other number representing the network id of the local network).

## Configuration Files in Version Control

The `project.json` file should be tracked in version control. This file represents an OpenZeppelin project’s configuration; the contracts and Ethereum Packages that compose it, its name and version, the version of the OpenZeppelin CLI it uses, etc. The file should be identical for all the contributors of a project.

Public network files like `mainnet.json` or `ropsten.json` should also be tracked in version control. These contain valuable information about your project’s status in the corresponding network; the addresses of the contract implementations that have been deployed, the addresses of the proxies that have been deployed, etc. Such files should also be identical for all the contributors of a project.

However, local network files like `dev-<network_id>.json` only represent a project’s deployment in a temporary local network such as `ganache-cli` that are only relevant to a single contributor of the project and should not be tracked in version control.

An example `.gitignore` file could contain the following entries:

```json hljs
// .gitignore
# OpenZeppelin
.openzeppelin/dev-*.json
.openzeppelin/.session
```

[← Commands](https://docs.openzeppelin.com/cli/2.8/commands)

[Contracts Architecture →](https://docs.openzeppelin.com/cli/2.8/contracts-architecture)Configuration Files - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Configuration Files

The OpenZeppelin CLI stores your project’s configuration in the `.openzeppelin` directory, inside a number of JSON files. Those are described here.

|     |     |
| --- | --- |
|  | You can skip ahead to see which files you should [track using version control](https://docs.openzeppelin.com/cli/2.7/configuration#configuration-files-in-version-control). |

## `project.json`

This stores the project’s general configuration, and is created by the `oz init` command. It has the following structure:

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": <projectName>,
  "version": <version>,
  "publish": <publishFlag>,
  "contracts": {
    <contract-1-alias>: <contract-1-name>,
    <contract-2-alias>: <contract-2-name>,
    ...
    <contract-N-alias>: <contract-N-name>
  },
  "dependencies": {
    <dependency-1-name>: <dependency-1-version>,
    <dependency-2-name>: <dependency-2-version>,
    ...
    <dependency-N-name>: <dependency-N-version>
  }
}
```

Here, `<projectName>` is the name of the project, and `<version>` is the current semver number. The boolean value `<publish>` indicates whether the project should be automatically published to the network upon being pushed, allowing it to be reused as an Ethereum Package by other projects. The field `manifestVersion` indicates the version of the configuration file.

Once you start adding your contracts via `oz add`, they will be recorded under the `"contracts"` field, with the contract aliases as the keys (which default to the contract names), and the contract names as the values. Finally, if you link a dependency with `oz link`, this will be reflected in the `"dependencies"` field, where `<dependency-name>` is the name of the linked Ethereum Package, and `<dependency-version>` is its semver required version.

## `<network_name>.json`

The OpenZeppelin CLI will also generate a file for each of the networks you work on ( `local`, `ropsten`, `mainnet`, etc). These should be configured in your `networks.js` file, but note that `oz init` already configures a `local` network for `localhost:8545`. These files share the same structure:

```json hljs
// .openzeppelin/<network_name>.json
{
  "manifestVersion": "2.2",
  "version": <app-version>,
  "contracts": {
    <contract-N-name>: {
      "address": <contract-N-address>,
      "constructorCode": <contract-N-constructor>,
      "bodyBytecodeHash": <contract-N-body>,
      "localBytecodeHash": <contract-N-local>,
      "deployedBytecodeHash": <contract-N-deployed>,
      "types": { ... },
      "storage": [ ... ],
      "warnings": { ... }
    },
    ...
  },
  "solidityLibs": {
    ...
  },
  "proxies": {
    <package-name>/<contract-name>: [\
      {\
        "address": <proxy-1-address>,\
        "version": <proxy-1-version>,\
        "implementation": <implementation-1-address>\
      },\
      ...\
    ],
    ...
  },
  "proxyAdmin": {
    "address": <proxyAdmin-address>
  },
  "app": {
    "address": <app-address>
  },
  "package": {
    "address": <package-address>
  },
  "provider": {
    "address": <provider-address>
  },
  "dependencies": {
    <dependency-name>: {
      "package": <dependency-address>,
      "version": <dependency-version>,
      "customDeploy": <dependency-custom-deploy>
    },
    ...
  }
}
```

The most important things to see here are the proxies and contracts' addresses, `<proxy-i-address>` and `<contract-i-address>` respectively. What will happen is that each time you upload new versions of your logic contracts, `<contract-i-address>` will change. The proxy addresses, however, will stay the same, so you can interact seamlessly with the same addresses as if no change has taken place. Note that `<implementation-i-address>` will always point to the current contract address `<contract-i-address>` if the proxies are `update`-ed. Proxies are grouped by the name of the package and contract they are backed by.

For every logic contract, besides the deployment address, the following info is also tracked:

- `constructorCode` is the SHA256 hash of the bytecode used to `CREATE` the logic contract

- `bodyBytecodeHash` is the SHA256 hash of the same bytecode as above, stripped of its constructor

- `localBytecodeHash` is the SHA256 hash of the bytecode, including any Solidity library placeholders

- `deployedBytecodeHash` is the SHA256 hash of the bytecode, with all Solidity library placeholders replaced by their corresponding addresses

- `types` keeps track of all the types used in the contract or its ancestors, from basic types like `uint256` to custom `struct` types

- `storage` tracks the storage layout of the linearized contract, referencing the types defined in the `types` section, and is used for verifying that any storage layout changes between subsequent versions are compatible

- `warnings` tracks any existing warnings for the contract, such as whether it has a constructor or `selfdestruct` operations


Any Solidity libraries used by the project’s contracts are tracked in the `solidityLibs` node, which has the same structure as the `contracts` item.

Another thing to notice in these files are the version numbers. The `<app-version>` keeps track of the latest app version, and matches `<version>` from `project.json`. The `<proxy-i-version>`, on the other hand, keeps track of which version of the contracts the proxies are pointing to. Say you deploy a contract in your app version 1.0.0, and then bump the version to 1.1.0 and push some upgraded code for that same contract. This will be reflected in the `<contract-i-address>`, but not yet in the proxy, which will display 1.0.0 in `<proxy-i-version>` and the old logic contract address in `<implementation-i-address>`. Once you run `oz update` to your contract, `<proxy-i-version>` will show the new 1.1.0 version, and `<implementation-i-address>` will point to the new `<contract-i-address>`. Note that this version identifier will refer to the version of the dependency (and not the app) if the proxy points to a dependent Ethereum Package.

The field `<proxyAdmin>` contains the address of the ProxyAdmin contract, used to manage the [transparent proxy pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes) in the project’s proxies.

Also, notice the fields `<app>`, `<package>`, and `<provider>`. These contain the addresses of contracts the OpenZeppelin CLI uses to facilitate the creation of proxies and the management of different versions of your contracts. These contracts will only be deployed once you `publish` your project to a desired network. That is, your project will not have an `app`, `package`, or `provider` unless explicitly running the `publish` command, or if the project was created with the `--publish` flag. Note that this step is required for projects that produce an Ethereum Package. To read more about the architecture of contracts we are using to publish your project on-chain please refer to the [Contract Architecture](https://docs.openzeppelin.com/cli/2.7/contracts-architecture) section.

Finally, the `dependencies` field stores information about linked Ethereum Packages. For each dependency, the `<dependency-address>` tracks the address of the deployed `package` in the network, and `<dependency-version>` is the exact semver identifier being used for the dependency. The `custom-deploy` field will be present only when a version of the Ethereum Package is deployed using the `--deploy-dependencies` flag of the `push` command, in which case `<custom-deploy>` will be `true`.

The naming of the file will be `<network_name>.json`, but note that `<network_name>` is not taken from the name of the network’s entry in the network file, but is instead inferred from the canonical network id associated to the entry. For example, given the following network configuration:

```json hljs
// networks.js
module.exports = {
  networks: {
     geth_ropsten: {
      host: 'localhost',
      port: 8555,
      network_id: 3
    },
     parity_ropsten: {
      host: 'localhost',
      port: 8565,
      network_id: 3
    },
     local: {
      host: 'localhost',
      port: 8545,
      network_id: *
    }
  }
};
```

Using `oz push --network geth_ropsten` or `oz push --network parity_ropsten` will both produce a file named `ropsten.json` no matter which method was used to connect to the ropsten network. The OpenZeppelin CLI will automatically detect which public network is being referred to (using web3.network.getVersion()) and use this information for determining the file name. When dealing with local networks, the OpenZeppelin CLI will generate files with `dev-<network_id>`, given that these networks are not public and don’t have a canonical name. Using `oz push --network local` will produce a file named `dev-1540303312049.json` (or some other number representing the network id of the local network).

## Configuration Files in Version Control

The `project.json` file should be tracked in version control. This file represents an OpenZeppelin project’s configuration; the contracts and Ethereum Packages that compose it, its name and version, the version of the OpenZeppelin CLI it uses, etc. The file should be identical for all the contributors of a project.

Public network files like `mainnet.json` or `ropsten.json` should also be tracked in version control. These contain valuable information about your project’s status in the corresponding network; the addresses of the contract implementations that have been deployed, the addresses of the proxies that have been deployed, etc. Such files should also be identical for all the contributors of a project.

However, local network files like `dev-<network_id>.json` only represent a project’s deployment in a temporary local network such as `ganache-cli` that are only relevant to a single contributor of the project and should not be tracked in version control.

An example `.gitignore` file could contain the following entries:

```json hljs
// .gitignore
# OpenZeppelin
.openzeppelin/dev-*.json
.openzeppelin/.session
```

[← Commands](https://docs.openzeppelin.com/cli/2.7/commands)

[Contracts Architecture →](https://docs.openzeppelin.com/cli/2.7/contracts-architecture)Access - OpenZeppelin Docs

# Access

Access control—​that is, "who is allowed to do this thing"—is incredibly important in the world of smart contracts.
The access control of your contract may govern who can mint tokens, vote on proposals, freeze transfers, and many other things.
It is therefore critical to understand how you implement it, lest someone else
[steals your whole system](https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7/).

## Ownership and `Ownable`

The most common and basic form of access control is the concept of ownership: there’s an account that is the `owner`
of a contract and can do administrative tasks on it.
This approach is perfectly reasonable for contracts that have a single administrative user.

OpenZeppelin Contracts for Cairo provides [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent) for implementing ownership in your contracts.

### Usage

Integrating this component into a contract first requires assigning an owner.
The implementing contract’s constructor should set the initial owner by passing the owner’s address to Ownable’s
[`initializer`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-initializer) like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Set the initial owner of the contract
        self.ownable.initializer(owner);
    }

    (...)
}
```

To restrict a function’s access to the owner only, add in the `assert_only_owner` method:

```cairo hljs
#[starknet::contract]
mod MyContract {
    (...)

    #[external(v0)]
    fn only_owner_allowed(ref self: ContractState) {
        // This function can only be called by the owner
        self.ownable.assert_only_owner();

        (...)
    }
}
```

### Interface

This is the full interface of the `OwnableMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait OwnableABI {
    // IOwnable
    fn owner() -> ContractAddress;
    fn transfer_ownership(new_owner: ContractAddress);
    fn renounce_ownership();

    // IOwnableCamelOnly
    fn transferOwnership(newOwner: ContractAddress);
    fn renounceOwnership();
}
```

Ownable also lets you:

- `transfer_ownership` from the owner account to a new one, and

- `renounce_ownership` for the owner to relinquish this administrative privilege, a common pattern
after an initial stage with centralized administration is over.


|     |     |
| --- | --- |
|  | Removing the owner altogether will mean that administrative tasks that are protected by `assert_only_owner`<br>will no longer be callable! |

### Two step transfer

The component also offers a more robust way of transferring ownership via the
[OwnableTwoStepImpl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableTwoStepImpl) implementation. A two step transfer mechanism helps
to prevent unintended and irreversible owner transfers. Simply replace the `OwnableMixinImpl`
with its respective two step variant:

```cairo hljs
#[abi(embed_v0)]
impl OwnableTwoStepMixinImpl = OwnableComponent::OwnableTwoStepMixinImpl<ContractState>;
```

#### Interface

This is the full interface of the two step `OwnableTwoStepMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait OwnableTwoStepABI {
    // IOwnableTwoStep
    fn owner() -> ContractAddress;
    fn pending_owner() -> ContractAddress;
    fn accept_ownership();
    fn transfer_ownership(new_owner: ContractAddress);
    fn renounce_ownership();

    // IOwnableTwoStepCamelOnly
    fn pendingOwner() -> ContractAddress;
    fn acceptOwnership();
    fn transferOwnership(newOwner: ContractAddress);
    fn renounceOwnership();
}
```

## Role-Based `AccessControl`

While the simplicity of ownership can be useful for simple systems or quick prototyping, different levels of
authorization are often needed. You may want for an account to have permission to ban users from a system, but not
create new tokens. [Role-Based Access Control (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control) offers
flexibility in this regard.

In essence, we will be defining multiple roles, each allowed to perform different sets of actions.
An account may have, for example, 'moderator', 'minter' or 'admin' roles, which you will then check for
instead of simply using [`assert_only_owner`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-assert_only_owner). This check can be enforced through [`assert_only_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role).
Separately, you will be able to define rules for how accounts can be granted a role, have it revoked, and more.

Most software uses access control systems that are role-based: some users are regular users, some may be supervisors
or managers, and a few will often have administrative privileges.

### Usage

For each role that you want to define, you will create a new _role identifier_ that is used to grant, revoke, and
check if an account has that role. See [Creating role identifiers](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access#creating_role_identifiers) for information
on creating identifiers.

Here’s a simple example of implementing [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) on a portion of an ERC20 token contract which defines
and sets a 'minter' role:

```cairo hljs
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::MINTER_ROLE;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        minter: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(MINTER_ROLE, minter);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }
}
```

|     |     |
| --- | --- |
|  | Make sure you fully understand how [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) works before<br>using it on your system, or copy-pasting the examples from this guide. |

While clear and explicit, this isn’t anything we wouldn’t have been able to achieve with
[Ownable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent). Where [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) shines the most is in scenarios where granular
permissions are required, which can be implemented by defining _multiple_ roles.

Let’s augment our ERC20 token example by also defining a 'burner' role, which lets accounts destroy tokens:

```cairo hljs
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");
const BURNER_ROLE: felt252 = selector!("BURNER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::{MINTER_ROLE, BURNER_ROLE};

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        minter: ContractAddress,
        burner: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(MINTER_ROLE, minter);
        self.accesscontrol._grant_role(BURNER_ROLE, burner);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }

    /// This function can only be called by a burner.
    #[external(v0)]
    fn burn(ref self: ContractState, account: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(BURNER_ROLE);
        self.erc20.burn(account, amount);
    }
}
```

So clean!
By splitting concerns this way, more granular levels of permission may be implemented than were possible with the
simpler ownership approach to access control. Limiting what each component of a system is able to do is known
as the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), and is a good
security practice. Note that each account may still have more than one role, if so desired.

### Granting and revoking roles

The ERC20 token example above uses [`_grant_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-_grant_role),
an `internal` function that is useful when programmatically assigning
roles (such as during construction). But what if we later want to grant the 'minter' role to additional accounts?

By default, **accounts with a role cannot grant it or revoke it from other accounts**: all having a role does is making
the [`assert_only_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role) check pass. To grant and revoke roles dynamically, you will need help from the role’s _admin_.

Every role has an associated admin role, which grants permission to call the
[`grant_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and
[`revoke_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role) functions.
A role can be granted or revoked by using these if the calling account has the corresponding admin role.
Multiple roles may have the same admin role to make management easier.
A role’s admin can even be the same role itself, which would cause accounts with that role to be able
to also grant and revoke it.

This mechanism can be used to create complex permissioning structures resembling organizational charts, but it also
provides an easy way to manage simpler applications. `AccessControl` includes a special role with the role identifier
of `0`, called `DEFAULT_ADMIN_ROLE`, which acts as the **default admin role for all roles**.
An account with this role will be able to manage any other role, unless
[`set_role_admin`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin) is used to select a new admin role.

Let’s take a look at the ERC20 token example, this time taking advantage of the default admin role:

```cairo hljs
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");
const BURNER_ROLE: felt252 = selector!("BURNER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::{MINTER_ROLE, BURNER_ROLE};

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        admin: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(DEFAULT_ADMIN_ROLE, admin);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }

    /// This function can only be called by a burner.
    #[external(v0)]
    fn burn(ref self: ContractState, account: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(BURNER_ROLE);
        self.erc20.burn(account, amount);
    }
}
```

|     |     |
| --- | --- |
|  | The `grant_role` and `revoke_role` functions are automatically exposed as `external` functions<br>from the `AccessControlImpl` by leveraging the `#[abi(embed_v0)]` annotation. |

Note that, unlike the previous examples, no accounts are granted the 'minter' or 'burner' roles.
However, because those roles' admin role is the default admin role, and that role was granted to the 'admin', that
same account can call `grant_role` to give minting or burning permission, and `revoke_role` to remove it.

Dynamic role allocation is often a desirable property, for example in systems where trust in a participant may vary
over time. It can also be used to support use cases such as [KYC](https://en.wikipedia.org/wiki/Know_your_customer),
where the list of role-bearers may not be known up-front, or may be prohibitively expensive to include in a single transaction.

### Creating role identifiers

In the Solidity implementation of AccessControl, contracts generally refer to the
[keccak256 hash](https://docs.soliditylang.org/en/latest/units-and-global-variables.html?highlight=keccak256#mathematical-and-cryptographic-functions)
of a role as the role identifier.

For example:

```cairo hljs
bytes32 public constant SOME_ROLE = keccak256("SOME_ROLE")
```

These identifiers take up 32 bytes (256 bits).

Cairo field elements ( `felt252`) store a maximum of 252 bits.
With this discrepancy, this library maintains an agnostic stance on how contracts should create identifiers.
Some ideas to consider:

- Use [sn\_keccak](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#starknet_keccak) instead.

- Use Cairo friendly hashing algorithms like Poseidon, which are implemented in the
[Cairo corelib](https://github.com/starkware-libs/cairo/blob/main/corelib/src/poseidon.cairo).


|     |     |
| --- | --- |
|  | The `selector!` macro can be used to compute [sn\_keccak](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#starknet_keccak) in Cairo. |

### Interface

This is the full interface of the `AccessControlMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait AccessControlABI {
    // IAccessControl
    fn has_role(role: felt252, account: ContractAddress) -> bool;
    fn get_role_admin(role: felt252) -> felt252;
    fn grant_role(role: felt252, account: ContractAddress);
    fn revoke_role(role: felt252, account: ContractAddress);
    fn renounce_role(role: felt252, account: ContractAddress);

    // IAccessControlCamel
    fn hasRole(role: felt252, account: ContractAddress) -> bool;
    fn getRoleAdmin(role: felt252) -> felt252;
    fn grantRole(role: felt252, account: ContractAddress);
    fn revokeRole(role: felt252, account: ContractAddress);
    fn renounceRole(role: felt252, account: ContractAddress);

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;
}
```

`AccessControl` also lets you `renounce_role` from the calling account.
The method expects an account as input as an extra security measure, to ensure you are
not renouncing a role from an unintended account.

[← SNIP12 and Typed Messages](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/snip12)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access)Interfaces and Dispatchers - OpenZeppelin Docs

# Interfaces and Dispatchers

This section describes the interfaces OpenZeppelin Contracts for Cairo offer, and explains the design choices behind them.

Interfaces can be found in the module tree under the `interface` submodule, such as `token::erc20::interface`. For example:

```cairo hljs
use openzeppelin_token::erc20::interface::IERC20;
```

or

```cairo hljs
use openzeppelin_token::erc20::interface::ERC20ABI;
```

|     |     |
| --- | --- |
|  | For simplicity, we’ll use ERC20 as example but the same concepts apply to other modules. |

## Interface traits

The library offers three types of traits to implement or interact with contracts:

### Standard traits

These are associated with a predefined interface such as a standard.
This includes only the functions defined in the interface, and is the standard way to interact with a compliant contract.

```cairo hljs
#[starknet::interface]
pub trait IERC20<TState> {
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

### ABI traits

They describe a contract’s complete interface. This is useful to interface with a preset contract offered by this library, such as the ERC20 preset that includes functions from different traits such as `IERC20` and `IERC20Camel`.

|     |     |
| --- | --- |
|  | The library offers an ABI trait for most components, providing all external function signatures<br>even when most of the time all of them don’t need to be implemented at the same time. This can be helpful when interacting with a contract implementing the component, instead of defining a new dispatcher. |

```cairo hljs
#[starknet::interface]
pub trait ERC20ABI<TState> {
    // IERC20
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;

    // IERC20Metadata
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;

    // IERC20CamelOnly
    fn totalSupply(self: @TState) -> u256;
    fn balanceOf(self: @TState, account: ContractAddress) -> u256;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
}
```

### Dispatcher traits

Traits annotated with `#[starknet::interface]` automatically generate a dispatcher that can be used to interact with contracts that implement the given interface. They can be imported by appending the `Dispatcher` and `DispatcherTrait` suffixes to the trait name, like this:

```cairo hljs
use openzeppelin_token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
```

Other types of dispatchers are also auto-generated from the annotated trait. See the
[Interacting with another contract](https://book.cairo-lang.org/ch15-02-interacting-with-another-contract.html) section of the Cairo book for more information.

|     |     |
| --- | --- |
|  | In the example, the `IERC20Dispatcher` is the one used to interact with contracts, but the<br>`IERC20DispatcherTrait` needs to be in scope for the functions to be available. |

## Dual interfaces

|     |     |
| --- | --- |
|  | `camelCase` functions are deprecated and maintained only for Backwards Compatibility.<br>It’s recommended to only use `snake_case` interfaces with contracts and components. The `camelCase` functions will be removed in<br>future versions. |

Following the [Great Interface Migration](https://community.starknet.io/t/the-great-interface-migration/92107) plan, we added `snake_case` functions to all of our preexisting `camelCase` contracts with the goal of eventually dropping support for the latter.

In short, the library offers two types of interfaces and utilities to handle them:

1. `camelCase` interfaces, which are the ones we’ve been using so far.

2. `snake_case` interfaces, which are the ones we’re migrating to.


This means that currently most of our contracts implement _dual interfaces_. For example, the ERC20 preset contract exposes `transferFrom`, `transfer_from`, `balanceOf`, `balance_of`, etc.

|     |     |
| --- | --- |
|  | Dual interfaces are available for all external functions present in previous versions of OpenZeppelin Contracts for Cairo ( [v0.6.1](https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.6.1) and below). |

### `IERC20`

The default version of the ERC20 interface trait exposes `snake_case` functions:

```cairo hljs
#[starknet::interface]
pub trait IERC20<TState> {
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

### `IERC20Camel`

On top of that, the library also offers a `camelCase` version of the same interface:

```cairo hljs
#[starknet::interface]
pub trait IERC20Camel<TState> {
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;
    fn totalSupply(self: @TState) -> u256;
    fn balanceOf(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

[← Presets](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

[Counterfactual Deployments →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment)Testing - OpenZeppelin Docs

# Testing

This crate provides various helper functions for declaring, deploying,
and testing smart contracts using the `snforge` toolchain from Starknet Foundry.

```cairo hljs
use openzeppelin_testing;
```

The module isn’t part of the `openzeppelin` package and to be accessible has to
be added as a separate dependency in `Scarb.toml`:

```none hljs
[dev-dependencies]
openzeppelin_testing = "0.20.0"
```

## Test Utilities

### `common`

A module providing common test helpers.

```cairo hljs
use openzeppelin_testing::common;
```

Members

Functions

- [`panic_data_to_byte_array(panic_data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-panic_data_to_byte_array)

- [`to_base_16_string(value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-to_base_16_string)

- [`to_base_16_string_no_padding(value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-to_base_16_string_no_padding)

- [`assert_entrypoint_not_found_error(result, selector, contract_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-assert_entrypoint_not_found_error)


Traits

- [`IntoBase16StringTrait`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-IntoBase16StringTrait)


#### Functions

#### `panic_data_to_byte_array(panic_data: Array<felt252>) → ByteArray` function

Converts panic data into a string ( `ByteArray`).

`panic_data` is expected to be a valid serialized `ByteArray` with an extra `felt252` at the beginning, which is the BYTE\_ARRAY\_MAGIC.

#### `to_base_16_string(value: felt252) → ByteArray` function

Converts a `felt252` to a `base16` string padded to 66 characters (including the `0x` prefix).

#### `to_base_16_string_no_padding(value: felt252) → ByteArray` function

Converts a `felt252` to a `base16` (hexadecimal) string without padding, but including the `0x`
prefix.

#### `assert_entrypoint_not_found_error<T, +Drop<T>>(result: SyscallResult<T>, selector: felt252, contract_address: ContractAddress)` function

Asserts that the syscall result of a call failed with an "Entrypoint not found" error,
following the Starknet Foundry emitted error format.

#### Traits

#### `IntoBase16StringTrait` trait

A helper trait that enables a value to be represented as a `base16`(hexadecimal) string padded to 66 characters
(including the `0x` prefix). The type of the value must implement `Into<T, felt252>` to be
convertible to `felt252`.

Usage example:

```cairo hljs
use openzeppelin_testing::common::IntoBase16String;

let expected_panic_message = format!(
    "Entry point selector {} not found in contract {}",
    selector.into_base_16_string(),
    contract_address.into_base_16_string()
);
```

|     |     |
| --- | --- |
|  | The no-padding version can be used in the same way by calling `selector.into_base_16_string_no_padding()`. |

### `deployment`

```cairo hljs
use openzeppelin_testing::deployment;
```

A module containing utilities that simplify declaring and deploying contracts using the `snforge` toolchain.

Members

Functions

- [`declare_class(contract_name)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-declare_class)

- [`deploy(contract_class, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-deploy)

- [`deploy_at(contract_class, contract_address, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-deploy_at)

- [`deploy_another_at(existing, target_address, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-deploy_another_at)

- [`declare_and_deploy(contract_name, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-declare_and_deploy)

- [`declare_and_deploy_at(contract_name, target_address, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-declare_and_deploy_at)


#### Functions

#### `declare_class(contract_name: ByteArray) → ContractClass` function

Declares a contract with a `snforge_std::declare` call and unwraps the result. This function will skip declaration and just return the `ContractClass` if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

#### `deploy(contract_class: ContractClass, calldata: Array<felt252>) → ContractAddress` function

Deploys an instance of a contract and unwraps the result.

#### `deploy_at(contract_class: ContractClass, target_address: ContractAddress, calldata: Array<felt252>)` function

Deploys an instance of a contract at a given address.

#### `deploy_another_at(existing: ContractAddress, target_address: ContractAddress, calldata: Array<felt252>)` function

Deploys a contract using the class hash from another already-deployed contract.

Note that currently, `snforge` does not support redeclaring a contract class. Consequently,
there is no direct method to deploy a second instance of a contract if neither its `ContractClass`
nor its `class_hash` is available in the context. This helper function provides a solution by retrieving
the class hash from an existing contract and using it to facilitate the deployment.

```cairo hljs
use openzeppelin_testing::deploy_another_at;

let alice_address = setup_account(array!['ALICE_PUBKEY']);
let bob_address = contract_address_const::<'BOB'>();
deploy_another_at(alice_address, bob_address, array!['BOB_PUBKEY']);
```

#### `declare_and_deploy(contract_name: ByteArray, calldata: Array<felt252>) → ContractAddress` function

Combines the declaration of a class and the deployment of a contract into one function call. This function will skip declaration if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

#### `declare_and_deploy_at(contract_name: ByteArray, target_address: ContractAddress, calldata: Array<felt252>)` function

Combines the declaration of a class and the deployment of a contract at the given address into one function call. This function will skip declaration if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

### `events`

```cairo hljs
use openzeppelin_testing::events;
use openzeppelin_testing::events::EventSpyExt;
```

A module offering an extended set of functions for handling emitted events, enhancing the default
event utilities provided by `snforge`. These functions are accessible via the `EventSpyExt`
trait implemented on the `EventSpy` struct.

Members

Functions

- [`assert_only_event(self, from_address, event)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_only_event)

- [`assert_emitted_single(self, from_address, expected_event)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_emitted_single)

- [`drop_event(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-drop_event)

- [`drop_n_events(self, number_to_drop)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-drop_n_events)

- [`drop_all_events(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-drop_all_events)

- [`assert_no_events_left(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_no_events_left)

- [`assert_no_events_left_from(self, from_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_no_events_left_from)

- [`count_events_from(self, from_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-count_events_from)


#### Functions

#### `assert_only_event<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)` function

Ensures that `from_address` has emitted only the `expected_event` and no additional events.

#### `assert_emitted_single<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)` function

Ensures that `from_address` has emitted the `expected_event`.

#### `drop_event(ref self: EventSpy)` function

Removes a single event from the queue. If the queue is empty, the function will panic.

#### `drop_n_events(ref self: EventSpy, number_to_drop: u32)` function

Removes `number_to_drop` events from the queue. If the queue is empty, the function will panic.

#### `drop_all_events(ref self: EventSpy)` function

Removes all events remaining on the queue. If the queue is empty already, the function will do nothing.

#### `assert_no_events_left(ref self: EventSpy)` function

Ensures that there are no events remaining on the queue.

#### `assert_no_events_left_from(ref self: EventSpy, from_address: ContractAddress)` function

Ensures that there are no events emitted from the given address remaining on the queue.

#### `count_events_from(ref self: EventSpy, from_address: ContractAddress) → u32` function

Counts the number of remaining events emitted from the given address.

### `signing`

```cairo hljs
use openzeppelin_testing::signing;
```

A module offering utility functions for easier management of key pairs and signatures.

Members

Functions

- [`get_stark_keys_from(private_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-get_stark_keys_from)

- [`get_secp256k1_keys_from(private_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-get_secp256k1_keys_from)

- [`get_secp256r1_keys_from(private_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-get_secp256r1_keys_from)


Traits

- [`SerializedSigning`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-SerializedSigning)


#### Functions

#### `get_stark_keys_from(private_key: felt252) → StarkKeyPair` function

Builds a [Stark](https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/) key pair from a private key represented by a `felt252` value.

#### `get_secp256k1_keys_from(private_key: u256) → Secp256k1KeyPair` function

Builds a [Secp256k1](https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/secp256k1.cairo) key pair from a private key represented by a `u256` value.

#### `get_secp256r1_keys_from(private_key: u256) → Secp256r1KeyPair` function

Builds a [Secp256r1](https://www.nervos.org/knowledge-base/what_is_secp256r1) key pair from a private key represented by a `u256` value.

#### Traits

#### `SerializedSigning` trait

A helper trait that facilitates signing and converting the result signature into a serialized format.

Usage example:

```cairo hljs
use openzeppelin_testing::signing::{
    StarkKeyPair, get_stark_keys_from, StarkSerializedSigning
};

let key_pair = get_stark_keys_from('SECRET_KEY');
let serialized_signature = key_pair.serialized_sign('TX_HASH');
```

[← Utilities](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities)

[Backwards Compatibility →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/backwards-compatibility)Migrating to a new CLI version - OpenZeppelin Docs

