# https://docs.openzeppelin.com/contracts-cairo/ llms-full.txt

Community Contracts - OpenZeppelin Docs

# Community Contracts

**A community-driven extension of our [Solidity library](https://docs.openzeppelin.com/contracts)**: the gold-standard of smart contract development. This library includes:

- Extensions and modules compatible with contracts in the original package

- Alternative implementation of interfaces defined in the original package

- Contracts with third-party integrations

- Contracts built by community members, that align with OpenZeppelin offerings

- General prototypes and experiments


Code is provided by the OpenZeppelin Contracts team, as well as by community contributors, for other developers to review, discuss, iterate on, and potentially use.

## Overview

### Installation

Given this extension is intended for more experimental use cases and therefore the development process is more flexible. For such reason, the library can only be installed with Foundry using gitmodules.

#### Foundry (git)

```console hljs language-shell
$ forge install OpenZeppelin/openzeppelin-community-contracts
```

|     |     |
| --- | --- |
|  | Make sure to add `@openzeppelin/community-contracts/=lib/openzeppelin-community-contracts/contracts/` in `remappings.txt.` |

### Usage

Once installed, you can use the contracts in the library by importing them:

```solidity hljs
// contracts/MyStablecoinAllowlist.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import {AccessManaged} from "@openzeppelin/contracts/access/manager/AccessManaged.sol";
import {ERC20Allowlist, ERC20} from "@openzeppelin/community-contracts/token/ERC20/extensions/ERC20Allowlist.sol";

contract MyStablecoinAllowlist is ERC20Allowlist, AccessManaged {
    constructor(address initialAuthority) ERC20("MyStablecoin", "MST") AccessManaged(initialAuthority) {}

    function allowUser(address user) public restricted {
        _allowUser(user);
    }

    function disallowUser(address user) public restricted {
        _disallowUser(user);
    }
}
```

To keep your system secure, you should **always** use the installed code as-is, and neither copy-paste it from online sources, nor modify it yourself. The library is designed so that only the contracts and functions you use are deployed, so you don’t need to worry about it needlessly increasing gas costs.

## Security

Contracts in the community library are provided as is, with no particular guarantees. Given changes in this repository are more frequent, the code is not formally audited and not covered by the [bug bounty program on Immunefi](https://www.immunefi.com/bounty/openzeppelin).

Similarly, the code has no backward compatibility guarantees.

We kindly ask to report any issue directly to our security [contact](mailto:security@openzeppelin.org). The team will do its best to assist and mitigate any potential misuses of the library. However, keep in mind the flexibility assumed for this repository may relax our assessment.

[Account Abstraction →](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction)Documentation - OpenZeppelin Docs

# Documentation

Explore our guides and examples to learn how to integrate OpenZeppelin security products with your project.

## Explore using OpenZeppelin

OpenZeppelin provides a complete suite of security products to adopt security best practices from the first line of code all the way to running your decentralized application on-chain.

[ContractsA library of modular, reusable, and secure smart contracts, written in Solidity.](https://docs.openzeppelin.com/contracts/5.x/)

[DefenderA mission-critical developer security platform to code, audit, deploy, monitor, and operate blockchain applications.](https://docs.openzeppelin.com/defender/)

[Community ContractsA community-driven extension of our Solidity library.](https://docs.openzeppelin.com/community-contracts/0.0.1/)

[UpgradesA comprehensive suite of contracts and tooling to deploy and manage upgradeable contracts on Ethereum.](https://docs.openzeppelin.com/upgrades)

[Contracts for CairoA library for secure smart contract development written in Cairo for Starknet.](https://docs.openzeppelin.com/contracts-cairo/0.20.0/)

[Contracts for StylusA library for secure smart contract development written in Rust for Arbitrum Stylus.](https://docs.openzeppelin.com/contracts-stylus/0.1.0/)

[Substrate RuntimesA collection of runtime templates for parachain development on Polkadot.](https://docs.openzeppelin.com/substrate-runtimes/3.0.0-rc/)

[Uniswap HooksA Solidity library for secure and modular Uniswap hooks.](https://docs.openzeppelin.com/uniswap-hooks/1.x/)

[Solidity DocgenA tool for automatically generating documentation based on the natspec comments of your Solidity contracts.](https://github.com/OpenZeppelin/solidity-docgen)

### Security Audits

OpenZeppelin security audits are trusted by leading organizations building decentralized systems. Browse through past public audits in our [blog](https://blog.openzeppelin.com/security-audits/) and follow our [quality checklist](https://blog.openzeppelin.com/follow-this-quality-checklist-before-an-audit-8cc6a0e44845/) before going to production. To learn more about OpenZeppelin’s audit process and request an audit, please visit our [security audits site](https://openzeppelin.com/security-audits/).

## Learn

Comprehensive guides for every step of your development journey.

[Setting Up a Node ProjectInstall node, npm, and the basic libraries for web3 development.](https://docs.openzeppelin.com/learn/setting-up-a-node-project)

[Developing Smart ContractsWrite and compile your first Solidity contracts, using the building blocks from the OpenZeppelin Contracts library.](https://docs.openzeppelin.com/learn/developing-smart-contracts)

[Deploying and InteractingDeploy your contracts to a local blockchain and send your first transactions using the console.](https://docs.openzeppelin.com/learn/deploying-and-interacting)

[Writing Automated TestsUnit test your contracts with assertions from OpenZeppelin Test Helpers and test using the OpenZeppelin Test Environment.](https://docs.openzeppelin.com/learn/writing-automated-tests)

[Connecting to Public Test NetworksSet up a staging environment by deploying your app to a public Ethereum testnet.](https://docs.openzeppelin.com/learn/connecting-to-public-test-networks)

[Upgrading Smart ContractsChange the code of your deployed contracts to add new features or fix bugs, using OpenZeppelin Upgrades Plugins.](https://docs.openzeppelin.com/learn/upgrading-smart-contracts)

[Preparing for MainnetAll the boxes you need to check before taking your project to production on the main Ethereum network.](https://docs.openzeppelin.com/learn/preparing-for-mainnet)

Check out [the OpenZeppelin forum](https://forum.openzeppelin.com/c/general/guides-and-tutorials/23) for additional community-contributed guides!

### Ethernaut

Learn more about security in Solidity contracts by playing [Ethernaut](https://ethernaut.openzeppelin.com/). Every level in Ethernaut is a smart contract waiting to be hacked, and teaches you a vulnerability by having you exploit it - many of them based on real-life hacks! You can discuss your solutions or ask for tips in [our forum](https://forum.openzeppelin.com/c/security/ethernaut/30).

## More from OpenZeppelin

### Careers

OpenZeppelin is growing. If you enjoy using our products or reading our audit reports, and have a genuine interest in protecting the open economy, please check out our current [job openings](https://openzeppelin.com/jobs/).

## Questions?

Join the OpenZeppelin community in [our forum](https://forum.openzeppelin.com/) to [ask for help](https://forum.openzeppelin.com/c/support/17), as well as share your feedback or showcase what you have built with OpenZeppelin!

## Share the Love!

If you are using OpenZeppelin contracts, tools, or libraries in your project, share the love with the rest of the community by adding a badge to your `README`! Let your audience know that your system is built with the most secure components available.

![built-with openzeppelin](https://img.shields.io/badge/built%20with-OpenZeppelin-3677FF)

```markdown hljs
[![built-with openzeppelin](https://img.shields.io/badge/built%20with-OpenZeppelin-3677FF)](https://docs.openzeppelin.com/)
```Contracts Architecture - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Contracts Architecture

Features such as contract upgrades and Ethereum Package linking involve interacting with a number of smart contracts. While regular usage of the CLI does not require awareness of these low-level details, it is still helpful to understand how everything works under the hood.

The following sections describe the contract achitecture behind both upgrades and Ethereum Packages.

|     |     |
| --- | --- |
|  | Most of these contracts are actually part of [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/), which the CLI uses. |

## Upgrades

The source code of the contracts involved with upgrades is located [here](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.6.0/packages/lib/contracts/upgradeability).

### `ProxyAdmin`

[`ProxyAdmin`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin) is a central admin for all [proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies) on your behalf, making their management as simple as possible.

As an admin of all proxy contracts it is in charge of upgrading them, as well as transferring their ownership to another admin. This contract is used to complement the [Transparent Proxy Pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes), which prevents an admin from accidentally triggering a proxy management function when interacting with their instances. `ProxyAdmin` is owned by its deployer (the project owner), and exposes its administrative interface to this account.

A `ProxyAdmin` is only deployed when you run an `oz create` (or `oz create2`) command for the first time. You can force the CLI to deploy one by running `oz push --deploy-proxy-admin`.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyAdmin.sol).

#### Ownership Transfer

The [`oz set-admin`](https://docs.openzeppelin.com/cli/2.7/commands#set-admin) CLI command is used to transfer ownership, both of any single contract or of the entire project (by transferring the ownership of the `ProxyAdmin` contract itself).

A contract’s ownership is transferred by providing its address and the new admin’s:

```console hljs language-shell
$ npx oz set-admin [MYCONTRACT_ADDRESS] [NEW_ADMIN_ADDRESS]
```

To instead transfer the whole project, just provide the new admin address:

```console hljs language-shell
$ npx oz set-admin [NEW_ADMIN_ADDRESS]
```

|     |     |
| --- | --- |
|  | `oz set-admin` is an interactive command: you can also run it with no arguments and it will prompt you for data as it proceeds. |

#### Contract Upgrades via `ProxyAdmin`

The `ProxyAdmin.sol` also responsible for upgrading our contracts. When you run the `oz upgrade` command, it goes through `ProxyAdmin’s` [`upgrade`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin-upgrade-contract-AdminUpgradeabilityProxy-address-) method. The `ProxyAdmin` contract also provides another method [`getProxyImplementation`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin-getProxyImplementation-contract-AdminUpgradeabilityProxy-) which returns the current implementation of a given proxy.

You can find your `ProxyAdmin` contract address in [`.openzeppelin/<network>.json`](https://docs.openzeppelin.com/cli/2.7/configuration#network.json) under the same name.

```json hljs
// .openzeppelin/<network.json>
"proxyAdmin": {
   "address": <proxyAdmin-address>
}
```

### `ProxyFactory`

[`ProxyFactory`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyFactory) is used when creating contracts via the `oz create2` command, as well as when creating minimal proxies. It contains all the necessary methods to deploy a proxy through the `CREATE2` opcode or a minimal non-upgradeable proxy.

This contract is only deployed when you run `openzeppelin create2` or `openzeppelin create --minimal` for the first time. You can force the CLI to deploy it by running `openzeppelin push --deploy-proxy-factory`.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyFactory.sol).

## Ethereum Packages

The source code of the contracts involved with a published Ethereum Package is located [here](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.6.0/packages/lib/contracts/application).

### `App`

[`App`](https://docs.openzeppelin.com/upgrades/2.8/api#App) is the project’s main entry point. Its most important function is to manage your project’s "providers". A provider is basically an Ethereum Package identified by a name at a specific version. For example, a project may track your application’s contracts in one provider named "my-application" at version "0.0.1", an OpenZeppelin Contracts provider named "@openzeppelin/contracts-ethereum-package" at version "2.0.0", and a few other providers. These providers are your project’s sources of on-chain logic.

The providers are mapped by name to `ProviderInfo` structs:

```solidity hljs
// App.sol
    ...

    mapping(string => ProviderInfo) internal providers;

    struct ProviderInfo {
        Package package;
        uint64[3] version;
    }

    ...
```

When you upgrade one of your application’s smart contracts, it is your application provider named "my-application" that is bumped to a new version, e.g. from "0.0.1" to "0.0.2". On the other hand, when you decide to use a new version of the OpenZeppelin Ethereum Package in your project, it is the "@openzeppelin/contracts-ethereum-package" provider which is now pointed at the "2.0.1" version of the package, instead of "2.0.0".

An Ethereum Package is defined by the `Package` contract, as we’ll see next.

|     |     |
| --- | --- |
|  | Additionally the `App` contract also facilitates the creation of proxies, by conveniently wrapping around the `AdminUpgradeabilityProxy` contract. |

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/App.sol).

### `Package`

A [`Package`](https://docs.openzeppelin.com/upgrades/2.8/api#Package) contract tracks all the versions of a given Ethereum Package. Following the example above, one package could be the "application package" associated to the name "my-application" containing all the contracts for version "0.0.1" of your application, and all the contracts for version "0.0.2" as well. Alternatively, another package could be an Ethereum Package associated to the name "@openzeppelin/contracts-ethereum-package" which contains a large number of versions "x.y.z" each of which contains a given set of contracts.

The versions are mapped by a semver hash to `Version` structs:

```solidity hljs
// Package.sol
    ...

    mapping (bytes32 => Version) internal versions;

    struct Version {
        uint64[3] semanticVersion;
        address contractAddress;
        bytes contentURI;
    }

    ...
```

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/Package.sol).

### `ImplementationDirectory`

A version’s `contractAddress` is an instance of the A [`ImplementationDirectory`](https://docs.openzeppelin.com/upgrades/2.8/api#ImplementationDirectory) contract, which is basically a mapping of contract aliases (or names) to deployed implementation instances. Continuing the example, your project’s "my-application" package for version "0.0.1" could contain a directory with the following contracts:

**Directory for version "0.0.1" of the "my-application" package**

- Alias: "MainContract", Implementation: "0x0B06339ad63A875D4874dB7B7C921012BbFfe943"

- Alias: "MyToken", Implementation: "0x1b9a62585255981c85Acec022cDaC701132884f7"


While version "0.0.2" of the "my-application" package could look like this:

**Directory for version "0.0.2" of the "my-application" package**

- Alias: "MainContract", Implementation: "0x0B06339ad63A875D4874dB7B7C921012BbFfe943"

- Alias: "MyToken", Implementation: "0x724a43099d375e36c07be60c967b8bbbec985dc8" ←-- this changed


Notice how version "0.0.2" uses a new implementation for the "MyToken" contract.

Likewise, different versions of the "@openzeppelin/contracts-ethereum-package" Ethereum Package could contain different implementations for persisting aliases such as "ERC20", "ERC721", etc.

An `ImplementationDirectory` is a contract that adopts the `ImplemetationProvider` interface, which simply requires that for a given contract alias or name, the deployed address of a contract is provided. In this particular implementation of the interface, an `ImplementationDirectory` can be frozen, indicating that it will no longer be able to set or unset additional contracts and aliases. This is helpful for making official releases of Ethereum Packages, where the immutability of the package is guaranteed.

Other implementations of the interface could provide contracts without such a limitation, which makes the architecture pretty flexible, yet secure.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/ImplementationDirectory.sol).

### Overview

The following diagram illustrates the interface of the contracts of published Ethereum Packages:

![OpenZeppelin 2.x UML](https://docs.openzeppelin.com/cli/2.7/_images/architecture.png)

[← Configuration Files](https://docs.openzeppelin.com/cli/2.7/configuration)Components - OpenZeppelin Docs

# Components

The following documentation provides reasoning and examples on how to use Contracts for Cairo components.

Starknet components are separate modules that contain storage, events, and implementations that can be integrated into a contract.
Components themselves cannot be declared or deployed.
Another way to think of components is that they are abstract modules that must be instantiated.

|     |     |
| --- | --- |
|  | For more information on the construction and design of Starknet components, see the [Starknet Shamans post](https://community.starknet.io/t/cairo-components/101136#components-1) and the [Cairo book](https://book.cairo-lang.org/ch99-01-05-00-components.html). |

## Building a contract

### Setup

The contract should first import the component and declare it with the `component!` macro:

```cairo hljs
#[starknet::contract]
mod MyContract {
    // Import the component
    use openzeppelin_security::InitializableComponent;

    // Declare the component
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);
}
```

The `path` argument should be the imported component itself (in this case, [InitializableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/security#initializable)).
The `storage` and `event` arguments are the variable names that will be set in the `Storage` struct and `Event` enum, respectively.
Note that even if the component doesn’t define any events, the compiler will still create an empty event enum inside the component module.

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }
}
```

The `#[substorage(v0)]` attribute must be included for each component in the `Storage` trait.
This allows the contract to have indirect access to the component’s storage.
See [Accessing component storage](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#accessing_component_storage) for more on this.

The `#[flat]` attribute for events in the `Event` enum, however, is not required.
For component events, the first key in the event log is the component ID.
Flattening the component event removes it, leaving the event ID as the first key.

### Implementations

Components come with granular implementations of different interfaces.
This allows contracts to integrate only the implementations that they’ll use and avoid unnecessary bloat.
Integrating an implementation looks like this:

```cairo hljs
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    // Gives the contract access to the implementation methods
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
```

Defining an `impl` gives the contract access to the methods within the implementation from the component.
For example, `is_initialized` is defined in the `InitializableImpl`.
A function on the contract level can expose it like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    (...)

    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;

    #[external(v0)]
    fn is_initialized(ref self: ContractState) -> bool {
        self.initializable.is_initialized()
    }
}
```

While there’s nothing wrong with manually exposing methods like in the previous example, this process can be tedious for implementations with many methods.
Fortunately, a contract can embed implementations which will expose all of the methods of the implementation.
To embed an implementation, add the `#[abi(embed_v0)]` attribute above the `impl`:

```cairo hljs
#[starknet::contract]
mod MyContract {
    (...)

    // This attribute exposes the methods of the `impl`
    #[abi(embed_v0)]
    impl InitializableImpl =
        InitializableComponent::InitializableImpl<ContractState>;
}
```

`InitializableImpl` defines the `is_initialized` method in the component.
By adding the embed attribute, `is_initialized` becomes a contract entrypoint for `MyContract`.

|     |     |
| --- | --- |
|  | Embeddable implementations, when available in this library’s components, are segregated from the internal component implementation which makes it easier to safely expose.<br>Components also separate granular implementations from [mixin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins) implementations.<br>The API documentation design reflects these groupings.<br>See [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component) as an example which includes:<br>- **Embeddable Mixin Implementation**<br>  <br>- **Embeddable Implementations**<br>  <br>- **Internal Implementations**<br>  <br>- **Events** |

### Mixins

Mixins are impls made of a combination of smaller, more specific impls.
While separating components into granular implementations offers flexibility,
integrating components with many implementations can appear crowded especially if the contract uses all of them.
Mixins simplify this by allowing contracts to embed groups of implementations with a single directive.

Compare the following code blocks to see the benefit of using a mixin when creating an account contract.

#### Account without mixin

```cairo hljs
component!(path: AccountComponent, storage: account, event: AccountEvent);
component!(path: SRC5Component, storage: src5, event: SRC5Event);

#[abi(embed_v0)]
impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;
#[abi(embed_v0)]
impl DeclarerImpl = AccountComponent::DeclarerImpl<ContractState>;
#[abi(embed_v0)]
impl DeployableImpl = AccountComponent::DeployableImpl<ContractState>;
#[abi(embed_v0)]
impl PublicKeyImpl = AccountComponent::PublicKeyImpl<ContractState>;
#[abi(embed_v0)]
impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;
#[abi(embed_v0)]
impl PublicKeyCamelImpl = AccountComponent::PublicKeyCamelImpl<ContractState>;
impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

#[abi(embed_v0)]
impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
```

#### Account with mixin

```cairo hljs
component!(path: AccountComponent, storage: account, event: AccountEvent);
component!(path: SRC5Component, storage: src5, event: SRC5Event);

#[abi(embed_v0)]
impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;
```

The rest of the setup for the contract, however, does not change.
This means that component dependencies must still be included in the `Storage` struct and `Event` enum.
Here’s a full example of an account contract that embeds the `AccountMixinImpl`:

```cairo hljs
#[starknet::contract]
mod Account {
    use openzeppelin_account::AccountComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // This embeds all of the methods from the many AccountComponent implementations
    // and also includes `supports_interface` from `SRC5Impl`
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
    }
}
```

### Initializers

|     |     |
| --- | --- |
|  | Failing to use a component’s `initializer` can result in irreparable contract deployments.<br>Always read the API documentation for each integrated component. |

Some components require some sort of setup upon construction.
Usually, this would be a job for a constructor; however, components themselves cannot implement constructors.
Components instead offer `initializer` s within their `InternalImpl` to call from the contract’s constructor.
Let’s look at how a contract would integrate [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent):

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Invoke ownable's `initializer`
        self.ownable.initializer(owner);
    }
}
```

### Immutable Config

While initializers help set up the component’s initial state, some require configuration that may be defined
as constants, saving gas by avoiding the necessity of reading from storage each time the variable needs to be used. The
Immutable Component Config pattern helps with this matter by allowing the implementing contract to define a set of
constants declared in the component, customizing its functionality.

|     |     |
| --- | --- |
|  | The Immutable Component Config standard is defined in the [SRC-107](https://github.com/starknet-io/SNIPs/blob/963848f0752bde75c7087c2446d83b7da8118b25/SNIPS/snip-107.md). |

Here’s an example of how to use the Immutable Component Config pattern with the [ERC2981Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component):

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::common::erc2981::ERC2981Component;
    use starknet::contract_address_const;

    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = ERC2981Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc2981: ERC2981Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC2981Event: ERC2981Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    // Define the immutable config
    pub impl ERC2981ImmutableConfig of ERC2981Component::ImmutableConfig {
        const FEE_DENOMINATOR: u128 = 10_000;
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let default_receiver = contract_address_const::<'RECEIVER'>();
        let default_royalty_fraction = 1000;
        // Invoke erc2981's `initializer`
        self.erc2981.initializer(default_receiver, default_royalty_fraction);
    }
}
```

#### Default config

Sometimes, components implementing the Immutable Component Config pattern provide a default configuration that can be
directly used without implementing the `ImmutableConfig` trait locally. When provided, this implementation will be named
`DefaultConfig` and will be available in the same module containing the component, as a sibling.

In the following example, the `DefaultConfig` trait is used to define the `FEE_DENOMINATOR` config constant.

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;
    // Bring the DefaultConfig trait into scope
    use openzeppelin_token::common::erc2981::{ERC2981Component, DefaultConfig};
    use starknet::contract_address_const;

    component!(path: ERC2981Component, storage: erc2981, event: ERC2981Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // Instantiate `InternalImpl` to give the contract access to the `initializer`
    impl InternalImpl = ERC2981Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        (...)
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        (...)
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let default_receiver = contract_address_const::<'RECEIVER'>();
        let default_royalty_fraction = 1000;
        // Invoke erc2981's `initializer`
        self.erc2981.initializer(default_receiver, default_royalty_fraction);
    }
}
```

#### `validate` function

The `ImmutableConfig` trait may also include a `validate` function with a default implementation, which
asserts that the configuration is correct, and must not be overridden by the implementing contract. For more information
on how to use this function, refer to the [validate section of the SRC-107](https://github.com/starknet-io/SNIPs/blob/963848f0752bde75c7087c2446d83b7da8118b25/SNIPS/snip-107.md#validate-function).

### Dependencies

Some components include dependencies of other components.
Contracts that integrate components with dependencies must also include the component dependency.
For instance, [AccessControlComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) depends on [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component).
Creating a contract with `AccessControlComponent` should look like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    #[abi(embed_v0)]
    impl AccessControlCamelImpl =
        AccessControlComponent::AccessControlCamelImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    (...)
}
```

## Customization

|     |     |
| --- | --- |
|  | Customizing implementations and accessing component storage can potentially corrupt the state, bypass security checks, and undermine the component logic.<br>**Exercise extreme caution**. See [Security](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#security). |

### Hooks

Hooks are entrypoints to the business logic of a token component that are accessible at the contract level.
This allows contracts to insert additional behaviors before and/or after token transfers (including mints and burns).
Prior to hooks, extending functionality required contracts to create [custom implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#custom_implementations).

All token components include a generic hooks trait that include empty default functions.
When creating a token contract, the using contract must create an implementation of the hooks trait.
Suppose an ERC20 contract wanted to include Pausable functionality on token transfers.
The following snippet leverages the `before_update` hook to include this behavior.

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_security::pausable::PausableComponent::InternalTrait;
    use openzeppelin_security::pausable::PausableComponent;
    use openzeppelin_token::erc20::ERC20Component;
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    // Create the hooks implementation
    impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {
        // Occurs before token transfers
        fn before_update(
            ref self: ERC20Component::ComponentState<ContractState>,
            from: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) {
            // Access local state from component state
            let contract_state = self.get_contract();
            // Call function from integrated component
            contract_state.pausable.assert_not_paused();
        }

        // Omitting the `after_update` hook because the default behavior
        // is already implemented in the trait
    }

    (...)
}
```

Notice that the `self` parameter expects a component state type.
Instead of passing the component state, the using contract’s state can be passed which simplifies the syntax.
The hook then moves the scope up with the Cairo-generated `get_contract` through the `HasComponent` trait (as illustrated with ERC20Component in this example).
From here, the hook can access the using contract’s integrated components, storage, and implementations.

Be advised that even if a token contract does not require hooks, the hooks trait must still be implemented.
The using contract may instantiate an empty impl of the trait;
however, the Contracts for Cairo library already provides the instantiated impl to abstract this away from contracts.
The using contract just needs to bring the implementation into scope like this:

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::ERC20Component;
    use openzeppelin_token::erc20::ERC20HooksEmptyImpl;

    (...)
}
```

|     |     |
| --- | --- |
|  | For a more in-depth guide on hooks, see [Extending Cairo Contracts with Hooks](https://fleming-andrew.medium.com/extending-cairo-contracts-with-hooks-c3ca21d1d6b8). |

### Custom implementations

There are instances where a contract requires different or amended behaviors from a component implementation.
In these scenarios, a contract must create a custom implementation of the interface.
Let’s break down a pausable ERC20 contract to see what that looks like.
Here’s the setup:

```cairo hljs
#[starknet::contract]
mod ERC20Pausable {
    use openzeppelin_security::pausable::PausableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    // Import the ERC20 interfaces to create custom implementations
    use openzeppelin_token::erc20::interface::{IERC20, IERC20CamelOnly};
    use starknet::ContractAddress;

    component!(path: PausableComponent, storage: pausable, event: PausableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    // `ERC20MetadataImpl` can keep the embed directive because the implementation
    // will not change
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    // Do not add the embed directive to these implementations because
    // these will be customized
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    impl ERC20CamelOnlyImpl = ERC20Component::ERC20CamelOnlyImpl<ContractState>;

    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)
}
```

The first thing to notice is that the contract imports the interfaces of the implementations that will be customized.
These will be used in the next code example.

Next, the contract includes the [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component) implementations; however, `ERC20Impl` and `ERC20CamelOnlyImplt` are **not** embedded.
Instead, we want to expose our custom implementation of an interface.
The following example shows the pausable logic integrated into the ERC20 implementations:

```cairo hljs
#[starknet::contract]
mod ERC20Pausable {
    (...)

    // Custom ERC20 implementation
    #[abi(embed_v0)]
    impl CustomERC20Impl of IERC20<ContractState> {
        fn transfer(
            ref self: ContractState, recipient: ContractAddress, amount: u256
        ) -> bool {
            // Add the custom logic
            self.pausable.assert_not_paused();
            // Add the original implementation method from `IERC20Impl`
            self.erc20.transfer(recipient, amount)
        }

        fn total_supply(self: @ContractState) -> u256 {
            // This method's behavior does not change from the component
            // implementation, but this method must still be defined.
            // Simply add the original implementation method from `IERC20Impl`
            self.erc20.total_supply()
        }

        (...)
    }

    // Custom ERC20CamelOnly implementation
    #[abi(embed_v0)]
    impl CustomERC20CamelOnlyImpl of IERC20CamelOnly<ContractState> {
        fn totalSupply(self: @ContractState) -> u256 {
            self.erc20.total_supply()
        }

        fn balanceOf(self: @ContractState, account: ContractAddress) -> u256 {
            self.erc20.balance_of(account)
        }

        fn transferFrom(
            ref self: ContractState,
            sender: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) -> bool {
            self.pausable.assert_not_paused();
            self.erc20.transfer_from(sender, recipient, amount)
        }
    }
}
```

Notice that in the `CustomERC20Impl`, the `transfer` method integrates `pausable.assert_not_paused` as well as `erc20.transfer` from `PausableImpl` and `ERC20Impl` respectively.
This is why the contract defined the `ERC20Impl` from the component in the previous example.

Creating a custom implementation of an interface must define **all** methods from that interface.
This is true even if the behavior of a method does not change from the component implementation (as `total_supply` exemplifies in this example).

|     |     |
| --- | --- |
|  | The ERC20 documentation provides another custom implementation guide for [Customizing decimals](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20#customizing_decimals). |

### Accessing component storage

There may be cases where the contract must read or write to an integrated component’s storage.
To do so, use the same syntax as calling an implementation method except replace the name of the method with the storage variable like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    (...)

    fn write_to_comp_storage(ref self: ContractState) {
        self.initializable.Initializable_initialized.write(true);
    }

    fn read_from_comp_storage(self: @ContractState) -> bool {
        self.initializable.Initializable_initialized.read()
    }
}
```

## Security

The maintainers of OpenZeppelin Contracts for Cairo are mainly concerned with the correctness and security of the code as published in the library.

Customizing implementations and manipulating the component state may break some important assumptions and introduce vulnerabilities.
While we try to ensure the components remain secure in the face of a wide range of potential customizations, this is done in a best-effort manner.
Any and all customizations to the component logic should be carefully reviewed and checked against the source code of the component they are customizing so as to fully understand their impact and guarantee their security.

[← Wizard](https://docs.openzeppelin.com/contracts-cairo/0.20.0/wizard)

[Presets →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)Command Line Interface (CLI) - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Command Line Interface (CLI)

|     |     |
| --- | --- |
|  | If you’re using Truffle or Buidler, check out the new [Upgrades plugins](https://github.com/OpenZeppelin/openzeppelin-upgrades) to integrate upgradeability into your existing workflow. |

**Develop, deploy and operate upgradeable smart contract projects**. Support for Ethereum and every other EVM-powered blockchain.

- **Interactive commands**: Send transactions, query balances, and interact with your contracts directly from the command line, using commands like `oz send-tx`, `oz call`, `oz balance`, and `oz transfer`.

- **Deploy & upgrade your contracts**: You can develop your smart contracts iteratively, speeding up development locally, or squashing bugs in production. Run `oz deploy` to deploy your contracts, followed by `oz upgrade` any time you want to change their code.

- **Link Ethereum Packages**: Use code from contracts already deployed to the blockchain directly on your project, saving gas on deployments and managing your dependencies securely, just with an `oz link` command.

- **Bootstrap your dapp**: Jumpstart your dapp by unpacking one of our starter kits, pre-configured with OpenZeppelin Contracts, React, and Infura. Run `oz unpack` to start!


## Overview

### Installation

```console hljs language-shell
$ npm install @openzeppelin/cli
```

### Usage

All CLI commands are fully interactive: you can call them with no or incomplete arguments and they will prompt you for options as they proceed.

Below is a short list of the most used commands:

- [`oz init`](https://docs.openzeppelin.com/cli/2.8/commands#init): initialize your OpenZeppelin project

- [`oz compile`](https://docs.openzeppelin.com/cli/2.8/commands#compile): compile all Solidity smart contracts in your project

- [`oz deploy`](https://docs.openzeppelin.com/cli/2.8/commands#deploy): deploy an upgradeable smart contract

- [`oz send-tx`](https://docs.openzeppelin.com/cli/2.8/commands#send): send a transaction to a contract and execute a function

- [`oz call`](https://docs.openzeppelin.com/cli/2.8/commands#call): read data from the blockchain by calling `view` and `pure` functions

- [`oz upgrade`](https://docs.openzeppelin.com/cli/2.8/commands#upgrade): upgrade a deployed contract to a new version without changing the address or state

- [`oz unpack`](https://docs.openzeppelin.com/cli/2.8/commands#unpack): bootstrap a project with a [Starter Kit](https://docs.openzeppelin.com/starter-kits/)

- [`oz link`](https://docs.openzeppelin.com/cli/2.8/commands#link): reuse on-chain code by to a [linking to Ethereum Packages](https://docs.openzeppelin.com/cli/2.8/dependencies)


## Learn More

- Head to [Getting Started](https://docs.openzeppelin.com/cli/2.8/getting-started) to see the CLI in action by deploying and upgrading a smart contract!

- [Using Dependencies](https://docs.openzeppelin.com/cli/2.8/dependencies) showcases a more complex project being built, including leveraging the [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/) library.

- If you are a Truffle user, go to [Using With Truffle](https://docs.openzeppelin.com/cli/2.8/truffle) for information on using both tools on the same project.

- Take a look at the API reference for all [CLI commands](https://docs.openzeppelin.com/cli/2.8/commands).

- For an overview of the internals of the CLI, you can read on the [Contracts Architecture](https://docs.openzeppelin.com/cli/2.8/contracts-architecture) and different [Configuration Files](https://docs.openzeppelin.com/cli/2.8/configuration).


|     |     |
| --- | --- |
|  | Looking for the documentation for version 2.4 or earlier? You can find it [here](https://docs.zeppelinos.org/versions). |

[Getting Started →](https://docs.openzeppelin.com/cli/2.8/getting-started)Governor - OpenZeppelin Docs

# Governor

Decentralized protocols are in constant evolution from the moment they are publicly released. Often,
the initial team retains control of this evolution in the first stages, but eventually delegates it
to a community of stakeholders. The process by which this community makes decisions is called
on-chain governance, and it has become a central component of decentralized protocols, fueling
varied decisions such as parameter tweaking, smart contract upgrades, integrations with other
protocols, treasury management, grants, etc.

This governance protocol is generally implemented in a special-purpose contract called “Governor”. In
OpenZeppelin Contracts for Cairo, we set out to build a modular system of Governor components where different
requirements can be accommodated by implementing specific traits. You will find the most common requirements out of the box,
but writing additional ones is simple, and we will be adding new features as requested by the community in future releases.

## Usage and setup

### Token

The voting power of each account in our governance setup will be determined by an ERC20 or an ERC721 token. The token has
to implement the [VotesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent) extension. This extension will keep track of historical balances so that voting power
is retrieved from past snapshots rather than current balance, which is an important protection that prevents double voting.

If your project already has a live token that does not include Votes and is not upgradeable, you can wrap it in a
governance token by using a wrapper. This will allow token holders to participate in governance by wrapping their tokens 1-to-1.

|     |     |
| --- | --- |
|  | The library currently does not include a wrapper for tokens, but it will be added in a future release. |

|     |     |
| --- | --- |
|  | Currently, the clock mode is fixed to block timestamps, since the Votes component uses the block timestamp to track<br>checkpoints. We plan to add support for more flexible clock modes in Votes in a future release, allowing to use, for example,<br>block numbers instead. |

### Governor

We will initially build a Governor without a timelock. The core logic is given by the [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent), but we
still need to choose:

1) how voting power is determined,

2) how many votes are needed for quorum,

3) what options people have when casting a vote and how those votes are counted, and

4) the execution mechanism that should be used.

Each of these aspects is customizable by writing your own extensions,
or more easily choosing one from the library.

**For 1)** we will use the [GovernorVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent) extension, which hooks to an [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) instance to determine the voting power
of an account based on the token balance they hold when a proposal becomes active.
This module requires the address of the token to be passed as an argument to the initializer.

**For 2)** we will use [GovernorVotesQuorumFraction](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent). This works together with the [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) instance to define the quorum as a
percentage of the total supply at the block when a proposal’s voting power is retrieved. This requires an initializer
parameter to set the percentage besides the votes token address. Most Governors nowadays use 4%. Since the quorum denominator
is 1000 for precision, we initialize the module with a numerator of 40, resulting in a 4% quorum (40/1000 = 0.04 or 4%).

**For 3)** we will use [GovernorCountingSimple](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent), an extension that offers 3 options to voters: For, Against, and Abstain,
and where only For and Abstain votes are counted towards quorum.

**For 4)** we will use [GovernorCoreExecution](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent), an extension that allows proposal execution directly through the governor.

|     |     |
| --- | --- |
|  | Another option is [GovernorTimelockExecution](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent). An example can be found in the next section. |

Besides these, we also need an implementation for the [GovernorSettingsTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) defining the voting delay, voting period,
and proposal threshold. While we can use the [GovernorSettings](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent) extension which allows to set these parameters by the
governor itself, we will implement the trait locally in the contract and set the voting delay, voting period,
and proposal threshold as constant values.

_voting\_delay_: How long after a proposal is created should voting power be fixed. A large voting delay gives
users time to unstake tokens if necessary.

_voting\_period_: How long does a proposal remain open to votes.

|     |     |
| --- | --- |
|  | These parameters are specified in the unit defined in the token’s clock, which is for now always timestamps. |

_proposal\_threshold_: This restricts proposal creation to accounts who have enough voting power.

An implementation of `GovernorComponent::ImmutableConfig` is also required. For the example below, we have used
the `DefaultConfig`. Check the [Immutable Component Config](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#immutable_config) guide for more details.

The last missing step is to add an `SNIP12Metadata` implementation used to retrieve the name and version of the governor.

```cairo hljs
#[starknet::contract]
mod MyGovernor {
    use openzeppelin_governance::governor::GovernorComponent::InternalTrait as GovernorInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorVotesQuorumFractionComponent::InternalTrait;
    use openzeppelin_governance::governor::extensions::{
        GovernorVotesQuorumFractionComponent, GovernorCountingSimpleComponent,
        GovernorCoreExecutionComponent,
    };
    use openzeppelin_governance::governor::{GovernorComponent, DefaultConfig};
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    pub const VOTING_DELAY: u64 = 86400; // 1 day
    pub const VOTING_PERIOD: u64 = 432_000; // 1 week
    pub const PROPOSAL_THRESHOLD: u256 = 10;
    pub const QUORUM_NUMERATOR: u256 = 40; // 4%

    component!(path: GovernorComponent, storage: governor, event: GovernorEvent);
    component!(
        path: GovernorVotesQuorumFractionComponent,
        storage: governor_votes,
        event: GovernorVotesEvent
    );
    component!(
        path: GovernorCountingSimpleComponent,
        storage: governor_counting_simple,
        event: GovernorCountingSimpleEvent
    );
    component!(
        path: GovernorCoreExecutionComponent,
        storage: governor_core_execution,
        event: GovernorCoreExecutionEvent
    );
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Governor
    #[abi(embed_v0)]
    impl GovernorImpl = GovernorComponent::GovernorImpl<ContractState>;

    // Extensions external
    #[abi(embed_v0)]
    impl QuorumFractionImpl =
        GovernorVotesQuorumFractionComponent::QuorumFractionImpl<ContractState>;

    // Extensions internal
    impl GovernorQuorumImpl = GovernorVotesQuorumFractionComponent::GovernorQuorum<ContractState>;
    impl GovernorVotesImpl = GovernorVotesQuorumFractionComponent::GovernorVotes<ContractState>;
    impl GovernorCountingSimpleImpl =
        GovernorCountingSimpleComponent::GovernorCounting<ContractState>;
    impl GovernorCoreExecutionImpl =
        GovernorCoreExecutionComponent::GovernorExecution<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        pub governor: GovernorComponent::Storage,
        #[substorage(v0)]
        pub governor_votes: GovernorVotesQuorumFractionComponent::Storage,
        #[substorage(v0)]
        pub governor_counting_simple: GovernorCountingSimpleComponent::Storage,
        #[substorage(v0)]
        pub governor_core_execution: GovernorCoreExecutionComponent::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        GovernorEvent: GovernorComponent::Event,
        #[flat]
        GovernorVotesEvent: GovernorVotesQuorumFractionComponent::Event,
        #[flat]
        GovernorCountingSimpleEvent: GovernorCountingSimpleComponent::Event,
        #[flat]
        GovernorCoreExecutionEvent: GovernorCoreExecutionComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, votes_token: ContractAddress) {
        self.governor.initializer();
        self.governor_votes.initializer(votes_token, QUORUM_NUMERATOR);
    }

    //
    // SNIP12 Metadata
    //

    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }

        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    //
    // Locally implemented extensions
    //

    pub impl GovernorSettings of GovernorComponent::GovernorSettingsTrait<ContractState> {
        /// See `GovernorComponent::GovernorSettingsTrait::voting_delay`.
        fn voting_delay(self: @GovernorComponent::ComponentState<ContractState>) -> u64 {
            VOTING_DELAY
        }

        /// See `GovernorComponent::GovernorSettingsTrait::voting_period`.
        fn voting_period(self: @GovernorComponent::ComponentState<ContractState>) -> u64 {
            VOTING_PERIOD
        }

        /// See `GovernorComponent::GovernorSettingsTrait::proposal_threshold`.
        fn proposal_threshold(self: @GovernorComponent::ComponentState<ContractState>) -> u256 {
            PROPOSAL_THRESHOLD
        }
    }
}
```

### Timelock

It is good practice to add a timelock to governance decisions. This allows users to exit the system if they disagree
with a decision before it is executed. We will use OpenZeppelin’s [TimelockController](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/timelock) in combination with the
GovernorTimelockExecution extension.

|     |     |
| --- | --- |
|  | When using a timelock, it is the timelock that will execute proposals and thus the timelock that should<br>hold any funds, ownership, and access control roles. |

TimelockController uses an [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access#role_based_accesscontrol) setup that we need to understand in order to set up roles.

The Proposer role is in charge of queueing operations: this is the role the Governor instance must be granted,
and it MUST be the only proposer (and canceller) in the system.

The Executor role is in charge of executing already available operations: we can assign this role to the special
zero address to allow anyone to execute (if operations can be particularly time sensitive, the Governor should be made Executor instead).

The Canceller role is in charge of canceling operations: the Governor instance must be granted this role,
and it MUST be the only canceller in the system.

Lastly, there is the Admin role, which can grant and revoke the two previous roles: this is a very sensitive role that will be granted automatically to the timelock itself, and optionally to a second account, which can be used for ease of setup but should promptly renounce the role.

The following example uses the GovernorTimelockExecution extension, together with GovernorSettings, and uses a
fixed quorum value instead of a percentage:

```cairo hljs
#[starknet::contract]
pub mod MyTimelockedGovernor {
    use openzeppelin_governance::governor::GovernorComponent::InternalTrait as GovernorInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorSettingsComponent::InternalTrait as GovernorSettingsInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorTimelockExecutionComponent::InternalTrait as GovernorTimelockExecutionInternalTrait;
    use openzeppelin_governance::governor::extensions::GovernorVotesComponent::InternalTrait as GovernorVotesInternalTrait;
    use openzeppelin_governance::governor::extensions::{
        GovernorVotesComponent, GovernorSettingsComponent, GovernorCountingSimpleComponent,
        GovernorTimelockExecutionComponent
    };
    use openzeppelin_governance::governor::{GovernorComponent, DefaultConfig};
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    pub const VOTING_DELAY: u64 = 86400; // 1 day
    pub const VOTING_PERIOD: u64 = 432_000; // 1 week
    pub const PROPOSAL_THRESHOLD: u256 = 10;
    pub const QUORUM: u256 = 100_000_000;

    component!(path: GovernorComponent, storage: governor, event: GovernorEvent);
    component!(path: GovernorVotesComponent, storage: governor_votes, event: GovernorVotesEvent);
    component!(
        path: GovernorSettingsComponent, storage: governor_settings, event: GovernorSettingsEvent
    );
    component!(
        path: GovernorCountingSimpleComponent,
        storage: governor_counting_simple,
        event: GovernorCountingSimpleEvent
    );
    component!(
        path: GovernorTimelockExecutionComponent,
        storage: governor_timelock_execution,
        event: GovernorTimelockExecutionEvent
    );
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Governor
    #[abi(embed_v0)]
    impl GovernorImpl = GovernorComponent::GovernorImpl<ContractState>;

    // Extensions external
    #[abi(embed_v0)]
    impl VotesTokenImpl = GovernorVotesComponent::VotesTokenImpl<ContractState>;
    #[abi(embed_v0)]
    impl GovernorSettingsAdminImpl =
        GovernorSettingsComponent::GovernorSettingsAdminImpl<ContractState>;
    #[abi(embed_v0)]
    impl TimelockedImpl =
        GovernorTimelockExecutionComponent::TimelockedImpl<ContractState>;

    // Extensions internal
    impl GovernorVotesImpl = GovernorVotesComponent::GovernorVotes<ContractState>;
    impl GovernorSettingsImpl = GovernorSettingsComponent::GovernorSettings<ContractState>;
    impl GovernorCountingSimpleImpl =
        GovernorCountingSimpleComponent::GovernorCounting<ContractState>;
    impl GovernorTimelockExecutionImpl =
        GovernorTimelockExecutionComponent::GovernorExecution<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        pub governor: GovernorComponent::Storage,
        #[substorage(v0)]
        pub governor_votes: GovernorVotesComponent::Storage,
        #[substorage(v0)]
        pub governor_settings: GovernorSettingsComponent::Storage,
        #[substorage(v0)]
        pub governor_counting_simple: GovernorCountingSimpleComponent::Storage,
        #[substorage(v0)]
        pub governor_timelock_execution: GovernorTimelockExecutionComponent::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        GovernorEvent: GovernorComponent::Event,
        #[flat]
        GovernorVotesEvent: GovernorVotesComponent::Event,
        #[flat]
        GovernorSettingsEvent: GovernorSettingsComponent::Event,
        #[flat]
        GovernorCountingSimpleEvent: GovernorCountingSimpleComponent::Event,
        #[flat]
        GovernorTimelockExecutionEvent: GovernorTimelockExecutionComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState, votes_token: ContractAddress, timelock_controller: ContractAddress
    ) {
        self.governor.initializer();
        self.governor_votes.initializer(votes_token);
        self.governor_settings.initializer(VOTING_DELAY, VOTING_PERIOD, PROPOSAL_THRESHOLD);
        self.governor_timelock_execution.initializer(timelock_controller);
    }

    //
    // SNIP12 Metadata
    //

    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }

        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    //
    // Locally implemented extensions
    //

    impl GovernorQuorum of GovernorComponent::GovernorQuorumTrait<ContractState> {
        /// See `GovernorComponent::GovernorQuorumTrait::quorum`.
        fn quorum(self: @GovernorComponent::ComponentState<ContractState>, timepoint: u64) -> u256 {
            QUORUM
        }
    }
}
```

## Interface

This is the full interface of the `Governor` implementation:

```cairo hljs
#[starknet::interface]
pub trait IGovernor<TState> {
    fn name(self: @TState) -> felt252;
    fn version(self: @TState) -> felt252;
    fn COUNTING_MODE(self: @TState) -> ByteArray;
    fn hash_proposal(self: @TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn state(self: @TState, proposal_id: felt252) -> ProposalState;
    fn proposal_threshold(self: @TState) -> u256;
    fn proposal_snapshot(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_deadline(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_proposer(self: @TState, proposal_id: felt252) -> ContractAddress;
    fn proposal_eta(self: @TState, proposal_id: felt252) -> u64;
    fn proposal_needs_queuing(self: @TState, proposal_id: felt252) -> bool;
    fn voting_delay(self: @TState) -> u64;
    fn voting_period(self: @TState) -> u64;
    fn quorum(self: @TState, timepoint: u64) -> u256;
    fn get_votes(self: @TState, account: ContractAddress, timepoint: u64) -> u256;
    fn get_votes_with_params(
        self: @TState, account: ContractAddress, timepoint: u64, params: Span<felt252>
    ) -> u256;
    fn has_voted(self: @TState, proposal_id: felt252, account: ContractAddress) -> bool;
    fn propose(ref self: TState, calls: Span<Call>, description: ByteArray) -> felt252;
    fn queue(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn execute(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn cancel(ref self: TState, calls: Span<Call>, description_hash: felt252) -> felt252;
    fn cast_vote(ref self: TState, proposal_id: felt252, support: u8) -> u256;
    fn cast_vote_with_reason(
        ref self: TState, proposal_id: felt252, support: u8, reason: ByteArray
    ) -> u256;
    fn cast_vote_with_reason_and_params(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        reason: ByteArray,
        params: Span<felt252>
    ) -> u256;
    fn cast_vote_by_sig(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        voter: ContractAddress,
        signature: Span<felt252>
    ) -> u256;
    fn cast_vote_with_reason_and_params_by_sig(
        ref self: TState,
        proposal_id: felt252,
        support: u8,
        voter: ContractAddress,
        reason: ByteArray,
        params: Span<felt252>,
        signature: Span<felt252>
    ) -> u256;
    fn nonces(self: @TState, voter: ContractAddress) -> felt252;
    fn relay(ref self: TState, call: Call);
}
```

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance)

[Multisig →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/multisig)Governance - OpenZeppelin Docs

# Governance

This crate includes primitives for on-chain governance.

## Governor

This modular system of Governor components allows the deployment of easily customizable on-chain voting protocols.

|     |     |
| --- | --- |
|  | For a walkthrough of how to implement a Governor, check the [Governor](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/governor) page. |

### `IGovernor`

```cairo hljs
use openzeppelin_governance::governor::interface::IGovernor;
```

Interface of a governor contract.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x1100a1f8546595b5bd75a6cd8fcc5b015370655e66f275963321c5cd0357ac9

Functions

- [`name()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-name)

- [`version()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-version)

- [`COUNTING_MODE()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-COUNTING_MODE)

- [`hash_proposal(calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-hash_proposal)

- [`state(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-state)

- [`proposal_threshold()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_threshold)

- [`proposal_snapshot(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_snapshot)

- [`proposal_deadline(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_deadline)

- [`proposal_proposer(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_proposer)

- [`proposal_eta(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_eta)

- [`proposal_needs_queuing(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-proposal_needs_queuing)

- [`voting_delay()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-voting_delay)

- [`voting_period()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-voting_period)

- [`quorum(timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-quorum)

- [`get_votes(account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-get_votes)

- [`get_votes_with_params(account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-get_votes_with_params)

- [`has_voted(proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-has_voted)

- [`propose(calls, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-propose)

- [`queue(calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-queue)

- [`execute(calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-execute)

- [`cancel(proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cancel)

- [`cast_vote(proposal_id, support)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote)

- [`cast_vote_with_reason(proposal_id, support, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_with_reason)

- [`cast_vote_with_reason_and_params(proposal_id, support, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_with_reason_and_params)

- [`cast_vote_by_sig(proposal_id, support, reason, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_by_sig)

- [`cast_vote_with_reason_and_params_by_sig(proposal_id, support, reason, params, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-cast_vote_with_reason_and_params_by_sig)

- [`nonces(voter)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-nonces)

- [`relay(call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-relay)


Events

- [`ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalCreated)

- [`ProposalQueued(proposal_id, eta_seconds)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalQueued)

- [`ProposalExecuted(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalExecuted)

- [`ProposalCanceled(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-ProposalCanceled)

- [`VoteCast(voter, proposal_id, support, weight, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-VoteCast)

- [`VoteCastWithParams(voter, proposal_id, support, weight, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IGovernor-VoteCastWithParams)


#### Functions

#### `name() → felt252` external

Name of the governor instance (used in building the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `version() → felt252` external

Version of the governor instance (used in building [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `COUNTING_MODE() → ByteArray` external

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs
to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs
that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in
`GovernorBravo`.

- `quorum=bravo` means that only For votes are counted towards quorum.

- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.


If a counting module makes use of encoded `params`, it should include this under a `params`
key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between
for/against/abstain.

- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.


|     |     |
| --- | --- |
|  | The string can be decoded by the standard [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)<br>JavaScript class. |

#### `hash_proposal(calls: Span<Call>, description_hash: felt252) → felt252` external

Hashing function used to (re)build the proposal id from the proposal details.

#### `state(proposal_id: felt252) → ProposalState` external

Returns the state of a proposal, given its id.

#### `proposal_threshold() → u256` external

The number of votes required in order for a voter to become a proposer.

#### `proposal_snapshot(proposal_id: felt252) → u64` external

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot is performed at the
end of this block. Hence, voting for this proposal starts at the beginning of the following block.

#### `proposal_deadline(proposal_id: felt252) → u64` external

Timepoint at which votes close. If using block number, votes close at the end of this block, so
it is possible to cast a vote during this block.

#### `proposal_proposer(proposal_id: felt252) → ContractAddress` external

The account that created a proposal.

#### `proposal_eta(proposal_id: felt252) → u64` external

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and
`proposal_deadline`, this doesn’t use the governor clock, and instead relies on the
executor’s clock which may be different. In most cases this will be a timestamp.

#### `proposal_needs_queuing(proposal_id: felt252) → bool` external

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

#### `voting_delay() → u64` external

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in
depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

#### `voting_period() → u64` external

Delay between when a vote starts and when it ends. The unit this duration is expressed in depends on
the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

|     |     |
| --- | --- |
|  | The `voting_delay` can delay the start of the vote. This must be considered when<br>setting the voting duration compared to the voting delay. |

|     |     |
| --- | --- |
|  | This value is stored when the proposal is submitted so that possible changes to the<br>value do not affect proposals that have already been submitted. |

#### `quorum(timepoint: u64) → u256` external

Minimum number of votes required for a proposal to be successful.

|     |     |
| --- | --- |
|  | The `timepoint` parameter corresponds to the snapshot used for counting vote. This<br>allows the quorum to scale depending on values such as the total supply of a token at this<br>timepoint. |

#### `get_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the voting power of an `account` at a specific `timepoint`.

|     |     |
| --- | --- |
|  | This can be implemented in a number of ways, for example by reading the delegated<br>balance from one (or multiple) `ERC20Votes` tokens. |

#### `get_votes_with_params(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` external

Returns the voting power of an `account` at a specific `timepoint`, given additional encoded parameters.

#### `has_voted(proposal_id: felt252, account: ContractAddress) → bool` external

Returns whether an `account` has cast a vote on a proposal.

#### `propose(calls: Span<Call>, description: ByteArray) → felt252` external

Creates a new proposal. Vote starts after a delay specified by `voting_delay` and lasts for a duration specified by `voting_period`.

|     |     |
| --- | --- |
|  | The state of the Governor and targets may change between the proposal creation and its execution.<br>This may be the result of third party actions on the targeted contracts, or other governor proposals.<br>For example, the balance of this contract could be updated or its access control permissions may be<br>modified, possibly compromising the proposal’s ability to execute successfully (e.g. the governor<br>doesn’t have enough value to cover a proposal with multiple transfers). |

Returns the id of the proposal.

#### `queue(calls: Span<Call>, description_hash: felt252) → felt252` external

Queue a proposal. Some governors require this step to be performed before execution can
happen. If queuing is not necessary, this function may revert.

Queuing a proposal requires the quorum to be reached, the vote to be successful, and the
deadline to be reached.

Returns the id of the proposal.

#### `execute(calls: span<Call>, description_hash: felt252) → felt252` external

Execute a successful proposal. This requires the quorum to be reached, the vote to be
successful, and the deadline to be reached. Depending on the governor it might also be
required that the proposal was queued and that some delay passed.

|     |     |
| --- | --- |
|  | Some modules can modify the requirements for execution, for example by adding an<br>additional timelock (See `timelock_controller`). |

Returns the id of the proposal.

#### `cancel(calls: Span<Call>, description_hash: felt252) → felt252` external

Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending
state, i.e. before the vote starts.

Returns the id of the proposal.

#### `cast_vote(proposal_id: felt252, support: u8) → u256` external

Cast a vote on a proposal.

Returns the weight of the vote.

#### `cast_vote_with_reason(proposal_id: felt252, support: u8, reason: ByteArray) → u256` external

Cast a vote on a proposal with a `reason`.

Returns the weight of the vote.

#### `cast_vote_with_reason_and_params(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256` external

Cast a vote on a proposal with a reason and additional encoded parameters.

Returns the weight of the vote.

#### `cast_vote_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256` external

Cast a vote on a proposal using the voter’s signature.

Returns the weight of the vote.

#### `cast_vote_with_reason_and_params_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256` external

Cast a vote on a proposal with a reason and additional encoded parameters using the `voter`'s signature.

Returns the weight of the vote.

#### `nonces(voter: ContractAddress) → felt252` external

Returns the next unused nonce for an address.

#### `relay(call: Call)` external

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like
when using a timelock, this function can be invoked in a governance proposal to recover
tokens that were sent to the governor contract by mistake.

|     |     |
| --- | --- |
|  | If the executor is simply the governor itself, use of `relay` is redundant. |

#### Events

#### `ProposalCreated(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)` event

Emitted when a proposal is created.

#### `ProposalQueued(proposal_id: felt252, eta_seconds: u64)` event

Emitted when a proposal is queued.

#### `ProposalExecuted(proposal_id: felt252)` event

Emitted when a proposal is executed.

#### `ProposalCanceled(proposal_id: felt252)` event

Emitted when a proposal is canceled.

#### `VoteCast(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)` event

Emitted when a vote is cast.

#### `VoteCastWithParams(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)` event

Emitted when a vote is cast with params.

### `GovernorComponent`

```cairo hljs
use openzeppelin_governance::governor::GovernorComponent;
```

Core of the governance system.

|     |     |
| --- | --- |
|  | The extension traits presented below are what make the GovernorComponent a modular and configurable system. The embeddable<br>and internal implementations depends on these trait. They can be implemented locally in the contract, or through the provided library<br>[component extensions](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#governor_extensions). |

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

Extensions traits

GovernorSettingsTrait

- [`voting_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorSettingsTrait-voting_delay)

- [`voting_period(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorSettingsTrait-voting_period)

- [`proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorSettingsTrait-proposal_threshold)


GovernorQuorumTrait

- [`quorum(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorQuorumTrait-quorum)


GovernorCountingTrait

- [`counting_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-counting_mode)

- [`count_vote(self, proposal_id, account, support, total_weight, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-count_vote)

- [`has_voted(self, proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-has_voted)

- [`quorum_reached(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-quorum_reached)

- [`vote_succeeded(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorCountingTrait-vote_succeeded)


GovernorVotesTrait

- [`clock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorVotesTrait-clock)

- [`clock_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorVotesTrait-clock_mode)

- [`get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorVotesTrait-get_votes)


GovernorExecutionTrait

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-state)

- [`executor(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-executor)

- [`execute_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-execute_operations)

- [`queue_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-queue_operations)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-proposal_needs_queuing)

- [`cancel_operations(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-GovernorExecutionTrait-cancel_operations)


Embeddable Implementations

GovernorImpl

- [`name(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-name)

- [`version(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-version)

- [`COUNTING_MODE(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-COUNTING_MODE)

- [`hash_proposal(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-hash_proposal)

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-state)

- [`proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_threshold)

- [`proposal_snapshot(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_snapshot)

- [`proposal_deadline(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_deadline)

- [`proposal_proposer(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_proposer)

- [`proposal_eta(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_eta)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-proposal_needs_queuing)

- [`voting_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-voting_delay)

- [`voting_period(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-voting_period)

- [`quorum(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-quorum)

- [`get_votes(self, account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-get_votes)

- [`get_votes_with_params(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-get_votes_with_params)

- [`has_voted(self, proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-has_voted)

- [`propose(self, calls, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-propose)

- [`queue(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-queue)

- [`execute(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-execute)

- [`cancel(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cancel)

- [`cast_vote(self, proposal_id, support)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote)

- [`cast_vote_with_reason(self, proposal_id, support, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_with_reason)

- [`cast_vote_with_reason_and_params(self, proposal_id, support, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_with_reason_and_params)

- [`cast_vote_by_sig(self, proposal_id, support, reason, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_by_sig)

- [`cast_vote_with_reason_and_params_by_sig(self, proposal_id, support, reason, params, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-cast_vote_with_reason_and_params_by_sig)

- [`nonces(self, voter)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-nonces)

- [`relay(self, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-relay)


Internal Implementations

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-initializer)

- [`get_proposal(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-get_proposal)

- [`is_valid_description_for_proposer(self, proposer, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-is_valid_description_for_proposer)

- [`_hash_proposal(self, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_hash_proposal)

- [`_proposal_snapshot(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_snapshot)

- [`_proposal_deadline(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_deadline)

- [`_proposal_proposer(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_proposer)

- [`_proposal_eta(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_eta)


InternalExtendedImpl

- [`assert_only_governance(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-assert_only_governance)

- [`validate_state(self, proposal_id, allowed_states)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-validate_state)

- [`use_nonce(self, voter)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-use_nonce)

- [`_get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_get_votes)

- [`_proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_proposal_threshold)

- [`_state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_state)

- [`_propose(self, calls, description, proposer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_propose)

- [`_cancel(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_cancel)

- [`_count_vote(self, proposal_id, account, support, total_weight, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_count_vote)

- [`_cast_vote(self, proposal_id, voter, support, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-_cast_vote)


Events

- [`ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCreated)

- [`ProposalQueued(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalQueued)

- [`ProposalExecuted(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalExecuted)

- [`ProposalCanceled(proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCanceled)

- [`VoteCast(voter, proposal_id, support, weight, reason)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast)

- [`VoteCastWithParams(voter, proposal_id, support, weight, reason, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams)


#### Extensions traits functions

#### `voting_delay(self: @ContractState) → u64` extension

Must return the delay, in number of timepoints, between when the proposal is created and when the vote starts. This can be
increased to leave time for users to buy voting power, or delegate it, before the voting of a
proposal starts.

#### `voting_period(self: @ContractState) → u64` extension

Must return the delay, in number of timepoints, between the vote start and vote end.

#### `proposal_threshold(self: @ContractState) → u256` extension

Must return the minimum number of votes that an account must have to create a proposal.

#### `quorum(self: @ContractState, timepoint: u64) → u256` extension

Must return the minimum number of votes required for a proposal to succeed.

#### `counting_mode(self: @ContractState) → ByteArray` extension

Must return a description of the possible `support` values for `cast_vote` and the way these votes are counted,
meant to be consumed by UIs to show correct vote options and interpret the results.
See [COUNTING\_MODE](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-COUNTING_MODE) for more details.

#### `count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256` extension

Must register a vote for `proposal_id` by `account` with a given `support`, voting `weight` and voting `params`.

|     |     |
| --- | --- |
|  | Support is generic and can represent various things depending on the voting system used. |

#### `has_voted(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool` extension

Must return whether an account has cast a vote on a proposal.

#### `quorum_reached(self: @ContractState, proposal_id: felt252) → bool` extension

Must return whether the minimum quorum has been reached for a proposal.

#### `vote_succeeded(self: @ContractState, proposal_id: felt252) → bool` extension

Must return whether a proposal has succeeded or not.

#### `clock(self: @ContractState) → u64` extension

Must return the current timepoint according to the clock mode the governor is operating in.

|     |     |
| --- | --- |
|  | For now, only timestamp is supported. |

#### `clock_mode(self: @ContractState) → ByteArray` extension

Must return the clock mode the governor is operating in.

|     |     |
| --- | --- |
|  | For now, only timestamp is supported. |

#### `get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` extension

Must return the voting power of an account at a specific timepoint with the given parameters.

#### `state(self: @ContractState, proposal_id: felt252) → ProposalState` extension

Must return the state of a proposal at the current time.

The state can be either:

- `Pending`: The proposal does not exist yet.

- `Active`: The proposal is active.

- `Canceled`: The proposal has been canceled.

- `Defeated`: The proposal has been defeated.

- `Succeeded`: The proposal has succeeded.

- `Queued`: The proposal has been queued.

- `Executed`: The proposal has been executed.


#### `executor(self: @ContractState) → ContractAddress` internal

Must return the address through which the governor executes action.
Should be used to specify whether the module execute actions through another contract
such as a timelock.

|     |     |
| --- | --- |
|  | MUST be the governor itself, or an instance of TimelockController with the<br>governor as the only proposer, canceller, and executor. |

|     |     |
| --- | --- |
|  | When the executor is not the governor itself (i.e. a timelock), it can call<br>functions that are restricted with the `assert_only_governance` guard, and also<br>potentially execute transactions on behalf of the governor. Because of this, this module<br>is designed to work with the TimelockController as the unique potential external<br>executor. |

#### `execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Execution mechanism. Can be used to modify the way operations are executed (for example adding a vault/timelock).

#### `queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Queuing mechanism. Can be used to modify the way queuing is
performed (for example adding a vault/timelock).

Requirements:

- Must return a timestamp that describes the expected ETA for execution. If the returned
value is 0, the core will consider queueing did not succeed, and the public `queue`
function will revert.


#### `proposal_needs_queuing(self: @ContractState) → bool` internal

Must return whether proposals need to be queued before execution. This usually indicates if the proposal needs to go through a timelock.

#### `cancel_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Cancel mechanism. Can be used to modify the way canceling is
performed (for example adding a vault/timelock).

#### Embeddable functions

#### `name() → felt252` external

Name of the governor instance (used in building the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `version() → felt252` external

Version of the governor instance (used in building [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### `COUNTING_MODE() → ByteArray` external

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs
to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs
that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in
`GovernorBravo`.

- `quorum=bravo` means that only For votes are counted towards quorum.

- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.


If a counting module makes use of encoded `params`, it should include this under a `params`
key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between
for/against/abstain.

- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.


|     |     |
| --- | --- |
|  | The string can be decoded by the standard [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)<br>JavaScript class. |

#### `hash_proposal(calls: Span<Call>, description_hash: felt252) → felt252` external

Hashing function used to (re)build the proposal id from the proposal details.

#### `state(proposal_id: felt252) → ProposalState` external

Returns the state of a proposal, given its id.

#### `proposal_threshold() → u256` external

The number of votes required in order for a voter to become a proposer.

#### `proposal_snapshot(proposal_id: felt252) → u64` external

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot is performed at the
end of this block. Hence, voting for this proposal starts at the beginning of the following block.

#### `proposal_deadline(proposal_id: felt252) → u64` external

Timepoint at which votes close. If using block number, votes close at the end of this block, so
it is possible to cast a vote during this block.

#### `proposal_proposer(proposal_id: felt252) → ContractAddress` external

The account that created a proposal.

#### `proposal_eta(proposal_id: felt252) → u64` external

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and
`proposal_deadline`, this doesn’t use the governor clock, and instead relies on the
executor’s clock which may be different. In most cases this will be a timestamp.

#### `proposal_needs_queuing(proposal_id: felt252) → bool` external

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

#### `voting_delay() → u64` external

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in
depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

#### `voting_period() → u64` external

Delay between the vote start and vote end. The unit this duration is expressed in depends on
the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

|     |     |
| --- | --- |
|  | The `voting_delay` can delay the start of the vote. This must be considered when<br>setting the voting duration compared to the voting delay. |

|     |     |
| --- | --- |
|  | This value is stored when the proposal is submitted so that possible changes to the<br>value do not affect proposals that have already been submitted. |

#### `quorum(timepoint: u64) → u256` external

Minimum number of votes required for a proposal to be successful.

|     |     |
| --- | --- |
|  | The `timepoint` parameter corresponds to the snapshot used for counting vote. This<br>allows the quorum to scale depending on values such as the total supply of a token at this<br>timepoint. |

#### `get_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the voting power of an `account` at a specific `timepoint`.

|     |     |
| --- | --- |
|  | This can be implemented in a number of ways, for example by reading the delegated<br>balance from one (or multiple) `ERC20Votes` tokens. |

#### `get_votes_with_params(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` external

Returns the voting power of an account at a specific timepoint, given additional encoded parameters.

#### `has_voted(proposal_id: felt252, account: ContractAddress) → bool` external

Returns whether an account has cast a vote on a proposal.

#### `propose(calls: Span<Call>, description: ByteArray) → felt252` external

Creates a new proposal. Voting starts after the delay specified by `voting_delay` and
lasts for a duration specified by `voting_period`. Returns the id of the proposal.

This function has opt-in frontrunning protection, described in
`is_valid_description_for_proposer`.

|     |     |
| --- | --- |
|  | The state of the Governor and targets may change between the proposal creation<br>and its execution. This may be the result of third party actions on the targeted<br>contracts, or other governor proposals. For example, the balance of this contract could<br>be updated or its access control permissions may be modified, possibly compromising the<br>proposal’s ability to execute successfully (e.g. the governor doesn’t have enough value<br>to cover a proposal with multiple transfers). |

Requirements:

- The proposer must be authorized to submit the proposal.

- The proposer must have enough votes to submit the proposal if `proposal_threshold` is
greater than zero.

- The proposal must not already exist.


Emits a [ProposalCreated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCreated) event.

#### `queue(calls: Span<Call>, description_hash: felt252) → felt252` external

Queues a proposal. Some governors require this step to be performed before execution can
happen. If queuing is not necessary, this function may revert.
Queuing a proposal requires the quorum to be reached, the vote to be successful, and the
deadline to be reached.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` state.

- The queue operation must return a non-zero ETA.


Emits a [ProposalQueued](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalQueued) event.

#### `execute(calls: span<Call>, description_hash: felt252) → felt252` external

Executes a successful proposal. This requires the quorum to be reached, the vote to be
successful, and the deadline to be reached. Depending on the governor it might also be
required that the proposal was queued and that some delay passed.

|     |     |
| --- | --- |
|  | Some modules can modify the requirements for execution, for example by adding an<br>additional timelock (See `timelock_controller`). |

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` or `Queued` state.


Emits a [ProposalExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalExecuted) event.

#### `cancel(calls: Span<Call>, description_hash: felt252) → felt252` external

Cancels a proposal. A proposal is cancellable by the proposer, but only while it is
Pending state, i.e. before the vote starts.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Pending` state.

- The caller must be the proposer of the proposal.


Emits a [ProposalCanceled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCanceled) event.

#### `cast_vote(proposal_id: felt252, support: u8) → u256` external

Cast a vote.

Requirements:

- The proposal must be active.


Emits a [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event.

#### `cast_vote_with_reason(proposal_id: felt252, support: u8, reason: ByteArray) → u256` external

Cast a vote with a `reason`.

Requirements:

- The proposal must be active.


Emits a [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event.

#### `cast_vote_with_reason_and_params(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256` external

Cast a vote with a `reason` and additional serialized `params`.

Requirements:

- The proposal must be active.


Emits either:

- [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event if no params are provided.

- [VoteCastWithParams](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams) event otherwise.


#### `cast_vote_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256` external

Cast a vote using the `voter`'s signature.

Requirements:

- The proposal must be active.

- The nonce in the signed message must match the account’s current nonce.

- `voter` must implement `SRC6::is_valid_signature`.

- `signature` must be valid for the message hash.


Emits a [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event.

#### `cast_vote_with_reason_and_params_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256` external

Cast a vote with a `reason` and additional serialized `params` using the `voter`'s
signature.

Requirements:

- The proposal must be active.

- The nonce in the signed message must match the account’s current nonce.

- `voter` must implement `SRC6::is_valid_signature`.

- `signature` must be valid for the message hash.


Emits either:

- [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event if no params are provided.

- [VoteCastWithParams](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams) event otherwise.


#### `nonces(voter: ContractAddress) → felt252` external

Returns the next unused nonce for an address.

#### `relay(call: Call)` external

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like
when using a timelock, this function can be invoked in a governance proposal to recover
tokens that were sent to the governor contract by mistake.

|     |     |
| --- | --- |
|  | If the executor is simply the governor itself, use of `relay` is redundant. |

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Initializes the contract by registering the supported interface id.

#### `get_proposal(self: @ContractState, proposal_id: felt252) → ProposalCore` internal

Returns the proposal object given its id.

#### `is_valid_description_for_proposer(self: @ContractState, proposer: ContractAddress, description: ByteArray) → bool` internal

Checks if the proposer is authorized to submit a proposal with the given description.

If the proposal description ends with `#proposer=0x???`, where `0x???` is an address
written as a hex string (case insensitive), then the submission of this proposal will
only be authorized to said address.

This is used for frontrunning protection. By adding this pattern at the end of their
proposal, one can ensure that no other address can submit the same proposal. An attacker
would have to either remove or change that part, which would result in a different
proposal id.

|     |     |
| --- | --- |
|  | In Starknet, the Sequencer ensures the order of transactions, but frontrunning<br>can still be achieved by nodes, and potentially other actors in the future with<br>sequencer decentralization. |

If the description does not match this pattern, it is unrestricted and anyone can submit
it. This includes:

- If the `0x???` part is not a valid hex string.

- If the `0x???` part is a valid hex string, but does not contain exactly 64 hex digits.

- If it ends with the expected suffix followed by newlines or other whitespace.

- If it ends with some other similar suffix, e.g. `#other=abc`.

- If it does not end with any such suffix.


#### `_hash_proposal(self: @ContractState, calls: Span<Call>, description_hash: felt252) → felt252` internal

Returns the proposal id computed from the given parameters.

The proposal id is computed as a Pedersen hash of:

- The array of calls being proposed

- The description hash


#### `_proposal_snapshot(self: @ContractState, proposal_id: felt252) → u64` internal

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot
is performed at the end of this block. Hence, voting for this proposal starts at the
beginning of the following block.

#### `_proposal_deadline(self: @ContractState, proposal_id: felt252) → u64` internal

Timepoint at which votes close. If using block number, votes close at the end of this
block, so it is possible to cast a vote during this block.

#### `_proposal_proposer(self: @ContractState, proposal_id: felt252) → ContractAddress` internal

The account that created a proposal.

#### `_proposal_eta(self: @ContractState, proposal_id: felt252) → u64` internal

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot`
and `proposal_deadline`, this doesn’t use the governor clock, and instead relies on the
executor’s clock which may be different. In most cases this will be a timestamp.

#### `assert_only_governance(self: @ContractState)` internal

Asserts that the caller is the governance executor.

|     |     |
| --- | --- |
|  | When the executor is not the governor itself (i.e. a timelock), it can call<br>functions that are restricted with this modifier, and also potentially execute<br>transactions on behalf of the governor. Because of this, this module is designed to work<br>with the TimelockController as the unique potential external executor. The timelock<br>MUST have the governor as the only proposer, canceller, and executor. |

#### `validate_state(self: @ContractState, proposal_id: felt252, state: ProposalState)` internal

Validates that a proposal is in the expected state. Otherwise it panics.

#### `use_nonce(ref self: ContractState) → felt252` internal

Consumes a nonce, returns the current value, and increments nonce.

#### `_get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Internal wrapper for `GovernorVotesTrait::get_votes`.

#### `_proposal_threshold(self: @ContractState) → u256` internal

Internal wrapper for `GovernorProposeTrait::proposal_threshold`.

#### `_state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal, given its id.

Requirements:

- The proposal must exist.


#### `_propose(ref self: ContractState, calls: Span<Call>, description_hash: felt252) → felt252` internal

Internal propose mechanism. Returns the proposal id.

Requirements:

- The proposal must not already exist.


Emits a [ProposalCreated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-ProposalCreated) event.

#### `_cancel(ref self: ContractState, proposal_id: felt252)` internal

Internal cancel mechanism with minimal restrictions.

A proposal can be cancelled in any state other than Canceled or Executed.

|     |     |
| --- | --- |
|  | Once cancelled, a proposal can’t be re-submitted. |

#### `_count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, weight: u256, params: Span<felt252>)` internal

Internal wrapper for `GovernorCountingTrait::count_vote`.

#### `_cast_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, reason: ByteArray, params: Span<felt252>) → u256` internal

Internal vote-casting mechanism.

Checks that the vote is pending and that it has not been cast yet.
This function retrieves the voting weight using `get_votes` and then calls
the `_count_vote` internal function.

Emits either:

- [VoteCast](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCast) event if no params are provided.

- [VoteCastWithParams](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-VoteCastWithParams) event otherwise.


#### Events

#### `ProposalCreated(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)` event

Emitted when a proposal is created.

#### `ProposalQueued(proposal_id: felt252, eta_seconds: u64)` event

Emitted when a proposal is queued.

#### `ProposalExecuted(proposal_id: felt252)` event

Emitted when a proposal is executed.

#### `ProposalCanceled(proposal_id: felt252)` event

Emitted when a proposal is canceled.

#### `VoteCast(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)` event

Emitted when a vote is cast.

#### `VoteCastWithParams(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)` event

Emitted when a vote is cast with params.

## Governor extensions

The Governor component can (and must) be extended by implementing the [extensions traits](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent-Extensions-Traits-Traits) to add the desired functionality.
This can be achieved by directly implementing the traits on your contract, or by using a set of ready-to-use extensions
provided by the library, which are presented below.

### `GovernorCoreExecutionComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorCoreExecutionComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) providing an execution mechanism directly through
the Governor itself. For a timelocked execution mechanism, see
[GovernorTimelockExecutionComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent).

Extension traits implementations

GovernorExecution

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-state)

- [`executor(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-executor)

- [`execute_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-execute_operations)

- [`queue_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-queue_operations)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-proposal_needs_queuing)

- [`cancel_operations(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCoreExecutionComponent-cancel_operations)


#### Extension traits functions

#### `state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.


#### `executor(self: @ContractState) → ContractAddress` internal

Returns the executor address.

In this case, it returns the governor contract address since execution is performed directly through it.

#### `execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)` internal

Executes the proposal’s operations directly through the governor contract.

#### `queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64` internal

In this implementation, queuing is not required so it returns 0.

#### `proposal_needs_queuing(self: @ContractState, proposal_id: felt252) → bool` internal

In this implementation, it always returns false.

#### `cancel_operations(ref self: ContractState, proposal_id: felt252, description_hash: felt252)` internal

Cancels a proposal’s operations.

### `GovernorCountingSimpleComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorCountingSimpleComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for simple vote counting with three options.

Extension traits implementations

GovernorCounting

- [`counting_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-counting_mode)

- [`count_vote(self, proposal_id, account, support, total_weight, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-count_vote)

- [`has_voted(self, proposal_id, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-has_voted)

- [`quorum_reached(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-quorum_reached)

- [`vote_succeeded(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorCountingSimpleComponent-vote_succeeded)


#### Extension traits functions

#### `counting_mode(self: @ContractState) → ByteArray` internal

Returns `"support=bravo&quorum=for,abstain"`.

- `support=bravo` indicates that the support follows the Governor Bravo format where voters can vote For, Against, or Abstain

- `quorum=for,abstain` indicates that both For and Abstain votes count toward quorum


#### `count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256` internal

Records a vote for a proposal.

The support value follows the `VoteType` enum (0=Against, 1=For, 2=Abstain).

Returns the weight that was counted.

#### `has_voted(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool` internal

Returns whether an account has cast a vote on a proposal.

#### `quorum_reached(self: @ContractState, proposal_id: felt252) → bool` internal

Returns whether a proposal has reached quorum.

In this implementation, both For and Abstain votes count toward quorum.

#### `vote_succeeded(self: @ContractState, proposal_id: felt252) → bool` internal

Returns whether a proposal has succeeded.

In this implementation, the For votes must be strictly greater than Against votes.

### `GovernorSettingsComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorSettingsComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for settings that are updatable through governance.

Extension traits implementations

GovernorSettings

- [`voting_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-voting_delay)

- [`voting_period(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-voting_period)

- [`proposal_threshold(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-proposal_threshold)


Embeddable implementations

GovernorSettingsAdminImpl

- [`set_voting_delay(self, new_voting_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-set_voting_delay)

- [`set_voting_period(self, new_voting_period)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-set_voting_period)

- [`set_proposal_threshold(self, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-set_proposal_threshold)


Internal implementations

InternalImpl

- [`initializer(self, new_voting_delay, new_voting_period, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-initializer)

- [`assert_only_governance(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-assert_only_governance)

- [`_set_voting_delay(self, new_voting_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-_set_voting_delay)

- [`_set_voting_period(self, new_voting_period)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-_set_voting_period)

- [`_set_proposal_threshold(self, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-_set_proposal_threshold)


Events

- [`VotingDelayUpdated(old_voting_delay, new_voting_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated)

- [`VotingPeriodUpdated(old_voting_period, new_voting_period)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated)

- [`ProposalThresholdUpdated(old_proposal_threshold, new_proposal_threshold)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated)


#### Extension traits functions

#### `voting_delay(self: @ContractState) → u64` internal

Returns the delay, between when a proposal is created and when voting starts.

#### `voting_period(self: @ContractState) → u64` internal

Returns the time period, during which votes can be cast.

#### `proposal_threshold(self: @ContractState) → u256` internal

Returns the minimum number of votes required for an account to create a proposal.

#### Embeddable functions

#### `set_voting_delay(ref self: ContractState, new_voting_delay: u64)` external

Sets the voting delay.

Requirements:

- Caller must be the governance executor.


|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting delay is the same as the old one. |

May emit a [VotingDelayUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated) event.

#### `set_voting_period(ref self: ContractState, new_voting_period: u64)` external

Sets the voting period.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting period is the same as the<br>old one. |

Requirements:

- Caller must be the governance executor.

- `new_voting_period` must be greater than 0.


May emit a [VotingPeriodUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated) event.

#### `set_proposal_threshold(ref self: ContractState, new_proposal_threshold: u256)` external

Sets the proposal threshold.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new proposal threshold is the same as<br>the old one. |

Requirements:

- Caller must be the governance executor.


May emit a [ProposalThresholdUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### Internal functions

#### `initializer(ref self: ContractState, initial_voting_delay: u64, initial_voting_period: u64, initial_proposal_threshold: u256)` internal

Initializes the component by setting the default values.

Requirements:

- `new_voting_period` must be greater than 0.


Emits a [VotingDelayUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated), [VotingPeriodUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated), and [ProposalThresholdUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### `assert_only_governance(ref self: ContractState)` internal

Asserts that the caller is the governance executor.

#### `_set_voting_delay(ref self: ContractState, new_voting_delay: u64)` internal

Internal function to update the voting delay.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting delay is the same as the<br>old one. |

May emit a [VotingDelayUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingDelayUpdated) event.

#### `_set_voting_period(ref self: ContractState, new_voting_period: u64)` internal

Internal function to update the voting period.

Requirements:

- `new_voting_period` must be greater than 0.


|     |     |
| --- | --- |
|  | This function does not emit an event if the new voting period is the same as the old one. |

May emit a [VotingPeriodUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-VotingPeriodUpdated) event.

#### `_set_proposal_threshold(ref self: ContractState, new_proposal_threshold: u256)` internal

Internal function to update the proposal threshold.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new proposal threshold is the same as the old one. |

May emit a [ProposalThresholdUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### Events

#### `VotingDelayUpdated(old_voting_delay: u64, new_voting_delay: u64)` event

Emitted when the voting delay is updated.

#### `VotingPeriodUpdated(old_voting_period: u64, new_voting_period: u64)` event

Emitted when the voting period is updated.

#### `ProposalThresholdUpdated(old_proposal_threshold: u256, new_proposal_threshold: u256)` event

Emitted when the proposal threshold is updated.

### `GovernorVotesComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorVotesComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for voting weight extraction from a token with the [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes)
extension.

Extension traits implementations

GovernorVotes

- [`clock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-clock)

- [`clock_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-clock_mode)

- [`get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-get_votes)


Embeddable implementations

VotesTokenImpl

- [`token(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-token)


Internal implementations

InternalImpl

- [`initializer(self, votes_token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesComponent-initializer)


#### Extension traits functions

#### `clock(self: @ContractState) → u64` internal

Returns the current timepoint according to the time mode the contract is operating in.

In this implementation, returns the current block timestamp.

|     |     |
| --- | --- |
|  | [VotesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent) always uses the block timestamp for tracking checkpoints.<br>This must be updated in order to allow for more flexible clock modes. |

#### `clock_mode(self: @ContractState) → ByteArray` internal

Returns `"mode=timestamp&from=starknet::SN_MAIN"`.

See [https://eips.ethereum.org/EIPS/eip-6372#clock\_mode](https://eips.ethereum.org/EIPS/eip-6372#clock_mode)

#### `get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Returns the voting power of `account` at a specific `timepoint` using the votes token.

#### Embeddable functions

#### `token(self: @ContractState) → ContractAddress` external

Returns the votes token that voting power is sourced from.

#### Internal functions

#### `initializer(ref self: ContractState, votes_token: ContractAddress)` internal

Initializes the component by setting the votes token.

Requirements:

- `votes_token` must not be zero.


### `GovernorVotesQuorumFractionComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorVotesQuorumFractionComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) for voting weight extraction from a token with the
[IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) extension and a quorum expressed as a fraction of the total supply.

Extension traits implementations

GovernorQuorum

- [`quorum(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-quorum)


GovernorVotes

- [`clock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-clock)

- [`clock_mode(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-clock_mode)

- [`get_votes(self, account, timepoint, params)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-get_votes)


Embeddable implementations

QuorumFractionImpl

- [`token(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-token)

- [`current_quorum_numerator(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-current_quorum_numerator)

- [`quorum_numerator(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-quorum_numerator)

- [`quorum_denominator(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-quorum_denominator)


Internal implementations

InternalImpl

- [`initializer(self, votes_token, quorum_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-initializer)

- [`update_quorum_numerator(self, new_quorum_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-update_quorum_numerator)


Events

- [`QuorumNumeratorUpdated(old_quorum_numerator, new_quorum_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated)


#### Extension traits functions

#### `quorum(self: @ContractState, timepoint: u64) → u256` internal

It is computed as a percentage of the votes token total supply at a given `timepoint` in the past.

#### `clock(self: @ContractState) → u64` internal

Returns the current timepoint according to the time mode the contract is operating in.

In this implementation, returns the current block timestamp.

#### `clock_mode(self: @ContractState) → ByteArray` internal

Returns `"mode=timestamp&from=starknet::SN_MAIN"`.

See [https://eips.ethereum.org/EIPS/eip-6372#clock\_mode](https://eips.ethereum.org/EIPS/eip-6372#clock_mode)

#### `get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Returns the voting power of `account` at a specific `timepoint` using the votes token.

#### Embeddable functions

#### `token(self: @ContractState) → ContractAddress` external

Returns the address of the votes token used for voting power extraction.

#### `current_quorum_numerator(self: @ContractState) → u256` external

Returns the current quorum numerator value.

#### `quorum_numerator(self: @ContractState, timepoint: u64) → u256` external

Returns the quorum numerator value at a specific `timepoint` in the past.

#### `quorum_denominator(self: @ContractState) → u256` external

Returns the quorum denominator value.

#### Internal functions

#### `initializer(self: @ComponentState<TContractState>, votes_token: ContractAddress, quorum_numerator: u256)` internal

Initializes the component by setting the votes token and the initial quorum numerator value.

Requirements:

- `votes_token` must not be zero.

- `quorum_numerator` must be less than `quorum_denominator`.


Emits a [QuorumNumeratorUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated) event.

#### `update_quorum_numerator(self: @ComponentState<TContractState>, new_quorum_numerator: u256)` internal

Updates the quorum numerator.

|     |     |
| --- | --- |
|  | This function does not emit an event if the new quorum numerator is the same as the old one. |

Requirements:

- `new_quorum_numerator` must be less than `quorum_denominator`.


May emit a [QuorumNumeratorUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated) event.

#### Events

#### `QuorumNumeratorUpdated(old_quorum_numerator: u256, new_quorum_numerator: u256)` event

Emitted when the quorum numerator is updated.

### `GovernorTimelockExecutionComponent`

```cairo hljs
use openzeppelin_governance::governor::extensions::GovernorTimelockExecutionComponent;
```

Extension of [GovernorComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorComponent) that binds the execution process to an instance of a contract
implementing [TimelockControllerComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent). This adds a delay, enforced by the timelock
to all successful proposals (in addition to the voting duration).

|     |     |
| --- | --- |
|  | The Governor needs the [PROPOSER, EXECUTOR, and CANCELLER roles](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/timelock#roles) to work properly. |

Using this model means the proposal will be operated by the timelock and not by the
governor. Thus, the assets and permissions must be attached to the timelock. Any asset
sent to the governor will be inaccessible from a proposal, unless executed via
`Governor::relay`.

|     |     |
| --- | --- |
|  | Setting up the timelock to have additional proposers or cancellers besides<br>the governor is very risky, as it grants them the ability to: 1) execute operations as the<br>timelock, and thus possibly performing operations or accessing funds that are expected to only<br>be accessible through a vote, and 2) block governance proposals that have been approved by the<br>voters, effectively executing a Denial of Service attack. |

Extension traits implementations

GovernorExecution

- [`state(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-state)

- [`executor(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-executor)

- [`execute_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-execute_operations)

- [`queue_operations(self, proposal_id, calls, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-queue_operations)

- [`proposal_needs_queuing(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-proposal_needs_queuing)

- [`cancel_operations(self, proposal_id, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-cancel_operations)


Embeddable implementations

TimelockedImpl

- [`timelock(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-timelock)

- [`get_timelock_id(self, proposal_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-get_timelock_id)

- [`update_timelock(self, new_timelock)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-update_timelock)


Internal implementations

InternalImpl

- [`initializer(self, timelock_controller)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-initializer)

- [`assert_only_governance(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-assert_only_governance)

- [`timelock_salt(self, description_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-timelock_salt)

- [`get_timelock_dispatcher(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-get_timelock_dispatcher)

- [`_update_timelock(self, new_timelock)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-_update_timelock)


Events

- [`TimelockUpdated(old_timelock, new_timelock)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-TimelockUpdated)


#### Extension traits functions

#### `state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.


#### `executor(self: @ContractState) → ContractAddress` internal

Returns the executor address.

In this module, the executor is the timelock controller.

#### `execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)` internal

Runs the already queued proposal through the timelock.

#### `queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64` internal

Queue a proposal to the timelock.

Returns the eta for the execution of the queued proposal.

#### `proposal_needs_queuing(self: @ContractState, proposal_id: felt252) → bool` internal

In this implementation, it always returns true.

#### `cancel_operations(ref self: ContractState, proposal_id: felt252, description_hash: felt252)` internal

Cancels the timelocked proposal if it has already been queued.

#### Embeddable functions

#### `timelock(self: @ContractState) → ContractAddress` external

Returns the timelock controller address.

#### `get_timelock_id(self: @ContractState) → felt252` external

Returns the timelock proposal id for a given proposal id.

#### `update_timelock(ref self: ContractState, new_timelock: ContractAddress)` external

Updates the associated timelock.

Requirements:

- The caller must be the governance.


Emits a [TimelockUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-TimelockUpdated) event.

#### Internal functions

#### `initializer(ref self: ContractState, timelock: ContractAddress)` internal

Initializes the timelock controller.

Requirements:

- The timelock must not be the zero address.


#### `assert_only_governance(self: @ContractState)` internal

Ensures the caller is the executor (the timelock controller in this case).

#### `timelock_salt(self: @ContractState, description_hash: felt252) → felt252` internal

Computes the `TimelockController` operation salt as the XOR of
the governor address and `description_hash`.

It is computed with the governor address itself to avoid collisions across
governor instances using the same timelock.

#### `get_timelock_dispatcher(self: @ContractState) → ITimelockDispatcher` internal

Returns a dispatcher for interacting with the timelock controller.

#### `_update_timelock(ref self: ContractState, new_timelock: ContractAddress)` internal

Internal function to update the timelock controller address.

Emits a [TimelockUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#GovernorTimelockExecutionComponent-TimelockUpdated) event.

#### Events

#### `TimelockUpdated(old_timelock: ContractAddress, new_timelock: ContractAddress)` event

Emitted when the timelock controller is updated.

## Multisig

A Multisig module enhances security and decentralization by requiring multiple signers to
approve and execute transactions. Features include configurable quorum, signer management,
and self-administration, ensuring collective decision-making and transparency for critical
operations.

### `IMultisig`

```cairo hljs
use openzeppelin_governance::multisig::interface::IMultisig;
```

Interface of a multisig contract.

Functions

- [`get_quorum()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_quorum)

- [`is_signer(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_signer)

- [`get_signers()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_signers)

- [`is_confirmed(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_confirmed)

- [`is_confirmed_by(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_confirmed_by)

- [`is_executed(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-is_executed)

- [`get_submitted_block(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_submitted_block)

- [`get_transaction_state(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_transaction_state)

- [`get_transaction_confirmations(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-get_transaction_confirmations)

- [`hash_transaction(to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-hash_transaction)

- [`hash_transaction_batch(calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-hash_transaction_batch)

- [`add_signers(new_quorum, signers_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-add_signers)

- [`remove_signers(new_quorum, signers_to_remove)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-remove_signers)

- [`replace_signer(signer_to_remove, signer_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-replace_signer)

- [`change_quorum(new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-change_quorum)

- [`submit_transaction(to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-submit_transaction)

- [`submit_transaction_batch(calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-submit_transaction_batch)

- [`confirm_transaction(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-confirm_transaction)

- [`revoke_confirmation(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-revoke_confirmation)

- [`execute_transaction(to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-execute_transaction)

- [`execute_transaction_batch(calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-execute_transaction_batch)


Events

- [`SignerAdded(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerAdded)

- [`SignerRemoved(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerRemoved)

- [`QuorumUpdated(old_quorum, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated)

- [`TransactionSubmitted(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionSubmitted)

- [`TransactionConfirmed(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionConfirmed)

- [`ConfirmationRevoked(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-ConfirmationRevoked)

- [`TransactionExecuted(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-CallSalt)


#### Functions

#### `get_quorum() → u32` external

Returns the current quorum value. The quorum is the minimum number of confirmations required to approve a transaction.

#### `is_signer(signer: ContractAddress) → bool` external

Returns whether the given `signer` is registered. Only registered signers can submit, confirm, or execute transactions.

#### `get_signers() → Span<ContractAddress>` external

Returns the list of all current signers.

#### `is_confirmed(id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been confirmed.

#### `is_confirmed_by(id: TransactionID, signer: ContractAddress) → bool` external

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

#### `is_executed(id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been executed.

#### `get_submitted_block(id: TransactionID) → u64` external

Returns the block number when the transaction with the given `id` was submitted.

#### `get_transaction_state(id: TransactionID) → TransactionState` external

Returns the current state of the transaction with the given `id`.

#### `get_transaction_confirmations(id: TransactionID) → u32` external

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

#### `hash_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID` external

Returns the computed identifier of a transaction containing a single call.

#### `hash_transaction_batch(calls: Span<Call>, salt: felt252) → TransactionID` external

Returns the computed identifier of a transaction containing a batch of calls.

#### `add_signers(new_quorum: u32, signers_to_add: Span<ContractAddress>)` external

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after addition.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated) event if the quorum changes.

#### `remove_signers(new_quorum: u32, signers_to_remove: Span<ContractAddress>)` external

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after removal.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated) event if the quorum changes.

#### `replace_signer(signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` external

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.

- `signer_to_remove` must be an existing signer.

- `signer_to_add` must not be an existing signer.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-SignerAdded) event for the new signer.

#### `change_quorum(new_quorum: u32)` external

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be non-zero.

- `new_quorum` must be less than or equal to the total number of signers.


Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-QuorumUpdated) event if the quorum changes.

#### `submit_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID` external

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-CallSalt) event if `salt` is not zero.

#### `submit_transaction_batch(calls: Span<Call>, salt: felt252) → TransactionID` external

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-CallSalt) event if `salt` is not zero.

#### `confirm_transaction(id: TransactionID)` external

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.

- The transaction must exist and not be executed.

- The caller must not have already confirmed the transaction.


Emits a [TransactionConfirmed](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionConfirmed) event.

#### `revoke_confirmation(id: TransactionID)` external

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.

- The caller must have previously confirmed the transaction.


Emits a [ConfirmationRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-ConfirmationRevoked) event.

#### `execute_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionExecuted) event.

#### `execute_transaction_batch(calls: Span<Call>, salt: felt252)` external

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig-TransactionExecuted) event.

#### Events

#### `SignerAdded(signer: ContractAddress)` event

Emitted when a new `signer` is added.

#### `SignerRemoved(signer: ContractAddress)` event

Emitted when a `signer` is removed.

#### `QuorumUpdated(old_quorum: u32, new_quorum: u32)` event

Emitted when the `quorum` value is updated.

#### `TransactionSubmitted(id: TransactionID, signer: ContractAddress)` event

Emitted when a new transaction is submitted by a `signer`.

#### `TransactionConfirmed(id: TransactionID, signer: ContractAddress)` event

Emitted when a transaction is confirmed by a `signer`.

#### `ConfirmationRevoked(id: TransactionID, signer: ContractAddress)` event

Emitted when a `signer` revokes his confirmation.

#### `TransactionExecuted(id: TransactionID)` event

Emitted when a transaction is executed.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new transaction is submitted with non-zero salt.

### `MultisigComponent`

```cairo hljs
use openzeppelin_governance::multisig::MultisigComponent;
```

Component that implements [IMultisig](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IMultisig) and provides functionality for multisignature wallets,
including transaction management, quorum handling, and signer operations.

Embeddable Implementations

MultisigImpl

- [`get_quorum(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_quorum)

- [`is_signer(self, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_signer)

- [`get_signers(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_signers)

- [`is_confirmed(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_confirmed)

- [`is_confirmed_by(self, id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_confirmed_by)

- [`is_executed(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-is_executed)

- [`get_submitted_block(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_submitted_block)

- [`get_transaction_state(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_transaction_state)

- [`get_transaction_confirmations(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-get_transaction_confirmations)

- [`hash_transaction(self, to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-hash_transaction)

- [`hash_transaction_batch(self, calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-hash_transaction_batch)

- [`add_signers(ref self, new_quorum, signers_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-add_signers)

- [`remove_signers(ref self, new_quorum, signers_to_remove)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-remove_signers)

- [`replace_signer(ref self, signer_to_remove, signer_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-replace_signer)

- [`change_quorum(ref self, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-change_quorum)

- [`submit_transaction(ref self, to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-submit_transaction)

- [`submit_transaction_batch(ref self, calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-submit_transaction_batch)

- [`confirm_transaction(ref self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-confirm_transaction)

- [`revoke_confirmation(ref self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-revoke_confirmation)

- [`execute_transaction(ref self, to, selector, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-execute_transaction)

- [`execute_transaction_batch(ref self, calls, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-execute_transaction_batch)


Internal Implementations

InternalImpl

- [`initializer(ref self, quorum, signers)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-initializer)

- [`resolve_tx_state(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-resolve_tx_state)

- [`assert_one_of_signers(self, caller)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-assert_one_of_signers)

- [`assert_tx_exists(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-assert_tx_exists)

- [`assert_only_self(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-assert_only_self)

- [`_add_signers(ref self, new_quorum, signers_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_add_signers)

- [`_remove_signers(ref self, new_quorum, signers_to_remove)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_remove_signers)

- [`_replace_signer(ref self, signer_to_remove, signer_to_add)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_replace_signer)

- [`_change_quorum(ref self, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-_change_quorum)


Events

- [`SignerAdded(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded)

- [`SignerRemoved(signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved)

- [`QuorumUpdated(old_quorum, new_quorum)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated)

- [`TransactionSubmitted(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionSubmitted)

- [`TransactionConfirmed(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionConfirmed)

- [`ConfirmationRevoked(id, signer)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-ConfirmationRevoked)

- [`TransactionExecuted(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-CallSalt)


#### Embeddable functions

#### `get_quorum(self: @ContractState) → u32` external

Returns the current quorum value.

#### `is_signer(self: @ContractState, signer: ContractAddress) → bool` external

Checks if a given `signer` is registered.

#### `get_signers(self: @ContractState) → Span<ContractAddress>` external

Returns a list of all current signers.

#### `is_confirmed(self: @ContractState, id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been confirmed. A confirmed transaction has received the required number of confirmations (quorum).

#### `is_confirmed_by(self: @ContractState, id: TransactionID, signer: ContractAddress) → bool` external

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

#### `is_executed(self: @ContractState, id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been executed.

#### `get_submitted_block(self: @ContractState, id: TransactionID) → u64` external

Returns the block number when the transaction with the given `id` was submitted.

#### `get_transaction_state(self: @ContractState, id: TransactionID) → TransactionState` external

Returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.

- `Pending`: the transaction exists but hasn’t reached the required confirmations.

- `Confirmed`: the transaction has reached the required confirmations but hasn’t been executed.

- `Executed`: the transaction has been executed.


#### `get_transaction_confirmations(self: @ContractState, id: TransactionID) → u32` external

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

#### `hash_transaction(self: @ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Returns the computed identifier of a transaction containing a single call.

#### `hash_transaction_batch(self: @ContractState, calls: Span<Call>, salt: felt252)` external

Returns the computed identifier of a transaction containing a batch of calls.

#### `add_signers(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)` external

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after addition.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `remove_signers(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)` external

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be less than or equal to the total number of signers after removal.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `replace_signer(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` external

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.

- `signer_to_remove` must be an existing signer.

- `signer_to_add` must not be an existing signer.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for the new signer.

#### `change_quorum(ref self: ContractState, new_quorum: u32)` external

Updates the quorum value to `new_quorum`.

Requirements:

- The caller must be the contract itself.

- `new_quorum` must be non-zero.

- `new_quorum` must be less than or equal to the total number of signers.


Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `submit_transaction(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-CallSalt) event if `salt` is not zero.

#### `submit_transaction_batch(ref self: ContractState, calls: Span<Call>, salt: felt252)` external

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.

- The transaction must not have been submitted before.


Emits a [TransactionSubmitted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionSubmitted) event.

Emits a [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-CallSalt) event if `salt` is not zero.

#### `confirm_transaction(ref self: ContractState, id: TransactionID)` external

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.

- The transaction must exist and not be executed.

- The caller must not have already confirmed the transaction.


Emits a [TransactionConfirmed](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionConfirmed) event.

#### `revoke_confirmation(ref self: ContractState, id: TransactionID)` external

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.

- The caller must have previously confirmed the transaction.


Emits a [ConfirmationRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-ConfirmationRevoked) event.

#### `execute_transaction(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionExecuted) event.

#### `execute_transaction_batch(ref self: ContractState, calls: Span<Call>, salt: felt252)` external

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.

- The transaction must be confirmed and not yet executed.


Emits a [TransactionExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-TransactionExecuted) event.

#### Internal functions

#### `initializer(ref self: ContractState, quorum: u32, signers: Span<ContractAddress>)` internal

Initializes the Multisig component with the initial `quorum` and `signers`.
This function must be called during contract initialization to set up the initial state.

Requirements:

- `quorum` must be non-zero and less than or equal to the number of `signers`.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event.

#### `resolve_tx_state(self: @ContractState, id: TransactionID) → TransactionState` internal

Resolves and returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.

- `Pending`: the transaction exists but hasn’t reached the required confirmations.

- `Confirmed`: the transaction has reached the required confirmations but hasn’t been executed.

- `Executed`: the transaction has been executed.


#### `assert_one_of_signers(self: @ContractState, caller: ContractAddress)` internal

Asserts that the `caller` is one of the registered signers.

Requirements:

- The `caller` must be a registered signer.


#### `assert_tx_exists(self: @ContractState, id: TransactionID)` internal

Asserts that a transaction with the given `id` exists.

Requirements:

- The transaction with the given `id` must have been submitted.


#### `assert_only_self(self: @ContractState)` internal

Asserts that the caller is the contract itself.

Requirements:

- The caller must be the contract’s own address.


#### `_add_signers(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)` internal

Adds new signers and updates the quorum.

Requirements:

- Each signer address must be non-zero.

- `new_quorum` must be non-zero and less than or equal to the total number of signers after addition.


Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for each new signer added.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `_remove_signers(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)` internal

Removes existing signers and updates the quorum.

Requirements:

- `new_quorum` must be non-zero and less than or equal to the total number of signers
after removal.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### `_replace_signer(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` internal

Replaces an existing signer with a new signer.

Requirements:

- `signer_to_remove` must be an existing signer.

- `signer_to_add` must not be an existing signer.

- `signer_to_add` must be a non-zero address.


Emits a [SignerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-SignerAdded) event for the new signer.

#### `_change_quorum(ref self: ContractState, new_quorum: u32)` internal

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- `new_quorum` must be non-zero.

- `new_quorum` must be less than or equal to the total number of signers.


Emits a [QuorumUpdated](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### Events

#### `SignerAdded(signer: ContractAddress)` event

Emitted when a new `signer` is added.

#### `SignerRemoved(signer: ContractAddress)` event

Emitted when a `signer` is removed.

#### `QuorumUpdated(old_quorum: u32, new_quorum: u32)` event

Emitted when the `quorum` value is updated.

#### `TransactionSubmitted(id: TransactionID, signer: ContractAddress)` event

Emitted when a new transaction is submitted by a `signer`.

#### `TransactionConfirmed(id: TransactionID, signer: ContractAddress)` event

Emitted when a transaction is confirmed by a `signer`.

#### `ConfirmationRevoked(id: TransactionID, signer: ContractAddress)` event

Emitted when a `signer` revokes his confirmation.

#### `TransactionExecuted(id: TransactionID)` event

Emitted when a transaction is executed.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new transaction is submitted with non-zero salt.

## Timelock

In a governance system, `TimelockControllerComponent` is in charge of introducing a delay between a proposal and its execution.

### `ITimelock`

```cairo hljs
use openzeppelin_governance::timelock::interface::ITimelock;
```

Interface of a timelock contract.

Functions

- [`is_operation(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation)

- [`is_operation_pending(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation_pending)

- [`is_operation_ready(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation_ready)

- [`is_operation_done(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-is_operation_done)

- [`get_timestamp(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_timestamp)

- [`get_operation_state(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_operation_state)

- [`get_min_delay()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_min_delay)

- [`hash_operation(call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-hash_operation)

- [`hash_operation_batch(calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-hash_operation_batch)

- [`schedule(call, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-schedule)

- [`schedule_batch(calls, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-schedule_batch)

- [`cancel(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-cancel)

- [`execute(call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-execute)

- [`execute_batch(calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-execute_batch)

- [`update_delay(new_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-update_delay)


Events

- [`CallScheduled(id, index, call, predecessor, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled)

- [`CallExecuted(id, index, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt)

- [`CallCancelled(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallCancelled)

- [`MinDelayChanged(old_duration, new_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged)


#### Functions

#### `is_operation(id: felt252) → bool` external

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

#### `is_operation_pending(id: felt252) → bool` external

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

#### `is_operation_ready(id: felt252) → bool` external

Returns whether the `id` OperationState is `Ready` or not.

#### `is_operation_done(id: felt252) → bool` external

Returns whether the `id` OperationState is `Done` or not.

#### `get_timestamp(id: felt252) → u64` external

Returns the timestamp at which `id` becomes `Ready`.

|     |     |
| --- | --- |
|  | `0` means the OperationState is `Unset` and `1` means the OperationState<br>is `Done`. |

#### `get_operation_state(id: felt252) → OperationState` external

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.

- `Waiting`: the operation has been scheduled and is pending the scheduled delay.

- `Ready`: the timer has expired, and the operation is eligible for execution.

- `Done`: the operation has been executed.


#### `get_min_delay() → u64` external

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

#### `hash_operation(call: Call, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a single transaction.

#### `hash_operation_batch(calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a batch of transactions.

#### `schedule(call: Call, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.


Emits [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `schedule_batch(calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.


Emits one [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event for each transaction in the batch.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `cancel(id: felt252)` external

Cancel an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.

- `id` must be a pending operation.


Emits a [CallCancelled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallCancelled) event.

#### `execute(call: Call, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because [`_after_call(self: @ContractState, id: felt252)` internal](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_after_call)<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `execute_batch(calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event for each Call.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because `_after_call`<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `update_delay(new_delay: u64)` external

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.


Emits a [MinDelayChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged) event.

#### Events

#### `CallScheduled(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)` event

Emitted when `call` is scheduled as part of operation `id`.

#### `CallExecuted(id: felt252, index: felt252, call: Call)` event

Emitted when `call` is performed as part of operation `id`.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new proposal is scheduled with non-zero salt.

#### `CallCancelled(id: felt252)` event

Emitted when operation `id` is cancelled.

#### `MinDelayChanged(old_duration: u64, new_duration: u64)` event

Emitted when the minimum delay for future operations is modified.

### `TimelockControllerComponent`

```cairo hljs
use openzeppelin_governance::timelock::TimelockControllerComponent;
```

Component that implements [ITimelock](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock) and enables the implementing contract to act as a timelock controller.

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

TimelockMixinImpl

- [`TimelockImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-Embeddable-Impls-TimelockImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)

- [`AccessControlImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls)

- [`AccessControlCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls)


Embeddable Implementations

TimelockImpl

- [`is_operation(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation)

- [`is_operation_pending(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation_pending)

- [`is_operation_ready(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation_ready)

- [`is_operation_done(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-is_operation_done)

- [`get_timestamp(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-get_timestamp)

- [`get_operation_state(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-get_operation_state)

- [`get_min_delay(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-get_min_delay)

- [`hash_operation(self, call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-hash_operation)

- [`hash_operation_batch(self, calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-hash_operation_batch)

- [`schedule(self, call, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-schedule)

- [`schedule_batch(self, calls, predecessor, salt, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-schedule_batch)

- [`cancel(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-cancel)

- [`execute(self, call, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-execute)

- [`execute_batch(self, calls, predecessor, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-execute_batch)

- [`update_delay(self, new_delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-update_delay)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


AccessControlImpl

- [`has_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-has_role)

- [`get_role_admin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-get_role_admin)

- [`grant_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role)

- [`revoke_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role)

- [`renounce_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-renounce_role)


AccessControlCamelImpl

- [`hasRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-hasRole)

- [`getRoleAdmin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-getRoleAdmin)

- [`grantRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grantRole)

- [`revokeRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revokeRole)

- [`renounceRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-renounceRole)


Internal Implementations

InternalImpl

- [`initializer(self, min_delay, proposers, executors, admin)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-initializer)

- [`assert_only_role(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-assert_only_role)

- [`assert_only_role_or_open_role(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-assert_only_role_or_open_role)

- [`assert_only_self(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-assert_only_self)

- [`_before_call(self, id, predecessor)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_before_call)

- [`_after_call(self, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_after_call)

- [`_schedule(self, id, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_schedule)

- [`_execute(self, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_execute)


Events

- [`CallScheduled(id, index, call, predecessor, delay)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallScheduled)

- [`CallExecuted(id, index, call)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallExecuted)

- [`CallSalt(id, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallSalt)

- [`CallCancelled(id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-CallCancelled)

- [`MinDelayChanged(old_duration, new_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-MinDelayChanged)


#### Embeddable functions

#### `is_operation(self: @ContractState, id: felt252) → bool` external

Returns whether `id` corresponds to a registered operation.
This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

#### `is_operation_pending(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is pending or not.
Note that a pending operation may be either `Waiting` or `Ready`.

#### `is_operation_ready(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is `Ready` or not.

#### `is_operation_done(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is `Done` or not.

#### `get_timestamp(self: @ContractState, id: felt252) → u64` external

Returns the timestamp at which `id` becomes `Ready`.

|     |     |
| --- | --- |
|  | `0` means the OperationState is `Unset` and `1` means the OperationState<br>is `Done`. |

#### `get_operation_state(self: @ContractState, id: felt252) → OperationState` external

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.

- `Waiting`: the operation has been scheduled and is pending the scheduled delay.

- `Ready`: the timer has expired, and the operation is eligible for execution.

- `Done`: the operation has been executed.


#### `get_min_delay(self: @ContractState) → u64` external

Returns the minimum delay in seconds for an operation to become valid.
This value can be changed by executing an operation that calls `update_delay`.

#### `hash_operation(self: @ContractState, call: Call, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a single transaction.

#### `hash_operation_batch(self: @ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a batch of transactions.

#### `schedule(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

- The proposal must not already exist.

- `delay` must be greater than or equal to the min delay.


Emits [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `schedule_batch(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

- The proposal must not already exist.

- `delay` must be greater than or equal to the min delay.


Emits one [CallScheduled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallScheduled) event for each transaction in the batch.
Emits [CallSalt](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallSalt) event if `salt` is not zero.

#### `cancel(ref self: ContractState, id: felt252)` external

Cancels an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.

- `id` must be a pending operation.


Emits a [CallCancelled](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallCancelled) event.

#### `execute(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because [`_after_call(self: @ContractState, id: felt252)` internal](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent-_after_call)<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `execute_batch(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.

- `id` must be in Ready OperationState.

- `predecessor` must either be `0` or in Done OperationState.


Emits a [CallExecuted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-CallExecuted) event for each Call.

|     |     |
| --- | --- |
|  | This function can reenter, but it doesn’t pose a risk because `_after_call`<br>checks that the proposal is pending, thus any modifications to the operation during<br>reentrancy should be caught. |

#### `update_delay(ref self: ContractState, new_delay: u64)` external

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling
and later executing an operation where the timelock is the target and the data
is the serialized call to this function.


Emits a [MinDelayChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged) event.

#### Internal functions

#### `initializer(ref self: ContractState, min_delay: u64, proposers: Span<ContractAddress>, executors: Span<ContractState>, admin: ContractAddress)` internal

Initializes the contract by registering support for SRC5 and AccessControl.

This function also configures the contract with the following parameters:

- `min_delay`: initial minimum delay in seconds for operations.

- `proposers`: accounts to be granted proposer and canceller roles.

- `executors`: accounts to be granted executor role.

- `admin`: optional account to be granted admin role; disable with zero address.


|     |     |
| --- | --- |
|  | The optional admin can aid with initial configuration of roles after deployment<br>without being subject to delay, but this role should be subsequently renounced in favor of<br>administration through timelocked proposals. |

Emits two [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) events for each account in `proposers` with `PROPOSER_ROLE` and
`CANCELLER_ROLE` roles.

Emits a [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event for each account in `executors` with `EXECUTOR_ROLE` role.

May emit a [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event for `admin` with `DEFAULT_ADMIN_ROLE` role (if `admin` is
not zero).

Emits [MinDelayChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-MinDelayChanged) event.

#### `assert_only_role(self: @ContractState, role: felt252)` internal

Validates that the caller has the given `role`.
Otherwise it panics.

#### `assert_only_role_or_open_role(self: @ContractState, role: felt252)` internal

Validates that the caller has the given `role`.
If `role` is granted to the zero address, then this is considered an open role which allows anyone to be the caller.

#### `assert_only_self(self: @ContractState)` internal

Validates that the caller is the timelock contract itself.
Otherwise it panics.

#### `_before_call(self: @ContractState, id: felt252, predecessor: felt252)` internal

Private function that checks before execution of an operation’s calls.

Requirements:

- `id` must be in the `Ready` OperationState.

- `predecessor` must either be zero or be in the `Done` OperationState.


#### `_after_call(self: @ContractState, id: felt252)` internal

Private function that checks after execution of an operation’s calls
and sets the OperationState of `id` to `Done`.

Requirements:

- `id` must be in the Ready OperationState.


#### `_schedule(ref self: ContractState, id: felt252, delay: u64)` internal

Private function that schedules an operation that is to become valid after a given `delay`.

#### `_execute(ref self: ContractState, call: Call)` internal

Private function that executes an operation’s calls.

#### Events

#### `CallScheduled(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)` event

Emitted when `call` is scheduled as part of operation `id`.

#### `CallExecuted(id: felt252, index: felt252, call: Call)` event

Emitted when `call` is performed as part of operation `id`.

#### `CallSalt(id: felt252, salt: felt252)` event

Emitted when a new proposal is scheduled with non-zero salt.

#### `CallCancelled(id: felt252)` event

Emitted when operation `id` is cancelled.

#### `MinDelayChanged(old_duration: u64, new_duration: u64)` event

Emitted when the minimum delay for future operations is modified.

## Votes

The `VotesComponent` provides a flexible system for tracking and delegating voting power. This system allows users to delegate their voting power to other addresses, enabling more active participation in governance.

### `IVotes`

```cairo hljs
use openzeppelin_governance::votes::interface::IVotes;
```

Common interface for Votes-enabled contracts.

Functions

- [`get_votes(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-get_votes)

- [`get_past_votes(account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-get_past_votes)

- [`get_past_total_supply(timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-get_past_total_supply)

- [`delegates(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-delegates)

- [`delegate(delegatee)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-delegate)

- [`delegate_by_sig(delegator, delegatee, nonce, expiry, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes-delegate_by_sig)


#### Functions

#### `get_votes(account: ContractAddress) → u256` external

Returns the current amount of votes that `account` has.

#### `get_past_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the amount of votes that `account` had at a specific moment in the past.

#### `get_past_total_supply(timepoint: u64) → u256` external

Returns the total supply of votes available at a specific moment in the past.

|     |     |
| --- | --- |
|  | This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.<br>Votes that have not been delegated are still part of total supply, even though they would not participate in a<br>vote. |

#### `delegates(account: ContractAddress) → ContractAddress` external

Returns the delegate that `account` has chosen.

#### `delegate(delegatee: ContractAddress)` external

Delegates votes from the sender to `delegatee`.

#### `delegate_by_sig(delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)` external

Delegates votes from `delegator` to `delegatee` through a [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message signature validation.

### `VotesComponent`

```cairo hljs
use openzeppelin_governance::votes::VotesComponent;
```

Component that implements the [IVotes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#IVotes) interface and provides a flexible system for tracking and delegating voting power.

By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.

|     |     |
| --- | --- |
|  | When using this module, your contract must implement the [VotingUnitsTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotingUnitsTrait). For convenience, this is done automatically for `ERC20` and `ERC721` tokens. |

Voting Units Trait Implementations

ERC20VotesImpl

- [`get_voting_units(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-ERC20VotesImpl-get_voting_units)


ERC721VotesImpl

- [`get_voting_units(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-ERC721VotesImpl-get_voting_units)


Embeddable Implementations

VotesImpl

- [`get_votes(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_votes)

- [`get_past_votes(self, account, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_past_votes)

- [`get_past_total_supply(self, timepoint)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_past_total_supply)

- [`delegates(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegates)

- [`delegate(self, delegatee)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegate)

- [`delegate_by_sig(self, delegator, delegatee, nonce, expiry, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegate_by_sig)


Internal implementations

InternalImpl

- [`get_total_supply(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-get_total_supply)

- [`move_delegate_votes(self, from, to, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-move_delegate_votes)

- [`transfer_voting_units(self, from, to, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-transfer_voting_units)

- [`num_checkpoints(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-num_checkpoints)

- [`checkpoints(self, account, pos)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-checkpoints)

- [`_delegate(self, account, delegatee)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-_delegate)


Events

- [`DelegateChanged(delegator, from_delegate, to_delegate)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged)

- [`DelegateVotesChanged(delegate, previous_votes, new_votes)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged)


#### ERC20VotesImpl

#### `get_voting_units(self: @ContractState, account: ContractAddress) → u256` internal

Returns the number of voting units for a given account.

This implementation is specific to ERC20 tokens, where the balance
of tokens directly represents the number of voting units.

|     |     |
| --- | --- |
|  | This implementation will work out of the box if the ERC20 component<br>is implemented in the final contract. |

|     |     |
| --- | --- |
|  | This implementation assumes tokens map to voting units 1:1.<br>Any deviation from this formula when transferring voting units (e.g. by using hooks)<br>may compromise the internal vote accounting. |

#### ERC721VotesImpl

#### `get_voting_units(self: @ContractState, account: ContractAddress) → u256` internal

Returns the number of voting units for a given account.

This implementation is specific to ERC721 tokens, where each token
represents one voting unit. The function returns the balance of
ERC721 tokens for the specified account.

|     |     |
| --- | --- |
|  | This implementation will work out of the box if the ERC721 component<br>is implemented in the final contract. |

|     |     |
| --- | --- |
|  | This implementation assumes tokens map to voting units 1:1.<br>Any deviation from this formula when transferring voting units (e.g. by using hooks)<br>may compromise the internal vote accounting. |

#### Embeddable functions

#### `get_votes(self: @ContractState, account: ContractAddress) → u256` external

Returns the current amount of votes that `account` has.

#### `get_past_votes(self: @ContractState, account: ContractAddress, timepoint: u64) → u256` external

Returns the amount of votes that `account` had at a specific moment in the past.

Requirements:

- `timepoint` must be in the past.


#### `get_past_total_supply(self: @ContractState, timepoint: u64) → u256` external

Returns the total supply of votes available at a specific moment in the past.

|     |     |
| --- | --- |
|  | This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.<br>Votes that have not been delegated are still part of total supply, even though they would not participate in a<br>vote. |

Requirements:

- `timepoint` must be in the past.


#### `delegates(self: @ContractState, account: ContractAddress) → ContractAddress` external

Returns the delegate that `account` has chosen.

#### `delegate(ref self: ContractState, delegatee: ContractAddress)` external

Delegates votes from the sender to `delegatee`.

Emits a [DelegateChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### `delegate_by_sig(ref self: ContractState, delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)` external

Delegates votes from `delegator` to `delegatee` through a [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message signature validation.

Requirements:

- `expiry` must not be in the past.

- `nonce` must match the account’s current nonce.

- `delegator` must implement `SRC6::is_valid_signature`.

- `signature` should be valid for the message hash.


Emits a [DelegateChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### Internal functions

#### `get_total_supply(self: @ContractState) → u256` internal

Returns the current total supply of votes.

#### `move_delegate_votes(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)` internal

Moves delegated votes from one delegate to another.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### `transfer_voting_units(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)` internal

Transfers, mints, or burns voting units.

To register a mint, `from` should be zero. To register a burn, `to`
should be zero. Total supply of voting units will be adjusted with mints and burns.

|     |     |
| --- | --- |
|  | If voting units are based on an underlying transferable asset (like a token), you must call this function every time the asset is transferred to keep the internal voting power accounting in sync. For ERC20 and ERC721 tokens, this is typically handled using hooks. |

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### `num_checkpoints(self: @ContractState, account: ContractAddress) → u64` internal

Returns the number of checkpoints for `account`.

#### `checkpoints(self: @ContractState, account: ContractAddress, pos: u64) → Checkpoint` internal

Returns the `pos`-th checkpoint for `account`.

#### `_delegate(ref self: ContractState, account: ContractAddress, delegatee: ContractAddress)` internal

Delegates all of `account`'s voting units to `delegatee`.

Emits a [DelegateChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-DelegateVotesChanged) events.

#### Events

#### `DelegateChanged(delegator: ContractAddress, from_delegate: ContractAddress, to_delegate: ContractAddress)` event

Emitted when an account changes their delegate.

#### `DelegateVotesChanged(delegate: ContractAddress, previous_votes: u256, new_votes: u256)` event

Emitted when a token transfer or delegate change results in changes to a delegate’s number of votes.

### `VotingUnitsTrait`

```cairo hljs
pub trait VotingUnitsTrait<TState> {
    fn get_voting_units(self: @TState, account: ContractAddress) -> u256;
}
```

A trait that must be implemented when integrating [VotesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent) into a contract. It offers a mechanism to retrieve the number of voting units for a given account at the current time.

Functions

- [`get_voting_units(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotingUnitsTrait-get_voting_units)


#### Functions

#### `get_voting_units(self: @TState, account: ContractAddress) → u256` external

Returns the number of voting units for a given account. For ERC20, this is typically the token balance. For ERC721, this is typically the number of tokens owned.

|     |     |
| --- | --- |
|  | While any formula can be used as a measure of voting units, the internal vote accounting of the contract may be<br>compromised if voting units are transferred in any external flow by following a different formula.<br>For example, when implementing the hook for ERC20, the number of voting units transferred should match the formula given by the<br>`get_voting_units` implementation. |

[← Votes](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/votes)

[Introspection →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection)Compiling - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Compiling

The OpenZeppelin CLI integrates the Solidity compiler to seamlessly compile your Solidity contracts into Ethereum Virtual Machine (EVM) bytecode.

This guide covers how compiling works, its different options, and the output format.

## Running the Compiler

Most CLI commands, like `oz create` or `oz upgrade`, will automatically compile your projects smart contracts when required, so you don’t need to worry about doing this yourself.

However, you can also just run the compilation by itself, using the [`oz compile`](https://docs.openzeppelin.com/cli/2.7/commands#compile) command:

```console hljs language-shell
$ npx oz compile
```

When executed for the first time, all smart contracts in the `contracts` directory will be compiled at once. Further invocations of `compile` however will _only_ compile contracts that have changed (along with their dependents), speeding up the process.

## Settings

All compilation settings are passed directly to the Solidity compiler. Check out its [documentation](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html) for more info on how each setting affects compilation.

### Picking a Compiler Version

Each Solidity source files should be annotated with a [version pragma](https://solidity.readthedocs.io/en/v0.5.15/layout-of-source-files.html#version-pragma) that indicates which compiler versions can be used to compile it.

The CLI will parse all of these declarations and automatically select the latest compiler version that matches all your version pragmas. This single version will be the one used to compile _all_ of your contracts.

|     |     |
| --- | --- |
|  | It is often best to use permissive pragmas, such as `^0.5.0` or `^0.6.0` (which select the 0.5.x and 0.6.x lines of the compiler, respectively), and let the CLI do the rest. |

Alternatively, you can also specify a compiler version when calling `oz compile` by using the `--solc-version` option:

```console hljs language-shell
$ npx oz compile --solc-version 0.5.14
```

In all cases, the selected Solidity compiler version will be automatically downloaded and saved to cache from the [official distribution list](https://solc-bin.ethereum.org/bin/list.json). Once the version is set, subsequent compilations will [use that same version](https://docs.openzeppelin.com/cli/2.7/compiling#saving-your-settings).

|     |     |
| --- | --- |
|  | For enhanced performance, you can [install the native Solidity binaries](https://solidity.readthedocs.io/en/v0.5.15/installing-solidity.html#binary-packages) on your machine: the CLI will automatically pick it up when compiling if it matches the target version. Massive speedups can be achieved by doing this, specially on large projects. Just make sure it’s available on your [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable))!. |

### Picking an EVM Version

Each version of the Solidity compiler ships with a default [EVM version](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html#setting-the-evm-version-to-target), which corresponds to the mainnet EVM version at the time of release. The CLI will respect these defaults unless otherwise instructed.

In some occasions, it may be necessary to select a specific EVM version. This is achieved via the `--evm-version` flag:

```console hljs language-shell
$ npx oz compile --evm-version berlin
```

### Using the Optimizer

The Solidity compiler features an optional optimizer: it can produce smaller and more gas-efficient EVM bytecode, at the cost of making it harder to understand.

The optimizer is enabled or disabled with the `--optimizer` option:

```console hljs language-shell
$ npx oz compile --optimizer on
```

For fine tuning, you can also pass the `--optimizer-runs` option. This number should be an estimate of how many times you expect your smart contract to be called: pass 1 for one-offs, or a higher number for regularly used contracts. The default value is 200.

```console hljs language-shell
$ npx oz compile --optimizer on --optimizer-runs 100
```

|     |     |
| --- | --- |
|  | Don’t worry if you’re not sure what value to pass to `--optimizer-runs`: the gains achieved by using this parameter correctly are very limited. |

### Saving Your Settings

All compilation settings, including compiler version, EVM version and optimizer configuration are stored in your [project configuration file](https://docs.openzeppelin.com/cli/2.7/configuration#project.json), will be used in all successive compilations.

To modify these settings, run `oz compile` with the newly desired values, or simply edit the configuration file manually.

## Compilation Results

### Storing Compiled Artifacts

The output of the compiler is a number of `.json` files (one per compiled contract), which hold all relevant information: compiler settings, copies of the source, and most importantly, the resulting ABI and bytecode. These files are stored in the `build/contracts` directory, which the CLI will create for you automatically.

|     |     |
| --- | --- |
|  | These files can be large, and since compilation is a fast process it’s often a good idea to add this directory to your `.gitignore`:<br>```diff hljs<br> // .gitignore<br>+build/contracts<br>``` |

### Loading Your Contracts

The format of the `.json` artifacts is standard, and compatible with all major smart contract tools out there, such as Truffle, Buidler, and Etherlime.

If you want to load your compiled contracts and interact with them from JavaScript code, we recommend using the [**OpenZeppelin Contract Loader**](https://docs.openzeppelin.com/contract-loader/0.6/):

```javascript hljs
const { setupLoader } = require('@openzeppelin/contract-loader');

const loader = setupLoader({
  provider,        // either a web3 provider or a web3 instance
  defaultSender,   // optional
});

// Load build/contracts/ERC20.json
const ERC20 = loader.web3.fromArtifact('ERC20');

// Deploy contract
const token = await ERC20.deploy().send();

// Query state and send transaction
const balance = await token.methods.balanceOf(sender).call();
await token.methods.transfer(receiver, balance).send({ from: sender });
```

[← Using Dependencies](https://docs.openzeppelin.com/cli/2.7/dependencies)

[Deploying With `CREATE2` →](https://docs.openzeppelin.com/cli/2.7/deploying-with-create2)Contracts for Cairo - OpenZeppelin Docs

# Contracts for Cairo

**A library for secure smart contract development** written in Cairo for [Starknet](https://starkware.co/product/starknet/). This library consists of a set of [reusable components](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components) to build custom smart contracts, as well as
ready-to-deploy [presets](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets). You can also find other [utilities](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities) including [interfaces and dispatchers](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces) and [test utilities](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing)
that facilitate testing with Starknet Foundry.

|     |     |
| --- | --- |
|  | This repo contains highly experimental code. Expect rapid iteration. **Use at your own risk.** |

|     |     |
| --- | --- |
|  | You can track our roadmap and future milestones in our [Github Project](https://github.com/orgs/OpenZeppelin/projects/29/). |

## Installation

The library is available as a [Scarb](https://docs.swmansion.com/scarb) package. Follow [this guide](https://docs.swmansion.com/scarb/download.html) for installing Cairo and Scarb on your machine
before proceeding, and run the following command to check that the installation was successful:

```bash hljs
$ scarb --version

scarb 2.9.1 (aba4f604a 2024-11-29)
cairo: 2.9.1 (https://crates.io/crates/cairo-lang-compiler/2.9.1)
sierra: 1.6.0
```

### Set up your project

Create an empty directory, and `cd` into it:

```bash hljs
mkdir my_project/ && cd my_project/
```

Initialize a new Scarb project:

```bash hljs
scarb init
```

The contents of `my_project/` should now look like this:

```bash hljs
$ ls

Scarb.toml src
```

### Install the library

Install the library by declaring it as a dependency in the project’s `Scarb.toml` file:

```text hljs
[dependencies]
openzeppelin = "0.20.0"
```

|     |     |
| --- | --- |
|  | Make sure the tag matches the target release. |

## Basic usage

This is how it looks to build an ERC20 contract using the [ERC20 component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20).
Copy the code into `src/lib.cairo`.

```cairo hljs
#[starknet::contract]
mod MyERC20Token {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress
    ) {
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }
}
```

You can now compile it:

```bash hljs
scarb build
```

[Wizard →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/wizard)Migrating ERC165 to SRC5 - OpenZeppelin Docs

# Migrating ERC165 to SRC5

In the smart contract ecosystem, having the ability to query if a contract supports a given interface is an extremely important feature.
The initial introspection design for Contracts for Cairo before version v0.7.0 followed Ethereum’s [EIP-165](https://eips.ethereum.org/EIPS/eip-165).
Since the Cairo language evolved introducing native types, we needed an introspection solution tailored to the Cairo ecosystem: the [SNIP-5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md) standard.
SNIP-5 allows interface ID calculations to use Cairo types and the Starknet keccak ( `sn_keccak`) function.
For more information on the decision, see the [Starknet Shamans proposal](https://community.starknet.io/t/starknet-standard-interface-detection/92664) or the [Dual Introspection Detection](https://github.com/OpenZeppelin/cairo-contracts/discussions/640) discussion.

## How to migrate

Migrating from ERC165 to SRC5 involves four major steps:

1. Integrate SRC5 into the contract.

2. Register SRC5 IDs.

3. Add a `migrate` function to apply introspection changes.

4. Upgrade the contract and call `migrate`.


The following guide will go through the steps with examples.

### Component integration

The first step is to integrate the necessary components into the new contract.
The contract should include the new introspection mechanism, [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component).
It should also include the [InitializableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#InitializableComponent) which will be used in the `migrate` function.
Here’s the setup:

```cairo hljs
#[starknet::contract]
mod MigratingContract {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_security::initializable::InitializableComponent;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;

    // Initializable
    impl InitializableInternalImpl = InitializableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        initializable: InitializableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }
}
```

### Interface registration

To successfully migrate ERC165 to SRC5, the contract needs to register the interface IDs that the contract supports with SRC5.

For this example, let’s say that this contract supports the [IERC721](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721) and [IERC721Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata) interfaces.
The contract should implement an `InternalImpl` and add a function to register those interfaces like this:

```cairo hljs
#[starknet::contract]
mod MigratingContract {
    use openzeppelin_token::erc721::interface::{IERC721_ID, IERC721_METADATA_ID};

    (...)

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        // Register SRC5 interfaces
        fn register_src5_interfaces(ref self: ContractState) {
            self.src5.register_interface(IERC721_ID);
            self.src5.register_interface(IERC721_METADATA_ID);
        }
    }
}
```

Since the new contract integrates `SRC5Component`, it can leverage SRC5’s [register\_interface](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-register_interface) function to register the supported interfaces.

### Migration initializer

Next, the contract should define and expose a migration function that will invoke the `register_src5_interfaces` function.
Since the `migrate` function will be publicly callable, it should include some sort of [Access Control](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access) so that only permitted addresses can execute the migration.
Finally, `migrate` should include a reinitialization check to ensure that it cannot be called more than once.

|     |     |
| --- | --- |
|  | If the original contract implemented `Initializable` at any point and called the `initialize` method, the `InitializableComponent` will not be usable at this time.<br>Instead, the contract can take inspiration from `InitializableComponent` and create its own initialization mechanism. |

```cairo hljs
#[starknet::contract]
mod MigratingContract {
    (...)

    #[external(v0)]
    fn migrate(ref self: ContractState) {
        // WARNING: Missing Access Control mechanism. Make sure to add one

        // WARNING: If the contract ever implemented `Initializable` in the past,
        // this will not work. Make sure to create a new initialization mechanism
        self.initializable.initialize();

        // Register SRC5 interfaces
        self.register_src5_interfaces();
    }
}
```

### Execute migration

Once the new contract is prepared for migration and **rigorously tested**, all that’s left is to migrate!
Simply upgrade the contract and then call `migrate`.

[← Introspection](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection)Presets - OpenZeppelin Docs

# Presets

Presets are ready-to-deploy contracts provided by the library. Since presets are intended to be very simple
and as generic as possible, there’s no support for custom or complex contracts such as `ERC20Pausable` or `ERC721Mintable`.

|     |     |
| --- | --- |
|  | For contract customization and combination of modules you can use [Wizard for Cairo](https://wizard.openzeppelin.com/), our code-generation tool. |

## Available presets

List of available presets and their corresponding [Sierra class hashes](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash).

|     |     |
| --- | --- |
|  | Class hashes were computed using [cairo 2.9.1](https://crates.io/crates/cairo-lang-compiler/2.9.1). |

| Name | Sierra Class Hash |
| --- | --- |
| `AccountUpgradeable` | `0x02b31e19e45c06f29234e06e2ee98a9966479ba3067f8785ed972794fdb0065c` |
| `ERC20Upgradeable` | `0x041385cd42de9877180b006fc01d613c70e2429fc2e660df6a791b4cc0e747de` |
| `ERC721Upgradeable` | `0x015922a7436b4ee45120d5f6442bcfd8dd407fa2283dfa2276ccb9db10a9deda` |
| `ERC1155Upgradeable` | `0x046ec13b3dc855cddbaad504c5d3526f34134541f04207c7cfa7b6919f5fd2be` |
| `EthAccountUpgradeable` | `0x02ba7c42372cf971c8ee60166544e7ff72c2e38bc2835d7edd89b327b1000d8b` |
| `UniversalDeployer` | `0x06b79a175c8be9fb2acf40a1b0289018c95d04092dd4f080a133d83f9e9c696b` |
| `VestingWallet` | `0x0386b4e438105ef2ba52b12dae76e6afef54a234083137d32c57d06693a8c7c7` |

|     |     |
| --- | --- |
|  | [starkli](https://book.starkli.rs/introduction) class-hash command can be used to compute the class hash from a Sierra artifact. |

## Usage

These preset contracts are ready-to-deploy which means they should already be declared on the Sepolia network.
Simply deploy the preset class hash and add the appropriate constructor arguments.
Deploying the ERC20Upgradeable preset with [starkli](https://book.starkli.rs/introduction), for example, will look like this:

```bash hljs
starkli deploy 0x041385cd42de9877180b006fc01d613c70e2429fc2e660df6a791b4cc0e747de \
  <CONSTRUCTOR_ARGS> \
  --network="sepolia"
```

If a class hash has yet to be declared, copy/paste the preset contract code and declare it locally.
Start by [setting up a project](https://docs.openzeppelin.com/contracts-cairo/0.20.0/#set_up_your_project) and [installing the Contracts for Cairo library](https://docs.openzeppelin.com/contracts-cairo/0.20.0/#install%20the_library).
Copy the target preset contract from the [presets directory](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.20.0/packages/presets/src) and paste it in the new project’s `src/lib.cairo` like this:

```cairo hljs
// src/lib.cairo

#[starknet::contract]
mod ERC20Upgradeable {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ContractAddress, ClassHash};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress,
        owner: ContractAddress
    ) {
        self.ownable.initializer(owner);
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.ownable.assert_only_owner();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

Next, compile the contract.

```bash hljs
scarb build
```

Finally, declare the preset.

```bash hljs
starkli declare target/dev/my_project_ERC20Upgradeable.contract_class.json \
  --network="sepolia"
```

[← Components](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components)

[Interfaces and Dispatchers →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces)Common (Token) - OpenZeppelin Docs

# Common (Token)

This module provides extensions and utilities that are common to multiple token standards.

## ERC2981

### `IERC2981`

```cairo hljs
use openzeppelin_token::common::erc2981::interface::IERC2981;
```

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x2d3414e45a8700c29f119a54b9f11dca0e29e06ddcb214018fc37340e165ed6

Interface of the ERC2981 standard as defined in [EIP-2981](https://eips.ethereum.org/EIPS/eip-2981).

Functions

- [`royalty_info(token_id, sale_price)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981-royalty_info)


#### Functions

#### `royalty_info(token_id: u256, sale_price: u256) → (ContractAddress, u256)` external

Returns how much royalty is owed and to whom, based on a sale price that may be denominated
in any unit of exchange. The royalty amount is denominated and must be paid in that same
unit of exchange.

### `IERC2981Info`

```cairo hljs
use openzeppelin_token::common::erc2981::interface::IERC2981Info;
```

Interface providing external read functions for discovering the state of ERC2981 component.

Functions

- [`default_royalty()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Info-default_royalty)

- [`token_royalty(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Info-token_royalty)


#### Functions

#### `default_royalty() → (ContractAddress, u128, u128)` external

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `token_royalty(token_id: u256) → (ContractAddress, u128, u128)` external

Returns the royalty information specific to a token.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


### `IERC2981Admin`

```cairo hljs
use openzeppelin_token::common::erc2981::interface::IERC2981Admin;
```

Interface providing external admin functions for managing the settings of ERC2981 component.

Functions

- [`set_default_royalty(receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-set_default_royalty)

- [`delete_default_royalty()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-delete_default_royalty)

- [`set_token_royalty(token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-set_token_royalty)

- [`reset_token_royalty(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981Admin-reset_token_royalty)


#### Functions

#### `set_default_royalty(receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information that all ids in this contract will default to.

#### `delete_default_royalty()` external

Sets the default royalty percentage and receiver to zero.

#### `set_token_royalty(token_id: u256, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information for a specific token id that takes precedence over the global default.

#### `reset_token_royalty(token_id: u256)` external

Resets royalty information for the token id back to unset.

### `ERC2981Component`

```cairo hljs
use openzeppelin_token::common::erc2981::ERC2981Component;
```

ERC2981 component extending [IERC2981](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#IERC2981).

[Immutable Component Config](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#immutable_config)

constants

- [`FEE_DENOMINATOR`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-IC-FEE_DENOMINATOR)


functions

- [`validate()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-IC-validate)


Embeddable Implementations

ERC2981Impl

- [`royalty_info(self, token_id, sale_price)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-royalty_info)


ERC2981InfoImpl

- [`default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981InfoImpl-default_royalty)

- [`token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981InfoImpl-token_royalty)


ERC2981AdminOwnableImpl

- [`set_default_royalty(self, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-set_default_royalty)

- [`delete_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-delete_default_royalty)

- [`set_token_royalty(self, token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-set_token_royalty)

- [`reset_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminOwnableImpl-reset_token_royalty)


ERC2981AdminAccessControlImpl

- [`set_default_royalty(self, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-set_default_royalty)

- [`delete_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-delete_default_royalty)

- [`set_token_royalty(self, token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-set_token_royalty)

- [`reset_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981AdminAccessControlImpl-reset_token_royalty)


Internal implementations

InternalImpl

- [`initializer(self, default_receiver, default_royalty_fraction)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-initializer)

- [`_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_default_royalty)

- [`_set_default_royalty(self, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_set_default_royalty)

- [`_delete_default_royalty(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_delete_default_royalty)

- [`_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_token_royalty)

- [`_set_token_royalty(self, token_id, receiver, fee_numerator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_set_token_royalty)

- [`_reset_token_royalty(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common#ERC2981Component-_reset_token_royalty)


#### Immutable Config constants

#### `FEE_DENOMINATOR: u128` constant

The denominator with which to interpret the fee set in
`_set_token_royalty` and `_set_default_royalty` as a fraction of the sale price.

#### `validate()` internal

Validates the given implementation of the contract’s configuration.

Requirements:

- `FEE_DENOMINATOR` must be greater than 0.


|     |     |
| --- | --- |
|  | This function is called by the contract’s initializer. |

#### Embeddable functions

#### `royalty_info(@self: ContractState, token_id: u256, sale_price: u256) → (ContractAddress, u256)` external

Returns how much royalty is owed and to whom, based on a sale price that may be
denominated in any unit of exchange. The royalty amount is denominated and should be
paid in that same unit of exchange.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The amount of royalty payment.


#### `default_royalty(@self: ContractState) → (ContractAddress, u128, u128)` external

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `token_royalty(self: @ContractState, token_id: u256) → (ContractAddress, u128, u128)` external

Returns the royalty information specific to a token.
If no specific royalty information is set for the token, the default is returned.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### ERC2981AdminOwnableImpl

Provides admin functions for managing royalty settings that are restricted to be called only by the contract’s owner.
Requires the contract to implement [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent).

#### `set_default_royalty(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information that all ids in this contract will default to.

Requirements:

- The caller is the contract owner.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `delete_default_royalty(ref self: ContractState)` external

Sets the default royalty percentage and receiver to zero.

Requirements:

- The caller is the contract owner.


#### `set_token_royalty(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- The caller is the contract owner.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `reset_token_royalty(ref self: ContractState, token_id: u256)` external

Resets royalty information for the token id back to unset.

Requirements:

- The caller is the contract owner.


#### ERC2981AdminAccessControlImpl

Provides admin functions for managing royalty settings that require `ROYALTY_ADMIN_ROLE` to be granted to the caller.
Requires the contract to implement [AccessControlComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent).

#### `ROYALTY_ADMIN_ROLE: felt252` constant

Role for the admin responsible for managing royalty settings.

#### `set_default_royalty(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information that all ids in this contract will default to.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `delete_default_royalty(ref self: ContractState)` external

Sets the default royalty percentage and receiver to zero.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.


#### `set_token_royalty(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)` external

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `reset_token_royalty(ref self: ContractState, token_id: u256)` external

Resets royalty information for the token id back to unset.

Requirements:

- The caller must have `ROYALTY_ADMIN_ROLE` role.


#### Internal functions

#### `initializer(ref self: ContractState, default_receiver: ContractAddress, default_royalty_fraction: u128)` internal

Initializes the contract by setting the default royalty and registering the supported interface.

Requirements:

- `default_receiver` cannot be the zero address.

- `default_royalty_fraction` cannot be greater than the fee denominator.

- The fee denominator must be greater than 0.


|     |     |
| --- | --- |
|  | The fee denominator is set by the contract using the [Immutable Component Config](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#immutable_config). |

#### `_default_royalty(self: @ContractState) → (ContractAddress, u128, u128)` internal

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `_set_default_royalty(ref self: ContractState, receiver: ContractAddress, fee_numerator: u128)` internal

Sets the royalty information that all ids in this contract will default to.

Requirements:

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `_delete_default_royalty(ref self: ContractState)` internal

Sets the default royalty percentage and receiver to zero.

#### `_token_royalty(self: @ContractState, token_id: u256) → (ContractAddress, u256, u256)` internal

Returns the royalty information that all ids in this contract will default to.

The returned tuple contains:

- `t.0`: The receiver of the royalty payment.

- `t.1`: The numerator of the royalty fraction.

- `t.2`: The denominator of the royalty fraction.


#### `_set_token_royalty(ref self: ContractState, token_id: u256, receiver: ContractAddress, fee_numerator: u128)` internal

Sets the royalty information for a specific token id that takes precedence over the global default.

Requirements:

- `receiver` cannot be the zero address.

- `fee_numerator` cannot be greater than the fee denominator.


#### `_reset_token_royalty(ref self: ContractState, token_id: u256)` internal

Resets royalty information for the token id back to unset.

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155)

[Universal Deployer Contract →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc)Publishing an Ethereum Package - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Publishing an Ethereum Package

In [Using Dependencies](https://docs.openzeppelin.com/cli/2.6/dependencies), we showed how to use the [`oz link`](https://docs.openzeppelin.com/cli/2.6/commands#link) command to use the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) as a dependency, taking advantage of its contracts being _already deployed on the blockchain_.

In this guide we’ll describe how you can create your own Ethereum Package, and make it available to everyone via the OpenZeppelin CLI.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with using public networks, upgradeable contracts, and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying to a Public Test Network](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::public-staging.adoc) and [Upgrades](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::on-upgrades.adoc). |

## Storing Your Project On-chain

So far, we’ve mostly limited ourselves to depoying contracts using [`oz create`](https://docs.openzeppelin.com/cli/2.6/commands#create), which creates _upgradeable instances_ by deploying _proxies_ to an existing implementation contract (refer to [How Upgrades Work](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::on-upgrades.adoc#how-upgrades-work) to brush up on this). Here, we will instead deploy just the implementations, so that other people can create new proxies pointing to them.

To achieve this, we’ll use two low-level CLI commands: [`oz add`](https://docs.openzeppelin.com/cli/2.6/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.6/commands#push). These work simmilarly to `git add` and `git push`: they will register contracts in your project and deploy them to a network.

In your [OpenZeppelin project](https://docs.openzeppelin.com/cli/2.6/getting-started#setting-up-your-project), run:

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add <contract-1>, <contract-2>
✓ Added contract <contract-1>
✓ Added contract <contract-2>
All the selected contracts have been added to the project
$ npx oz push
? Pick a network mainnet
✓ Contract <contract-1> deployed
✓ Contract <contract-2> deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | For your Ethereum Pacakge to be used by others, it needs to be deployed on a real network instead of a local one. Take a look at [Deploying to a Public Test Network](https://docs.openzeppelin.com/cli/2.6/publishing-ethereum-package#learn::public-staging.adoc) for detailed instructions for this process. |

Ethereum Packages are upgradeable, which means they track the different implementation contracts that correspond to each version of the package. We’ll use the [`oz publish`](https://docs.openzeppelin.com/cli/2.6/commands#publish) command for this, which will deploy an [`App`](https://docs.openzeppelin.com/cli/2.6/contracts-architecture#app.sol) contract and register the implementations there:

```console hljs language-shell
$ npx oz publish
? Pick a network mainnet
✓ Project structure deployed
✓ Registering <contract-1> at 0x2c2eB5B599C2C4Bb2cA7e43179585aFec0D97D51 in directory
✓ Registering <contract-2> at 0x6389e6409Ad106aF5e7e6bE8D95Fca637980fB63 in directory
✓ Published to mainnet!
```

The Ethereum Package is complete! But we’re still lacking something: a convenient way to tell people about its existence.

## Distributing With `npm`

For your Ethereum Package to [usable from other projects](https://docs.openzeppelin.com/cli/2.6/dependencies), it needs to be published on the [npm registry](https://www.npmjs.com/). If you havent’t published an npm package before, go ahead and [sign up for a free npm account](https://www.npmjs.com/signup).

First, add your contract sources, compiled artifacts and OpenZeppelin project files to your package by including the following entries in your project’s `package.json`:

```diff hljs
 // package.json
 {
   ...,
   "files": [\
+    "build",\
+    "contracts",\
+    ".openzeppelin/*.json"\
   ]
 }
```

|     |     |
| --- | --- |
|  | The files in your `.openzeppelin` directory that [should not be tracked in version control](https://docs.openzeppelin.com/cli/2.6/configuration#configuration-files-in-version-control) are not required to be part of your published npm package: remove them before publishing to the registry. |

Almost done! Log into npm and upload your package with:

```console hljs language-shell
$ npm login
$ npm publish
```

Success! The Ethereum Package is now live on the blockchain, and accessible to everyone via the npm registry.

Any OpenZeppelin project can now [link](https://docs.openzeppelin.com/cli/2.6/commands#link) to your package:

```console hljs language-shell
$ npx oz link <your-project-name>
```

|     |     |
| --- | --- |
|  | Your Ethereum Package’s name is the same one you provided [during initialization](https://docs.openzeppelin.com/cli/2.6/getting-started#setting-up-your-project). |Introspection - OpenZeppelin Docs

# Introspection

To smooth interoperability, often standards require smart contracts to implement [introspection mechanisms](https://en.wikipedia.org/wiki/Type_introspection).

In Ethereum, the [EIP165](https://eips.ethereum.org/EIPS/eip-165) standard defines how contracts should declare
their support for a given interface, and how other contracts may query this support.

Starknet offers a similar mechanism for interface introspection defined by the [SRC5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md) standard.

## SRC5

Similar to its Ethereum counterpart, the [SRC5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md) standard requires contracts to implement the `supports_interface` function,
which can be used by others to query if a given interface is supported.

### Usage

To expose this functionality, the contract must implement the [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component), which defines the `supports_interface` function.
Here is an example contract:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl SRC5InternalImpl = SRC5Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.src5.register_interface(selector!("some_interface"));
    }
}
```

### Interface

```cairo hljs
#[starknet::interface]
pub trait ISRC5 {
    /// Query if a contract implements an interface.
    /// Receives the interface identifier as specified in SRC-5.
    /// Returns `true` if the contract implements `interface_id`, `false` otherwise.
    fn supports_interface(interface_id: felt252) -> bool;
}
```

## Computing the interface ID

The interface ID, as specified in the standard, is the [XOR](https://en.wikipedia.org/wiki/Exclusive_or) of all the
[Extended Function Selectors](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#extended-function-selector)
of the interface. We strongly advise reading the SNIP to understand the specifics of computing these
extended function selectors. There are tools such as [src5-rs](https://github.com/ericnordelo/src5-rs) that can help with this process.

## Registering interfaces

For a contract to declare its support for a given interface, we recommend using the SRC5 component to register support upon contract deployment through a constructor either directly or indirectly (as an initializer) like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_account::interface;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;
    impl InternalImpl = SRC5Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        // Register the contract's support for the ISRC6 interface
        self.src5.register_interface(interface::ISRC6_ID);
    }

    (...)
}
```

## Querying interfaces

Use the `supports_interface` function to query a contract’s support for a given interface.

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_account::interface;
    use openzeppelin_introspection::interface::ISRC5DispatcherTrait;
    use openzeppelin_introspection::interface::ISRC5Dispatcher;
    use starknet::ContractAddress;

    #[storage]
    struct Storage {}

    #[external(v0)]
    fn query_is_account(self: @ContractState, target: ContractAddress) -> bool {
        let dispatcher = ISRC5Dispatcher { contract_address: target };
        dispatcher.supports_interface(interface::ISRC6_ID)
    }
}
```

|     |     |
| --- | --- |
|  | If you are unsure whether a contract implements SRC5 or not, you can follow the process described in<br>[here](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md#how-to-detect-if-a-contract-implements-src-5). |

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance)

[Migrating ERC165 to SRC5 →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/src5-migration)Accounts - OpenZeppelin Docs

# Accounts

Unlike Ethereum where accounts are derived from a private key, all Starknet accounts are contracts. This means there’s no Externally Owned Account (EOA)
concept on Starknet.

Instead, the network features native account abstraction and signature validation happens at the contract level.

For a general overview of account abstraction, see
[Starknet’s documentation](https://docs.starknet.io/documentation/architecture_and_concepts/Accounts/introduction/).
A more detailed discussion on the topic can be found in
[Starknet Shaman’s forum](https://community.starknet.io/t/starknet-account-abstraction-model-part-1/781).

|     |     |
| --- | --- |
|  | For detailed information on the usage and implementation check the [API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account) section. |

## What is an account?

Accounts in Starknet are smart contracts, and so they can be deployed and interacted
with like any other contract, and can be extended to implement any custom logic. However, an account is a special type
of contract that is used to validate and execute transactions. For this reason, it must implement a set of entrypoints
that the protocol uses for this execution flow. The [SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md) proposal defines a standard interface for accounts,
supporting this execution flow and interoperability with DApps in the ecosystem.

### ISRC6 Interface

```cairo hljs
/// Represents a call to a target contract function.
struct Call {
    to: ContractAddress,
    selector: felt252,
    calldata: Span<felt252>
}

/// Standard Account Interface
#[starknet::interface]
pub trait ISRC6 {
    /// Executes a transaction through the account.
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;

    /// Asserts whether the transaction is valid to be executed.
    fn __validate__(calls: Array<Call>) -> felt252;

    /// Asserts whether a given signature for a given hash is valid.
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;
}
```

|     |     |
| --- | --- |
|  | The `calldata` member of the `Call` struct in the accounts has been updated to `Span<felt252>` for optimization<br>purposes, but the interface ID remains the same for backwards compatibility. This inconsistency will be fixed in future releases. |

[SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md) adds the `is_valid_signature` method. This method is not used by the protocol, but it’s useful for
DApps to verify the validity of signatures, supporting features like Sign In with Starknet.

SNIP-6 also defines that compliant accounts must implement the SRC5 interface following [SNIP-5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md), as
a mechanism for detecting whether a contract is an account or not through introspection.

### ISRC5 Interface

```cairo hljs
/// Standard Interface Detection
#[starknet::interface]
pub trait ISRC5 {
    /// Queries if a contract implements a given interface.
    fn supports_interface(interface_id: felt252) -> bool;
}
```

[SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md) compliant accounts must return `true` when queried for the ISRC6 interface ID.

Even though these interfaces are not enforced by the protocol, it’s recommended to implement them for enabling
interoperability with the ecosystem.

### Protocol-level methods

The Starknet protocol uses a few entrypoints for abstracting the accounts. We already mentioned the first two
as part of the ISRC6 interface, and both are required for enabling accounts to be used for executing transactions. The rest are optional:

1. `__validate__` verifies the validity of the transaction to be executed. This is usually used to validate signatures,
but the entrypoint implementation can be customized to feature any validation mechanism [with some limitations](https://docs.starknet.io/documentation/architecture_and_concepts/Accounts/validate_and_execute/#validate_limitations).

2. `__execute__` executes the transaction if the validation is successful.

3. `__validate_declare__` optional entrypoint similar to `__validate__` but for transactions
meant to declare other contracts.

4. `__validate_deploy__` optional entrypoint similar to `__validate__` but meant for [counterfactual deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment).


|     |     |
| --- | --- |
|  | Although these entrypoints are available to the protocol for its regular transaction flow, they can also be called like any other method. |

## Starknet Account

Starknet native account abstraction pattern allows for the creation of custom accounts with different validation schemes, but
usually most account implementations validate transactions using the [Stark curve](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/stark-curve) which is the most efficient way
of validating signatures since it is a STARK-friendly curve.

OpenZeppelin Contracts for Cairo provides [AccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent) for implementing this validation scheme.

### Usage

Constructing an account contract requires integrating both [AccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent) and [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component). The contract should also set up the constructor to initialize the public key that will be used as the account’s signer. Here’s an example of a basic contract:

```cairo hljs
#[starknet::contract(account)]
mod MyAccount {
    use openzeppelin_account::AccountComponent;
    use openzeppelin_introspection::src5::SRC5Component;

    component!(path: AccountComponent, storage: account, event: AccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Account Mixin
    #[abi(embed_v0)]
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        account: AccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccountEvent: AccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: felt252) {
        self.account.initializer(public_key);
    }
}
```

### Interface

This is the full interface of the `AccountMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait AccountABI {
    // ISRC6
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;
    fn __validate__(calls: Array<Call>) -> felt252;
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IDeclarer
    fn __validate_declare__(class_hash: felt252) -> felt252;

    // IDeployable
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: felt252
    ) -> felt252;

    // IPublicKey
    fn get_public_key() -> felt252;
    fn set_public_key(new_public_key: felt252, signature: Span<felt252>);

    // ISRC6CamelOnly
    fn isValidSignature(hash: felt252, signature: Array<felt252>) -> felt252;

    // IPublicKeyCamel
    fn getPublicKey() -> felt252;
    fn setPublicKey(newPublicKey: felt252, signature: Span<felt252>);
}
```

## Ethereum Account

Besides the Stark-curve account, OpenZeppelin Contracts for Cairo also offers Ethereum-flavored accounts that use the [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) curve for signature validation.
For this the [EthAccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent) must be used.

### Usage

Constructing a secp256k1 account contract also requires integrating both [EthAccountComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent) and [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component).
The contract should also set up the constructor to initialize the public key that will be used as the account’s signer.
Here’s an example of a basic contract:

```cairo hljs
#[starknet::contract(account)]
mod MyEthAccount {
    use openzeppelin_account::EthAccountComponent;
    use openzeppelin_account::interface::EthPublicKey;
    use openzeppelin_introspection::src5::SRC5Component;
    use starknet::ClassHash;

    component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // EthAccount Mixin
    #[abi(embed_v0)]
    impl EthAccountMixinImpl =
        EthAccountComponent::EthAccountMixinImpl<ContractState>;
    impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        eth_account: EthAccountComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        EthAccountEvent: EthAccountComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, public_key: EthPublicKey) {
        self.eth_account.initializer(public_key);
    }
}
```

### Interface

This is the full interface of the `EthAccountMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait EthAccountABI {
    // ISRC6
    fn __execute__(calls: Array<Call>) -> Array<Span<felt252>>;
    fn __validate__(calls: Array<Call>) -> felt252;
    fn is_valid_signature(hash: felt252, signature: Array<felt252>) -> felt252;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IDeclarer
    fn __validate_declare__(class_hash: felt252) -> felt252;

    // IEthDeployable
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: EthPublicKey
    ) -> felt252;

    // IEthPublicKey
    fn get_public_key() -> EthPublicKey;
    fn set_public_key(new_public_key: EthPublicKey, signature: Span<felt252>);

    // ISRC6CamelOnly
    fn isValidSignature(hash: felt252, signature: Array<felt252>) -> felt252;

    // IEthPublicKeyCamel
    fn getPublicKey() -> EthPublicKey;
    fn setPublicKey(newPublicKey: EthPublicKey, signature: Span<felt252>);
}
```

## Deploying an account

In Starknet there are two ways of deploying smart contracts: using the `deploy_syscall` and doing
counterfactual deployments.
The former can be easily done with the [Universal Deployer Contract (UDC)](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc), a contract that
wraps and exposes the `deploy_syscall` to provide arbitrary deployments through regular contract calls.
But if you don’t have an account to invoke it, you will probably want to use the latter.

To do counterfactual deployments, you need to implement another protocol-level entrypoint named
`__validate_deploy__`. Check the [counterfactual deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment) guide to learn how.

## Sending transactions

Let’s now explore how to send transactions through these accounts.

### Starknet Account

First, let’s take the example account we created before and deploy it:

```[ hljs language-rust\
#[starknet::contract(account)]\
mod MyAccount {\
    use openzeppelin_account::AccountComponent;\
    use openzeppelin_introspection::src5::SRC5Component;\
\
    component!(path: AccountComponent, storage: account, event: AccountEvent);\
    component!(path: SRC5Component, storage: src5, event: SRC5Event);\
\
    // Account Mixin\
    #[abi(embed_v0)]\
    impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;\
    impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;\
\
    #[storage]\
    struct Storage {\
        #[substorage(v0)]\
        account: AccountComponent::Storage,\
        #[substorage(v0)]\
        src5: SRC5Component::Storage\
    }\
\
    #[event]\
    #[derive(Drop, starknet::Event)]\
    enum Event {\
        #[flat]\
        AccountEvent: AccountComponent::Event,\
        #[flat]\
        SRC5Event: SRC5Component::Event\
    }\
\
    #[constructor]\
    fn constructor(ref self: ContractState, public_key: felt252) {\
        self.account.initializer(public_key);\
    }\
}\
```\
\
To deploy the account variant, compile the contract and declare the class hash because custom accounts are likely not declared.\
This means that you’ll need an account already deployed.\
\
Next, create the account JSON with Starknet Foundry’s [custom account setup](https://foundry-rs.github.io/starknet-foundry/starknet/account.html#custom-account-contract) and include the `--class-hash` flag with the declared class hash.\
The flag enables custom account variants.\
\
|     |     |\
| --- | --- |\
|  | The following examples use `sncast` [v0.23.0](https://github.com/foundry-rs/starknet-foundry/releases/tag/v0.23.0). |\
\
```[ hljs language-solidity\
$ sncast \\
  --url http://127.0.0.1:5050 \\
  account create \\
  --name my-custom-account \\
  --class-hash 0x123456...\
```\
\
This command will output the precomputed contract address and the recommended `max-fee`.\
To counterfactually deploy the account, send funds to the address and then deploy the custom account.\
\
```[ hljs language-solidity\
$ sncast \\
  --url http://127.0.0.1:5050 \\
  account deploy \\
  --name my-custom-account\
```\
\
Once the account is deployed, set the `--account` flag with the custom account name to send transactions from that account.\
\
```[ hljs language-javascript\
$ sncast \\
  --account my-custom-account \\
  --url http://127.0.0.1:5050 \\
  invoke \\
  --contract-address 0x123... \\
  --function "some_function" \\
  --calldata 1 2 3\
```\
\
### Ethereum Account\
\
First, let’s take the example account we created before and deploy it:\
\
```[ hljs language-rust\
#[starknet::contract(account)]\
mod MyEthAccount {\
    use openzeppelin_account::EthAccountComponent;\
    use openzeppelin_account::interface::EthPublicKey;\
    use openzeppelin_introspection::src5::SRC5Component;\
\
    component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);\
    component!(path: SRC5Component, storage: src5, event: SRC5Event);\
\
    // EthAccount Mixin\
    #[abi(embed_v0)]\
    impl EthAccountMixinImpl =\
        EthAccountComponent::EthAccountMixinImpl<ContractState>;\
    impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;\
\
    #[storage]\
    struct Storage {\
        #[substorage(v0)]\
        eth_account: EthAccountComponent::Storage,\
        #[substorage(v0)]\
        src5: SRC5Component::Storage\
    }\
\
    #[event]\
    #[derive(Drop, starknet::Event)]\
    enum Event {\
        #[flat]\
        EthAccountEvent: EthAccountComponent::Event,\
        #[flat]\
        SRC5Event: SRC5Component::Event\
    }\
\
    #[constructor]\
    fn constructor(ref self: ContractState, public_key: EthPublicKey) {\
        self.eth_account.initializer(public_key);\
    }\
}\
```\
\
Special tooling is required in order to deploy and send transactions with an Ethereum-flavored account contract.\
The following examples utilize the [StarknetJS](https://www.starknetjs.com/) library.\
\
Compile and declare the contract on the target network.\
Next, precompute the EthAccount contract address using the declared class hash.\
\
|     |     |\
| --- | --- |\
|  | The following examples use unreleased features from StarknetJS ( `starknetjs@next`) at commit [d002baea0abc1de3ac6e87a671f3dec3757437b3](https://github.com/starknet-io/starknet.js/commit/d002baea0abc1de3ac6e87a671f3dec3757437b3). |\
\
```[ hljs language-solidity\
import * as dotenv from 'dotenv';\
import { CallData, EthSigner, hash } from 'starknet';\
import { ABI as ETH_ABI } from '../abis/eth_account.js';\
dotenv.config();\
\
// Calculate EthAccount address\
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);\
const ethPubKey = await ethSigner.getPubKey();\
const ethAccountClassHash = '<ETH_ACCOUNT_CLASS_HASH>';\
const ethCallData = new CallData(ETH_ABI);\
const ethAccountConstructorCalldata = ethCallData.compile('constructor', {\
    public_key: ethPubKey\
})\
const salt = '0x12345';\
const deployerAddress = '0x0';\
const ethContractAddress = hash.calculateContractAddressFromHash(\
    salt,\
    ethAccountClassHash,\
    ethAccountConstructorCalldata,\
    deployerAddress\
);\
console.log('Pre-calculated EthAccount address: ', ethContractAddress);\
```\
\
Send funds to the pre-calculated EthAccount address and deploy the contract.\
\
```[ hljs language-solidity\
import * as dotenv from 'dotenv';\
import { Account, CallData, EthSigner, RpcProvider, stark } from 'starknet';\
import { ABI as ETH_ABI } from '../abis/eth_account.js';\
dotenv.config();\
\
// Prepare EthAccount\
const provider = new RpcProvider({ nodeUrl: process.env.API_URL });\
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);\
const ethPubKey = await ethSigner.getPubKey();\
const ethAccountAddress = '<ETH_ACCOUNT_ADDRESS>'\
const ethAccount = new Account(provider, ethAccountAddress, ethSigner);\
\
// Prepare payload\
const ethAccountClassHash = '<ETH_ACCOUNT_CLASS_HASH>'\
const ethCallData = new CallData(ETH_ABI);\
const ethAccountConstructorCalldata = ethCallData.compile('constructor', {\
    public_key: ethPubKey\
})\
const salt = '0x12345';\
const deployPayload = {\
    classHash: ethAccountClassHash,\
    constructorCalldata: ethAccountConstructorCalldata,\
    addressSalt: salt,\
};\
\
// Deploy\
const { suggestedMaxFee: feeDeploy } = await ethAccount.estimateAccountDeployFee(deployPayload);\
const { transaction_hash, contract_address } = await ethAccount.deployAccount(\
    deployPayload,\
    { maxFee: stark.estimatedFeeToMaxFee(feeDeploy, 100) }\
);\
await provider.waitForTransaction(transaction_hash);\
console.log('EthAccount deployed at: ', contract_address);\
```\
\
Once deployed, connect the EthAccount instance to the target contract which enables calls to come from the EthAccount.\
Here’s what an ERC20 transfer from an EthAccount looks like.\
\
```[ hljs language-solidity\
import * as dotenv from 'dotenv';\
import { Account, RpcProvider, Contract, EthSigner } from 'starknet';\
dotenv.config();\
\
// Prepare EthAccount\
const provider = new RpcProvider({ nodeUrl: process.env.API_URL });\
const ethSigner = new EthSigner(process.env.ETH_PRIVATE_KEY);\
const ethAccountAddress = '<ETH_ACCOUNT_CONTRACT_ADDRESS>'\
const ethAccount = new Account(provider, ethAccountAddress, ethSigner);\
\
// Prepare target contract\
const erc20 = new Contract(compiledErc20.abi, erc20Address, provider);\
\
// Connect EthAccount with the target contract\
erc20.connect(ethAccount);\
\
// Execute ERC20 transfer\
const transferCall = erc20.populate('transfer', {\
    recipient: recipient.address,\
    amount: 50n\
});\
const tx = await erc20.transfer(\
    transferCall.calldata, { maxFee: 900_000_000_000_000 }\
);\
await provider.waitForTransaction(tx.transaction_hash);\
```\
\
[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access)\
\
[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account)Proxy - OpenZeppelin Docs

# Proxy

|     |     |
| --- | --- |
|  | This document is better viewed at [https://docs.openzeppelin.com/community-contracts/proxy](https://docs.openzeppelin.com/community-contracts/proxy) |

Variants of proxy patterns, which are contracts that allow to forward a call to an implementation contract by using `delegatecall`. This contracts include:

- [`HybridProxy`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/proxy#HybridProxy): An ERC-1967 proxy that uses the implementation slot as a beacon in a way that a user can upgrade to an implementation of their choice.


## General

### `HybridProxy`

```solidity hljs
import "@openzeppelin/community-contracts/proxy/HybridProxy.sol";
```

A version of an ERC-1967 proxy that uses the address stored in the implementation slot as a beacon.

The design allows to set an initial beacon that the contract may quit by upgrading to its own implementation
afterwards. Transition between the "beacon mode" and the "direct mode" require implementation that expose an
upgrade mechanism that writes to the ERC-1967 implementation slot. Note that UUPSUpgradable includes security
checks that are not compatible with this proxy design.

|     |     |
| --- | --- |
|  | The fallback mechanism relies on the implementation not to define the {IBeacon-implementation} function.<br>Consider that if your implementation has this function, it’ll be assumed as the beacon address, meaning that<br>the returned address will be used as this proxy’s implementation. |

Functions

- `constructor(implementation, data)`

- `_implementation()`


Proxy

- `_delegate(implementation)`

- `_fallback()`

- `fallback()`


#### `constructor(address implementation, bytes data)` public

Initializes the proxy with an initial implementation. If data is present, it will be used to initialize the
implementation using a delegate call.

#### `_implementation() → address` internal

Returns the current implementation address according to ERC-1967’s implementation slot.

|     |     |
| --- | --- |
|  | The way this function identifies whether the implementation is a beacon, is by checking<br>if it implements the {IBeacon-implementation} function. Consider that an actual implementation could<br>define this function, mistakenly identifying it as a beacon. |

[← Account](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account)

[Token →](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token)ERC-721 Consecutive - OpenZeppelin Docs

# ERC-721 Consecutive

Consecutive extension for [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) is useful for efficiently minting multiple tokens in a single transaction. This can significantly reduce gas costs and improve performance when creating a large number of tokens at once.

## Usage

In order to make [`ERC-721 Consecutive`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/consecutive/index.html) methods “external” so that other contracts can call them, you need to add the following code to your contract:

```rust hljs
use openzeppelin_stylus::token::erc721::extensions::consecutive::{
    Erc721Consecutive, Error,
};

sol_storage! {
    #[entrypoint]
    struct Erc721ConsecutiveExample {
        #[borrow]
        Erc721Consecutive erc721_consecutive;
    }
}

#[public]
#[inherit(Erc721Consecutive)]
impl Erc721ConsecutiveExample {
    pub fn burn(&mut self, token_id: U256) -> Result<(), Error> {
        self.erc721_consecutive._burn(token_id)
    }

    pub fn mint(&mut self, to: Address, token_id: U256) -> Result<(), Error> {
        self.erc721_consecutive._mint(to, token_id)
    }
}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy). Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc721ConsecutiveExample {
    mapping(uint256 tokenId => address) private _owners;
    mapping(address owner => uint256) private _balances;
    mapping(uint256 tokenId => address) private _tokenApprovals;
    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;

    Checkpoint160[] private _checkpoints; // _sequentialOwnership
    mapping(uint256 bucket => uint256) private _data; // _sequentialBurn
    uint96 private _firstConsecutiveId;
    uint96 private _maxBatchSize;

    error ERC721InvalidReceiver(address receiver);
    error ERC721ForbiddenBatchMint();
    error ERC721ExceededMaxBatchMint(uint256 batchSize, uint256 maxBatch);
    error ERC721ForbiddenMint();
    error ERC721ForbiddenBatchBurn();
    error CheckpointUnorderedInsertion();

    event ConsecutiveTransfer(
        uint256 indexed fromTokenId,
        uint256 toTokenId,
        address indexed fromAddress,
        address indexed toAddress
    );

    struct Checkpoint160 {
        uint96 _key;
        uint160 _value;
    }

    constructor(
        address[] memory receivers,
        uint96[] memory amounts,
        uint96 firstConsecutiveId,
        uint96 maxBatchSize)
    {
        _firstConsecutiveId = firstConsecutiveId;
        _maxBatchSize = maxBatchSize;
        for (uint256 i = 0; i < receivers.length; ++i) {
            _mintConsecutive(receivers[i], amounts[i]);
        }
    }

    function latestCheckpoint() internal view returns (bool exists, uint96 _key, uint160 _value) {
        uint256 pos = _checkpoints.length;
        if (pos == 0) {
            return (false, 0, 0);
        } else {
            Checkpoint160 storage ckpt = _checkpoints[pos - 1];
            return (true, ckpt._key, ckpt._value);
        }
    }

    function push(uint96 key, uint160 value) internal returns (uint160, uint160) {
        return _insert(key, value);
    }

    function _insert(uint96 key, uint160 value) private returns (uint160, uint160) {
        uint256 pos = _checkpoints.length;

        if (pos > 0) {
            Checkpoint160 storage last = _checkpoints[pos - 1];
            uint96 lastKey = last._key;
            uint160 lastValue = last._value;

            // Checkpoint keys must be non-decreasing.
            if (lastKey > key) {
                revert CheckpointUnorderedInsertion();
            }

            // Update or push new checkpoint.
            if (lastKey == key) {
                _checkpoints[pos - 1]._value = value;
            } else {
                _checkpoints.push(Checkpoint160({_key: key, _value: value}));
            }
            return (lastValue, value);
        } else {
            _checkpoints.push(Checkpoint160({_key: key, _value: value}));
            return (0, value);
        }
    }

    function _mintConsecutive(address to, uint96 batchSize) internal virtual returns (uint96) {
        uint96 next = _nextConsecutiveId();

        // minting a batch of size 0 is a no-op.
        if (batchSize > 0) {
            if (address(this).code.length > 0) {
                revert ERC721ForbiddenBatchMint();
            }
            if (to == address(0)) {
                revert ERC721InvalidReceiver(address(0));
            }

            uint256 maxBatchSize = _maxBatchSize;
            if (batchSize > maxBatchSize) {
                revert ERC721ExceededMaxBatchMint(batchSize, maxBatchSize);
            }

            // push an ownership checkpoint & emit event.
            uint96 last = next + batchSize - 1;
            push(last, uint160(to));

            // The invariant required by this function is preserved because the new sequentialOwnership checkpoint
            // is attributing ownership of `batchSize` new tokens to account `to`.
            _increaseBalance(to, batchSize);

            emit ConsecutiveTransfer(next, last, address(0), to);
        }

        return next;
    }

    function _nextConsecutiveId() private view returns (uint96) {
        (bool exists, uint96 latestId,) = latestCheckpoint();
        return exists ? latestId + 1 : _firstConsecutiveId;
    }

    function _increaseBalance(address account, uint128 value) internal virtual {
        unchecked {
            _balances[account] += value;
        }
    }
}
```ERC20 - OpenZeppelin Docs

# ERC20

The ERC20 token standard is a specification for [fungible tokens](https://docs.openzeppelin.com/contracts/4.x/tokens#different-kinds-of-tokens), a type of token where all the units are exactly equal to each other.
`token::erc20::ERC20Component` provides an approximation of [EIP-20](https://eips.ethereum.org/EIPS/eip-20) in Cairo for Starknet.

|     |     |
| --- | --- |
|  | Prior to [Contracts v0.7.0](https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.7.0), ERC20 contracts store and read `decimals` from storage; however, this implementation returns a static `18`.<br>If upgrading an older ERC20 contract that has a decimals value other than `18`, the upgraded contract **must** use a custom `decimals` implementation.<br>See the [Customizing decimals](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20#customizing_decimals) guide. |

## Usage

Using Contracts for Cairo, constructing an ERC20 contract requires setting up the constructor and instantiating the token implementation.
Here’s what that looks like:

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }
}
```

`MyToken` integrates both the `ERC20Impl` and `ERC20MetadataImpl` with the embed directive which marks the implementations as external in the contract.
While the `ERC20MetadataImpl` is optional, it’s generally recommended to include it because the vast majority of ERC20 tokens provide the metadata methods.
The above example also includes the `ERC20InternalImpl` instance.
This allows the contract’s constructor to initialize the contract and create an initial supply of tokens.

|     |     |
| --- | --- |
|  | For a more complete guide on ERC20 token mechanisms, see [Creating ERC20 Supply](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/erc20-supply). |

## Interface

The following interface represents the full ABI of the Contracts for Cairo [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component).
The interface includes the [IERC20](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20) standard interface as well as the optional [IERC20Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata).

To support older token deployments, as mentioned in [Dual interfaces](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces#dual_interfaces), the component also includes an implementation of the interface written in camelCase.

```cairo hljs
#[starknet::interface]
pub trait ERC20ABI {
    // IERC20
    fn total_supply() -> u256;
    fn balance_of(account: ContractAddress) -> u256;
    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(spender: ContractAddress, amount: u256) -> bool;

    // IERC20Metadata
    fn name() -> ByteArray;
    fn symbol() -> ByteArray;
    fn decimals() -> u8;

    // IERC20Camel
    fn totalSupply() -> u256;
    fn balanceOf(account: ContractAddress) -> u256;
    fn transferFrom(
        sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
}
```

## ERC20 compatibility

Although Starknet is not EVM compatible, this component aims to be as close as possible to the ERC20 token standard.
Some notable differences, however, can still be found, such as:

- The `ByteArray` type is used to represent strings in Cairo.

- The component offers a [dual interface](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces#dual_interfaces) which supports both snake\_case and camelCase methods, as opposed to just camelCase in Solidity.

- `transfer`, `transfer_from` and `approve` will never return anything different from `true` because they will revert on any error.

- Function selectors are calculated differently between [Cairo](https://github.com/starkware-libs/cairo/blob/7dd34f6c57b7baf5cd5a30c15e00af39cb26f7e1/crates/cairo-lang-starknet/src/contract.rs#L39-L48) and [Solidity](https://solidity-by-example.org/function-selector/).


## Customizing decimals

Cairo, like Solidity, does not support [floating-point numbers](https://en.wikipedia.org//wiki/Floating-point_arithmetic).
To get around this limitation, ERC20 token contracts may offer a `decimals` field which communicates to outside interfaces (wallets, exchanges, etc.) how the token should be displayed.
For instance, suppose a token had a `decimals` value of `3` and the total token supply was `1234`.
An outside interface would display the token supply as `1.234`.
In the actual contract, however, the supply would still be the integer `1234`.
In other words, **the decimals field in no way changes the actual arithmetic** because all operations are still performed on integers.

Most contracts use `18` decimals and this was even proposed to be compulsory (see the [EIP discussion](https://github.com/ethereum/EIPs/issues/724)).
The Contracts for Cairo `ERC20` component includes a `decimals` function that returns `18` by default to save on gas fees.
For those who want an ERC20 token with a configurable number of decimals, the following guide shows two ways to achieve this.

|     |     |
| --- | --- |
|  | Both approaches require creating a custom implementation of the `IERC20Metadata` interface. |

### The static approach

The simplest way to customize `decimals` consists of returning the target value from the `decimals` method.
For example:

```cairo hljs
#[abi(embed_v0)]
impl ERC20MetadataImpl of interface::IERC20Metadata<ContractState> {
    fn decimals(self: @ContractState) -> u8 {
        // Change the `3` below to the desired number of decimals
        3
    }

    (...)
}
```

### The storage approach

For more complex scenarios, such as a factory deploying multiple tokens with differing values for decimals, a flexible solution might be appropriate.

|     |     |
| --- | --- |
|  | Note that we are not using the MixinImpl in this case, since we need to customize the IERC20Metadata implementation. |

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20CamelOnlyImpl = ERC20Component::ERC20CamelOnlyImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        // The decimals value is stored locally
        decimals: u8
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        decimals: u8,
        initial_supply: u256,
        recipient: ContractAddress,
    ) {
        // Call the internal function that writes decimals to storage
        self._set_decimals(decimals);

        // Initialize ERC20
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);
    }

    #[abi(embed_v0)]
    impl ERC20MetadataImpl of interface::IERC20Metadata<ContractState> {
        fn name(self: @ContractState) -> ByteArray {
            self.erc20.name()
        }

        fn symbol(self: @ContractState) -> ByteArray {
            self.erc20.symbol()
        }

        fn decimals(self: @ContractState) -> u8 {
            self.decimals.read()
        }
    }

    #[generate_trait]
    impl InternalImpl of InternalTrait {
        fn _set_decimals(ref self: ContractState, decimals: u8) {
            self.decimals.write(decimals);
        }
    }
}
```

This contract expects a `decimals` argument in the constructor and uses an internal function to write the decimals to storage.
Note that the `decimals` state variable must be defined in the contract’s storage because this variable does not exist in the component offered by OpenZeppelin Contracts for Cairo.
It’s important to include a custom ERC20 metadata implementation and NOT use the Contracts for Cairo `ERC20MetadataImpl` in this specific case since the `decimals` method will always return `18`.

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security)

[Creating Supply →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/erc20-supply)Tokens - OpenZeppelin Docs

# Tokens

Ah, the "token": blockchain’s most powerful and most misunderstood tool.

A token is a _representation of something in the blockchain_. This something can be money, time, services, shares in a company, a virtual pet, anything. By representing things as tokens, we can allow smart contracts to interact with them, exchange them, create or destroy them.

## But First, Coffee a Primer on Token Contracts

Much of the confusion surrounding tokens comes from two concepts getting mixed up: _token contracts_ and the actual _tokens_.

A _token contract_ is simply an Ethereum smart contract. "Sending tokens" actually means "calling a method on a smart contract that someone wrote and deployed". At the end of the day, a token contract is not much more than a mapping of addresses to balances, plus some methods to add and subtract from those balances.

It is these balances that represent the _tokens_ themselves. Someone "has tokens" when their balance in the token contract is non-zero. That’s it! These balances could be considered money, experience points in a game, deeds of ownership, or voting rights, and each of these tokens would be stored in different token contracts.

## Different Kinds of Tokens

Note that there’s a big difference between having two voting rights and two deeds of ownership: each vote is equal to all others, but houses usually are not! This is called [fungibility](https://en.wikipedia.org/wiki/Fungibility). _Fungible goods_ are equivalent and interchangeable, like Ether, fiat currencies, and voting rights. _Non-fungible_ goods are unique and distinct, like deeds of ownership, or collectibles.

In a nutshell, when dealing with non-fungibles (like your house) you care about _which ones_ you have, while in fungible assets (like your bank account statement) what matters is _how much_ you have.

## Standards

Even though the concept of a token is simple, they have a variety of complexities in the implementation. Because everything in Ethereum is just a smart contract, and there are no rules about what smart contracts have to do, the community has developed a variety of **standards** (called EIPs or ERCs) for documenting how a contract can interoperate with other contracts.

You’ve probably heard of the ERC-20 or ERC-721 token standards, and that’s why you’re here. Head to our specialized guides to learn more about these:

- [ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20): the most widespread token standard for fungible assets, albeit somewhat limited by its simplicity.

- [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721): the de-facto solution for non-fungible tokens, often used for collectibles and games.


[← Deploying Contracts](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy)

[ERC-20 →](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20)ERC721 - OpenZeppelin Docs

# ERC721

This module provides interfaces, presets, and utilities related to ERC721 contracts.

|     |     |
| --- | --- |
|  | For an overview of ERC721, read our [ERC721 guide](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc721). |

## Core

### `IERC721`

```cairo hljs
use openzeppelin_token::erc721::interface::IERC721;
```

Interface of the IERC721 standard as defined in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x33eb2f84c309543403fd69f0d0f363781ef06ef6faeb0131ff16ea3175bd943

Functions

- [`balance_of(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of)

- [`owner_of(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-owner_of)

- [`safe_transfer_from(from, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from)

- [`transfer_from(from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-transfer_from)

- [`approve(to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-approve)

- [`set_approval_for_all(operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-set_approval_for_all)

- [`get_approved(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-get_approved)

- [`is_approved_for_all(owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-is_approved_for_all)


Events

- [`Approval(owner, approved, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-ApprovalForAll)

- [`Transfer(from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer)


#### Functions

#### `balance_of(account: ContractAddress) → u256` external

Returns the number of NFTs owned by `account`.

#### `owner_of(token_id: u256) → ContractAddress` external

Returns the owner address of `token_id`.

#### `safe_transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` external

Transfer ownership of `token_id` from `from` to `to`, checking first that `to` is aware of the ERC721 protocol to prevent tokens being locked forever.
For information regarding how contracts communicate their awareness of the ERC721 protocol, see [Receiving Tokens](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc721#receiving_tokens).

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256)` external

Transfer ownership of `token_id` from `from` to `to`.

Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 transfers or else they may be permanently lost.
Usage of [IERC721::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from) prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `approve(to: ContractAddress, token_id: u256)` external

Change or reaffirm the approved address for an NFT.

Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `set_approval_for_all(operator: ContractAddress, approved: bool)` external

Enable or disable approval for `operator` to manage all of the caller’s assets.

Emits an [ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-ApprovalForAll) event.

#### `get_approved(token_id: u256) -> u256` external

Returns the address approved for `token_id`.

#### `is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool` external

Query if `operator` is an authorized operator for `owner`.

#### Events

#### `Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)` event

Emitted when `owner` enables `approved` to manage the `token_id` token.

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

Emitted when `owner` enables or disables `operator` to manage the `token_id` token.

#### `Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)` event

Emitted when `token_id` token is transferred from `from` to `to`.

### `IERC721Metadata`

```cairo hljs
use openzeppelin_token::erc721::interface::IERC721Metadata;
```

Interface for the optional metadata functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0xabbcd595a567dce909050a1038e055daccb3c42af06f0add544fa90ee91f25

Functions

- [`name()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-name)

- [`symbol()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-symbol)

- [`token_uri(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-token_uri)


#### Functions

#### `name() -> ByteArray` external

Returns the NFT name.

#### `symbol() -> ByteArray` external

Returns the NFT ticker symbol.

#### `token_uri(token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

### `ERC721Component`

```cairo hljs
use openzeppelin_token::erc721::ERC721Component;
```

ERC721 component implementing [IERC721](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721) and [IERC721Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

|     |     |
| --- | --- |
|  | See [Hooks](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Hooks) to understand how are hooks used. |

Hooks

ERC721HooksTrait

- [`before_update(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-before_update)

- [`after_update(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-after_update)


[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERC721MixinImpl

- [`ERC721Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721Impl)

- [`ERC721MetadataImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721MetadataImpl)

- [`ERC721CamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl)

- [`ERC721MetadataCamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

ERC721Impl

- [`balance_of(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-balance_of)

- [`owner_of(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-owner_of)

- [`safe_transfer_from(self, from, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_transfer_from)

- [`transfer_from(self, from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transfer_from)

- [`approve(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-approve)

- [`set_approval_for_all(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-set_approval_for_all)

- [`get_approved(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-get_approved)

- [`is_approved_for_all(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-is_approved_for_all)


ERC721MetadataImpl

- [`name(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-name)

- [`symbol(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-symbol)

- [`token_uri(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-token_uri)


ERC721CamelOnlyImpl

- [`balanceOf(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-balanceOf)

- [`ownerOf(self, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-ownerOf)

- [`safeTransferFrom(self, from, to, tokenId, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safeTransferFrom)

- [`transferFrom(self, from, to, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transferFrom)

- [`setApprovalForAll(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-setApprovalForAll)

- [`getApproved(self, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-getApproved)

- [`isApprovedForAll(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-isApprovedForAll)


ERC721MetadataCamelOnlyImpl

- [`tokenURI(self, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-tokenURI)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


Internal functions

InternalImpl

- [`initializer(self, name, symbol, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-initializer)

- [`exists(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-exists)

- [`transfer(self, from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transfer)

- [`mint(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-mint)

- [`safe_transfer(self, from, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_transfer)

- [`safe_mint(self, to, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_mint)

- [`burn(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-burn)

- [`update(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-update)

- [`_owner_of(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_owner_of)

- [`_require_owned(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_require_owned)

- [`_approve(self, to, token_id, auth)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_approve)

- [`_approve_with_optional_event(self, to, token_id, auth, emit_event)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_approve_with_optional_event)

- [`_set_approval_for_all(self, owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_set_approval_for_all)

- [`_set_base_uri(self, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_set_base_uri)

- [`_base_uri(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_base_uri)

- [`_is_authorized(self, owner, spender, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_is_authorized)

- [`_check_authorized(self, owner, spender, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_check_authorized)


Events

IERC721

- [`Approval(owner, approved, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Approval)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-ApprovalForAll)

- [`Transfer(from, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Transfer)


#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC721Component is expected to provide an implementation of the ERC721HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

|     |     |
| --- | --- |
|  | You can use `openzeppelin_token::erc721::ERC721HooksEmptyImpl` which is already available as part of the library<br>for this purpose. |

#### `before_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` hook

Function executed at the beginning of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-update) function prior to any other logic.

#### `after_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` hook

Function executed at the end of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-update) function.

#### Embeddable functions

#### `balance_of(self: @ContractState, account: ContractAddress) → u256` external

See [IERC721::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of).

#### `owner_of(self: @ContractState, token_id: u256) → ContractAddress` external

See [IERC721::owner\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-owner_of).

Requirements:

- `token_id` exists.


#### `safe_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` external

See [IERC721::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from).

Requirements:

- Caller is either approved or the `token_id` owner.

- `to` is not the zero address.

- `from` is not the zero address.

- `token_id` exists.

- `to` is either an account contract or supports the [IERC721Receiver](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver) interface.


#### `transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)` external

See [IERC721::transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-transfer_from).

Requirements:

- Caller either approved or the `token_id` owner.

- `to` is not the zero address.

- `from` is not the zero address.

- `token_id` exists.


#### `approve(ref self: ContractState, to: ContractAddress, token_id: u256)` external

See [IERC721::approve](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-approve).

Requirements:

- The caller is either an approved operator or the `token_id` owner.

- `to` cannot be the token owner or the zero address.

- `token_id` exists.


#### `set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [IERC721::set\_approval\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-set_approval_for_all).

Requirements:

- `operator` is not the zero address.


#### `get_approved(self: @ContractState, token_id: u256) -> u256` external

See [IERC721::get\_approved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-get_approved).

Requirements:

- `token_id` exists.


#### `is_approved_for_all(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [IERC721::is\_approved\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-is_approved_for_all).

#### `name(self: @ContractState) -> ByteArray` external

See [IERC721Metadata::name](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-name).

#### `symbol(self: @ContractState) -> ByteArray` external

See [IERC721Metadata::symbol](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-symbol).

#### `token_uri(self: @ContractState, token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If a base URI is set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
For example, the base URI `https://token-cdn-domain/` would be returned as `https://token-cdn-domain/123` for token ID `123`.

If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

#### `balanceOf(self: @ContractState, account: ContractAddress) -> u256` external

See [ERC721Component::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-balance_of).

#### `ownerOf(self: @ContractState, tokenId: u256) -> ContractAddress` external

See [ERC721Component::owner\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-owner_of).

#### `safeTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, data: Span<felt252>)` external

See [ERC721Component::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-safe_transfer_from).

#### `transferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256)` external

See [ERC721Component::transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-transfer_from).

#### `setApprovalForAll(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [ERC721Component::set\_approval\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-set_approval_for_all).

#### `getApproved(self: @ContractState, tokenId: u256) -> ContractAddress` external

See [ERC721Component::get\_approved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-get_approved).

#### `isApprovedForAll(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [ERC721Component::is\_approved\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-is_approved_for_all).

#### `tokenURI(self: @ContractState, tokenId: u256) -> ByteArray` external

See [ERC721Component::token\_uri](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-token_uri).

#### Internal functions

#### `initializer(ref self: ContractState, name: ByteArray, symbol: ByteArray, base_uri: ByteArray)` internal

Initializes the contract by setting the token name and symbol.
This should be used inside the contract’s constructor.

#### `exists(self: @ContractState, token_id: u256) -> bool` internal

Internal function that returns whether `token_id` exists.

Tokens start existing when they are minted ( [mint](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721-mint)), and stop existing when they are burned ( [burn](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721-burn)).

#### `transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)` internal

Transfers `token_id` from `from` to `to`.

Internal function without access restriction.

|     |     |
| --- | --- |
|  | This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol. |

Requirements:

- `to` is not the zero address.

- `from` is the token owner.

- `token_id` exists.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `mint(ref self: ContractState, to: ContractAddress, token_id: u256)` internal

Mints `token_id` and transfers it to `to`.
Internal function without access restriction.

|     |     |
| --- | --- |
|  | This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol. |

Requirements:

- `to` is not the zero address.

- `token_id` does not exist.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `safe_transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` internal

Transfers ownership of `token_id` from `from` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

|     |     |
| --- | --- |
|  | This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities. |

Requirements:

- `to` cannot be the zero address.

- `from` must be the token owner.

- `token_id` exists.

- `to` is either an account contract or supports the `IERC721Receiver` interface.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `safe_mint(ref self: ContractState, to: ContractAddress, token_id: u256, data: Span<felt252>)` internal

Mints `token_id` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

|     |     |
| --- | --- |
|  | This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities. |

Requirements:

- `token_id` does not exist.

- `to` is either an account contract or supports the `IERC721Receiver` interface.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `burn(ref self: ContractState, token_id: u256)` internal

Destroys `token_id`. The approval is cleared when the token is burned.

This internal function does not check if the caller is authorized
to operate on the token.

Requirements:

- `token_id` exists.


Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

#### `update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` internal

Transfers `token_id` from its current owner to `to`, or alternatively mints (or burns) if the current owner
(or `to`) is the zero address. Returns the owner of the `token_id` before the update.

The `auth` argument is optional. If the value passed is non-zero, then this function will check that
`auth` is either the owner of the token, or approved to operate on the token (by the owner).

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer) event.

|     |     |
| --- | --- |
|  | This function can be extended using the `ERC721HooksTrait`, to add<br>functionality before and/or after the transfer, mint, or burn. |

#### `_owner_of(self: @ContractState, token_id: felt252) -> ContractAddress` internal

Internal function that returns the owner address of `token_id`.

#### `_require_owned(self: @ContractState, token_id: felt252) -> ContractAddress` internal

Version of [\_owner\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_owner_of) that panics if owner is the zero address.

#### `_approve(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` internal

Approve `to` to operate on `token_id`

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is
either the owner of the token, or approved to operate on all tokens held by this owner.

Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `_approve_with_optional_event(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress, emit_event: bool)` internal

Variant of [\_approve](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-_approve) with an optional flag to enable or disable the `Approval` event.
The event is not emitted in the context of transfers.

|     |     |
| --- | --- |
|  | If `auth` is zero and `emit_event` is false, this function will not check that the token exists. |

Requirements:

- if `auth` is non-zero, it must be either the owner of the token or approved to
operate on all of its tokens.


May emit an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `_set_approval_for_all(ref self: ContractState, owner: ContractAddress, operator: ContractAddress, approved: bool)` internal

Enables or disables approval for `operator` to manage
all of the `owner` assets.

Requirements:

- `operator` is not the zero address.


Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval) event.

#### `_set_base_uri(ref self: ContractState, base_uri: ByteArray)` internal

Internal function that sets the `base_uri`.

#### `_base_uri(self: @ContractState) -> ByteArray` internal

Base URI for computing [token\_uri](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-token_uri).

If set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
Returns an empty `ByteArray` if not set.

#### `_is_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool` internal

Returns whether `spender` is allowed to manage `owner`'s tokens, or `token_id` in
particular (ignoring whether it is owned by `owner`).

|     |     |
| --- | --- |
|  | This function assumes that `owner` is the actual owner of `token_id` and does not verify this<br>assumption. |

#### `_check_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool` internal

Checks if `spender` can operate on `token_id`, assuming the provided `owner` is the actual owner.

Requirements:

- `owner` cannot be the zero address.

- `spender` cannot be the zero address.

- `spender` must be the owner of `token_id` or be approved to operate on it.


|     |     |
| --- | --- |
|  | This function assumes that `owner` is the actual owner of `token_id` and does not verify this<br>assumption. |

#### Events

#### `Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)` event

See [IERC721::Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Approval).

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

See [IERC721::ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-ApprovalForAll).

#### `Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)` event

See [IERC721::Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-Transfer).

## Receiver

### `IERC721Receiver`

```cairo hljs
use openzeppelin_token::erc721::interface::IERC721Receiver;
```

Interface for contracts that support receiving `safe_transfer_from` transfers.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x3a0dff5f70d80458ad14ae37bb182a728e3c8cdda0402a5daa86620bdf910bc

Functions

- [`on_erc721_received(operator, from, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver-on_erc721_received)


#### Functions

#### `on_erc721_received(operator: ContractAddress, from: ContractAddress, token_id: u256, data: Span<felt252>) -> felt252` external

Whenever an IERC721 `token_id` token is transferred to this non-account contract via [IERC721::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from) by `operator` from `from`, this function is called.

### `ERC721ReceiverComponent`

```cairo hljs
use openzeppelin_token::erc721::ERC721ReceiverComponent;
```

ERC721Receiver component implementing [IERC721Receiver](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERCReceiverMixinImpl

- [`ERC721ReceiverImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl)

- [`ERC721ReceiverCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

ERC721ReceiverImpl

- [`on_erc721_received(self, operator, from, token_id, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-on_erc721_received)


ERC721ReceiverCamelImpl

- [`onERC721Received(self, operator, from, tokenId, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-onERC721Received)


Internal Functions

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-initializer)


#### Embeddable functions

#### `on_erc721_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252` external

Returns the `IERC721Receiver` interface ID.

#### `onERC721Received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252` external

See [ERC721ReceiverComponent::on\_erc721\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721ReceiverComponent-on_erc721_received).

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Registers the `IERC721Receiver` interface ID as supported through introspection.

## Extensions

### `IERC721Enumerable`

Interface for the optional enumerable functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x16bc0f502eeaf65ce0b3acb5eea656e2f26979ce6750e8502a82f377e538c87

Functions

- [`total_supply()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-total_supply)

- [`token_by_index(index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_by_index)

- [`token_of_owner_by_index(owner, index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_of_owner_by_index)


#### Functions

#### `total_supply() -> u256` external

Returns the total amount of tokens stored by the contract.

#### `token_by_index(index: u256) -> u256` external

Returns a token id at a given `index` of all the tokens stored by the contract.
Use along with [IERC721Enumerable::total\_supply](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-total_supply) to enumerate all tokens.

#### `token_of_owner_by_index(owner: ContractAddress, index: u256) -> u256` external

Returns the token id owned by `owner` at a given `index` of its token list.
Use along with [IERC721::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of) to enumerate all of `owner`'s tokens.

### `ERC721EnumerableComponent`

```cairo hljs
use openzeppelin_token::erc721::extensions::ERC721EnumerableComponent;
```

Extension of ERC721 as defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account.
This extension allows contracts to publish their entire list of NFTs and make them discoverable.

|     |     |
| --- | --- |
|  | Implementing [ERC721Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component) is a requirement for this component to be implemented. |

To properly track token ids, this extension requires that the [ERC721EnumerableComponent::before\_update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-before_update) function is called before every transfer, mint, or burn operation.
For this, the [ERC721HooksTrait::before\_update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-before_update) hook must be used.
Here’s how the hook should be implemented in a contract:

```[ hljs language-cairo\
#[starknet::contract]\
mod ERC721EnumerableContract {\
    (...)\
\
    component!(path: ERC721Component, storage: erc721, event: ERC721Event);\
    component!(path: ERC721EnumerableComponent, storage: erc721_enumerable, event: ERC721EnumerableEvent);\
    component!(path: SRC5Component, storage: src5, event: SRC5Event);\
\
    impl ERC721HooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {\
        fn before_update(\
            ref self: ERC721Component::ComponentState<ContractState>,\
            to: ContractAddress,\
            token_id: u256,\
            auth: ContractAddress\
        ) {\
            let mut contract_state = self.get_contract_mut();\
            contract_state.erc721_enumerable.before_update(to, token_id);\
        }\
    }\
}\
```\
\
Embeddable Implementations\
\
ERC721EnumerableImpl\
\
- [`total_supply(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-total_supply)\
\
- [`token_by_index(self, index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-token_by_index)\
\
- [`token_of_owner_by_index(self, address, index)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-token_of_owner_by_index)\
\
\
Internal functions\
\
InternalImpl\
\
- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-initializer)\
\
- [`before_update(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-before_update)\
\
- [`all_tokens_of_owner(self, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-all_tokens_of_owner)\
\
- [`_add_token_to_owner_enumeration(self, to, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_add_token_to_owner_enumeration)\
\
- [`_add_token_to_all_tokens_enumeration(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration)\
\
- [`_remove_token_from_owner_enumeration(self, from, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_remove_token_from_owner_enumeration)\
\
- [`_remove_token_from_all_tokens_enumeration(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration)\
\
\
#### Embeddable functions\
\
#### `total_supply(self: @ContractState) → u256` external\
\
Returns the current amount of votes that `account` has.\
\
#### `token_by_index(self: @ContractState, index: u256) → u256` external\
\
See [IERC721Enumerable::token\_by\_index](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_by_index).\
\
Requirements:\
\
- `index` is less than the total token supply.\
\
\
#### `token_of_owner_by_index(self: @ContractState, owner: ContractAddress, index: u256) → u256` external\
\
See [IERC721Enumerable::token\_of\_owner\_by\_index](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Enumerable-token_of_owner_by_index).\
\
Requirements:\
\
- `index` is less than `owner`'s token balance.\
\
- `owner` is not the zero address.\
\
\
#### Internal functions\
\
#### `initializer(ref self: ContractState)` internal\
\
Registers the `IERC721Enumerable` interface ID as supported through introspection.\
\
#### `before_update(ref self: ContractState, to: ContractAddress, token_id: u256)` internal\
\
Updates the ownership and token-tracking data structures.\
\
When a token is minted (or burned), `token_id` is added to (or removed from) the token-tracking structures.\
\
When a token is transferred, minted, or burned, the ownership-tracking data structures reflect the change in ownership of `token_id`.\
\
This must be added to the implementing contract’s [ERC721HooksTrait::before\_update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-before_update) hook.\
\
#### `all_tokens_of_owner(self: @ContractState, owner: ContractAddress) → Span<u256>` internal\
\
Returns a list of all token ids owned by the specified `owner`.\
This function provides a more efficient alternative to calling `ERC721::balance_of`\
and iterating through tokens with `ERC721Enumerable::token_of_owner_by_index`.\
\
Requirements:\
\
- `owner` is not the zero address.\
\
\
#### `_add_token_to_owner_enumeration(ref self: ContractState, to: ContractAddress, token_id: u256)` internal\
\
Adds token to this extension’s ownership-tracking data structures.\
\
#### `_add_token_to_all_tokens_enumeration(ref self: ContractState, token_id: u256)` internal\
\
Adds token to this extension’s token-tracking data structures.\
\
#### `_remove_token_from_owner_enumeration(ref self: ContractState, from: ContractAddress, token_id: u256)` internal\
\
Removes a token from this extension’s ownership-tracking data structures.\
\
This has 0(1) time complexity but alters the indexed order of owned tokens by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.\
\
#### `_remove_token_from_all_tokens_enumeration(ref self: ContractState, token_id: u256)` internal\
\
Removes `token_id` from this extension’s token-tracking data structures.\
\
This has 0(1) time complexity but alters the indexed order by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.\
\
## Presets\
\
### `ERC721Upgradeable`\
\
```cairo hljs\
use openzeppelin_presets::ERC721Upgradeable;\
```\
\
Upgradeable ERC721 contract leveraging [ERC721Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component).\
\
[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)\
\
0x015922a7436b4ee45120d5f6442bcfd8dd407fa2283dfa2276ccb9db10a9deda\
\
Constructor\
\
- [`constructor(self, name, symbol, recipient, token_ids, base_uri, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Upgradeable-constructor)\
\
\
Embedded Implementations\
\
ERC721MixinImpl\
\
- [`ERC721MixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component-Embeddable-Mixin-Impl)\
\
\
OwnableMixinImpl\
\
- [`OwnableMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Mixin-Impl)\
\
\
External Functions\
\
- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Upgradeable-upgrade)\
\
\
#### Constructor\
\
#### `constructor(ref self: ContractState, name: ByteArray, symbol: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, base_uri: ByteArray, owner: ContractAddress)` constructor\
\
Sets the `name` and `symbol`.\
Mints `token_ids` tokens to `recipient` and sets the `base_uri`.\
Assigns `owner` as the contract owner with permissions to upgrade.\
\
#### External functions\
\
#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` external\
\
Upgrades the contract to a new implementation given by `new_class_hash`.\
\
Requirements:\
\
- The caller is the contract owner.\
\
- `new_class_hash` cannot be zero.\
\
\
[← ERC721](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc721)\
\
[ERC1155 →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc1155)Publishing an Ethereum Package - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Publishing an Ethereum Package

In [Using Dependencies](https://docs.openzeppelin.com/cli/2.8/dependencies), we showed how to use the [`oz link`](https://docs.openzeppelin.com/cli/2.8/commands#link) command to use the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) as a dependency, taking advantage of its contracts being _already deployed on the blockchain_.

In this guide we’ll describe how you can create your own Ethereum Package, and make it available to everyone via the OpenZeppelin CLI.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with using public networks, upgradeable contracts, and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying to a Public Test Network](https://docs.openzeppelin.com/learn/connecting-to-public-test-networks) and [Upgrades](https://docs.openzeppelin.com/learn/upgrading-smart-contracts). |

## Storing Your Project On-chain

So far, we’ve mostly limited ourselves to depoying contracts using [`oz deploy`](https://docs.openzeppelin.com/cli/2.8/commands#create), which creates _upgradeable instances_ by deploying _proxies_ to an existing implementation contract (refer to [How Upgrades Work](https://docs.openzeppelin.com/learn/upgrading-smart-contracts#how-upgrades-work) to brush up on this). Here, we will instead deploy just the implementations, so that other people can create new proxies pointing to them.

To achieve this, we’ll use two low-level CLI commands: [`oz add`](https://docs.openzeppelin.com/cli/2.8/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.8/commands#push). These work simmilarly to `git add` and `git push`: they will register contracts in your project and deploy them to a network.

In your [OpenZeppelin project](https://docs.openzeppelin.com/cli/2.8/getting-started#setting-up-your-project), run:

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add <contract-1>, <contract-2>
✓ Added contract <contract-1>
✓ Added contract <contract-2>
All the selected contracts have been added to the project
$ npx oz push
? Pick a network mainnet
✓ Contract <contract-1> deployed
✓ Contract <contract-2> deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | For your Ethereum Pacakge to be used by others, it needs to be deployed on a real network instead of a local one. Take a look at [Deploying to a Public Test Network](https://docs.openzeppelin.com/learn/connecting-to-public-test-networks) for detailed instructions for this process. |

Ethereum Packages are upgradeable, which means they track the different implementation contracts that correspond to each version of the package. We’ll use the [`oz publish`](https://docs.openzeppelin.com/cli/2.8/commands#publish) command for this, which will deploy an [`App`](https://docs.openzeppelin.com/cli/2.8/contracts-architecture#app.sol) contract and register the implementations there:

```console hljs language-shell
$ npx oz publish
? Pick a network mainnet
✓ Project structure deployed
✓ Registering <contract-1> at 0x2c2eB5B599C2C4Bb2cA7e43179585aFec0D97D51 in directory
✓ Registering <contract-2> at 0x6389e6409Ad106aF5e7e6bE8D95Fca637980fB63 in directory
✓ Published to mainnet!
```

The Ethereum Package is complete! But we’re still lacking something: a convenient way to tell people about its existence.

## Distributing With `npm`

For your Ethereum Package to [usable from other projects](https://docs.openzeppelin.com/cli/2.8/dependencies), it needs to be published on the [npm registry](https://www.npmjs.com/). If you havent’t published an npm package before, go ahead and [sign up for a free npm account](https://www.npmjs.com/signup).

First, add your contract sources, compiled artifacts and OpenZeppelin project files to your package by including the following entries in your project’s `package.json`:

```diff hljs
 // package.json
 {
   ...,
   "files": [\
+    "build",\
+    "contracts",\
+    ".openzeppelin/*.json"\
   ]
 }
```

|     |     |
| --- | --- |
|  | The files in your `.openzeppelin` directory that [should not be tracked in version control](https://docs.openzeppelin.com/cli/2.8/configuration#configuration-files-in-version-control) are not required to be part of your published npm package: remove them before publishing to the registry. |

Almost done! Log into npm and upload your package with:

```console hljs language-shell
$ npm login
$ npm publish
```

Success! The Ethereum Package is now live on the blockchain, and accessible to everyone via the npm registry.

Any OpenZeppelin project can now [link](https://docs.openzeppelin.com/cli/2.8/commands#link) to your package:

```console hljs language-shell
$ npx oz link <your-project-name>
```

|     |     |
| --- | --- |
|  | Your Ethereum Package’s name is the same one you provided [during initialization](https://docs.openzeppelin.com/cli/2.8/getting-started#setting-up-your-project). |Command Line Interface (CLI) - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Command Line Interface (CLI)

**Develop, deploy and operate upgradeable smart contract projects**. Support for Ethereum and every other EVM-powered blockchain.

- **Interactive commands**: Send transactions, query balances, and interact with your contracts directly from the command line, using commands like `oz send-tx`, `oz call`, `oz balance`, and `oz transfer`.

- **Deploy & upgrade your contracts**: You can develop your smart contracts iteratively, speeding up development locally, or squashing bugs in production. Run `oz create` to deploy your contracts, followed by `oz upgrade` any time you want to change their code.

- **Link Ethereum Packages**: Use code from contracts already deployed to the blockchain directly on your project, saving gas on deployments and managing your dependencies securely, just with an `oz link` command.

- **Bootstrap your dapp**: Jumpstart your dapp by unpacking one of our starter kits, pre-configured with OpenZeppelin Contracts, React, and Infura. Run `oz unpack` to start!


## Overview

### Installation

```console hljs language-shell
$ npm install @openzeppelin/cli
```

### Usage

All CLI commands are fully interactive: you can call them with no or incomplete arguments and they will prompt you for options as they proceed.

Below is a short list of the most used commands:

- [`oz init`](https://docs.openzeppelin.com/cli/2.7/commands#init): initialize your OpenZeppelin project

- [`oz compile`](https://docs.openzeppelin.com/cli/2.7/commands#compile): compile all Solidity smart contracts in your project

- [`oz create`](https://docs.openzeppelin.com/cli/2.7/commands#create): deploy an upgradeable smart contract

- [`oz send-tx`](https://docs.openzeppelin.com/cli/2.7/commands#send): send a transaction to a contract and execute a function

- [`oz call`](https://docs.openzeppelin.com/cli/2.7/commands#call): read data from the blockchain by calling `view` and `pure` functions

- [`oz upgrade`](https://docs.openzeppelin.com/cli/2.7/commands#upgrade): upgrade a deployed contract to a new version without changing the address or state

- [`oz unpack`](https://docs.openzeppelin.com/cli/2.7/commands#unpack): bootstrap a project with a [Starter Kit](https://docs.openzeppelin.com/starter-kits/)

- [`oz link`](https://docs.openzeppelin.com/cli/2.7/commands#link): reuse on-chain code by to a [linking to Ethereum Packages](https://docs.openzeppelin.com/cli/2.7/dependencies)


## Learn More

- Head to [Getting Started](https://docs.openzeppelin.com/cli/2.7/getting-started) to see the CLI in action by deploying and upgrading a smart contract!

- [Using Dependencies](https://docs.openzeppelin.com/cli/2.7/dependencies) showcases a more complex project being built, including leveraging the [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/) library.

- If you are a Truffle user, go to [Using With Truffle](https://docs.openzeppelin.com/cli/2.7/truffle) for information on using both tools on the same project.

- Take a look at the API reference for all [CLI commands](https://docs.openzeppelin.com/cli/2.7/commands).

- For an overview of the internals of the CLI, you can read on the [Contracts Architecture](https://docs.openzeppelin.com/cli/2.7/contracts-architecture) and different [Configuration Files](https://docs.openzeppelin.com/cli/2.7/configuration).


|     |     |
| --- | --- |
|  | Looking for the documentation for version 2.4 or earlier? You can find it [here](https://docs.zeppelinos.org/versions). |

[Getting Started →](https://docs.openzeppelin.com/cli/2.7/getting-started)Access Control - OpenZeppelin Docs

# Access Control

This crate provides ways to restrict who can access the functions of a contract or when they can do it.

- [Ownable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent) is a simple mechanism with a single "owner" role that can be assigned to a single account.
This mechanism can be useful in simple scenarios, but fine grained access needs are likely to outgrow it.

- [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) provides a general role based access control mechanism. Multiple hierarchical roles can be created and
assigned each to multiple accounts.


## Authorization

### `OwnableComponent`

```cairo hljs
use openzeppelin_access::ownable::OwnableComponent;
```

`Ownable` provides a basic access control mechanism where an account
(an owner) can be granted exclusive access to specific functions.

This module includes the internal `assert_only_owner` to restrict a function to be used only by the owner.

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

OwnableMixinImpl

- [`OwnableImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableImpl)

- [`OwnableCamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableCamelOnlyImpl)


OwnableTwoStepMixinImpl

- [`OwnableTwoStepImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableTwoStepImpl)

- [`OwnableTwoStepCamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Embeddable-Impls-OwnableTwoStepCamelOnlyImpl)


Embeddable Implementations

OwnableImpl

- [`owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-owner)

- [`transfer_ownership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-transfer_ownership)

- [`renounce_ownership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-renounce_ownership)


OwnableTwoStepImpl

- [`owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-owner)

- [`pending_owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-pending_owner)

- [`accept_ownership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-accept_ownership)

- [`transfer_ownership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-transfer_ownership)

- [`renounce_ownership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-renounce_ownership)


OwnableCamelOnlyImpl

- [`transferOwnership(self, newOwner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-transferOwnership)

- [`renounceOwnership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-renounceOwnership)


OwnableTwoStepCamelOnlyImpl

- [`pendingOwner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-pendingOwner)

- [`acceptOwnership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-acceptOwnership)

- [`transferOwnership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-transferOwnership)

- [`renounceOwnership(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-renounceOwnership)


Internal Implementations

InternalImpl

- [`initializer(self, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-initializer)

- [`assert_only_owner(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-assert_only_owner)

- [`_transfer_ownership(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-_transfer_ownership)

- [`_propose_owner(self, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-_propose_owner)


Events

- [`OwnershipTransferStarted(previous_owner, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferStarted)

- [`OwnershipTransferred(previous_owner, new_owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred)


#### Embeddable functions

#### `owner(self: @ContractState) → ContractAddress` external

Returns the address of the current owner.

#### `transfer_ownership(ref self: ContractState, new_owner: ContractAddress)` external

Transfers ownership of the contract to a new account ( `new_owner`).
Can only be called by the current owner.

Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `renounce_ownership(ref self: ContractState)` external

Leaves the contract without owner. It will not be possible to call
`assert_only_owner` functions anymore. Can only be called by the current owner.

|     |     |
| --- | --- |
|  | Renouncing ownership will leave the contract without an owner,<br>thereby removing any functionality that is only available to the owner. |

#### Embeddable functions (two step transfer)

#### `owner(self: @ContractState) → ContractAddress` external

Returns the address of the current owner.

#### `pending_owner(self: @ContractState) → ContractAddress` external

Returns the address of the pending owner.

#### `accept_ownership(ref self: ContractState)` external

Transfers ownership of the contract to the pending owner.
Can only be called by the pending owner.
Resets pending owner to zero address.

Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `transfer_ownership(ref self: ContractState, new_owner: ContractAddress)` external

Starts the two step ownership transfer process, by setting the pending owner. Setting `new_owner` to the zero address is allowed, this can be used to cancel an initiated ownership transfer.

Can only be called by the current owner.

Emits an [OwnershipTransferStarted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferStarted) event.

#### `renounce_ownership(ref self: ContractState)` external

Leaves the contract without owner. It will not be possible to call
`assert_only_owner` functions anymore. Can only be called by the current owner.

|     |     |
| --- | --- |
|  | Renouncing ownership will leave the contract without an owner,<br>thereby removing any functionality that is only available to the owner. |

#### `transferOwnership(ref self: ContractState, newOwner: ContractAddress)` external

See [transfer\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-transfer_ownership).

#### `renounceOwnership(ref self: ContractState)` external

See [renounce\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-renounce_ownership).

#### `pendingOwner(self: @ContractState)` external

See [pending\_owner](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-pending_owner).

#### `acceptOwnership(self: @ContractState)` external

See [accept\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-accept_ownership).

#### `transferOwnership(self: @ContractState)` external

See [transfer\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-transfer_ownership).

#### `renounceOwnership(self: @ContractState)` external

See [renounce\_ownership](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-two-step-renounce_ownership).

#### Internal functions

#### `initializer(ref self: ContractState, owner: ContractAddress)` internal

Initializes the contract and sets `owner` as the initial owner.

Requirements:

- `owner` cannot be the zero address.


Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `assert_only_owner(self: @ContractState)` internal

Panics if called by any account other than the owner.

#### `_transfer_ownership(ref self: ContractState, new_owner: ContractAddress)` internal

Transfers ownership of the contract to a new account ( `new_owner`).
Internal function without access restriction.

Emits an [OwnershipTransferred](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferred) event.

#### `_propose_owner(ref self: ContractState, new_owner: ContractAddress)` internal

Sets a new pending owner in a two step transfer.

Internal function without access restriction.

Emits an [OwnershipTransferStarted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-OwnershipTransferStarted) event.

#### Events

#### `OwnershipTransferStarted(previous_owner: ContractAddress, new_owner: ContractAddress)` event

Emitted when the pending owner is updated.

#### `OwnershipTransferred(previous_owner: ContractAddress, new_owner: ContractAddress)` event

Emitted when the ownership is transferred.

### `IAccessControl`

```cairo hljs
use openzeppelin_access::accesscontrol::interface::IAccessControl;
```

External interface of AccessControl.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x23700be02858dbe2ac4dc9c9f66d0b6b0ed81ec7f970ca6844500a56ff61751

Functions

- [`has_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-has_role)

- [`get_role_admin(role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-get_role_admin)

- [`grant_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role)

- [`revoke_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role)

- [`renounce_role(role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-renounce_role)


Events

- [`RoleAdminChanged(role, previous_admin_role, new_admin_role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged)

- [`RoleGranted(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted)

- [`RoleRevoked(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked)


#### Functions

#### `has_role(role: felt252, account: ContractAddress) → bool` external

Returns `true` if `account` has been granted `role`.

#### `get_role_admin(role: felt252) → felt252` external

Returns the admin role that controls `role`. See [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role) and
[revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role).

To change a role’s admin, use [set\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin).

#### `grant_role(role: felt252, account: ContractAddress)` external

Grants `role` to `account`.

If `account` had not been already granted `role`, emits a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted)
event.

Requirements:

- the caller must have `role`'s admin role.


#### `revoke_role(role: felt252, account: ContractAddress)` external

Revokes `role` from `account`.

If `account` had been granted `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

Requirements:

- the caller must have `role`'s admin role.


#### `renounce_role(role: felt252, account: ContractAddress)` external

Revokes `role` from the calling account.

Roles are often managed via [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-grant_role) and [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-revoke_role). This function’s
purpose is to provide a mechanism for accounts to lose their privileges
if they are compromised (such as when a trusted device is misplaced).

If the calling account had been granted `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked)
event.

Requirements:

- the caller must be `account`.


#### Events

#### `RoleAdminChanged(role: felt252, previous_admin_role: ContractAddress, new_admin_role: ContractAddress)` event

Emitted when `new_admin_role` is set as `role`'s admin role, replacing `previous_admin_role`

`DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
[RoleAdminChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged) not being emitted signaling this.

#### `RoleGranted(role: felt252, account: ContractAddress, sender: ContractAddress)` event

Emitted when `account` is granted `role`.

`sender` is the account that originated the contract call, an admin role
bearer.

#### `RoleRevoked(role: felt252, account: ContractAddress, sender: ContractAddress)` event

Emitted when `account` is revoked `role`.

`sender` is the account that originated the contract call:

- if using `revoke_role`, it is the admin role bearer.

- if using `renounce_role`, it is the role bearer (i.e. `account`).


### `AccessControlComponent`

```cairo hljs
use openzeppelin_access::accesscontrol::AccessControlComponent;
```

Component that allows contracts to implement role-based access control mechanisms.
Roles are referred to by their `felt252` identifier:

```cairo hljs
const MY_ROLE: felt252 = selector!("MY_ROLE");
```

Roles can be used to represent a set of permissions. To restrict access to a
function call, use [`assert_only_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role):

```cairo hljs
(...)

#[external(v0)]
fn foo(ref self: ContractState) {
    self.accesscontrol.assert_only_role(MY_ROLE);

    // Do something
}
```

Roles can be granted and revoked dynamically via the [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and
[revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role) functions. Each role has an associated admin role, and only
accounts that have a role’s admin role can call [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role).

By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
that only accounts with this role will be able to grant or revoke other
roles. More complex role relationships can be created by using
[set\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin).

|     |     |
| --- | --- |
|  | The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to<br>grant and revoke this role. Extra precautions should be taken to secure<br>accounts that have been granted it. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

AccessControlMixinImpl

- [`AccessControlImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls-AccessControlImpl)

- [`AccessControlCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-Embeddable-Impls-AccessControlCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

AccessControlImpl

- [`has_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-has_role)

- [`get_role_admin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-get_role_admin)

- [`grant_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role)

- [`revoke_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role)

- [`renounce_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-renounce_role)


AccessControlCamelImpl

- [`hasRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-hasRole)

- [`getRoleAdmin(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-getRoleAdmin)

- [`grantRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grantRole)

- [`revokeRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revokeRole)

- [`renounceRole(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-renounceRole)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


Internal Implementations

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-initializer)

- [`assert_only_role(self, role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role)

- [`set_role_admin(self, role, admin_role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin)

- [`_grant_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-_grant_role)

- [`_revoke_role(self, role, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-_revoke_role)


Events

IAccessControl

- [`RoleAdminChanged(role, previous_admin_role, new_admin_role)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-RoleAdminChanged)

- [`RoleGranted(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-RoleGranted)

- [`RoleRevoked(role, account, sender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-RoleRevoked)


#### Embeddable functions

#### `has_role(self: @ContractState, role: felt252, account: ContractAddress) → bool` external

Returns `true` if `account` has been granted `role`.

#### `get_role_admin(self: @ContractState, role: felt252) → felt252` external

Returns the admin role that controls `role`. See [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and
[revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role).

To change a role’s admin, use [set\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin).

#### `grant_role(ref self: ContractState, role: felt252, account: ContractAddress)` external

Grants `role` to `account`.

If `account` had not been already granted `role`, emits a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted)
event.

Requirements:

- the caller must have `role`'s admin role.


May emit a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event.

#### `revoke_role(ref self: ContractState, role: felt252, account: ContractAddress)` external

Revokes `role` from `account`.

If `account` had been granted `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

Requirements:

- the caller must have `role`'s admin role.


May emit a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

#### `renounce_role(ref self: ContractState, role: felt252, account: ContractAddress)` external

Revokes `role` from the calling account.

Roles are often managed via [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role). This function’s
purpose is to provide a mechanism for accounts to lose their privileges
if they are compromised (such as when a trusted device is misplaced).

If the calling account had been revoked `role`, emits a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked)
event.

Requirements:

- the caller must be `account`.


May emit a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

#### `supports_interface(self: @ContractState, interface_id: felt252) → bool` external

See [ISRC5::supports\_interface](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface).

#### `hasRole(self: @ContractState, role: felt252, account: ContractAddress) → bool` external

See [has\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-has_role).

#### `getRoleAdmin(self: @ContractState, role: felt252) → felt252` external

See [get\_role\_admin](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-get_role_admin).

#### `grantRole(ref self: ContractState, role: felt252, account: ContractAddress)` external

See [grant\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role).

#### `revokeRole(ref self: ContractState, role: felt252, account: ContractAddress)` external

See [revoke\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role).

#### `renounceRole(ref self: ContractState, role: felt252, account: ContractAddress)` external

See [renounce\_role](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-renounce_role).

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Initializes the contract by registering the [IAccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl) interface ID.

#### `assert_only_role(self: @ContractState, role: felt252)` internal

Panics if called by any account without the given `role`.

#### `set_role_admin(ref self: ContractState, role: felt252, admin_role: felt252)` internal

Sets `admin_role` as `role`'s admin role.

Internal function without access restriction.

Emits a [RoleAdminChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged) event.

#### `_grant_role(ref self: ContractState, role: felt252, account: ContractAddress)` internal

Grants `role` to `account`.

Internal function without access restriction.

May emit a [RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted) event.

#### `_revoke_role(ref self: ContractState, role: felt252, account: ContractAddress)` internal

Revokes `role` from `account`.

Internal function without access restriction.

May emit a [RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked) event.

#### Events

#### `RoleAdminChanged(role: felt252, previous_admin_role: ContractAddress, new_admin_role: ContractAddress)` event

See [IAccessControl::RoleAdminChanged](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleAdminChanged).

#### `RoleGranted(role: felt252, account: ContractAddress, sender: ContractAddress)` event

See [IAccessControl::RoleGranted](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleGranted).

#### `RoleRevoked(role: felt252, account: ContractAddress, sender: ContractAddress)` event

See [IAccessControl::RoleRevoked](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#IAccessControl-RoleRevoked).

[← Access](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access)

[Accounts →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/accounts)OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


## openzeppelin\|oz

Usage: `openzeppelin|oz <command> [options]`

where <command> is one of: accounts, add, balance, bump, call, check, compile, create, create2, deploy, freeze, init, link, publish, push, remove, send-tx, session, set-admin, transfer, unlink, unpack, upgrade, verify

`--version`

output the version number

`-v, --verbose`

verbose mode on: output errors stacktrace and detailed log.

`-s, --silent`

silent mode: no output sent to stderr.

## accounts

Usage: `accounts [options]`

list the accounts of the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## add

Usage: `add [contractName1[:contractAlias1] …​ contractNameN[:contractAliasN]] [options]`

add contract to your project. Provide a list of whitespace-separated contract names

`--all`

add all contracts in your build directory

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## balance

Usage: `balance --network <network> [options]`

query the balance of the specified account

`--erc20 <contractAddress>`

query the balance of an ERC20 token instead of ETH

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## bump

Usage: `bump <version> [options]`

bump your project to a new <version>

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## call

Usage: `call --to <to> --method <method> [options]`

call a method of the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the call

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## check

Usage: `check [contract] [options]`

checks your contracts for potential issues

`--skip-compile`

skips contract compilation

## compile

Usage: `compile [options]`

compiles all contracts in the current project

`--solc-version [version]`

version of the solc compiler to use (value is written to configuration file for future runs, defaults to most recent release that satisfies contract pragmas)

`--optimizer [on|off]`

enables compiler optimizer (value is written to configuration file for future runs, defaults to off)

`--optimizer-runs [runs]`

specify number of runs if optimizer enabled (value is written to configuration file for future runs, defaults to 200)

`--evm-version [evm]`

choose target evm version (value is written to configuration file for future runs, defaults depends on compiler: byzantium prior to 0.5.5, petersburg from 0.5.5)

`--typechain [web3-v1|truffle|ethers]`

enables typechain generation of typescript wrappers for contracts using the chosen target

`--typechain-outdir [path]`

path where typechain artifacts are written (defaults to ./types/contracts/)

`--no-interactive`

force to run the command in non-interactive mode

## create

Usage: `create [alias] --network <network> [options]`

deploys a new upgradeable contract instance. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package.

`--init [function]`

call function after creating contract. If none is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--force`

ignore contracts validation errors

`--minimal`

creates a cheaper but non-upgradeable instance instead, using a minimal proxy

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## create2

Usage: `create2 [alias] --network <network> --salt <salt> [options]`

deploys a new upgradeable contract instance using CREATE2 at a predetermined address given a numeric <salt> and a <from> address. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package. A <signature> can be provided to derive the deployment address from a signer different to the <from> address. Warning: support for this feature is experimental.

`--salt <salt>`

salt used to determine the deployment address (required)

`--query [sender]`

do not create the contract and just return the deployment address, optionally specifying the sender used to derive the deployment address (defaults to 'from')

`--init [function]`

initialization function to call after creating contract (defaults to 'initialize', skips initialization if not set)

`--args <arg1, arg2, …​>`

arguments to the initialization function

`--admin <admin>`

admin of the proxy (uses the project’s proxy admin if not set)

`--signature <signature>`

signature of the request, uses the signer to derive the deployment address (uses the sender to derive deployment address if not set)

`--force`

force creation even if contracts have local modifications

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## deploy

Usage: `deploy [options] [contract] [arguments…​]`

deploy a contract instance

`--skip-compile`

use existing compilation artifacts

`-k, --kind <kind>`

the kind of deployment (regular, upgradeable, minimal)

`-n, --network <network>`

network to use

`--timeout <timeout>`

timeout in seconds for each transaction (default: 750)

`-f, --from <address>`

sender for the contract creation transaction

`--migrate-manifest`

enable automatic migration of manifest format

`--no-interactive`

disable interactive prompts

## freeze

Usage: `freeze --network <network> [options]`

freeze current release version of your published project

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## init

Usage: `init <project-name> [version]`

initialize your OpenZeppelin project. Provide a <project-name> and optionally an initial \[version\] name

`--publish`

automatically publish your project upon pushing it to a network

`--force`

overwrite existing project if there is one

`--typechain <target>`

enable typechain support with specified target (web3-v1, ethers, or truffle)

`--typechain-outdir <path>`

set output directory for typechain compilation (defaults to types/contracts)

`--link <dependency>`

link to a dependency

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## link

Usage: `link [dependencyName1 …​ dependencyNameN] [options]`

links project with a list of dependencies each located in its npm package

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## publish

Usage: `publish --network <network> [options]`

publishes your project to the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## push

Usage: `push --network <network> [options]`

deploys your project to the specified <network>

`--skip-compile`

skips contract compilation

`-d, --deploy-dependencies`

deploys dependencies to the network if there is no existing deployment

`--reset`

redeploys all contracts (not only the ones that changed)

`--force`

ignores validation errors and deploys contracts

`--deploy-proxy-admin`

eagerly deploys the project’s proxy admin (if not deployed yet on the provided network)

`--deploy-proxy-factory`

eagerly deploys the project’s proxy factory (if not deployed yet on the provided network)

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## remove

Usage: `remove [contract1 …​ contractN] [options]`

removes one or more contracts from your project. Provide a list of whitespace-separated contract names.

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## send-tx

Usage: `send-tx --to <to> --method <method> [options]`

send a transaction to the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the transaction

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`--value <value>`

optional value in wei to send with the transaction

`--gas <gas>`

gas limit of the transaction, will default to the limit specified in the configuration file, or use gas estimation if not set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## session

Usage: `session [options]`

by providing network options, commands like create, freeze, push, and update will use them unless overridden. Use --close to undo.

`--expires <expires>`

expiration of the session in seconds (defaults to 900, 15 minutes)

`--close`

closes the current session, removing all network options set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## set-admin

Usage: `set-admin [alias-or-address] [new-admin-address] --network <network> [options]`

change upgradeability admin of a contract instance, all instances or proxy admin. Provide the \[alias\] or \[package\]/\[alias\] of the contract to change the ownership of all its instances, or its \[address\] to change a single one, or none to change all contract instances to a new admin. Note that if you transfer to an incorrect address, you may irreversibly lose control over upgrading your contract.

`--force`

bypass a manual check

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## transfer

Usage: `transfer --network <network> [options]`

send funds to a given address

`--to <to>`

specify recipient address

`--value <value>`

the amount of ether units to be transferred

`--unit <unit>`

unit name. Wei, kwei, gwei, milli and ether are supported among others. If none is given, 'ether' will be used.

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## unlink

Usage: `unlink [dependencyName1…​ dependencyNameN]`

unlinks dependencies from the project. Provide a list of whitespace-separated dependency names

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## unpack

Usage: `unpack [kit]`

download and install an OpenZeppelin Starter Kit to the current directory

`--no-interactive`

force to run the command in non-interactive mode

## upgrade

Usage: `upgrade [alias-or-address] --network <network> [options]`

upgrade contract to a new logic. Provide the \[alias\] or \[package\]/\[alias\] you added your contract with, its \[address\], or use --all flag to upgrade all contracts in your project.

`--init [function]`

call function after upgrading contract. If no name is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--all`

upgrade all contracts in the application

`--force`

ignore contracts validation errors

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## verify

Usage: `verify [options] [contract]`

verify a contract’s source with Etherscan or Etherchain

`-n, --network <network>`

network to verify contracts in

`-o, --optimizer <enabled>`

whether compilation optimizations were enabled

`--optimizer-runs <runs>`

the number of runs for the optimizer

`--remote <remote>`

the remote endpoint to use for verification (etherscan, etherchain)

`--api-key <key>`

Etherscan API key (get one at [https://etherscan.io/myapikey](https://etherscan.io/myapikey))

`--no-interactive`

disable interactive prompts

[← Upgrades Library](https://docs.openzeppelin.com/upgrades/2.8/)

[Configuration Files →](https://docs.openzeppelin.com/cli/2.8/configuration)Getting Started - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Getting Started

This tutorial will showcase usage of the OpenZeppelin CLI, giving you a taste of its capabilities and serving as a starting point for your own projects.

We will cover:
\\* Create a new OpenZeppelin project with a smart contract
\\* Deploying our contract to a local development network
\\* Interacting with our contract from the terminal
\\* Upgrading the deployed contract to a new version

## Prerequisites

The CLI is installed as a dependency to your Node project:

```console hljs language-shell
$ npm install @openzeppelin/cli
```

|     |     |
| --- | --- |
|  | If you’re unfamiliar with Node and npm, head to our guide on [Setting Up a Development Environment](https://docs.openzeppelin.com/cli/2.6/getting-started#learn::set-up-dev-environment). |

We are installing the CLI [locally](https://docs.npmjs.com/downloading-and-installing-packages-locally) instead of [globally](https://docs.npmjs.com/downloading-and-installing-packages-globally), which means usage of the CLI will be prefixed with `npx`. This will avoid issues that arise from having global dependencies, and will let you have different versions of the CLI in each of your projects, if you so desire.

## Setting up Your Project

Inside your Node project, use the CLI to initialize an OpenZeppelin project:

```console hljs language-shell
$ npx openzeppelin init
```

The CLI will prompt you for a project name and version, defaulting to the ones from the `package.json`, and then set up a few files and directories for running your OpenZeppelin project.

|     |     |
| --- | --- |
|  | If you’d rather type less, you can use the `oz` command alias, so `openzeppelin init` becomes just `oz init`. We’ll use this throughout the tutorial. |

We are now ready to begin working on our project.

|     |     |
| --- | --- |
|  | Should you get lost at any point during this tutorial, you can refer to the full code for this project in our [`Github repo`](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.4.0/examples/first-project). |

## Your First Contract

We will write a simple contract in [Solidity](https://solidity.readthedocs.io/), the most popular language for Ethereum smart contracts. Create a new file `contracts/Counter.sol` in your project with the following content:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
    uint256 public value;

    function increase() public {
      value++;
    }
}
```

This contract stores a numeric `value` that is increased by one every time we send a transaction to the `increase()` function.

You can run `oz compile` to compile the contract and check for any errors. Once that’s done, we’ll be ready to deploy it.

|     |     |
| --- | --- |
|  | You don’t have to worry if you forget to compile your contract. The CLI will automatically check if your contract changed when you run any command, and compile it if needed. |

## Deploying to a Development Network

We will use [Ganache](https://truffleframework.com/ganache) as a _development network_ to deploy our contract. If you don’t have Ganache installed, do so now by running `npm install ganache-cli`.

Development networks are mini blockchains that run just on your computer, and are much faster than the actual Ethereum network. We will use one for coding and testing.

|     |     |
| --- | --- |
|  | Head to [Setting up a Local Blockchain](https://docs.openzeppelin.com/cli/2.6/getting-started#learn::deploy-and-interact.adoc#local-blockchain) to learn more about using Ganache. |

Open a separate terminal and start a new Ganache process:

```console hljs language-shell
$ npx ganache-cli --deterministic
```

This will start a new development network using a deterministic set of accounts, instead of random ones. We can now deploy our contract there, running `oz create`, and choosing to deploy the `Counter` contract to the `development` network.

```console hljs language-shell
$ npx oz create
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
? Pick a contract to instantiate: Counter
? Pick a network: development
✓ Added contract Counter
✓ Contract Counter deployed
? Call a function to initialize the instance after creating it?: No
✓ Setting everything up to create contract instances
✓ Instance created at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
```

|     |     |
| --- | --- |
|  | The addresses where your contracts are created and the transaction identifiers you see may differ from the ones listed here. |

Our `Counter` contract is deployed to the local development network and ready to go! We can test it out by interacting with it from the terminal. Let’s try incrementing the counter, by sending a transaction to call the `increase` function through `oz send-tx`.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase()
✓ Transaction successful. Transaction hash: 0x20bef6583ea32cc57fe179e34dd57a5494db3c403e441624e56a886898cb52bd
```

We can now use `oz call` to query the contract’s public `value`, and check that it was indeed increased from zero to one.

```console hljs language-shell
$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
✓ Method 'value()' returned: 1
```

## Upgrading Your Contract

We will now modify our `Counter` contract to make the `increase` function more interesting. Instead of increasing the counter by one, we will allow the caller to increase the counter by any value. Let’s modify the code in `contracts/Counter.sol` to the following:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
  uint256 public value;

  function increase(uint256 amount) public {
    value += amount;
  }
}
```

We can now upgrade the instance we created earlier to this new version:

```console hljs language-shell
$ npx oz upgrade
? Pick a network: development
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
✓ Contract Counter deployed
? Which proxies would you like to upgrade?: All proxies
Instance upgraded at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601.
```

Done! Our `Counter` instance has been upgraded to the latest version, and **neither its address nor its state have changed**. Let’s check it out by increasing the counter by ten, which should yield eleven, since we had already increased it by one:

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase(amount: uint256)
? amount (uint256): 10
Transaction successful: 0x9c84faf32a87a33f517b424518712f1dc5ba0bdac4eae3a67ca80a393c555ece

$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
Returned "11"
```

|     |     |
| --- | --- |
|  | That smart contracts are immutable, so you may be wondering how the OpenZeppelin CLI achieved this feat. To learn about this, head to the docomentation for [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/), in particular the guide about [Proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies).<br>You will note that there are some changes that are not supported during upgrades. For instance, you cannot [remove or change the type of a contract state variable](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts). Nevertheless, you can change, add, or remove all the functions you want. |

That’s it! You now know how to start a simple OpenZeppelin project, create a contract, deploy it to a local network, and even upgrade it as you develop. Head over to the next tutorial to learn how to interact with your contract from your code.

[← Overview](https://docs.openzeppelin.com/cli/2.6/)

[Using Dependencies →](https://docs.openzeppelin.com/cli/2.6/dependencies)Security - OpenZeppelin Docs

# Security

The following documentation provides context, reasoning, and examples of modules found under `openzeppelin_security`.

|     |     |
| --- | --- |
|  | Expect these modules to evolve. |

## Initializable

The [Initializable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#InitializableComponent) component provides a simple mechanism that mimics
the functionality of a constructor.
More specifically, it enables logic to be performed once and only once which is useful to set up a contract’s initial state when a constructor cannot be used, for example when there are circular dependencies at construction time.

### Usage

You can use the component in your contracts like this:

```cairo hljs
#[starknet::contract]
mod MyInitializableContract {
    use openzeppelin_security::InitializableComponent;

    component!(path: InitializableComponent, storage: initializable, event: InitializableEvent);

    impl InternalImpl = InitializableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        initializable: InitializableComponent::Storage,
        param: felt252
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        InitializableEvent: InitializableComponent::Event
    }

    fn initializer(ref self: ContractState, some_param: felt252) {
        // Makes the method callable only once
        self.initializable.initialize();

        // Initialization logic
        self.param.write(some_param);
    }
}
```

|     |     |
| --- | --- |
|  | This Initializable pattern should only be used in one function. |

### Interface

The component provides the following external functions as part of the `InitializableImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait InitializableABI {
    fn is_initialized() -> bool;
}
```

## Pausable

The [Pausable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent) component allows contracts to implement an emergency stop mechanism.
This can be useful for scenarios such as preventing trades until the end of an evaluation period or having an emergency switch to freeze all transactions in the event of a large bug.

To become pausable, the contract should include `pause` and `unpause` functions (which should be protected).
For methods that should be available only when paused or not, insert calls to `assert_paused` and `assert_not_paused`
respectively.

### Usage

For example (using the [Ownable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent) component for access control):

```cairo hljs
#[starknet::contract]
mod MyPausableContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_security::PausableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // Pausable
    #[abi(embed_v0)]
    impl PausableImpl = PausableComponent::PausableImpl<ContractState>;
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        pausable: PausableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        PausableEvent: PausableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[external(v0)]
    fn pause(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.pausable.pause();
    }

    #[external(v0)]
    fn unpause(ref self: ContractState) {
        self.ownable.assert_only_owner();
        self.pausable.unpause();
    }

    #[external(v0)]
    fn when_not_paused(ref self: ContractState) {
        self.pausable.assert_not_paused();
        // Do something
    }

    #[external(v0)]
    fn when_paused(ref self: ContractState) {
        self.pausable.assert_paused();
        // Do something
    }
}
```

### Interface

The component provides the following external functions as part of the `PausableImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait PausableABI {
    fn is_paused() -> bool;
}
```

## Reentrancy Guard

A [reentrancy attack](https://gus-tavo-guim.medium.com/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4) occurs when the caller is able to obtain more resources than allowed by recursively calling a target’s function.

### Usage

Since Cairo does not support modifiers like Solidity, the [ReentrancyGuard](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#ReentrancyGuardComponent)
component exposes two methods `start` and `end` to protect functions against reentrancy attacks.
The protected function must call `start` before the first function statement, and `end` before the return statement, as shown below:

```cairo hljs
#[starknet::contract]
mod MyReentrancyContract {
    use openzeppelin_security::ReentrancyGuardComponent;

    component!(
        path: ReentrancyGuardComponent, storage: reentrancy_guard, event: ReentrancyGuardEvent
    );

    impl InternalImpl = ReentrancyGuardComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        reentrancy_guard: ReentrancyGuardComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ReentrancyGuardEvent: ReentrancyGuardComponent::Event
    }

    #[external(v0)]
    fn protected_function(ref self: ContractState) {
        self.reentrancy_guard.start();

        // Do something

        self.reentrancy_guard.end();
    }

    #[external(v0)]
    fn another_protected_function(ref self: ContractState) {
        self.reentrancy_guard.start();

        // Do something

        self.reentrancy_guard.end();
    }
}
```

|     |     |
| --- | --- |
|  | The guard prevents the execution flow occurring inside `protected_function`<br>to call itself or `another_protected_function`, and vice versa. |

[← Merkle Tree](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security)ERC1155 - OpenZeppelin Docs

# ERC1155

The ERC1155 multi token standard is a specification for [fungibility-agnostic](https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens) token contracts.
The ERC1155 library implements an approximation of [EIP-1155](https://eips.ethereum.org/EIPS/eip-1155) in Cairo for StarkNet.

## Multi Token Standard

The distinctive feature of ERC1155 is that it uses a single smart contract to represent multiple tokens at once. This
is why its [balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of) function differs from ERC20’s and ERC777’s: it has an additional ID argument for the
identifier of the token that you want to query the balance of.

This is similar to how ERC721 does things, but in that standard a token ID has no concept of balance: each token is
non-fungible and exists or doesn’t. The ERC721 [balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-balance_of) function refers to how many different tokens an account
has, not how many of each. On the other hand, in ERC1155 accounts have a distinct balance for each token ID, and
non-fungible tokens are implemented by simply minting a single one of them.

This approach leads to massive gas savings for projects that require multiple tokens. Instead of deploying a new
contract for each token type, a single ERC1155 token contract can hold the entire system state, reducing deployment
costs and complexity.

## Usage

Using Contracts for Cairo, constructing an ERC1155 contract requires integrating both `ERC1155Component` and `SRC5Component`.
The contract should also set up the constructor to initialize the token’s URI and interface support.
Here’s an example of a basic contract:

```cairo hljs
#[starknet::contract]
mod MyERC1155 {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc1155::{ERC1155Component, ERC1155HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC1155Component, storage: erc1155, event: ERC1155Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC1155 Mixin
    #[abi(embed_v0)]
    impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;
    impl ERC1155InternalImpl = ERC1155Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc1155: ERC1155Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC1155Event: ERC1155Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        token_uri: ByteArray,
        recipient: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>
    ) {
        self.erc1155.initializer(token_uri);
        self
            .erc1155
            .batch_mint_with_acceptance_check(recipient, token_ids, values, array![].span());
    }
}
```

## Interface

The following interface represents the full ABI of the Contracts for Cairo [ERC1155Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component).
The interface includes the [IERC1155](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155) standard interface and the optional [IERC1155MetadataURI](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155MetadataURI) interface together with [ISRC5](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5).

To support older token deployments, as mentioned in [Dual interfaces](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces#dual_interfaces), the component also includes implementations of the interface written in camelCase.

```cairo hljs
#[starknet::interface]
pub trait ERC1155ABI {
    // IERC1155
    fn balance_of(account: ContractAddress, token_id: u256) -> u256;
    fn balance_of_batch(
        accounts: Span<ContractAddress>, token_ids: Span<u256>
    ) -> Span<u256>;
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        value: u256,
        data: Span<felt252>
    );
    fn safe_batch_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    );
    fn is_approved_for_all(
        owner: ContractAddress, operator: ContractAddress
    ) -> bool;
    fn set_approval_for_all(operator: ContractAddress, approved: bool);

    // IERC1155MetadataURI
    fn uri(token_id: u256) -> ByteArray;

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;

    // IERC1155Camel
    fn balanceOf(account: ContractAddress, tokenId: u256) -> u256;
    fn balanceOfBatch(
        accounts: Span<ContractAddress>, tokenIds: Span<u256>
    ) -> Span<u256>;
    fn safeTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenId: u256,
        value: u256,
        data: Span<felt252>
    );
    fn safeBatchTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenIds: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    );
    fn isApprovedForAll(owner: ContractAddress, operator: ContractAddress) -> bool;
    fn setApprovalForAll(operator: ContractAddress, approved: bool);
}
```

## ERC1155 Compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC1155 standard but some differences can still be found, such as:

- The optional `data` argument in both `safe_transfer_from` and `safe_batch_transfer_from` is implemented as `Span<felt252>`.

- `IERC1155Receiver` compliant contracts must implement SRC5 and register the `IERC1155Receiver` interface ID.

- `IERC1155Receiver::on_erc1155_received` must return that interface ID on success.


## Batch operations

Because all state is held in a single contract, it is possible to operate over multiple tokens in a single transaction very efficiently. The standard provides two functions, [balance\_of\_batch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of_batch) and [safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from), that make querying multiple balances and transferring multiple tokens simpler and less gas-intensive. We also have [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) for non-batch operations.

In the spirit of the standard, we’ve also included batch operations in the non-standard functions, such as
[batch\_mint\_with\_acceptance\_check](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-batch_mint_with_acceptance_check).

|     |     |
| --- | --- |
|  | While [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) and [safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from) prevent loss by checking the receiver can handle the<br>tokens, this yields execution to the receiver which can result in a [reentrant call](https://docs.openzeppelin.com/contracts-cairo/0.20.0/security#reentrancy_guard). |

## Receiving tokens

In order to be sure a non-account contract can safely accept ERC1155 tokens, said contract must implement the `IERC1155Receiver` interface.
The recipient contract must also implement the [SRC5](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#src5) interface which supports interface introspection.

### IERC1155Receiver

```cairo hljs
#[starknet::interface]
pub trait IERC1155Receiver {
    fn on_erc1155_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        value: u256,
        data: Span<felt252>
    ) -> felt252;
    fn on_erc1155_batch_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_ids: Span<u256>,
        values: Span<u256>,
        data: Span<felt252>
    ) -> felt252;
}
```

Implementing the `IERC1155Receiver` interface exposes the [on\_erc1155\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_received) and [on\_erc1155\_batch\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_batch_received) methods.
When [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) and [safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from) are called, they invoke the recipient contract’s `on_erc1155_received` or `on_erc1155_batch_received` methods respectively which **must** return the [IERC1155Receiver interface ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver).
Otherwise, the transaction will fail.

|     |     |
| --- | --- |
|  | For information on how to calculate interface IDs, see [Computing the interface ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#computing_the_interface_id). |

### Creating a token receiver contract

The Contracts for Cairo [ERC1155ReceiverComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent) already returns the correct interface ID for safe token transfers.
To integrate the `IERC1155Receiver` interface into a contract, simply include the ABI embed directive to the implementations and add the `initializer` in the contract’s constructor.
Here’s an example of a simple token receiver contract:

```cairo hljs
#[starknet::contract]
mod MyTokenReceiver {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc1155::ERC1155ReceiverComponent;
    use starknet::ContractAddress;

    component!(path: ERC1155ReceiverComponent, storage: erc1155_receiver, event: ERC1155ReceiverEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC1155Receiver Mixin
    #[abi(embed_v0)]
    impl ERC1155ReceiverMixinImpl = ERC1155ReceiverComponent::ERC1155ReceiverMixinImpl<ContractState>;
    impl ERC1155ReceiverInternalImpl = ERC1155ReceiverComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc1155_receiver: ERC1155ReceiverComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC1155ReceiverEvent: ERC1155ReceiverComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc1155_receiver.initializer();
    }
}
```

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155)ERC1155 - OpenZeppelin Docs

# ERC1155

This module provides interfaces, presets, and utilities related to ERC1155 contracts.

|     |     |
| --- | --- |
|  | For an overview of ERC1155, read our [ERC1155 guide](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc1155). |

## Core

### `IERC1155`

```cairo hljs
use openzeppelin_token::erc1155::interface::IERC1155;
```

Interface of the IERC1155 standard as defined in [EIP1155](https://eips.ethereum.org/EIPS/eip-1155).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x6114a8f75559e1b39fcba08ce02961a1aa082d9256a158dd3e64964e4b1b52

Functions

- [`balance_of(account, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of)

- [`balance_of_batch(accounts, token_ids)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-balance_of_batch)

- [`safe_transfer_from(from, to, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from)

- [`safe_batch_transfer_from(from, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from)

- [`set_approval_for_all(operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-set_approval_for_all)

- [`is_approved_for_all(owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-is_approved_for_all)


Events

- [`TransferSingle(operator, from, to, id, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferSingle)

- [`TransferBatch(operator, from, to, ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferBatch)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-ApprovalForAll)

- [`URI(value, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-URI)


#### Functions

#### `balance_of(account: ContractAddress, token_id: u256) → u256` external

Returns the amount of `token_id` tokens owned by `account`.

#### `balance_of_batch(accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>` external

Returns a list of balances derived from the `accounts` and `token_ids` pairs.

#### `safe_transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256,  value: u256, data: Span<felt252>)` external

Transfers ownership of `value` amount of `token_id` from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferSingle) event.

#### `safe_batch_transfer_from(from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` external

Transfers ownership of `token_ids` and `values` pairs from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferBatch) event.

#### `set_approval_for_all(operator: ContractAddress, approved: bool)` external

Enables or disables approval for `operator` to manage all of the caller’s assets.

Emits an [ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-ApprovalForAll) event.

#### `is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool` external

Queries if `operator` is an authorized operator for `owner`.

#### Events

#### `TransferSingle(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)` event

Emitted when `value` amount of `id` token is transferred from `from` to `to` through `operator`.

#### `TransferBatch(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)` event

Emitted when a batch of `values` amount of `ids` tokens are transferred from `from` to `to` through `operator`.

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

Emitted when `owner` enables or disables `operator` to manage all of the owner’s assets.

#### `URI(value: ByteArray, id: u256)` event

Emitted when the token URI is updated to `value` for the `id` token.

### `IERC1155MetadataURI`

```cairo hljs
use openzeppelin_token::erc1155::interface::IERC1155MetadataURI;
```

Interface for the optional metadata function in [EIP1155](https://eips.ethereum.org/EIPS/eip-1155#metadata).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0xcabe2400d5fe509e1735ba9bad205ba5f3ca6e062da406f72f113feb889ef7

Functions

- [`uri(token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155MetadataURI-uri)


#### Functions

#### `uri(token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token.

### `ERC1155Component`

```cairo hljs
use openzeppelin_token::erc1155::ERC1155Component;
```

ERC1155 component implementing [IERC1155](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155) and [IERC1155MetadataURI](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155MetadataURI).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

|     |     |
| --- | --- |
|  | See [Hooks](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Hooks) to understand how are hooks used. |

Hooks

ERC1155HooksTrait

- [`before_update(self, from, to, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-before_update)

- [`after_update(self, from, to, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-after_update)


[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERC1155MixinImpl

- [`ERC1155Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Impls-ERC1155Impl)

- [`ERC1155MetadataURIImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Impls-ERC1155MetadataURIImpl)

- [`ER1155CamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Impls-ER1155CamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls-SRC5Impl)


Embeddable Implementations

ERC1155Impl

- [`balance_of(self, account, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of)

- [`balance_of_batch(self, accounts, token_ids)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of_batch)

- [`safe_transfer_from(self, from, to, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_transfer_from)

- [`safe_batch_transfer_from(self, from, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_batch_transfer_from)

- [`set_approval_for_all(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-set_approval_for_all)

- [`is_approved_for_all(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-is_approved_for_all)


ERC1155MetadataURIImpl

- [`uri(self, token_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-uri)


ER1155CamelImpl

- [`balanceOf(self, account, tokenId)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balanceOf)

- [`balanceOfBatch(self, accounts, tokenIds)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balanceOfBatch)

- [`safeTransferFrom(self, from, to, tokenId, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safeTransferFrom)

- [`safeBatchTransferFrom(self, from, to, tokenIds, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safeBatchTransferFrom)

- [`setApprovalForAll(self, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-setApprovalForAll)

- [`isApprovedForAll(self, owner, operator)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-isApprovedForAll)


Internal Functions

InternalImpl

- [`initializer(self, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-initializer)

- [`mint_with_acceptance_check(self, to, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-mint_with_acceptance_check)

- [`batch_mint_with_acceptance_check(self, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-batch_mint_with_acceptance_check)

- [`burn(self, from, token_id, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-burn)

- [`batch_burn(self, from, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-batch_burn)

- [`update_with_acceptance_check(self, from, to, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update_with_acceptance_check)

- [`update(self, from, to, token_ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update)

- [`_set_base_uri(self, base_uri)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-_set_base_uri)


Events

IERC1155

- [`TransferSingle(operator, from, to, id, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle)

- [`TransferBatch(operator, from, to, ids, values)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch)

- [`ApprovalForAll(owner, operator, approved)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-ApprovalForAll)

- [`URI(value, id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-URI)


#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC1155Component is expected to provide an implementation of the ERC1155HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

|     |     |
| --- | --- |
|  | You can use `openzeppelin_token::erc1155::ERC1155HooksEmptyImpl` which is already available as part of the library<br>for this purpose. |

#### `before_update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` hook

Function executed at the beginning of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update) function prior to any other logic.

#### `after_update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` hook

Function executed at the end of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update) function.

#### Embeddable functions

#### `balance_of(self: @ContractState, account: ContractAddress, token_id: u256) → u256` external

Returns the amount of `token_id` tokens owned by `account`.

#### `balance_of_batch(self: @ContractState, accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>` external

Returns a list of balances derived from the `accounts` and `token_ids` pairs.

Requirements:

- `token_ids` and `accounts` must have the same length.


#### `safe_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256,  value: u256, data: Span<felt252>)` external

Transfers ownership of `value` amount of `token_id` from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

|     |     |
| --- | --- |
|  | This function can potentially allow a reentrancy attack when transferring tokens<br>to an untrusted contract, when invoking `on_ERC1155_received` on the receiver.<br>Ensure to follow the checks-effects-interactions pattern and consider employing<br>reentrancy guards when interacting with untrusted contracts. |

Requirements:

- Caller is either approved or the `token_id` owner.

- `from` is not the zero address.

- `to` is not the zero address.

- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_received`
and return the required magic value.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event.

#### `safe_batch_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` external

Transfers ownership of `values` and `token_ids` pairs from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

|     |     |
| --- | --- |
|  | This function can potentially allow a reentrancy attack when transferring tokens<br>to an untrusted contract, when invoking `on_ERC1155_batch_received` on the receiver.<br>Ensure to follow the checks-effects-interactions pattern and consider employing<br>reentrancy guards when interacting with untrusted contracts. |

Requirements:

- Caller is either approved or the `token_id` owner.

- `from` is not the zero address.

- `to` is not the zero address.

- `token_ids` and `values` must have the same length.

- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received`
and return the acceptance magic value.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event if the arrays contain one element,
and [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) otherwise.

#### `set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool)` external

Enables or disables approval for `operator` to manage all of the callers assets.

Requirements:

- `operator` cannot be the caller.


Emits an [ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-ApprovalForAll) event.

#### `is_approved_for_all(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

Queries if `operator` is an authorized operator for `owner`.

#### `uri(self: @ContractState, token_id: u256) -> ByteArray` external

This implementation returns the same URI for **all** token types. It relies
on the token type ID substitution mechanism
[specified in the EIP](https://eips.ethereum.org/EIPS/eip-1155#metadata).

Clients calling this function must replace the `{id}` substring with the
actual token type ID.

#### `balanceOf(self: @ContractState, account: ContractAddress, tokenId: u256) → u256` external

See [ERC1155Component::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of).

#### `balanceOfBatch(self: @ContractState, accounts: Span<ContractAddress>, tokenIds: Span<u256>) → Span<u256>` external

See [ERC1155Component::balance\_of\_batch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-balance_of_batch).

#### `safeTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256,  value: u256, data: Span<felt252>)` external

See [ERC1155Component::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_transfer_from).

#### `safeBatchTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data: Span<felt252>)` external

See [ERC1155Component::safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-safe_batch_transfer_from).

#### `setApprovalForAll(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [ERC1155Component::set\_approval\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-set_approval_for_all).

#### `isApprovedForAll(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [ERC1155Component::is\_approved\_for\_all](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-is_approved_for_all).

#### Internal functions

#### `initializer(ref self: ContractState, base_uri: ByteArray)` internal

Initializes the contract by setting the token’s base URI as `base_uri`, and registering the supported interfaces.
This should only be used inside the contract’s constructor.

#### `mint_with_acceptance_check(ref self: ContractState, to: ContractAddress, token_id: u256, value: u256, data: Span<felt252>)` internal

Creates a `value` amount of tokens of type `token_id`, and assigns them to `to`.

Requirements:

- `to` cannot be the zero address.

- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_received`
and return the acceptance magic value.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event.

#### `batch_mint_with_acceptance_check(ref self: ContractState, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` internal

Batched version of [mint\_with\_acceptance\_check](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-mint_with_acceptance_check).

Requirements:

- `to` cannot be the zero address.

- `token_ids` and `values` must have the same length.

- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received`
and return the acceptance magic value.


Emits a [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) event.

#### `burn(ref self: ContractState, from: ContractAddress, token_id: u256, value: u256)` internal

Destroys a `value` amount of tokens of type `token_id` from `from`.

Requirements:

- `from` cannot be the zero address.

- `from` must have at least `value` amount of tokens of type `token_id`.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event.

#### `batch_burn(ref self: ContractState, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` internal

Batched version of [burn](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-burn).

Requirements:

- `from` cannot be the zero address.

- `from` must have at least `value` amount of tokens of type `token_id`.

- `token_ids` and `values` must have the same length.


Emits a [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) event.

#### `update_with_acceptance_check(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)` internal

Version of `update` that performs the token acceptance check by calling
`onERC1155Received` or `onERC1155BatchReceived` in the receiver if
it implements `IERC1155Receiver`, otherwise by checking if it is an account.

Requirements:

- `to` is either an account contract or supports the `IERC1155Receiver` interface.

- `token_ids` and `values` must have the same length.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event if the arrays contain one element,
and [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) otherwise.

#### `update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)` internal

Transfers a `value` amount of tokens of type `id` from `from` to `to`.
Will mint (or burn) if `from` (or `to`) is the zero address.

Requirements:

- `token_ids` and `values` must have the same length.


Emits a [TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferSingle) event if the arrays contain one element,
and [TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-TransferBatch) otherwise.

|     |     |
| --- | --- |
|  | This function can be extended using the [ERC1155HooksTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-ERC1155HooksTrait), to add<br>functionality before and/or after the transfer, mint, or burn. |

|     |     |
| --- | --- |
|  | The ERC1155 acceptance check is not performed in this function.<br>See [update\_with\_acceptance\_check](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-update_with_acceptance_check) instead. |

#### `_set_base_uri(ref self: ContractState, base_uri: ByteArray)` internal

Sets a new URI for all token types, by relying on the token type ID
substitution mechanism
[specified in the EIP](https://eips.ethereum.org/EIPS/eip-1155#metadata).

By this mechanism, any occurrence of the `{id}` substring in either the
URI or any of the values in the JSON file at said URI will be replaced by
clients with the token type ID.

For example, the `https://token-cdn-domain/\{id\}.json` URI would be
interpreted by clients as
`https://token-cdn-domain/000000000000...000000000000004cce0.json`
for token type ID `0x4cce0`.

Because these URIs cannot be meaningfully represented by the `URI` event,
this function emits no events.

#### Events

#### `TransferSingle(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)` event

See [IERC1155::TransferSingle](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferSingle).

#### `TransferBatch(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)` event

See [IERC1155::TransferBatch](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-TransferBatch).

#### `ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

See [IERC1155::ApprovalForAll](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-ApprovalForAll).

#### `URI(value: ByteArray, id: u256)` event

See [IERC1155::URI](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-URI).

## Receiver

### `IERC1155Receiver`

```cairo hljs
use openzeppelin_token::erc1155::interface::IERC1155Receiver;
```

Interface for contracts that support receiving token transfers from `ERC1155` contracts.

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x15e8665b5af20040c3af1670509df02eb916375cdf7d8cbaf7bd553a257515e

Functions

- [`on_erc1155_received(operator, from, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_received)

- [`on_erc1155_batch_received(operator, from, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver-on_erc1155_batch_received)


#### Functions

#### `on_erc1155_received(operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252` external

This function is called whenever an ERC1155 `token_id` token is transferred to this `IERC1155Receiver` implementer
via [IERC1155::safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_transfer_from) by `operator` from `from`.

#### `on_erc1155_batch_received(operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252` external

This function is called whenever multiple ERC1155 `token_ids` tokens are transferred to this `IERC1155Receiver` implementer
via [IERC1155::safe\_batch\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155-safe_batch_transfer_from) by `operator` from `from`.

### `ERC1155ReceiverComponent`

```cairo hljs
use openzeppelin_token::erc1155::ERC1155ReceiverComponent;
```

ERC1155Receiver component implementing [IERC1155Receiver](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#IERC1155Receiver).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERC1155MixinImpl

- [`ERC1155ReceiverImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverImpl)

- [`ERC1155ReceiverCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls-SRC5Impl)


Embeddable Implementations

ERC1155ReceiverImpl

- [`on_erc1155_received(self, operator, from, token_id, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_received)

- [`on_erc1155_batch_received(self, operator, from, token_ids, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_batch_received)


ERC1155ReceiverCamelImpl

- [`onERC1155Received(self, operator, from, tokenId, value, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-onERC1155Received)

- [`onERC1155BatchReceived(self, operator, from, tokenIds, values, data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-onERC1155BatchReceived)


Internal Functions

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-initializer)


#### Embeddable functions

#### `on_erc1155_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252` external

Returns the `IERC1155Receiver` interface ID.

#### `on_erc1155_batch_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252` external

Returns the `IERC1155Receiver` interface ID.

#### `onERC1155Received(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenId: u256, value: u256, data Span<felt252>) -> felt252` external

See [ERC1155ReceiverComponent::on\_erc1155\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_received).

#### `onERC1155BatchReceived(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252` external

See [ERC1155ReceiverComponent::on\_erc1155\_batch\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155ReceiverComponent-on_erc1155_batch_received).

#### Internal functions

#### `initializer(ref self: ContractState)` internal

Registers the `IERC1155Receiver` interface ID as supported through introspection.

## Presets

### `ERC1155Upgradeable`

```cairo hljs
use openzeppelin_presets::ERC1155;
```

Upgradeable ERC1155 contract leveraging [ERC1155Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component).

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x046ec13b3dc855cddbaad504c5d3526f34134541f04207c7cfa7b6919f5fd2be

Constructor

- [`constructor(self, base_uri, recipient, token_ids, values, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Upgradeable-constructor)


Embedded Implementations

ERC1155Component

- [`ERC1155MixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Component-Embeddable-Mixin-Impl)


OwnableMixinImpl

- [`OwnableMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Mixin-Impl)


External Functions

- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc1155#ERC1155Upgradeable-upgrade)


#### Constructor

#### `constructor(ref self: ContractState, base_uri: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, values: Span<u256>, owner: ContractAddress)` constructor

Sets the `base_uri` for all tokens and registers the supported interfaces.
Mints the `values` for `token_ids` tokens to `recipient`.
Assigns `owner` as the contract owner with permissions to upgrade.

Requirements:

- `to` is either an account contract (supporting ISRC6) or
supports the `IERC1155Receiver` interface.

- `token_ids` and `values` must have the same length.


#### External Functions

#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` external

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.

- `new_class_hash` cannot be zero.


[← ERC1155](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc1155)

[Common →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common)Finance - OpenZeppelin Docs

# Finance

This crate includes primitives for financial systems.

## Vesting

### `IVesting`

```cairo hljs
use openzeppelin_finance::vesting::interface::IVesting;
```

Common interface for contracts implementing the vesting functionality.

Functions

- [`start()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-start)

- [`cliff()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-cliff)

- [`duration()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-duration)

- [`end()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-end)

- [`released(token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-released)

- [`releasable(token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-releasable)

- [`vested_amount(token, timestamp)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-vested_amount)

- [`release(token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-release)


Events

- [`AmountReleased(token, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-AmountReleased)


#### Functions

#### `start() → u64` external

Returns the timestamp marking the beginning of the vesting period.

#### `cliff() → u64` external

Returns the timestamp marking the end of the cliff period.

#### `duration() → u64` external

Returns the total duration of the vesting period.

#### `end() → u64` external

Returns the timestamp marking the end of the vesting period.

#### `released(token: ContractAddress) → u256` external

Returns the already released amount for a given `token`.

#### `releasable(token: ContractAddress) → u256` external

Returns the amount of a given `token` that can be released at the time of the call.

#### `vested_amount(token: ContractAddress, timestamp: u64) → u256` external

Returns the total vested amount of a specified `token` at a given `timestamp`.

#### `release(token: ContractAddress) → u256` external

Releases the amount of a given `token` that has already vested and returns that amount.

May emit an [AmountReleased](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-AmountReleased) event.

#### Events

#### `AmountReleased(token: ContractAddress, amount: u256)` event

Emitted when vested tokens are released to the beneficiary.

### `VestingComponent`

```cairo hljs
use openzeppelin_finance::vesting::VestingComponent;
```

Vesting component implementing the [`IVesting`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting) interface.

Vesting Schedule Trait Implementations

functions

- [`calculate_vested_amount(self, token, total_allocation,\\
timestamp, start, duration, cliff)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-calculate_vested_amount)


Embeddable Implementations

VestingImpl

- [`start(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-start)

- [`cliff(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-cliff)

- [`duration(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-duration)

- [`end(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-end)

- [`released(self, token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-released)

- [`releasable(self, token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-releasable)

- [`vested_amount(self, token, timestamp)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-vested_amount)

- [`release(self, token)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-release)


Internal implementations

InternalImpl

- [`initializer(self, start, duration, cliff_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-initializer)

- [`resolve_vested_amount(self, token, timestamp)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-resolve_vested_amount)


#### VestingSchedule trait

A trait that defines the logic for calculating the vested amount based on a given timestamp.

|     |     |
| --- | --- |
|  | You can read more about the trait’s purpose and how to use it [here](https://docs.openzeppelin.com/contracts-cairo/0.20.0/finance#vesting_schedule). |

#### `calculate_vested_amount(self: @ContractState, token: ContractAddress, total_allocation: u256, timestamp: u64, start: u64, duration: u64, cliff: u64) → u256` internal

Calculates and returns the vested amount at a given `timestamp` based on the core vesting parameters.

#### Functions

#### `start(self: @ContractState) → u64` external

Returns the timestamp marking the beginning of the vesting period.

#### `cliff(self: @ContractState) → u64` external

Returns the timestamp marking the end of the cliff period.

#### `duration(self: @ContractState) → u64` external

Returns the total duration of the vesting period.

#### `end(self: @ContractState) → u64` external

Returns the timestamp marking the end of the vesting period.

#### `released(self: @ContractState, token: ContractAddress) → u256` external

Returns the already released amount for a given `token`.

#### `releasable(self: @ContractState, token: ContractAddress) → u256` external

Returns the amount of a given `token` that can be released at the time of the call.

#### `vested_amount(self: @ContractState, token: ContractAddress, timestamp: u64) → u256` external

Returns the total vested amount of a specified `token` at a given `timestamp`.

#### `release(ref self: ContractState, token: ContractAddress) → u256` external

Releases the amount of a given `token` that has already vested and returns that amount.

|     |     |
| --- | --- |
|  | If the releasable amount is zero, this function won’t emit the event<br>or attempt to transfer the tokens. |

Requirements:

- `transfer` call to the `token` must return `true` indicating a successful transfer.


May emit an [AmountReleased](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#IVesting-AmountReleased) event.

#### Internal functions

#### `initializer(ref self: ContractState, start: u64, duration: u64, cliff_duration: u64)` internal

Initializes the component by setting the vesting `start`, `duration` and `cliff_duration`. To prevent
reinitialization, this should only be used inside of a contract’s constructor.

Requirements:

- `cliff_duration` must be less than or equal to `duration`.


#### `resolve_vested_amount(self: @ContractState, token: ContractAddress, timestamp: u64) → u256` internal

Returns the vested amount that’s calculated using the [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) trait implementation.

### `LinearVestingSchedule`

```cairo hljs
use openzeppelin_finance::vesting::LinearVestingSchedule;
```

Defines the logic for calculating the vested amount, incorporating a cliff period.
It returns 0 before the cliff ends. After the cliff period, the vested amount returned
is directly proportional to the time passed since the start of the vesting schedule.

## Presets

### `VestingWallet`

```cairo hljs
use openzeppelin::presets::VestingWallet;
```

A non-upgradable contract leveraging [VestingComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent) and [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent).

|     |     |
| --- | --- |
|  | The contract is intentionally designed to be non-upgradable to ensure that neither the vesting initiator<br>nor the vesting beneficiary can modify the vesting schedule without the consent of the other party. |

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x0386b4e438105ef2ba52b12dae76e6afef54a234083137d32c57d06693a8c7c7

Constructor

- [`constructor(self, beneficiary, start, duration, cliff_duration)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingWallet-constructor)


Embedded Implementations

VestingComponent

- [`VestingImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Embeddable-Impls-VestingImpl)


OwnableComponent

- [`OwnableMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Mixin-Impl)


#### Constructor

#### `constructor(ref self: ContractState, beneficiary: ContractAddress, start: u64, duration: u64, cliff_duration: u64)` constructor

Initializes the vesting component by setting the vesting `start`, `duration` and `cliff_duration`. Assigns `beneficiary` as the contract owner and the vesting beneficiary.

Requirements:

- `cliff_duration` must be less than or equal to `duration`.


[← Finance](https://docs.openzeppelin.com/contracts-cairo/0.20.0/finance)

[Governor →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/governor)Configuration Files - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Configuration Files

The OpenZeppelin CLI stores your project’s configuration in the `.openzeppelin` directory, inside a number of JSON files. Those are described here.

|     |     |
| --- | --- |
|  | You can skip ahead to see which files you should [track using version control](https://docs.openzeppelin.com/cli/2.8/configuration#configuration-files-in-version-control). |

## `project.json`

This stores the project’s general configuration, and is created by the `oz init` command. It has the following structure:

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": <projectName>,
  "version": <version>,
  "publish": <publishFlag>,
  "contracts": {
    <contract-1-alias>: <contract-1-name>,
    <contract-2-alias>: <contract-2-name>,
    ...
    <contract-N-alias>: <contract-N-name>
  },
  "dependencies": {
    <dependency-1-name>: <dependency-1-version>,
    <dependency-2-name>: <dependency-2-version>,
    ...
    <dependency-N-name>: <dependency-N-version>
  }
}
```

Here, `<projectName>` is the name of the project, and `<version>` is the current semver number. The boolean value `<publish>` indicates whether the project should be automatically published to the network upon being pushed, allowing it to be reused as an Ethereum Package by other projects. The field `manifestVersion` indicates the version of the configuration file.

Once you start adding your contracts via `oz add`, they will be recorded under the `"contracts"` field, with the contract aliases as the keys (which default to the contract names), and the contract names as the values. Finally, if you link a dependency with `oz link`, this will be reflected in the `"dependencies"` field, where `<dependency-name>` is the name of the linked Ethereum Package, and `<dependency-version>` is its semver required version.

## `<network_name>.json`

The OpenZeppelin CLI will also generate a file for each of the networks you work on ( `local`, `ropsten`, `mainnet`, etc). These should be configured in your `networks.js` file, but note that `oz init` already configures a `local` network for `localhost:8545`. These files share the same structure:

```json hljs
// .openzeppelin/<network_name>.json
{
  "manifestVersion": "2.2",
  "version": <app-version>,
  "contracts": {
    <contract-N-name>: {
      "address": <contract-N-address>,
      "constructorCode": <contract-N-constructor>,
      "bodyBytecodeHash": <contract-N-body>,
      "localBytecodeHash": <contract-N-local>,
      "deployedBytecodeHash": <contract-N-deployed>,
      "types": { ... },
      "storage": [ ... ],
      "warnings": { ... }
    },
    ...
  },
  "solidityLibs": {
    ...
  },
  "proxies": {
    <package-name>/<contract-name>: [\
      {\
        "address": <proxy-1-address>,\
        "version": <proxy-1-version>,\
        "implementation": <implementation-1-address>\
      },\
      ...\
    ],
    ...
  },
  "proxyAdmin": {
    "address": <proxyAdmin-address>
  },
  "app": {
    "address": <app-address>
  },
  "package": {
    "address": <package-address>
  },
  "provider": {
    "address": <provider-address>
  },
  "dependencies": {
    <dependency-name>: {
      "package": <dependency-address>,
      "version": <dependency-version>,
      "customDeploy": <dependency-custom-deploy>
    },
    ...
  }
}
```

The most important things to see here are the proxies and contracts' addresses, `<proxy-i-address>` and `<contract-i-address>` respectively. What will happen is that each time you upload new versions of your logic contracts, `<contract-i-address>` will change. The proxy addresses, however, will stay the same, so you can interact seamlessly with the same addresses as if no change has taken place. Note that `<implementation-i-address>` will always point to the current contract address `<contract-i-address>` if the proxies are `update`-ed. Proxies are grouped by the name of the package and contract they are backed by.

For every logic contract, besides the deployment address, the following info is also tracked:

- `constructorCode` is the SHA256 hash of the bytecode used to `CREATE` the logic contract

- `bodyBytecodeHash` is the SHA256 hash of the same bytecode as above, stripped of its constructor

- `localBytecodeHash` is the SHA256 hash of the bytecode, including any Solidity library placeholders

- `deployedBytecodeHash` is the SHA256 hash of the bytecode, with all Solidity library placeholders replaced by their corresponding addresses

- `types` keeps track of all the types used in the contract or its ancestors, from basic types like `uint256` to custom `struct` types

- `storage` tracks the storage layout of the linearized contract, referencing the types defined in the `types` section, and is used for verifying that any storage layout changes between subsequent versions are compatible

- `warnings` tracks any existing warnings for the contract, such as whether it has a constructor or `selfdestruct` operations


Any Solidity libraries used by the project’s contracts are tracked in the `solidityLibs` node, which has the same structure as the `contracts` item.

Another thing to notice in these files are the version numbers. The `<app-version>` keeps track of the latest app version, and matches `<version>` from `project.json`. The `<proxy-i-version>`, on the other hand, keeps track of which version of the contracts the proxies are pointing to. Say you deploy a contract in your app version 1.0.0, and then bump the version to 1.1.0 and push some upgraded code for that same contract. This will be reflected in the `<contract-i-address>`, but not yet in the proxy, which will display 1.0.0 in `<proxy-i-version>` and the old logic contract address in `<implementation-i-address>`. Once you run `oz update` to your contract, `<proxy-i-version>` will show the new 1.1.0 version, and `<implementation-i-address>` will point to the new `<contract-i-address>`. Note that this version identifier will refer to the version of the dependency (and not the app) if the proxy points to a dependent Ethereum Package.

The field `<proxyAdmin>` contains the address of the ProxyAdmin contract, used to manage the [transparent proxy pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes) in the project’s proxies.

Also, notice the fields `<app>`, `<package>`, and `<provider>`. These contain the addresses of contracts the OpenZeppelin CLI uses to facilitate the creation of proxies and the management of different versions of your contracts. These contracts will only be deployed once you `publish` your project to a desired network. That is, your project will not have an `app`, `package`, or `provider` unless explicitly running the `publish` command, or if the project was created with the `--publish` flag. Note that this step is required for projects that produce an Ethereum Package. To read more about the architecture of contracts we are using to publish your project on-chain please refer to the [Contract Architecture](https://docs.openzeppelin.com/cli/2.8/contracts-architecture) section.

Finally, the `dependencies` field stores information about linked Ethereum Packages. For each dependency, the `<dependency-address>` tracks the address of the deployed `package` in the network, and `<dependency-version>` is the exact semver identifier being used for the dependency. The `custom-deploy` field will be present only when a version of the Ethereum Package is deployed using the `--deploy-dependencies` flag of the `push` command, in which case `<custom-deploy>` will be `true`.

The naming of the file will be `<network_name>.json`, but note that `<network_name>` is not taken from the name of the network’s entry in the network file, but is instead inferred from the canonical network id associated to the entry. For example, given the following network configuration:

```json hljs
// networks.js
module.exports = {
  networks: {
     geth_ropsten: {
      host: 'localhost',
      port: 8555,
      network_id: 3
    },
     parity_ropsten: {
      host: 'localhost',
      port: 8565,
      network_id: 3
    },
     local: {
      host: 'localhost',
      port: 8545,
      network_id: *
    }
  }
};
```

Using `oz push --network geth_ropsten` or `oz push --network parity_ropsten` will both produce a file named `ropsten.json` no matter which method was used to connect to the ropsten network. The OpenZeppelin CLI will automatically detect which public network is being referred to (using web3.network.getVersion()) and use this information for determining the file name. When dealing with local networks, the OpenZeppelin CLI will generate files with `dev-<network_id>`, given that these networks are not public and don’t have a canonical name. Using `oz push --network local` will produce a file named `dev-1540303312049.json` (or some other number representing the network id of the local network).

## Configuration Files in Version Control

The `project.json` file should be tracked in version control. This file represents an OpenZeppelin project’s configuration; the contracts and Ethereum Packages that compose it, its name and version, the version of the OpenZeppelin CLI it uses, etc. The file should be identical for all the contributors of a project.

Public network files like `mainnet.json` or `ropsten.json` should also be tracked in version control. These contain valuable information about your project’s status in the corresponding network; the addresses of the contract implementations that have been deployed, the addresses of the proxies that have been deployed, etc. Such files should also be identical for all the contributors of a project.

However, local network files like `dev-<network_id>.json` only represent a project’s deployment in a temporary local network such as `ganache-cli` that are only relevant to a single contributor of the project and should not be tracked in version control.

An example `.gitignore` file could contain the following entries:

```json hljs
// .gitignore
# OpenZeppelin
.openzeppelin/dev-*.json
.openzeppelin/.session
```

[← Commands](https://docs.openzeppelin.com/cli/2.8/commands)

[Contracts Architecture →](https://docs.openzeppelin.com/cli/2.8/contracts-architecture)Configuration Files - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Configuration Files

The OpenZeppelin CLI stores your project’s configuration in the `.openzeppelin` directory, inside a number of JSON files. Those are described here.

|     |     |
| --- | --- |
|  | You can skip ahead to see which files you should [track using version control](https://docs.openzeppelin.com/cli/2.7/configuration#configuration-files-in-version-control). |

## `project.json`

This stores the project’s general configuration, and is created by the `oz init` command. It has the following structure:

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": <projectName>,
  "version": <version>,
  "publish": <publishFlag>,
  "contracts": {
    <contract-1-alias>: <contract-1-name>,
    <contract-2-alias>: <contract-2-name>,
    ...
    <contract-N-alias>: <contract-N-name>
  },
  "dependencies": {
    <dependency-1-name>: <dependency-1-version>,
    <dependency-2-name>: <dependency-2-version>,
    ...
    <dependency-N-name>: <dependency-N-version>
  }
}
```

Here, `<projectName>` is the name of the project, and `<version>` is the current semver number. The boolean value `<publish>` indicates whether the project should be automatically published to the network upon being pushed, allowing it to be reused as an Ethereum Package by other projects. The field `manifestVersion` indicates the version of the configuration file.

Once you start adding your contracts via `oz add`, they will be recorded under the `"contracts"` field, with the contract aliases as the keys (which default to the contract names), and the contract names as the values. Finally, if you link a dependency with `oz link`, this will be reflected in the `"dependencies"` field, where `<dependency-name>` is the name of the linked Ethereum Package, and `<dependency-version>` is its semver required version.

## `<network_name>.json`

The OpenZeppelin CLI will also generate a file for each of the networks you work on ( `local`, `ropsten`, `mainnet`, etc). These should be configured in your `networks.js` file, but note that `oz init` already configures a `local` network for `localhost:8545`. These files share the same structure:

```json hljs
// .openzeppelin/<network_name>.json
{
  "manifestVersion": "2.2",
  "version": <app-version>,
  "contracts": {
    <contract-N-name>: {
      "address": <contract-N-address>,
      "constructorCode": <contract-N-constructor>,
      "bodyBytecodeHash": <contract-N-body>,
      "localBytecodeHash": <contract-N-local>,
      "deployedBytecodeHash": <contract-N-deployed>,
      "types": { ... },
      "storage": [ ... ],
      "warnings": { ... }
    },
    ...
  },
  "solidityLibs": {
    ...
  },
  "proxies": {
    <package-name>/<contract-name>: [\
      {\
        "address": <proxy-1-address>,\
        "version": <proxy-1-version>,\
        "implementation": <implementation-1-address>\
      },\
      ...\
    ],
    ...
  },
  "proxyAdmin": {
    "address": <proxyAdmin-address>
  },
  "app": {
    "address": <app-address>
  },
  "package": {
    "address": <package-address>
  },
  "provider": {
    "address": <provider-address>
  },
  "dependencies": {
    <dependency-name>: {
      "package": <dependency-address>,
      "version": <dependency-version>,
      "customDeploy": <dependency-custom-deploy>
    },
    ...
  }
}
```

The most important things to see here are the proxies and contracts' addresses, `<proxy-i-address>` and `<contract-i-address>` respectively. What will happen is that each time you upload new versions of your logic contracts, `<contract-i-address>` will change. The proxy addresses, however, will stay the same, so you can interact seamlessly with the same addresses as if no change has taken place. Note that `<implementation-i-address>` will always point to the current contract address `<contract-i-address>` if the proxies are `update`-ed. Proxies are grouped by the name of the package and contract they are backed by.

For every logic contract, besides the deployment address, the following info is also tracked:

- `constructorCode` is the SHA256 hash of the bytecode used to `CREATE` the logic contract

- `bodyBytecodeHash` is the SHA256 hash of the same bytecode as above, stripped of its constructor

- `localBytecodeHash` is the SHA256 hash of the bytecode, including any Solidity library placeholders

- `deployedBytecodeHash` is the SHA256 hash of the bytecode, with all Solidity library placeholders replaced by their corresponding addresses

- `types` keeps track of all the types used in the contract or its ancestors, from basic types like `uint256` to custom `struct` types

- `storage` tracks the storage layout of the linearized contract, referencing the types defined in the `types` section, and is used for verifying that any storage layout changes between subsequent versions are compatible

- `warnings` tracks any existing warnings for the contract, such as whether it has a constructor or `selfdestruct` operations


Any Solidity libraries used by the project’s contracts are tracked in the `solidityLibs` node, which has the same structure as the `contracts` item.

Another thing to notice in these files are the version numbers. The `<app-version>` keeps track of the latest app version, and matches `<version>` from `project.json`. The `<proxy-i-version>`, on the other hand, keeps track of which version of the contracts the proxies are pointing to. Say you deploy a contract in your app version 1.0.0, and then bump the version to 1.1.0 and push some upgraded code for that same contract. This will be reflected in the `<contract-i-address>`, but not yet in the proxy, which will display 1.0.0 in `<proxy-i-version>` and the old logic contract address in `<implementation-i-address>`. Once you run `oz update` to your contract, `<proxy-i-version>` will show the new 1.1.0 version, and `<implementation-i-address>` will point to the new `<contract-i-address>`. Note that this version identifier will refer to the version of the dependency (and not the app) if the proxy points to a dependent Ethereum Package.

The field `<proxyAdmin>` contains the address of the ProxyAdmin contract, used to manage the [transparent proxy pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes) in the project’s proxies.

Also, notice the fields `<app>`, `<package>`, and `<provider>`. These contain the addresses of contracts the OpenZeppelin CLI uses to facilitate the creation of proxies and the management of different versions of your contracts. These contracts will only be deployed once you `publish` your project to a desired network. That is, your project will not have an `app`, `package`, or `provider` unless explicitly running the `publish` command, or if the project was created with the `--publish` flag. Note that this step is required for projects that produce an Ethereum Package. To read more about the architecture of contracts we are using to publish your project on-chain please refer to the [Contract Architecture](https://docs.openzeppelin.com/cli/2.7/contracts-architecture) section.

Finally, the `dependencies` field stores information about linked Ethereum Packages. For each dependency, the `<dependency-address>` tracks the address of the deployed `package` in the network, and `<dependency-version>` is the exact semver identifier being used for the dependency. The `custom-deploy` field will be present only when a version of the Ethereum Package is deployed using the `--deploy-dependencies` flag of the `push` command, in which case `<custom-deploy>` will be `true`.

The naming of the file will be `<network_name>.json`, but note that `<network_name>` is not taken from the name of the network’s entry in the network file, but is instead inferred from the canonical network id associated to the entry. For example, given the following network configuration:

```json hljs
// networks.js
module.exports = {
  networks: {
     geth_ropsten: {
      host: 'localhost',
      port: 8555,
      network_id: 3
    },
     parity_ropsten: {
      host: 'localhost',
      port: 8565,
      network_id: 3
    },
     local: {
      host: 'localhost',
      port: 8545,
      network_id: *
    }
  }
};
```

Using `oz push --network geth_ropsten` or `oz push --network parity_ropsten` will both produce a file named `ropsten.json` no matter which method was used to connect to the ropsten network. The OpenZeppelin CLI will automatically detect which public network is being referred to (using web3.network.getVersion()) and use this information for determining the file name. When dealing with local networks, the OpenZeppelin CLI will generate files with `dev-<network_id>`, given that these networks are not public and don’t have a canonical name. Using `oz push --network local` will produce a file named `dev-1540303312049.json` (or some other number representing the network id of the local network).

## Configuration Files in Version Control

The `project.json` file should be tracked in version control. This file represents an OpenZeppelin project’s configuration; the contracts and Ethereum Packages that compose it, its name and version, the version of the OpenZeppelin CLI it uses, etc. The file should be identical for all the contributors of a project.

Public network files like `mainnet.json` or `ropsten.json` should also be tracked in version control. These contain valuable information about your project’s status in the corresponding network; the addresses of the contract implementations that have been deployed, the addresses of the proxies that have been deployed, etc. Such files should also be identical for all the contributors of a project.

However, local network files like `dev-<network_id>.json` only represent a project’s deployment in a temporary local network such as `ganache-cli` that are only relevant to a single contributor of the project and should not be tracked in version control.

An example `.gitignore` file could contain the following entries:

```json hljs
// .gitignore
# OpenZeppelin
.openzeppelin/dev-*.json
.openzeppelin/.session
```

[← Commands](https://docs.openzeppelin.com/cli/2.7/commands)

[Contracts Architecture →](https://docs.openzeppelin.com/cli/2.7/contracts-architecture)Access - OpenZeppelin Docs

# Access

Access control—​that is, "who is allowed to do this thing"—is incredibly important in the world of smart contracts.
The access control of your contract may govern who can mint tokens, vote on proposals, freeze transfers, and many other things.
It is therefore critical to understand how you implement it, lest someone else
[steals your whole system](https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7/).

## Ownership and `Ownable`

The most common and basic form of access control is the concept of ownership: there’s an account that is the `owner`
of a contract and can do administrative tasks on it.
This approach is perfectly reasonable for contracts that have a single administrative user.

OpenZeppelin Contracts for Cairo provides [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent) for implementing ownership in your contracts.

### Usage

Integrating this component into a contract first requires assigning an owner.
The implementing contract’s constructor should set the initial owner by passing the owner’s address to Ownable’s
[`initializer`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-initializer) like this:

```cairo hljs
#[starknet::contract]
mod MyContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl InternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        // Set the initial owner of the contract
        self.ownable.initializer(owner);
    }

    (...)
}
```

To restrict a function’s access to the owner only, add in the `assert_only_owner` method:

```cairo hljs
#[starknet::contract]
mod MyContract {
    (...)

    #[external(v0)]
    fn only_owner_allowed(ref self: ContractState) {
        // This function can only be called by the owner
        self.ownable.assert_only_owner();

        (...)
    }
}
```

### Interface

This is the full interface of the `OwnableMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait OwnableABI {
    // IOwnable
    fn owner() -> ContractAddress;
    fn transfer_ownership(new_owner: ContractAddress);
    fn renounce_ownership();

    // IOwnableCamelOnly
    fn transferOwnership(newOwner: ContractAddress);
    fn renounceOwnership();
}
```

Ownable also lets you:

- `transfer_ownership` from the owner account to a new one, and

- `renounce_ownership` for the owner to relinquish this administrative privilege, a common pattern
after an initial stage with centralized administration is over.


|     |     |
| --- | --- |
|  | Removing the owner altogether will mean that administrative tasks that are protected by `assert_only_owner`<br>will no longer be callable! |

### Two step transfer

The component also offers a more robust way of transferring ownership via the
[OwnableTwoStepImpl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableTwoStepImpl) implementation. A two step transfer mechanism helps
to prevent unintended and irreversible owner transfers. Simply replace the `OwnableMixinImpl`
with its respective two step variant:

```cairo hljs
#[abi(embed_v0)]
impl OwnableTwoStepMixinImpl = OwnableComponent::OwnableTwoStepMixinImpl<ContractState>;
```

#### Interface

This is the full interface of the two step `OwnableTwoStepMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait OwnableTwoStepABI {
    // IOwnableTwoStep
    fn owner() -> ContractAddress;
    fn pending_owner() -> ContractAddress;
    fn accept_ownership();
    fn transfer_ownership(new_owner: ContractAddress);
    fn renounce_ownership();

    // IOwnableTwoStepCamelOnly
    fn pendingOwner() -> ContractAddress;
    fn acceptOwnership();
    fn transferOwnership(newOwner: ContractAddress);
    fn renounceOwnership();
}
```

## Role-Based `AccessControl`

While the simplicity of ownership can be useful for simple systems or quick prototyping, different levels of
authorization are often needed. You may want for an account to have permission to ban users from a system, but not
create new tokens. [Role-Based Access Control (RBAC)](https://en.wikipedia.org/wiki/Role-based_access_control) offers
flexibility in this regard.

In essence, we will be defining multiple roles, each allowed to perform different sets of actions.
An account may have, for example, 'moderator', 'minter' or 'admin' roles, which you will then check for
instead of simply using [`assert_only_owner`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-assert_only_owner). This check can be enforced through [`assert_only_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role).
Separately, you will be able to define rules for how accounts can be granted a role, have it revoked, and more.

Most software uses access control systems that are role-based: some users are regular users, some may be supervisors
or managers, and a few will often have administrative privileges.

### Usage

For each role that you want to define, you will create a new _role identifier_ that is used to grant, revoke, and
check if an account has that role. See [Creating role identifiers](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access#creating_role_identifiers) for information
on creating identifiers.

Here’s a simple example of implementing [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) on a portion of an ERC20 token contract which defines
and sets a 'minter' role:

```cairo hljs
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::MINTER_ROLE;

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        minter: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(MINTER_ROLE, minter);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }
}
```

|     |     |
| --- | --- |
|  | Make sure you fully understand how [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) works before<br>using it on your system, or copy-pasting the examples from this guide. |

While clear and explicit, this isn’t anything we wouldn’t have been able to achieve with
[Ownable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent). Where [AccessControl](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) shines the most is in scenarios where granular
permissions are required, which can be implemented by defining _multiple_ roles.

Let’s augment our ERC20 token example by also defining a 'burner' role, which lets accounts destroy tokens:

```cairo hljs
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");
const BURNER_ROLE: felt252 = selector!("BURNER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::{MINTER_ROLE, BURNER_ROLE};

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        accesscontrol: AccessControlComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        minter: ContractAddress,
        burner: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(MINTER_ROLE, minter);
        self.accesscontrol._grant_role(BURNER_ROLE, burner);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }

    /// This function can only be called by a burner.
    #[external(v0)]
    fn burn(ref self: ContractState, account: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(BURNER_ROLE);
        self.erc20.burn(account, amount);
    }
}
```

So clean!
By splitting concerns this way, more granular levels of permission may be implemented than were possible with the
simpler ownership approach to access control. Limiting what each component of a system is able to do is known
as the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), and is a good
security practice. Note that each account may still have more than one role, if so desired.

### Granting and revoking roles

The ERC20 token example above uses [`_grant_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-_grant_role),
an `internal` function that is useful when programmatically assigning
roles (such as during construction). But what if we later want to grant the 'minter' role to additional accounts?

By default, **accounts with a role cannot grant it or revoke it from other accounts**: all having a role does is making
the [`assert_only_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-assert_only_role) check pass. To grant and revoke roles dynamically, you will need help from the role’s _admin_.

Every role has an associated admin role, which grants permission to call the
[`grant_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-grant_role) and
[`revoke_role`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-revoke_role) functions.
A role can be granted or revoked by using these if the calling account has the corresponding admin role.
Multiple roles may have the same admin role to make management easier.
A role’s admin can even be the same role itself, which would cause accounts with that role to be able
to also grant and revoke it.

This mechanism can be used to create complex permissioning structures resembling organizational charts, but it also
provides an easy way to manage simpler applications. `AccessControl` includes a special role with the role identifier
of `0`, called `DEFAULT_ADMIN_ROLE`, which acts as the **default admin role for all roles**.
An account with this role will be able to manage any other role, unless
[`set_role_admin`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent-set_role_admin) is used to select a new admin role.

Let’s take a look at the ERC20 token example, this time taking advantage of the default admin role:

```cairo hljs
const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");
const BURNER_ROLE: felt252 = selector!("BURNER_ROLE");

#[starknet::contract]
mod MyContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;
    use super::{MINTER_ROLE, BURNER_ROLE};

    component!(path: AccessControlComponent, storage: accesscontrol, event: AccessControlEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // AccessControl
    #[abi(embed_v0)]
    impl AccessControlImpl =
        AccessControlComponent::AccessControlImpl<ContractState>;
    impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;

    // SRC5
    #[abi(embed_v0)]
    impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20Impl = ERC20Component::ERC20Impl<ContractState>;
    #[abi(embed_v0)]
    impl ERC20MetadataImpl = ERC20Component::ERC20MetadataImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        initial_supply: u256,
        recipient: ContractAddress,
        admin: ContractAddress
    ) {
        // ERC20-related initialization
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, initial_supply);

        // AccessControl-related initialization
        self.accesscontrol.initializer();
        self.accesscontrol._grant_role(DEFAULT_ADMIN_ROLE, admin);
    }

    /// This function can only be called by a minter.
    #[external(v0)]
    fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(MINTER_ROLE);
        self.erc20.mint(recipient, amount);
    }

    /// This function can only be called by a burner.
    #[external(v0)]
    fn burn(ref self: ContractState, account: ContractAddress, amount: u256) {
        self.accesscontrol.assert_only_role(BURNER_ROLE);
        self.erc20.burn(account, amount);
    }
}
```

|     |     |
| --- | --- |
|  | The `grant_role` and `revoke_role` functions are automatically exposed as `external` functions<br>from the `AccessControlImpl` by leveraging the `#[abi(embed_v0)]` annotation. |

Note that, unlike the previous examples, no accounts are granted the 'minter' or 'burner' roles.
However, because those roles' admin role is the default admin role, and that role was granted to the 'admin', that
same account can call `grant_role` to give minting or burning permission, and `revoke_role` to remove it.

Dynamic role allocation is often a desirable property, for example in systems where trust in a participant may vary
over time. It can also be used to support use cases such as [KYC](https://en.wikipedia.org/wiki/Know_your_customer),
where the list of role-bearers may not be known up-front, or may be prohibitively expensive to include in a single transaction.

### Creating role identifiers

In the Solidity implementation of AccessControl, contracts generally refer to the
[keccak256 hash](https://docs.soliditylang.org/en/latest/units-and-global-variables.html?highlight=keccak256#mathematical-and-cryptographic-functions)
of a role as the role identifier.

For example:

```cairo hljs
bytes32 public constant SOME_ROLE = keccak256("SOME_ROLE")
```

These identifiers take up 32 bytes (256 bits).

Cairo field elements ( `felt252`) store a maximum of 252 bits.
With this discrepancy, this library maintains an agnostic stance on how contracts should create identifiers.
Some ideas to consider:

- Use [sn\_keccak](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#starknet_keccak) instead.

- Use Cairo friendly hashing algorithms like Poseidon, which are implemented in the
[Cairo corelib](https://github.com/starkware-libs/cairo/blob/main/corelib/src/poseidon.cairo).


|     |     |
| --- | --- |
|  | The `selector!` macro can be used to compute [sn\_keccak](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#starknet_keccak) in Cairo. |

### Interface

This is the full interface of the `AccessControlMixinImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait AccessControlABI {
    // IAccessControl
    fn has_role(role: felt252, account: ContractAddress) -> bool;
    fn get_role_admin(role: felt252) -> felt252;
    fn grant_role(role: felt252, account: ContractAddress);
    fn revoke_role(role: felt252, account: ContractAddress);
    fn renounce_role(role: felt252, account: ContractAddress);

    // IAccessControlCamel
    fn hasRole(role: felt252, account: ContractAddress) -> bool;
    fn getRoleAdmin(role: felt252) -> felt252;
    fn grantRole(role: felt252, account: ContractAddress);
    fn revokeRole(role: felt252, account: ContractAddress);
    fn renounceRole(role: felt252, account: ContractAddress);

    // ISRC5
    fn supports_interface(interface_id: felt252) -> bool;
}
```

`AccessControl` also lets you `renounce_role` from the calling account.
The method expects an account as input as an extra security measure, to ensure you are
not renouncing a role from an unintended account.

[← SNIP12 and Typed Messages](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/snip12)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access)Interfaces and Dispatchers - OpenZeppelin Docs

# Interfaces and Dispatchers

This section describes the interfaces OpenZeppelin Contracts for Cairo offer, and explains the design choices behind them.

Interfaces can be found in the module tree under the `interface` submodule, such as `token::erc20::interface`. For example:

```cairo hljs
use openzeppelin_token::erc20::interface::IERC20;
```

or

```cairo hljs
use openzeppelin_token::erc20::interface::ERC20ABI;
```

|     |     |
| --- | --- |
|  | For simplicity, we’ll use ERC20 as example but the same concepts apply to other modules. |

## Interface traits

The library offers three types of traits to implement or interact with contracts:

### Standard traits

These are associated with a predefined interface such as a standard.
This includes only the functions defined in the interface, and is the standard way to interact with a compliant contract.

```cairo hljs
#[starknet::interface]
pub trait IERC20<TState> {
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

### ABI traits

They describe a contract’s complete interface. This is useful to interface with a preset contract offered by this library, such as the ERC20 preset that includes functions from different traits such as `IERC20` and `IERC20Camel`.

|     |     |
| --- | --- |
|  | The library offers an ABI trait for most components, providing all external function signatures<br>even when most of the time all of them don’t need to be implemented at the same time. This can be helpful when interacting with a contract implementing the component, instead of defining a new dispatcher. |

```cairo hljs
#[starknet::interface]
pub trait ERC20ABI<TState> {
    // IERC20
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;

    // IERC20Metadata
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;

    // IERC20CamelOnly
    fn totalSupply(self: @TState) -> u256;
    fn balanceOf(self: @TState, account: ContractAddress) -> u256;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
}
```

### Dispatcher traits

Traits annotated with `#[starknet::interface]` automatically generate a dispatcher that can be used to interact with contracts that implement the given interface. They can be imported by appending the `Dispatcher` and `DispatcherTrait` suffixes to the trait name, like this:

```cairo hljs
use openzeppelin_token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
```

Other types of dispatchers are also auto-generated from the annotated trait. See the
[Interacting with another contract](https://book.cairo-lang.org/ch15-02-interacting-with-another-contract.html) section of the Cairo book for more information.

|     |     |
| --- | --- |
|  | In the example, the `IERC20Dispatcher` is the one used to interact with contracts, but the<br>`IERC20DispatcherTrait` needs to be in scope for the functions to be available. |

## Dual interfaces

|     |     |
| --- | --- |
|  | `camelCase` functions are deprecated and maintained only for Backwards Compatibility.<br>It’s recommended to only use `snake_case` interfaces with contracts and components. The `camelCase` functions will be removed in<br>future versions. |

Following the [Great Interface Migration](https://community.starknet.io/t/the-great-interface-migration/92107) plan, we added `snake_case` functions to all of our preexisting `camelCase` contracts with the goal of eventually dropping support for the latter.

In short, the library offers two types of interfaces and utilities to handle them:

1. `camelCase` interfaces, which are the ones we’ve been using so far.

2. `snake_case` interfaces, which are the ones we’re migrating to.


This means that currently most of our contracts implement _dual interfaces_. For example, the ERC20 preset contract exposes `transferFrom`, `transfer_from`, `balanceOf`, `balance_of`, etc.

|     |     |
| --- | --- |
|  | Dual interfaces are available for all external functions present in previous versions of OpenZeppelin Contracts for Cairo ( [v0.6.1](https://github.com/OpenZeppelin/cairo-contracts/releases/tag/v0.6.1) and below). |

### `IERC20`

The default version of the ERC20 interface trait exposes `snake_case` functions:

```cairo hljs
#[starknet::interface]
pub trait IERC20<TState> {
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

### `IERC20Camel`

On top of that, the library also offers a `camelCase` version of the same interface:

```cairo hljs
#[starknet::interface]
pub trait IERC20Camel<TState> {
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;
    fn totalSupply(self: @TState) -> u256;
    fn balanceOf(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transferFrom(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;
}
```

[← Presets](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

[Counterfactual Deployments →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment)Testing - OpenZeppelin Docs

# Testing

This crate provides various helper functions for declaring, deploying,
and testing smart contracts using the `snforge` toolchain from Starknet Foundry.

```cairo hljs
use openzeppelin_testing;
```

The module isn’t part of the `openzeppelin` package and to be accessible has to
be added as a separate dependency in `Scarb.toml`:

```none hljs
[dev-dependencies]
openzeppelin_testing = "0.20.0"
```

## Test Utilities

### `common`

A module providing common test helpers.

```cairo hljs
use openzeppelin_testing::common;
```

Members

Functions

- [`panic_data_to_byte_array(panic_data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-panic_data_to_byte_array)

- [`to_base_16_string(value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-to_base_16_string)

- [`to_base_16_string_no_padding(value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-to_base_16_string_no_padding)

- [`assert_entrypoint_not_found_error(result, selector, contract_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-assert_entrypoint_not_found_error)


Traits

- [`IntoBase16StringTrait`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-common-IntoBase16StringTrait)


#### Functions

#### `panic_data_to_byte_array(panic_data: Array<felt252>) → ByteArray` function

Converts panic data into a string ( `ByteArray`).

`panic_data` is expected to be a valid serialized `ByteArray` with an extra `felt252` at the beginning, which is the BYTE\_ARRAY\_MAGIC.

#### `to_base_16_string(value: felt252) → ByteArray` function

Converts a `felt252` to a `base16` string padded to 66 characters (including the `0x` prefix).

#### `to_base_16_string_no_padding(value: felt252) → ByteArray` function

Converts a `felt252` to a `base16` (hexadecimal) string without padding, but including the `0x`
prefix.

#### `assert_entrypoint_not_found_error<T, +Drop<T>>(result: SyscallResult<T>, selector: felt252, contract_address: ContractAddress)` function

Asserts that the syscall result of a call failed with an "Entrypoint not found" error,
following the Starknet Foundry emitted error format.

#### Traits

#### `IntoBase16StringTrait` trait

A helper trait that enables a value to be represented as a `base16`(hexadecimal) string padded to 66 characters
(including the `0x` prefix). The type of the value must implement `Into<T, felt252>` to be
convertible to `felt252`.

Usage example:

```cairo hljs
use openzeppelin_testing::common::IntoBase16String;

let expected_panic_message = format!(
    "Entry point selector {} not found in contract {}",
    selector.into_base_16_string(),
    contract_address.into_base_16_string()
);
```

|     |     |
| --- | --- |
|  | The no-padding version can be used in the same way by calling `selector.into_base_16_string_no_padding()`. |

### `deployment`

```cairo hljs
use openzeppelin_testing::deployment;
```

A module containing utilities that simplify declaring and deploying contracts using the `snforge` toolchain.

Members

Functions

- [`declare_class(contract_name)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-declare_class)

- [`deploy(contract_class, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-deploy)

- [`deploy_at(contract_class, contract_address, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-deploy_at)

- [`deploy_another_at(existing, target_address, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-deploy_another_at)

- [`declare_and_deploy(contract_name, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-declare_and_deploy)

- [`declare_and_deploy_at(contract_name, target_address, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-deployment-declare_and_deploy_at)


#### Functions

#### `declare_class(contract_name: ByteArray) → ContractClass` function

Declares a contract with a `snforge_std::declare` call and unwraps the result. This function will skip declaration and just return the `ContractClass` if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

#### `deploy(contract_class: ContractClass, calldata: Array<felt252>) → ContractAddress` function

Deploys an instance of a contract and unwraps the result.

#### `deploy_at(contract_class: ContractClass, target_address: ContractAddress, calldata: Array<felt252>)` function

Deploys an instance of a contract at a given address.

#### `deploy_another_at(existing: ContractAddress, target_address: ContractAddress, calldata: Array<felt252>)` function

Deploys a contract using the class hash from another already-deployed contract.

Note that currently, `snforge` does not support redeclaring a contract class. Consequently,
there is no direct method to deploy a second instance of a contract if neither its `ContractClass`
nor its `class_hash` is available in the context. This helper function provides a solution by retrieving
the class hash from an existing contract and using it to facilitate the deployment.

```cairo hljs
use openzeppelin_testing::deploy_another_at;

let alice_address = setup_account(array!['ALICE_PUBKEY']);
let bob_address = contract_address_const::<'BOB'>();
deploy_another_at(alice_address, bob_address, array!['BOB_PUBKEY']);
```

#### `declare_and_deploy(contract_name: ByteArray, calldata: Array<felt252>) → ContractAddress` function

Combines the declaration of a class and the deployment of a contract into one function call. This function will skip declaration if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

#### `declare_and_deploy_at(contract_name: ByteArray, target_address: ContractAddress, calldata: Array<felt252>)` function

Combines the declaration of a class and the deployment of a contract at the given address into one function call. This function will skip declaration if the contract is already declared (the result of `snforge_std::declare` call is of type `DeclareResult::AlreadyDeclared`).

### `events`

```cairo hljs
use openzeppelin_testing::events;
use openzeppelin_testing::events::EventSpyExt;
```

A module offering an extended set of functions for handling emitted events, enhancing the default
event utilities provided by `snforge`. These functions are accessible via the `EventSpyExt`
trait implemented on the `EventSpy` struct.

Members

Functions

- [`assert_only_event(self, from_address, event)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_only_event)

- [`assert_emitted_single(self, from_address, expected_event)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_emitted_single)

- [`drop_event(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-drop_event)

- [`drop_n_events(self, number_to_drop)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-drop_n_events)

- [`drop_all_events(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-drop_all_events)

- [`assert_no_events_left(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_no_events_left)

- [`assert_no_events_left_from(self, from_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-assert_no_events_left_from)

- [`count_events_from(self, from_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-events-count_events_from)


#### Functions

#### `assert_only_event<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)` function

Ensures that `from_address` has emitted only the `expected_event` and no additional events.

#### `assert_emitted_single<T, +starknet::Event<T>, +Drop<T>>(ref self: EventSpy, from_address: ContractAddress, expected_event: T)` function

Ensures that `from_address` has emitted the `expected_event`.

#### `drop_event(ref self: EventSpy)` function

Removes a single event from the queue. If the queue is empty, the function will panic.

#### `drop_n_events(ref self: EventSpy, number_to_drop: u32)` function

Removes `number_to_drop` events from the queue. If the queue is empty, the function will panic.

#### `drop_all_events(ref self: EventSpy)` function

Removes all events remaining on the queue. If the queue is empty already, the function will do nothing.

#### `assert_no_events_left(ref self: EventSpy)` function

Ensures that there are no events remaining on the queue.

#### `assert_no_events_left_from(ref self: EventSpy, from_address: ContractAddress)` function

Ensures that there are no events emitted from the given address remaining on the queue.

#### `count_events_from(ref self: EventSpy, from_address: ContractAddress) → u32` function

Counts the number of remaining events emitted from the given address.

### `signing`

```cairo hljs
use openzeppelin_testing::signing;
```

A module offering utility functions for easier management of key pairs and signatures.

Members

Functions

- [`get_stark_keys_from(private_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-get_stark_keys_from)

- [`get_secp256k1_keys_from(private_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-get_secp256k1_keys_from)

- [`get_secp256r1_keys_from(private_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-get_secp256r1_keys_from)


Traits

- [`SerializedSigning`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing#testing-signing-SerializedSigning)


#### Functions

#### `get_stark_keys_from(private_key: felt252) → StarkKeyPair` function

Builds a [Stark](https://docs.starknet.io/architecture-and-concepts/cryptography/stark-curve/) key pair from a private key represented by a `felt252` value.

#### `get_secp256k1_keys_from(private_key: u256) → Secp256k1KeyPair` function

Builds a [Secp256k1](https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/secp256k1.cairo) key pair from a private key represented by a `u256` value.

#### `get_secp256r1_keys_from(private_key: u256) → Secp256r1KeyPair` function

Builds a [Secp256r1](https://www.nervos.org/knowledge-base/what_is_secp256r1) key pair from a private key represented by a `u256` value.

#### Traits

#### `SerializedSigning` trait

A helper trait that facilitates signing and converting the result signature into a serialized format.

Usage example:

```cairo hljs
use openzeppelin_testing::signing::{
    StarkKeyPair, get_stark_keys_from, StarkSerializedSigning
};

let key_pair = get_stark_keys_from('SECRET_KEY');
let serialized_signature = key_pair.serialized_sign('TX_HASH');
```

[← Utilities](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities)

[Backwards Compatibility →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/backwards-compatibility)Migrating to a new CLI version - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Migrating to a new CLI version

To migrate to a new OpenZeppelin CLI version is generally a matter of upgrading the OpenZeppelin CLI and OpenZeppelin Upgrades versions.

```console hljs language-shell
$ npm upgrade @openzeppelin/cli @openzeppelin/upgrades
```

## Migrating from ZeppelinOS to OpenZeppelin CLI

ZeppelinOS was renamed to OpenZeppelin CLI as part of [rebranding the company and the projects](https://blog.openzeppelin.com/openzeppelin-rebranding/). OpenZeppelin CLI and OpenZeppelin Upgrades were first released as [version 2.5.0](https://github.com/OpenZeppelin/openzeppelin-sdk/releases/tag/v2.5.0), to follow the ZeppelinOS versioning.

The CLI **changed the name of the executable from `zos` to `openzeppelin`** (or the alias `oz`, if you prefer shorter names).
It also has all configuration files under a single `.openzeppelin` folder, to avoid polluting your project’s root.
The [version 2.5.0 release changelog](https://github.com/OpenZeppelin/openzeppelin-sdk/releases/tag/v2.5.0) describes all modifications in more detail.

However, **all the previous namings are still supported**, meaning that **you don’t need to change anything on your project**
when you migrate. You can still run `zos` in your command line or scripts, and if a `zos.json` is found at the root of your project,
the CLI will still pick it up. Also, the Ethereum Package `openzeppelin-eth` will still be supported by the SDK, but you can opt-in
to the new `@openzeppelin/contracts-ethereum-package`.

The only thing that will require a change on your end are import statements: for instance, if you are importing
`zos-lib/contracts/Initializable.sol`, you will now need to import `@openzeppelin/upgrades/contracts/Initializable.sol`.

## Migrating from ZeppelinOS 2.0 or 2.1 to ZeppelinOS 2.2

If you created a project using ZeppelinOS 2.0 or 2.1, and then decided to upgrade your ZeppelinOS dependency to 2.2,
you need to create and set up a `ProxyAdmin` contract for each of the networks your project is deployed to.
Good news though! This can be done automatically by using the ZeppelinOS CLI.

To trigger the migration in a particular network, you need to start a session in it (or use the `--network myNetwork` parameter)
and use any of the following commands: `create`, `update`, `set-admin`, or `publish`. The CLI will prompt if you want to migrate your
deployment on that specific network you are interacting with, and will set up the ProxyAdmin contract automatically.

So you can go ahead and say yes, and the CLI will take care of the rest, to migrate you to ZeppelinOS 2.2.

[← Using With Truffle](https://docs.openzeppelin.com/cli/2.8/truffle)

[Frequently Asked Questions →](https://docs.openzeppelin.com/cli/2.8/faq)ERC721 - OpenZeppelin Docs

# ERC721

The ERC721 token standard is a specification for [non-fungible tokens](https://docs.openzeppelin.com/contracts/5.x/tokens#different-kinds-of-tokens), or more colloquially: NFTs.
`token::erc721::ERC721Component` provides an approximation of [EIP-721](https://eips.ethereum.org/EIPS/eip-721) in Cairo for Starknet.

## Usage

Using Contracts for Cairo, constructing an ERC721 contract requires integrating both `ERC721Component` and `SRC5Component`.
The contract should also set up the constructor to initialize the token’s name, symbol, and interface support.
Here’s an example of a basic contract:

```cairo hljs
#[starknet::contract]
mod MyNFT {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc721::{ERC721Component, ERC721HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC721 Mixin
    #[abi(embed_v0)]
    impl ERC721MixinImpl = ERC721Component::ERC721MixinImpl<ContractState>;
    impl ERC721InternalImpl = ERC721Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc721: ERC721Component::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC721Event: ERC721Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        recipient: ContractAddress
    ) {
        let name = "MyNFT";
        let symbol = "NFT";
        let base_uri = "https://api.example.com/v1/";
        let token_id = 1;

        self.erc721.initializer(name, symbol, base_uri);
        self.erc721.mint(recipient, token_id);
    }
}
```

## Interface

The following interface represents the full ABI of the Contracts for Cairo [ERC721Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721Component).
The interface includes the [IERC721](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721) standard interface and the optional [IERC721Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata) interface.

To support older token deployments, as mentioned in [Dual interfaces](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces#dual_interfaces), the component also includes implementations of the interface written in camelCase.

```cairo hljs
#[starknet::interface]
pub trait ERC721ABI {
    // IERC721
    fn balance_of(account: ContractAddress) -> u256;
    fn owner_of(token_id: u256) -> ContractAddress;
    fn safe_transfer_from(
        from: ContractAddress,
        to: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    );
    fn transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256);
    fn approve(to: ContractAddress, token_id: u256);
    fn set_approval_for_all(operator: ContractAddress, approved: bool);
    fn get_approved(token_id: u256) -> ContractAddress;
    fn is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool;

    // IERC721Metadata
    fn name() -> ByteArray;
    fn symbol() -> ByteArray;
    fn token_uri(token_id: u256) -> ByteArray;

    // IERC721CamelOnly
    fn balanceOf(account: ContractAddress) -> u256;
    fn ownerOf(tokenId: u256) -> ContractAddress;
    fn safeTransferFrom(
        from: ContractAddress,
        to: ContractAddress,
        tokenId: u256,
        data: Span<felt252>
    );
    fn transferFrom(from: ContractAddress, to: ContractAddress, tokenId: u256);
    fn setApprovalForAll(operator: ContractAddress, approved: bool);
    fn getApproved(tokenId: u256) -> ContractAddress;
    fn isApprovedForAll(owner: ContractAddress, operator: ContractAddress) -> bool;

    // IERC721MetadataCamelOnly
    fn tokenURI(tokenId: u256) -> ByteArray;
}
```

## ERC721 compatibility

Although Starknet is not EVM compatible, this implementation aims to be as close as possible to the ERC721 standard.
This implementation does, however, include a few notable differences such as:

- `interface_id` s are hardcoded and initialized by the constructor.
The hardcoded values derive from Starknet’s selector calculations.
See the [Introspection](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection) docs.

- `safe_transfer_from` can only be expressed as a single function in Cairo as opposed to the two functions declared in EIP721, because function overloading is currently not possible in Cairo.
The difference between both functions consists of accepting `data` as an argument.
`safe_transfer_from` by default accepts the `data` argument which is interpreted as `Span<felt252>`.
If `data` is not used, simply pass an empty array.

- ERC721 utilizes [SRC5](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#src5) to declare and query interface support on Starknet as opposed to Ethereum’s [EIP165](https://eips.ethereum.org/EIPS/eip-165).
The design for `SRC5` is similar to OpenZeppelin’s [ERC165Storage](https://docs.openzeppelin.com/contracts/4.x/api/utils#ERC165Storage).

- `IERC721Receiver` compliant contracts return a hardcoded interface ID according to Starknet selectors (as opposed to selector calculation in Solidity).


## Token transfers

This library includes [transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-transfer_from) and [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from) to transfer NFTs.
If using `transfer_from`, **the caller is responsible to confirm that the recipient is capable of receiving NFTs or else they may be permanently lost.**
The `safe_transfer_from` method mitigates this risk by querying the recipient contract’s interface support.

|     |     |
| --- | --- |
|  | Usage of `safe_transfer_from` prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability. |

## Receiving tokens

In order to be sure a non-account contract can safely accept ERC721 tokens, said contract must implement the `IERC721Receiver` interface.
The recipient contract must also implement the [SRC5](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#src5) interface which, as described earlier, supports interface introspection.

### IERC721Receiver

```cairo hljs
#[starknet::interface]
pub trait IERC721Receiver {
    fn on_erc721_received(
        operator: ContractAddress,
        from: ContractAddress,
        token_id: u256,
        data: Span<felt252>
    ) -> felt252;
}
```

Implementing the `IERC721Receiver` interface exposes the [on\_erc721\_received](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver-on_erc721_received) method.
When safe methods such as [safe\_transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721-safe_transfer_from) and [safe\_mint](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#ERC721-safe_mint) are called, they invoke the recipient contract’s `on_erc721_received` method which **must** return the [IERC721Receiver interface ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Receiver).
Otherwise, the transaction will fail.

|     |     |
| --- | --- |
|  | For information on how to calculate interface IDs, see [Computing the interface ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#computing_the_interface_id). |

### Creating a token receiver contract

The Contracts for Cairo `IERC721ReceiverImpl` already returns the correct interface ID for safe token transfers.
To integrate the `IERC721Receiver` interface into a contract, simply include the ABI embed directive to the implementation and add the `initializer` in the contract’s constructor.
Here’s an example of a simple token receiver contract:

```cairo hljs
#[starknet::contract]
mod MyTokenReceiver {
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc721::ERC721ReceiverComponent;
    use starknet::ContractAddress;

    component!(path: ERC721ReceiverComponent, storage: erc721_receiver, event: ERC721ReceiverEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // ERC721Receiver Mixin
    #[abi(embed_v0)]
    impl ERC721ReceiverMixinImpl = ERC721ReceiverComponent::ERC721ReceiverMixinImpl<ContractState>;
    impl ERC721ReceiverInternalImpl = ERC721ReceiverComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc721_receiver: ERC721ReceiverComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC721ReceiverEvent: ERC721ReceiverComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc721_receiver.initializer();
    }
}
```

## Storing ERC721 URIs

Token URIs were previously stored as single field elements prior to Cairo v0.2.5.
ERC721Component now stores only the base URI as a `ByteArray` and the full token URI is returned as the `ByteArray` concatenation of the base URI and the token ID through the [token\_uri](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721#IERC721Metadata-token_uri) method.
This design mirrors OpenZeppelin’s default [Solidity implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/932fddf69a699a9a80fd2396fd1a2ab91cdda123/contracts/token/ERC721/ERC721.sol#L85-L93) for ERC721.

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc721)Universal Deployer Contract - OpenZeppelin Docs

# Universal Deployer Contract

The Universal Deployer Contract (UDC) is a singleton smart contract that wraps the [deploy syscall](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#deploy) to expose it to any contract that doesn’t implement it, such as account contracts. You can think of it as a standardized generic factory for Starknet contracts.

Since Starknet has no deployment transaction type, it offers a standardized way to deploy smart contracts by following the [Standard Deployer Interface](https://community.starknet.io/t/snip-deployer-contract-interface/2772) and emitting a [ContractDeployed](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#IUniversalDeployer-ContractDeployed) event.

For details on the motivation and the decision making process, see the [Universal Deployer Contract proposal](https://community.starknet.io/t/universal-deployer-contract-proposal/1864).

## UDC contract address

The UDC address is deployed at address `0x04a64cd09a853868621d94cae9952b106f2c36a3f81260f85de6696c6b050221` in Mainnet and Sepolia testnet.

## Interface

```cairo hljs
#[starknet::interface]
pub trait IUniversalDeployer {
    fn deploy_contract(
        class_hash: ClassHash,
        salt: felt252,
        from_zero: bool,
        calldata: Span<felt252>
    ) -> ContractAddress;
}
```

## Deploying a contract with the UDC

First, [declare](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/transactions/#declare-transaction) the target contract (if it’s not already declared).
Next, call the UDC’s `deploy_contract` method.
Here’s an implementation example in Cairo:

```cairo hljs
use openzeppelin_utils::interfaces::{IUniversalDeployerDispatcher, IUniversalDeployerDispatcherTrait};

const UDC_ADDRESS: felt252 = 0x04a64cd09a853868621d94cae9952b106f2c36a3f81260f85de6696c6b050221;

fn deploy() -> ContractAddress {
    let dispatcher = IUniversalDeployerDispatcher {
        contract_address: UDC_ADDRESS.try_into().unwrap()
    };

    // Deployment parameters
    let class_hash = class_hash_const::<
       0x5c478ee27f2112411f86f207605b2e2c58cdb647bac0df27f660ef2252359c6
    >();
    let salt = 1234567879;
    let from_zero = false;
    let calldata = array![];

    // The UDC returns the deployed contract address
    dispatcher.deploy_contract(class_hash, salt, from_zero, calldata.span())
}
```

## Deployment types

The Universal Deployer Contract offers two types of addresses to deploy: origin-dependent and origin-independent.
As the names suggest, the origin-dependent type includes the deployer’s address in the address calculation,
whereas, the origin-independent type does not.
The `from_zero` boolean parameter ultimately determines the type of deployment.

|     |     |
| --- | --- |
|  | When deploying a contract that uses `get_caller_address` in the constructor calldata, remember that the UDC, not the account, deploys that contract.<br>Therefore, querying `get_caller_address` in a contract’s constructor returns the UDC’s address, _not the account’s address_. |

### Origin-dependent

By making deployments dependent upon the origin address, users can reserve a whole address space to prevent someone else from taking ownership of the address.

Only the owner of the origin address can deploy to those addresses.

Achieving this type of deployment necessitates that the origin sets `from_zero` to `false` in the [deploy\_contract](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#UniversalDeployer-deploy_contract) call.
Under the hood, the function passes a modified salt to the `deploy_syscall`, which is the hash of the origin’s address with the given salt.

To deploy a unique contract address pass:

```js hljs language-javascript
let deployed_addr = udc.deploy_contract(class_hash, salt, false, calldata.span());
```

### Origin-independent

Origin-independent contract deployments create contract addresses independent of the deployer and the UDC instance.
Instead, only the class hash, salt, and constructor arguments determine the address.
This type of deployment enables redeployments of accounts and known systems across multiple networks.
To deploy a reproducible deployment, set `from_zero` to `true`.

```cairo hljs
let deployed_addr = udc.deploy_contract(class_hash, salt, true, calldata.span());
```

## Version changes

|     |     |
| --- | --- |
|  | See the [previous Universal Deployer API](https://docs.openzeppelin.com/contracts-cairo/0.6.1/udc#api_specification) for the initial spec. |

The latest iteration of the UDC includes some notable changes to the API which include:

- `deployContract` method is replaced with the snake\_case [deploy\_contract](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#UniversalDeployer-deploy_contract).

- [Pedersen](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#pedersen_hash) hashing algorithm is replaced with the [Poseidon](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/hash-functions/#poseidon_hash) hashing algorithm for computing the salt on [origin-dependent deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc#origin_dependent).

- `unique` parameter is replaced with `from_zero` in both the `deploy_contract` method and [ContractDeployed](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#IUniversalDeployer-ContractDeployed) event.


|     |     |
| --- | --- |
|  | Origin-dependent deployments previously meant that the `unique` argument would be `true`.<br>Origin-dependent deployments from the new UDC iteration, however, requires that `from_zero` is `false`.<br>It’s especially important to keep this in mind when dealing with `ContractDeployed` events because this change will appear as the opposite boolean per deployment type. |

## Precomputing contract addresses

This library offers utility functions written in Cairo to precompute contract addresses.
They include the generic [calculate\_contract\_address\_from\_deploy\_syscall](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-calculate_contract_address_from_deploy_syscall) as well as the UDC-specific [calculate\_contract\_address\_from\_udc](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-calculate_contract_address_from_udc).
Check out the [deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments) for more information.

[← Common](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/token_common)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc)Backwards Compatibility - OpenZeppelin Docs

# Backwards Compatibility

OpenZeppelin Contracts uses semantic versioning to communicate backwards compatibility of its API and storage layout. Patch and minor updates will generally be backwards compatible, with rare exceptions as detailed below. Major updates should be assumed incompatible with previous releases. On this page, we provide details about these guarantees.

Bear in mind that while releasing versions under `v1.0.0`, we treat minors as majors and patches as minors, in accordance with semantic versioning. This means that `v0.7.1` could be adding features to `v0.7.0`, while `v0.8.0` would be considered a breaking release.

## API

In backwards compatible releases, all changes should be either additions or modifications to internal implementation details. Most code should continue to compile and behave as expected. The exceptions to this rule are listed below.

### Security

Infrequently, a patch or minor update will remove or change an API in a breaking way but only if the previous API is considered insecure. These breaking changes will be noted in the changelog and release notes, and published along with a security advisory.

### Errors

The specific error format and data that is included with reverts should not be assumed stable unless otherwise specified.

### Major releases

Major releases should be assumed incompatible. Nevertheless, the external interfaces of contracts will remain compatible if they are standardized, or if the maintainers judge that changing them would cause significant strain on the ecosystem.

An important aspect that major releases may break is "upgrade compatibility", in particular storage layout compatibility. It will never be safe for a live contract to upgrade from one major release to another.

## Storage layout

Patch updates will always preserve storage layout compatibility, and after `v1.0.0` minors will too. This means that a live contract can be upgraded from one minor to another without corrupting the storage layout. In some cases it may be necessary to initialize new state variables when upgrading, although we expect this to be infrequent.

## Cairo version

The minimum Cairo version required to compile the contracts will remain unchanged for patch updates, but it may change for minors.

[← Test Utilities](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing)

[Contracts for Solidity →](https://docs.openzeppelin.com/contracts/5.x/)ERC-721 Enumerable - OpenZeppelin Docs

# ERC-721 Enumerable

The OpenZeppelin [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) Enumerable extension is used to provide additional functionality to the standard ERC-721 token. Specifically, it allows for enumeration of all the token IDs in the contract as well as all the token IDs owned by each account. This is useful for applications that need to list or iterate over tokens, such as marketplaces or wallets.

## Usage

In order to make an [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) token with [Enumerable](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/enumerable/index.html) flavour,
you need to create a specified contract as follows:

```rust hljs
use openzeppelin_stylus::token::erc721::{
    extensions::{Erc721Enumerable, IErc721Burnable},
    Erc721, IErc721,
};

sol_storage! {
    #[entrypoint]
    struct Erc721Example {
        #[borrow]
        Erc721 erc721;
        #[borrow]
        Erc721Enumerable enumerable;
    }
}

#[public]
#[inherit(Erc721, Erc721Enumerable)]
impl Erc721Example {
    pub fn burn(&mut self, token_id: U256) -> Result<(), Vec<u8>> {
        // Retrieve the owner.
        let owner = self.erc721.owner_of(token_id)?;

        self.erc721.burn(token_id)?;

        // Update the extension's state.
        self.enumerable._remove_token_from_owner_enumeration(
            owner,
            token_id,
            &self.erc721,
        )?;
        self.enumerable._remove_token_from_all_tokens_enumeration(token_id);

        Ok(())
    }

    pub fn mint(&mut self, to: Address, token_id: U256) -> Result<(), Vec<u8>> {
        self.erc721._mint(to, token_id)?;

        // Update the extension's state.
        self.enumerable._add_token_to_all_tokens_enumeration(token_id);
        self.enumerable._add_token_to_owner_enumeration(
            to,
            token_id,
            &self.erc721,
        )?;

        Ok(())
    }

    pub fn safe_transfer_from(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Vec<u8>> {
        // Retrieve the previous owner.
        let previous_owner = self.erc721.owner_of(token_id)?;

        self.erc721.safe_transfer_from(from, to, token_id)?;

        // Update the extension's state.
        self.enumerable._remove_token_from_owner_enumeration(
            previous_owner,
            token_id,
            &self.erc721,
        )?;
        self.enumerable._add_token_to_owner_enumeration(
            to,
            token_id,
            &self.erc721,
        )?;

        Ok(())
    }

    #[selector(name = "safeTransferFrom")]
    pub fn safe_transfer_from_with_data(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
        data: Bytes,
    ) -> Result<(), Vec<u8>> {
        // Retrieve the previous owner.
        let previous_owner = self.erc721.owner_of(token_id)?;

        self.erc721.safe_transfer_from_with_data(from, to, token_id, data)?;

        // Update the extension's state.
        self.enumerable._remove_token_from_owner_enumeration(
            previous_owner,
            token_id,
            &self.erc721,
        )?;
        self.enumerable._add_token_to_owner_enumeration(
            to,
            token_id,
            &self.erc721,
        )?;

        Ok(())
    }

    pub fn transfer_from(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Vec<u8>> {
        // Retrieve the previous owner.
        let previous_owner = self.erc721.owner_of(token_id)?;

        self.erc721.transfer_from(from, to, token_id)?;

        // Update the extension's state.
        self.enumerable._remove_token_from_owner_enumeration(
            previous_owner,
            token_id,
            &self.erc721,
        )?;
        self.enumerable._add_token_to_owner_enumeration(
            to,
            token_id,
            &self.erc721,
        )?;

        Ok(())
    }
}
```ERC-20 Pausable - OpenZeppelin Docs

# ERC-20 Pausable

ERC20 token with pausable token transfers, minting, and burning.

Useful for scenarios such as preventing trades until the end of an evaluation period, or having an emergency switch for freezing all token transfers in the event of a large bug.

## Usage

In order to make your ERC20 token `pausable`, you need to use the [`Pausable`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/utils/pausable/index.html) contract and apply its mechanisms to ERC20 token functions as follows:

```rust hljs
use openzeppelin_stylus::{
    token::erc20::Erc20,
    utils::Pausable,
};

sol_storage! {
    #[entrypoint]
    struct Erc20Example {
        #[borrow]
        Erc20 erc20;
        #[borrow]
        Pausable pausable;
    }
}

#[public]
#[inherit(Erc20, Pausable)]
impl Erc20Example {
    pub fn burn(&mut self, value: U256) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc20.burn(value).map_err(|e| e.into())
    }

    pub fn burn_from(
        &mut self,
        account: Address,
        value: U256,
    ) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc20.burn_from(account, value).map_err(|e| e.into())
    }

    pub fn mint(
        &mut self,
        account: Address,
        value: U256,
    ) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc20._mint(account, value)?;
        Ok(())
    }

    pub fn transfer(
        &mut self,
        to: Address,
        value: U256,
    ) -> Result<bool, Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc20.transfer(to, value).map_err(|e| e.into())
    }

    pub fn transfer_from(
        &mut self,
        from: Address,
        to: Address,
        value: U256,
    ) -> Result<bool, Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc20.transfer_from(from, to, value).map_err(|e| e.into())
    }

}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy). Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc20Example {
    bool private _paused;

    constructor() {
        _paused = false;
    }
}
```ERC-721 Pausable - OpenZeppelin Docs

# ERC-721 Pausable

ERC721 token with pausable token transfers, minting, and burning.

Useful for scenarios such as preventing trades until the end of an evaluation period, or having an emergency switch for freezing all token transfers, e.g. caused by a bug.

## Usage

In order to make your ERC721 token `pausable`, you need to use the [`Pausable`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/utils/pausable/index.html) contract and apply its mechanisms to ERC721 token functions as follows:

```rust hljs
use openzeppelin_stylus::{
    token::erc721::Erc721,
    utils::Pausable,
};

sol_storage! {
    #[entrypoint]
    struct Erc721Example {
        #[borrow]
        Erc721 erc721;
        #[borrow]
        Pausable pausable;
    }
}

#[public]
#[inherit(Erc721, Pausable)]
impl Erc721Example {
    pub fn burn(&mut self, token_id: U256) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc721.burn(token_id)?;
        Ok(())
    }

    pub fn mint(&mut self, to: Address, token_id: U256) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc721._mint(to, token_id)?;
        Ok(())
    }

    pub fn safe_transfer_from(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc721.safe_transfer_from(from, to, token_id)?;
        Ok(())
    }

    #[selector(name = "safeTransferFrom")]
    pub fn safe_transfer_from_with_data(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
        data: Bytes,
    ) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc721.safe_transfer_from_with_data(from, to, token_id, data)?;
        Ok(())
    }

    pub fn transfer_from(
        &mut self,
        from: Address,
        to: Address,
        token_id: U256,
    ) -> Result<(), Vec<u8>> {
        // ...
        self.pausable.when_not_paused()?;
        // ...
        self.erc721.transfer_from(from, to, token_id)?;
        Ok(())
    }
}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy). Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc721Example {
    bool private _paused;

    constructor() {
        _paused = false;
    }
}
```Compiling - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Compiling

The OpenZeppelin CLI integrates the Solidity compiler to seamlessly compile your Solidity contracts into Ethereum Virtual Machine (EVM) bytecode.

This guide covers how compiling works, its different options, and the output format.

## Running the Compiler

Most CLI commands, like `oz deploy` or `oz upgrade`, will automatically compile your projects smart contracts when required, so you don’t need to worry about doing this yourself.

However, you can also just run the compilation by itself, using the [`oz compile`](https://docs.openzeppelin.com/cli/2.8/commands#compile) command:

```console hljs language-shell
$ npx oz compile
```

When executed for the first time, all smart contracts in the `contracts` directory will be compiled at once. Further invocations of `compile` however will _only_ compile contracts that have changed (along with their dependents), speeding up the process.

## Settings

All compilation settings are passed directly to the Solidity compiler. Check out its [documentation](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html) for more info on how each setting affects compilation.

### Picking a Compiler Version

Each Solidity source files should be annotated with a [version pragma](https://solidity.readthedocs.io/en/v0.5.15/layout-of-source-files.html#version-pragma) that indicates which compiler versions can be used to compile it.

The CLI will parse all of these declarations and automatically select the latest compiler version that matches all your version pragmas. This single version will be the one used to compile _all_ of your contracts.

|     |     |
| --- | --- |
|  | It is often best to use permissive pragmas, such as `^0.5.0` or `^0.6.0` (which select the 0.5.x and 0.6.x lines of the compiler, respectively), and let the CLI do the rest. |

Alternatively, you can also specify a compiler version when calling `oz compile` by using the `--solc-version` option:

```console hljs language-shell
$ npx oz compile --solc-version 0.5.14
```

In all cases, the selected Solidity compiler version will be automatically downloaded and saved to cache from the [official distribution list](https://solc-bin.ethereum.org/bin/list.json). Once the version is set, subsequent compilations will [use that same version](https://docs.openzeppelin.com/cli/2.8/compiling#saving-your-settings).

|     |     |
| --- | --- |
|  | For enhanced performance, you can [install the native Solidity binaries](https://solidity.readthedocs.io/en/v0.5.15/installing-solidity.html#binary-packages) on your machine: the CLI will automatically pick it up when compiling if it matches the target version. Massive speedups can be achieved by doing this, specially on large projects. Just make sure it’s available on your [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable))!. |

### Picking an EVM Version

Each version of the Solidity compiler ships with a default [EVM version](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html#setting-the-evm-version-to-target), which corresponds to the mainnet EVM version at the time of release. The CLI will respect these defaults unless otherwise instructed.

In some occasions, it may be necessary to select a specific EVM version. This is achieved via the `--evm-version` flag:

```console hljs language-shell
$ npx oz compile --evm-version berlin
```

### Using the Optimizer

The Solidity compiler features an optional optimizer: it can produce smaller and more gas-efficient EVM bytecode, at the cost of making it harder to understand.

The optimizer is enabled or disabled with the `--optimizer` option:

```console hljs language-shell
$ npx oz compile --optimizer on
```

For fine tuning, you can also pass the `--optimizer-runs` option. This number should be an estimate of how many times you expect your smart contract to be called: pass 1 for one-offs, or a higher number for regularly used contracts. The default value is 200.

```console hljs language-shell
$ npx oz compile --optimizer on --optimizer-runs 100
```

|     |     |
| --- | --- |
|  | Don’t worry if you’re not sure what value to pass to `--optimizer-runs`: the gains achieved by using this parameter correctly are very limited. |

### Saving Your Settings

All compilation settings, including compiler version, EVM version and optimizer configuration are stored in your [project configuration file](https://docs.openzeppelin.com/cli/2.8/configuration#project.json), will be used in all successive compilations.

To modify these settings, run `oz compile` with the newly desired values, or simply edit the configuration file manually.

## Compilation Results

### Storing Compiled Artifacts

The output of the compiler is a number of `.json` files (one per compiled contract), which hold all relevant information: compiler settings, copies of the source, and most importantly, the resulting ABI and bytecode. These files are stored in the `build/contracts` directory, which the CLI will create for you automatically.

|     |     |
| --- | --- |
|  | These files can be large, and since compilation is a fast process it’s often a good idea to add this directory to your `.gitignore`:<br>```diff hljs<br> // .gitignore<br>+build/contracts<br>``` |

### Loading Your Contracts

The format of the `.json` artifacts is standard, and compatible with all major smart contract tools out there, such as Truffle, Buidler, and Etherlime.

If you want to load your compiled contracts and interact with them from JavaScript code, we recommend using the [**OpenZeppelin Contract Loader**](https://docs.openzeppelin.com/contract-loader/0.6/):

```javascript hljs
const { setupLoader } = require('@openzeppelin/contract-loader');

const loader = setupLoader({
  provider,        // either a web3 provider or a web3 instance
  defaultSender,   // optional
});

// Load build/contracts/ERC20.json
const ERC20 = loader.web3.fromArtifact('ERC20');

// Deploy contract
const token = await ERC20.deploy().send();

// Query state and send transaction
const balance = await token.methods.balanceOf(sender).call();
await token.methods.transfer(receiver, balance).send({ from: sender });
```

[← Using Dependencies](https://docs.openzeppelin.com/cli/2.8/dependencies)

[Deploying With `CREATE2` →](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


## openzeppelin\|oz

Usage: `openzeppelin|oz <command> [options]`

where <command> is one of: accounts, add, balance, bump, call, check, compile, create, create2, freeze, init, link, publish, push, remove, send-tx, session, set-admin, transfer, unlink, unpack, upgrade, verify

`--version`

output the version number

`-v, --verbose`

verbose mode on: output errors stacktrace and detailed log.

`-s, --silent`

silent mode: no output sent to stderr.

## accounts

Usage: `accounts [options]`

list the accounts of the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## add

Usage: `add [contractName1[:contractAlias1] …​ contractNameN[:contractAliasN]] [options]`

add contract to your project. Provide a list of whitespace-separated contract names

`--all`

add all contracts in your build directory

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## balance

Usage: `balance --network <network> [options]`

query the balance of the specified account

`--erc20 <contractAddress>`

query the balance of an ERC20 token instead of ETH

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## bump

Usage: `bump <version> [options]`

bump your project to a new <version>

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

## call

Usage: `call --to <to> --method <method> [options]`

call a method of the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the call

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## check

Usage: `check [contract] [options]`

checks your contracts for potential issues

`--skip-compile`

skips contract compilation

## compile

Usage: `compile [options]`

compiles all contracts in the current project

`--solc-version [version]`

version of the solc compiler to use (value is written to configuration file for future runs, defaults to most recent release that satisfies contract pragmas)

`--optimizer [on|off]`

enables compiler optimizer (value is written to configuration file for future runs, defaults to off)

`--optimizer-runs [runs]`

specify number of runs if optimizer enabled (value is written to configuration file for future runs, defaults to 200)

`--evm-version [evm]`

choose target evm version (value is written to configuration file for future runs, defaults depends on compiler: byzantium prior to 0.5.5, petersburg from 0.5.5)

`--no-interactive`

force to run the command in non-interactive mode

## create

Usage: `create [alias] --network <network> [options]`

deploys a new upgradeable contract instance. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package.

`--init [function]`

call function after creating contract. If none is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--force`

force creation even if contracts have local modifications

`--minimal`

creates a cheaper but non-upgradeable instance instead, using a minimal proxy

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## create2

Usage: `create2 [alias] --network <network> --salt <salt> [options]`

deploys a new upgradeable contract instance using CREATE2 at a predetermined address given a numeric <salt> and a <from> address. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package. A <signature> can be provided to derive the deployment address from a signer different to the <from> address. Warning: support for this feature is experimental.

`--salt <salt>`

salt used to determine the deployment address (required)

`--query [sender]`

do not create the contract and just return the deployment address, optionally specifying the sender used to derive the deployment address (defaults to 'from')

`--init [function]`

initialization function to call after creating contract (defaults to 'initialize', skips initialization if not set)

`--args <arg1, arg2, …​>`

arguments to the initialization function

`--admin <admin>`

admin of the proxy (uses the project’s proxy admin if not set)

`--signature <signature>`

signature of the request, uses the signer to derive the deployment address (uses the sender to derive deployment address if not set)

`--force`

force creation even if contracts have local modifications

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

## freeze

Usage: `freeze --network <network> [options]`

freeze current release version of your published project

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

## init

Usage: `init <project-name> [version]`

initialize your OpenZeppelin project. Provide a <project-name> and optionally an initial \[version\] name

`--publish`

automatically publish your project upon pushing it to a network

`--force`

overwrite existing project if there is one

`--typechain <target>`

enable typechain support with specified target (web3-v1, ethers, or truffle)

`--typechain-outdir <path>`

set output directory for typechain compilation (defaults to types/contracts)

`--link <dependency>`

link to a dependency

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## link

Usage: `link [dependencyName1 …​ dependencyNameN] [options]`

links project with a list of dependencies each located in its npm package

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## publish

Usage: `publish --network <network> [options]`

publishes your project to the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## push

Usage: `push --network <network> [options]`

deploys your project to the specified <network>

`--skip-compile`

skips contract compilation

`-d, --deploy-dependencies`

deploys dependencies to the network if there is no existing deployment

`--reset`

redeploys all contracts (not only the ones that changed)

`--force`

ignores validation errors and deploys contracts

`--deploy-proxy-admin`

eagerly deploys the project’s proxy admin (if not deployed yet on the provided network)

`--deploy-proxy-factory`

eagerly deploys the project’s proxy factory (if not deployed yet on the provided network)

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## remove

Usage: `remove [contract1 …​ contractN] [options]`

removes one or more contracts from your project. Provide a list of whitespace-separated contract names.

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## send-tx

Usage: `send-tx --to <to> --method <method> [options]`

send a transaction to the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the transaction

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`--value <value>`

optional value in wei to send with the transaction

`--gas <gas>`

gas limit of the transaction, will default to the limit specified in the configuration file, or use gas estimation if not set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## session

Usage: `session [options]`

by providing network options, commands like create, freeze, push, and update will use them unless overridden. Use --close to undo.

`--expires <expires>`

expiration of the session in seconds (defaults to 900, 15 minutes)

`--close`

closes the current session, removing all network options set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## set-admin

Usage: `set-admin [alias-or-address] [new-admin-address] --network <network> [options]`

change upgradeability admin of a contract instance, all instances or proxy admin. Provide the \[alias\] or \[package\]/\[alias\] of the contract to change the ownership of all its instances, or its \[address\] to change a single one, or none to change all contract instances to a new admin. Note that if you transfer to an incorrect address, you may irreversibly lose control over upgrading your contract.

`--force`

bypass a manual check

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## transfer

Usage: `transfer --network <network> [options]`

send funds to a given address

`--to <to>`

specify recipient address

`--value <value>`

the amount of ether units to be transferred

`--unit <unit>`

unit name. Wei, kwei, gwei, milli and ether are supported among others. If none is given, 'ether' will be used.

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## unlink

Usage: `unlink [dependencyName1…​ dependencyNameN]`

unlinks dependencies from the project. Provide a list of whitespace-separated dependency names

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--no-interactive`

force to run the command in non-interactive mode

## unpack

Usage: `unpack [kit]`

download and install an OpenZeppelin Starter Kit to the current directory

`--no-interactive`

force to run the command in non-interactive mode

## upgrade

Usage: `upgrade [alias-or-address] --network <network> [options]`

upgrade contract to a new logic. Provide the \[alias\] or \[package\]/\[alias\] you added your contract with, its \[address\], or use --all flag to upgrade all contracts in your project.

`--init [function]`

call function after upgrading contract. If no name is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--all`

upgrade all contracts in the application

`--force`

force creation even if contracts have local modifications

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each blockchain transaction (defaults to 600s)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## verify

Usage: `verify [options] [contract-alias]`

verify a contract with etherscan or etherchain. Provide a contract name.

`-n, --network [network]`

network where to verify the contract

`-o, --optimizer`

enables optimizer option

`--optimizer-runs [runs]`

specify number of runs if optimizer enabled.

`--remote <remote>`

specify remote endpoint to use for verification

`--api-key <key>`

specify etherscan API key. To get one, go to: [https://etherscan.io/myapikey](https://etherscan.io/myapikey)

`--no-interactive`

force to run the command in non-interactive mode

[← Frequently Asked Questions](https://docs.openzeppelin.com/cli/2.6/faq)

[Configuration Files →](https://docs.openzeppelin.com/cli/2.6/configuration)Counterfactual deployments - OpenZeppelin Docs

# Counterfactual deployments

A counterfactual contract is a contract we can interact with even before actually deploying it on-chain.
For example, we can send funds or assign privileges to a contract that doesn’t yet exist.
Why? Because deployments in Starknet are deterministic, allowing us to predict the address where our contract will be deployed.
We can leverage this property to make a contract pay for its own deployment by simply sending funds in advance. We call this a counterfactual deployment.

This process can be described with the following steps:

|     |     |
| --- | --- |
|  | For testing this flow you can check the [Starknet Foundry](https://foundry-rs.github.io/starknet-foundry/starknet/account.html) or the [Starkli](https://book.starkli.rs/accounts#account-deployment) guides for deploying accounts. |

1. Deterministically precompute the `contract_address` given a `class_hash`, `salt`, and constructor `calldata`.
Note that the `class_hash` must be previously declared for the deployment to succeed.

2. Send funds to the `contract_address`. Usually you will estimate the fee of the transaction first. Existing
tools usually do this for you.

3. Send a `DeployAccount` type transaction to the network.

4. The protocol will then validate the transaction with the `__validate_deploy__` entrypoint of the contract to be deployed.

5. If the validation succeeds, the protocol will charge the fee and then register the contract as deployed.


|     |     |
| --- | --- |
|  | Although this method is very popular to deploy accounts, this works for any kind of contract. |

## Deployment validation

To be counterfactually deployed, the deploying contract must implement the `__validate_deploy__` entrypoint,
called by the protocol when a `DeployAccount` transaction is sent to the network.

```cairo hljs
trait IDeployable {
    /// Must return 'VALID' when the validation is successful.
    fn __validate_deploy__(
        class_hash: felt252, contract_address_salt: felt252, public_key: felt252
    ) -> felt252;
}
```

[← Interfaces and Dispatchers](https://docs.openzeppelin.com/contracts-cairo/0.20.0/interfaces)

[SNIP12 and Typed Messages →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/snip12)Introspection - OpenZeppelin Docs

# Introspection

This crate handles [type introspection](https://en.wikipedia.org/wiki/Type_introspection) of contracts. In other words, it examines which functions can be called on a given contract. This is referred to as the contract’s interface.

## Core

### `ISRC5`

```cairo hljs
use openzeppelin_introspection::interface::ISRC5;
```

Interface of the SRC5 Introspection Standard as defined in [SNIP-5](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-5.md).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x3f918d17e5ee77373b56385708f855659a07f75997f365cf87748628532a055

Functions

- [`supports_interface(interface_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


#### Functions

#### `supports_interface(interface_id: felt252) → bool` external

Checks whether the contract implements the given interface.

|     |     |
| --- | --- |
|  | Check [Computing the Interface ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/introspection#computing_the_interface_id) for more information<br>on how to compute this ID. |

### `SRC5Component`

```cairo hljs
use openzeppelin_introspection::src5::SRC5Component;
```

SRC5 component extending [`ISRC5`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5).

Embeddable Implementations

SRC5Impl

- [`supports_interface(self, interface_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-supports_interface)


Internal Implementations

InternalImpl

- [`register_interface(self, interface_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-register_interface)

- [`deregister_interface(self, interface_id)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-deregister_interface)


#### Embeddable functions

#### `supports_interface(self: @ContractState, interface_id: felt252) → bool` external

See [`ISRC5::supports_interface`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface).

#### Internal functions

#### `register_interface(ref self: ComponentState, interface_id: felt252)` internal

Registers support for the given `interface_id`.

#### `deregister_interface(ref self: ComponentState, interface_id: felt252)` internal

Deregisters support for the given `interface_id`.

[← Migrating ERC165 to SRC5](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/src5-migration)

[Merkle Tree →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree)Using the OpenZeppelin CLI With Truffle - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Using the OpenZeppelin CLI With Truffle

Truffle is a framework for writing, compiling, deploying and testing smart contracts. You’ll notice we haven’t used it so far - this is because the OpenZeppelin tools are self-sufficient. It brings its own compiler along, its own habits and best practices, its own configuration files, and with some of the starter kits even its own UI elements and frameworks. But what if you’re used to Truffle and prefer it for the additional features it can offer? Do you need to pick between the OpenZeppelin CLI and Truffle now?

That’s a definitive _No_, captain. Let’s see how we can use them together.

This tutorial assumes you’ve gone through the [basic SDK guide](https://docs.openzeppelin.com/sdk/first) and have at least a passing familiarity with Truffle.

## Prerequisites

We’ll assume that you have:

- NodeJS and NPM installed, preferably via NVM

- Ganache installed and available on the command line via `ganache-cli`

- OpenZeppelin SDK installed and available on the command line, either globally or via NPX


All of these conditions should be met if you’ve gone through the [basic guide](https://docs.openzeppelin.com/sdk/first), so if you haven’t please do so now.

|     |     |
| --- | --- |
|  | If you have installed OpenZeppelin SDK globally, you will have to either install it again locally ( `npm install @openzeppelin/cli`) or link to it with `npm link @openzeppelin/cli` which creates a symlink from the globally installed module to your local folder (works on newer versions of Windows 10, too). This is because there’s no easier way to import globally installed Node modules into local scripts. |

## Configuration

When initializing a project with OpenZeppelin SDK, you’ll get a `network.js` file containing something like this:

```js hljs language-javascript
module.exports = {
  networks: {
    development: {
      protocol: 'http',
      host: 'localhost',
      port: 8545,
      gas: 5000000,
      gasPrice: 5e9,
      networkId: '*',
    },
  },
};
```

This configuration makes OpenZeppelin SDK default to a locally running instance of a blockchain, usually Ganache. With Truffle, the configuration is in `truffle-config.js` or `truffle.js`, so in most cases all you need to integrate the two is just make sure that file exists. If it does, OpenZeppelin SDK will default to reading that one for network settings and offer those network names to you when you invoke CLI commands. That said, let’s look at ways to integrate the two.

## Adding Truffle to an OpenZeppelin SDK project

In your example project (the one created by the [basic guide](https://docs.openzeppelin.com/sdk/first)), run `npm install truffle`. Alternatively, have Truffle installed globally so it’s accessible from everywhere ( `npm install -g truffle`) without having to run it with `npx`. We’ll use the `npx` approach in this guide - it makes it possible to use a specific Truffle version per project.

Once Truffle is installed, run `truffle init` in the project folder to initialize the project, or manually create the `truffle-config.js` file.

|     |     |
| --- | --- |
|  | if you say _yes_ when asked to overwrite an existing folder, e.g. if you already had a contracts folder, the contents of that folder will be deleted! The recommended approach is making a backup copy of the contracts folder, running `truffle init` with overwrites, and then merging the contents of the two folders later. |

If you used `init`, you should now have a very verbose `truffle-config.js` file in your project directory which, when the commented out examples are stripped out, comes down to this:

```js hljs language-javascript
module.exports = {
  networks: {
    development: {
     host: "127.0.0.1",
     port: 8545,
     network_id: "*",
    },
  },

  compilers: {
    solc: {
      version: "0.5.2",
      docker: false,
      settings: {
       optimizer: {
         enabled: true,
         runs: 200
       },
       evmVersion: "byzantium"
      }
    }
  }
}
```

If you created `truffle-config.js` from scratch, paste this in. If not, feel free to just uncomment the relevant lines or just paste this over everything. We can now delete OpenZeppelin’s `networks.js` file.

You should also have a file `contracts/Migrations.sol`. If you don’t, create it with the following content:

```sol hljs language-solidity
pragma solidity >=0.4.21 <0.6.0;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}
```

If you now run `openzeppelin create` or any other `openzeppelin` command that depends on compiling first, it will call `truffle compile` under the hood before proceeding with the other operations. The SDK will let you know about this:

```bash hljs
λ openzeppelin create
√ Compiling contracts with Truffle, using settings from truffle.js file
Truffle output:

Compiling your contracts...
===========================
> Compiling .\contracts\Counter.sol
> Artifacts written to ~\repos\openzeppelin-sdk-guide\build\contracts
> Compiled successfully using:
   - solc: 0.5.2+commit.1df8f40c.Emscripten.clang

? Pick a contract to instantiate ...
```

If you decide to instead recompile with OpenZeppelin, you can force this with `openzeppelin compile` which always compiles with OZ SDK.

Note that network settings are **always** read from Truffle’s configuration if present and will fall back to OpenZeppelin’s `network.js` if not.

## Adding OpenZeppelin SDK to a Truffle project

To add OZ SDK to a Truffle project, simply install OpenZeppelin locally or globally and `openzeppelin init` in the Truffle project’s folder. The `networks.js` file will not be created as OpenZeppelin will detect that it’s initializing in a Truffle folder. OpenZeppelin’s SDK is careful about overwriting essential files, so it won’t cause any conflicts like those that might occur when adding Truffle into an OZ project.

## Migrations

Now that the projects are merged, let’s see how we perform some Migrations - Truffle’s incremental, linked deployments to the blockchain. Migrations are useful when you want to bootstrap a project; like making sure that contracts link to each other properly, ensuring that values are initialized, and so on. By removing human errors and fat fingers from the process of a project’s launch, you make the whole thing much safer.

Our simple Counter contract gets deployed with a value of 0, so let’s write a migration which immediately sends a transaction increasing the value by 10.

OpenZeppelin’s SDK comes with a JavaScript interface which the CLI also uses to execute commands. We can invoke those if we import them in another project or script - like a Truffle migration.

Truffle comes with a default migration which makes subsequent migrations possible. Migrations are executed oredered by prefix - so if the name of a new migration file starts with 2, it will execute after `1_initial_migration.js`. Let’s create `2_deploy_counter.js` with the content:

```js hljs language-javascript
const { scripts, ConfigManager } = require('@openzeppelin/cli');
const { add, push, create } = scripts;

async function deploy(options) {
  add({ contractsData: [{ name: 'Counter', alias: 'Counter' }] });
  await push(options);
  await create(Object.assign({ contractAlias: 'Counter' }, options));
}

module.exports = function(deployer, networkName, accounts) {
  deployer.then(async () => {
    const { network, txParams } = await ConfigManager.initNetworkConfiguration({ network: networkName, from: accounts[0] })
    await deploy({ network, txParams })
  })
}
```

Let’s test it. Run:

```bash hljs
truffle migrate --network development
```

```bash hljs
λ npx truffle migrate --network development
Compiling .\contracts\Counter.sol...
Compiling .\contracts\Migrations.sol...
Writing artifacts to .\build\contracts
```

|     |     |
| --- | --- |
|  | If you’re using an HDWalletProvider, it must be Web3 1.0 enabled or your migration will hang. |

```
Starting migrations...
======================
> Network name:    'development'
> Network id:      1564927897006
> Block gas limit: 6721975

1_initial_migration.js
======================

   Deploying 'Migrations'
   ----------------------
   > transaction hash:    0x18fd35c7395f6dbc2ad39a6cef6bbb05af41f3c1b24a7abdef7066ff14e9d0b2
   > Blocks: 0            Seconds: 0
   > contract address:    0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab
   > account:             0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
   > balance:             99.99557658
   > gas used:            221171
   > gas price:           20 gwei
   > value sent:          0 ETH
   > total cost:          0.00442342 ETH

   > Saving artifacts
   -------------------------------------
   > Total cost:          0.00442342 ETH

2_deploy_counter.js
===================
0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B
   -------------------------------------
   > Total cost:                   0 ETH

Summary
=======
> Total deployments:   1
> Final cost:          0.00442342 ETH
```

It works! Let’s make sure and re-run migrations, it should tell us that we’re up to date.

```bash hljs
λ npx truffle migrate

Compiling your contracts...
===========================
> Everything is up to date, there is nothing to compile.

Network up to date.
```

Our counter is deployed but to make sure let’s check if we can interact with it. We’ll use OZ SDK.

```bash hljs
λ openzeppelin call
? Pick a network development
? Pick an instance Counter at 0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B
? Select which function value()
√ Method 'value()' returned: 0
0
```

Perfect. Now let’s make the second migration which increases the counter value by 10. Create `migrations/3_increment.js`.

```js hljs language-javascript
const Counter = artifacts.require("Counter");

module.exports = async function(deployer) {
    const counter = await Counter.deployed();
    await counter.increase(10);
};
```

You’ll notice we used Truffle’s default migration process instead of `sendTx` or `call`, like we would when interacting with OpenZeppelin’s SDK on the command line. This is because the JavaScript API does not have those helper functions exported for the moment (a pending change), so we have to interact with contracts _the old way_.

## Caveats

Once you start using Truffle in an OpenZeppelin SDK project, it’s recommended you keep using it and don’t mix and match other than in the context of migration scripts where you can use the OpenZeppelin SDK API as much as you wish. The reason is that OpenZeppelin will not respect the migrations deployed by Truffle as it is not aware of them, and will instead deploy its own copy of the contracts you’re creating, possibly causing conflicts.

* * *

Now that you know the fusion of Truffle and OpenZeppelin SDK is a possibility, go forth, #buidl and [let us know](https://twitter.com/openzeppelin) what you created!

[← Deploying With `CREATE2`](https://docs.openzeppelin.com/cli/2.7/deploying-with-create2)

[Frequently Asked Questions →](https://docs.openzeppelin.com/cli/2.7/faq)Tokens - OpenZeppelin Docs

# Tokens

|     |     |
| --- | --- |
|  | This document is better viewed at [https://docs.openzeppelin.com/community-contracts/token](https://docs.openzeppelin.com/community-contracts/token) |

Set of extensions and utilities for tokens (e.g ERC-20, ERC-721, ERC-1155) and derivated ERCs (e.g. ERC-4626, ERC-1363).

- [`OnTokenTransferAdapter`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#OnTokenTransferAdapter): Adapter of the ERC-1363 receiver interface to comply with Chainlink’s 667 interface.

- [`ERC20Allowlist`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Allowlist): Extension of ERC20 with transfers and approvals that require users to be registered into an allowlist.

- [`ERC20Blocklist`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Blocklist): Extension of ERC20 with transfers and approvals that can be disabled by adding users into a blocklist.

- [`ERC20Collateral`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Collateral): Oracle-agnostic extension of ERC20 that limits the total supply based on a collateral amount.

- [`ERC20Custodian`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Custodian): Extension of ERC20 that implements an access-control agnostic approach to define a custodian that can freeze user’s transfers and approvals.

- [`ERC4626Fees`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC4626Fees): ERC4626 vault with fees on entry (deposit/mint) or exit (withdraw/redeem).


## General

### `OnTokenTransferAdapter`

```solidity hljs
import "@openzeppelin/community-contracts/token/OnTokenTransferAdapter.sol";
```

This contract exposes the 667 `onTokenTransfer` hook on top of {IERC1363Receiver-onTransferReceived}.

Inheriting from this adapter makes your `ERC1363Receiver` contract automatically compatible with tokens, such as
Chainlink’s Link, that implement the 667 interface for transferAndCall.

Functions

- `onTokenTransfer(from, amount, data)`


IERC1363Receiver

- `onTransferReceived(operator, from, value, data)`


#### `onTokenTransfer(address from, uint256 amount, bytes data) → bool` public

## ERC20

### `ERC20Allowlist`

```solidity hljs
import "@openzeppelin/community-contracts/token/ERC20/extensions/ERC20Allowlist.sol";
```

Extension of {ERC20} that allows to implement an allowlist
mechanism that can be managed by an authorized account with the
[`_disallowUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Allowlist-_disallowUser-address-) and [`_allowUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Allowlist-_allowUser-address-) functions.

The allowlist provides the guarantee to the contract owner
(e.g. a DAO or a well-configured multisig) that any account won’t be
able to execute transfers or approvals to other entities to operate
on its behalf if [`_allowUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Allowlist-_allowUser-address-) was not called with such account as an
argument. Similarly, the account will be disallowed again if
[`_disallowUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Allowlist-_disallowUser-address-) is called.

Functions

- `allowed(account)`

- `_allowUser(user)`

- `_disallowUser(user)`

- `_update(from, to, value)`

- `_approve(owner, spender, value, emitEvent)`


ERC20

- `name()`

- `symbol()`

- `decimals()`

- `totalSupply()`

- `balanceOf(account)`

- `transfer(to, value)`

- `allowance(owner, spender)`

- `approve(spender, value)`

- `transferFrom(from, to, value)`

- `_transfer(from, to, value)`

- `_mint(account, value)`

- `_burn(account, value)`

- `_approve(owner, spender, value)`

- `_spendAllowance(owner, spender, value)`


Events

- `UserAllowed(user)`

- `UserDisallowed(user)`


IERC20

- `Transfer(from, to, value)`

- `Approval(owner, spender, value)`


Errors

- `ERC20Disallowed(user)`


IERC20Errors

- `ERC20InsufficientBalance(sender, balance, needed)`

- `ERC20InvalidSender(sender)`

- `ERC20InvalidReceiver(receiver)`

- `ERC20InsufficientAllowance(spender, allowance, needed)`

- `ERC20InvalidApprover(approver)`

- `ERC20InvalidSpender(spender)`


#### `allowed(address account) → bool` public

Returns the allowed status of an account.

#### `_allowUser(address user) → bool` internal

Allows a user to receive and transfer tokens, including minting and burning.

#### `_disallowUser(address user) → bool` internal

Disallows a user from receiving and transferring tokens, including minting and burning.

#### `_update(address from, address to, uint256 value)` internal

See {ERC20-\_update}.

#### `_approve(address owner, address spender, uint256 value, bool emitEvent)` internal

See {ERC20-\_approve}.

#### `UserAllowed(address indexed user)` event

Emitted when a `user` is allowed to transfer and approve.

#### `UserDisallowed(address indexed user)` event

Emitted when a user is disallowed.

#### `ERC20Disallowed(address user)` error

The operation failed because the user is not allowed.

### `ERC20Blocklist`

```solidity hljs
import "@openzeppelin/community-contracts/token/ERC20/extensions/ERC20Blocklist.sol";
```

Extension of {ERC20} that allows to implement a blocklist
mechanism that can be managed by an authorized account with the
[`_blockUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Blocklist-_blockUser-address-) and [`_unblockUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Blocklist-_unblockUser-address-) functions.

The blocklist provides the guarantee to the contract owner
(e.g. a DAO or a well-configured multisig) that any account won’t be
able to execute transfers or approvals to other entities to operate
on its behalf if [`_blockUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Blocklist-_blockUser-address-) was not called with such account as an
argument. Similarly, the account will be unblocked again if
[`_unblockUser`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Blocklist-_unblockUser-address-) is called.

Functions

- `blocked(account)`

- `_blockUser(user)`

- `_unblockUser(user)`

- `_update(from, to, value)`

- `_approve(owner, spender, value, emitEvent)`


ERC20

- `name()`

- `symbol()`

- `decimals()`

- `totalSupply()`

- `balanceOf(account)`

- `transfer(to, value)`

- `allowance(owner, spender)`

- `approve(spender, value)`

- `transferFrom(from, to, value)`

- `_transfer(from, to, value)`

- `_mint(account, value)`

- `_burn(account, value)`

- `_approve(owner, spender, value)`

- `_spendAllowance(owner, spender, value)`


Events

- `UserBlocked(user)`

- `UserUnblocked(user)`


IERC20

- `Transfer(from, to, value)`

- `Approval(owner, spender, value)`


Errors

- `ERC20Blocked(user)`


IERC20Errors

- `ERC20InsufficientBalance(sender, balance, needed)`

- `ERC20InvalidSender(sender)`

- `ERC20InvalidReceiver(receiver)`

- `ERC20InsufficientAllowance(spender, allowance, needed)`

- `ERC20InvalidApprover(approver)`

- `ERC20InvalidSpender(spender)`


#### `blocked(address account) → bool` public

Returns the blocked status of an account.

#### `_blockUser(address user) → bool` internal

Blocks a user from receiving and transferring tokens, including minting and burning.

#### `_unblockUser(address user) → bool` internal

Unblocks a user from receiving and transferring tokens, including minting and burning.

#### `_update(address from, address to, uint256 value)` internal

See {ERC20-\_update}.

#### `_approve(address owner, address spender, uint256 value, bool emitEvent)` internal

See {ERC20-\_approve}.

#### `UserBlocked(address indexed user)` event

Emitted when a user is blocked.

#### `UserUnblocked(address indexed user)` event

Emitted when a user is unblocked.

#### `ERC20Blocked(address user)` error

The operation failed because the user is blocked.

### `ERC20Collateral`

```solidity hljs
import "@openzeppelin/community-contracts/token/ERC20/extensions/ERC20Collateral.sol";
```

Extension of {ERC20} that limits the supply of tokens based
on a collateral amount and time-based expiration.

The [`collateral`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Collateral-collateral--) function must be implemented to return the collateral
data. This function can call external oracles or use any local storage.

Functions

- `constructor(liveness_)`

- `liveness()`

- `clock()`

- `CLOCK_MODE()`

- `collateral()`

- `_update(from, to, value)`


ERC20

- `name()`

- `symbol()`

- `decimals()`

- `totalSupply()`

- `balanceOf(account)`

- `transfer(to, value)`

- `allowance(owner, spender)`

- `approve(spender, value)`

- `transferFrom(from, to, value)`

- `_transfer(from, to, value)`

- `_mint(account, value)`

- `_burn(account, value)`

- `_approve(owner, spender, value)`

- `_approve(owner, spender, value, emitEvent)`

- `_spendAllowance(owner, spender, value)`


Events

IERC20

- `Transfer(from, to, value)`

- `Approval(owner, spender, value)`


Errors

- `ERC20ExceededSupply(increasedSupply, cap)`

- `ERC20ExpiredCollateral(timestamp, expiration)`


IERC20Errors

- `ERC20InsufficientBalance(sender, balance, needed)`

- `ERC20InvalidSender(sender)`

- `ERC20InvalidReceiver(receiver)`

- `ERC20InsufficientAllowance(spender, allowance, needed)`

- `ERC20InvalidApprover(approver)`

- `ERC20InvalidSpender(spender)`


#### `constructor(uint48 liveness_)` internal

Sets the value of the `_liveness`. This value is immutable, it can only be
set once during construction.

#### `liveness() → uint48` public

Returns the minimum liveness duration of collateral.

#### `clock() → uint48` public

Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).

#### `CLOCK_MODE() → string` public

Description of the clock

#### `collateral() → uint256 amount, uint48 timestamp` public

Returns the collateral data of the token.

#### `_update(address from, address to, uint256 value)` internal

See {ERC20-\_update}.

#### `ERC20ExceededSupply(uint256 increasedSupply, uint256 cap)` error

Total supply cap has been exceeded.

#### `ERC20ExpiredCollateral(uint48 timestamp, uint48 expiration)` error

Collateral amount has expired.

### `ERC20Custodian`

```solidity hljs
import "@openzeppelin/community-contracts/token/ERC20/extensions/ERC20Custodian.sol";
```

Extension of {ERC20} that allows to implement a custodian
mechanism that can be managed by an authorized account with the
[`freeze`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Custodian-freeze-address-uint256-) function.

This mechanism allows a custodian (e.g. a DAO or a
well-configured multisig) to freeze and unfreeze the balance
of a user.

The frozen balance is not available for transfers or approvals
to other entities to operate on its behalf if. The frozen balance
can be reduced by calling [`freeze`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Custodian-freeze-address-uint256-) again with a lower amount.

Modifiers

- `onlyCustodian()`


Functions

- `frozen(user)`

- `freeze(user, amount)`

- `availableBalance(account)`

- `_isCustodian(user)`

- `_update(from, to, value)`


ERC20

- `name()`

- `symbol()`

- `decimals()`

- `totalSupply()`

- `balanceOf(account)`

- `transfer(to, value)`

- `allowance(owner, spender)`

- `approve(spender, value)`

- `transferFrom(from, to, value)`

- `_transfer(from, to, value)`

- `_mint(account, value)`

- `_burn(account, value)`

- `_approve(owner, spender, value)`

- `_approve(owner, spender, value, emitEvent)`

- `_spendAllowance(owner, spender, value)`


Events

- `TokensFrozen(user, amount)`

- `TokensUnfrozen(user, amount)`


IERC20

- `Transfer(from, to, value)`

- `Approval(owner, spender, value)`


Errors

- `ERC20InsufficientUnfrozenBalance(user)`

- `ERC20InsufficientFrozenBalance(user)`

- `ERC20NotCustodian()`


IERC20Errors

- `ERC20InsufficientBalance(sender, balance, needed)`

- `ERC20InvalidSender(sender)`

- `ERC20InvalidReceiver(receiver)`

- `ERC20InsufficientAllowance(spender, allowance, needed)`

- `ERC20InvalidApprover(approver)`

- `ERC20InvalidSpender(spender)`


#### `onlyCustodian()` modifier

Modifier to restrict access to custodian accounts only.

#### `frozen(address user) → uint256` public

Returns the amount of tokens frozen for a user.

#### `freeze(address user, uint256 amount)` external

Adjusts the amount of tokens frozen for a user.

#### `availableBalance(address account) → uint256 available` public

Returns the available (unfrozen) balance of an account.

#### `_isCustodian(address user) → bool` internal

Checks if the user is a custodian.

#### `_update(address from, address to, uint256 value)` internal

Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
(or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
this function.

Emits a {Transfer} event.

#### `TokensFrozen(address indexed user, uint256 amount)` event

Emitted when tokens are frozen for a user.

#### `TokensUnfrozen(address indexed user, uint256 amount)` event

Emitted when tokens are unfrozen for a user.

#### `ERC20InsufficientUnfrozenBalance(address user)` error

The operation failed because the user has insufficient unfrozen balance.

#### `ERC20InsufficientFrozenBalance(address user)` error

The operation failed because the user has insufficient frozen balance.

#### `ERC20NotCustodian()` error

Error thrown when a non-custodian account attempts to perform a custodian-only operation.

### `ERC20Bridgeable`

```solidity hljs
import "@openzeppelin/community-contracts/token/ERC20/extensions/ERC20Bridgeable.sol";
```

ERC20 extension that implements the standard token interface according to
[ERC-7802](https://github.com/ethereum/ERCs/blob/bcea9feb6c3f3ded391e33690056635d722b101e/ERCS/erc-7802.md).

|     |     |
| --- | --- |
|  | To implement a crosschain gateway for a chain, consider using an implementation if {IERC7786} token<br>bridge (e.g. {AxelarGatewaySource}, {AxelarGatewayDestination}). |

Modifiers

- `onlyTokenBridge()`


Functions

- `supportsInterface(interfaceId)`

- `crosschainMint(to, value)`

- `crosschainBurn(from, value)`

- `_checkTokenBridge(caller)`


ERC20

- `name()`

- `symbol()`

- `decimals()`

- `totalSupply()`

- `balanceOf(account)`

- `transfer(to, value)`

- `allowance(owner, spender)`

- `approve(spender, value)`

- `transferFrom(from, to, value)`

- `_transfer(from, to, value)`

- `_update(from, to, value)`

- `_mint(account, value)`

- `_burn(account, value)`

- `_approve(owner, spender, value)`

- `_approve(owner, spender, value, emitEvent)`

- `_spendAllowance(owner, spender, value)`


Events

IERC7802

- `CrosschainMint(to, amount, sender)`

- `CrosschainBurn(from, amount, sender)`


IERC20

- `Transfer(from, to, value)`

- `Approval(owner, spender, value)`


Errors

IERC20Errors

- `ERC20InsufficientBalance(sender, balance, needed)`

- `ERC20InvalidSender(sender)`

- `ERC20InvalidReceiver(receiver)`

- `ERC20InsufficientAllowance(spender, allowance, needed)`

- `ERC20InvalidApprover(approver)`

- `ERC20InvalidSpender(spender)`


#### `onlyTokenBridge()` modifier

Modifier to restrict access to the token bridge.

#### `supportsInterface(bytes4 interfaceId) → bool` public

See {IERC165-supportsInterface}.

#### `crosschainMint(address to, uint256 value)` public

See {IERC7802-crosschainMint}. Emits a [`crosschainMint`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Bridgeable-crosschainMint-address-uint256-) event.

#### `crosschainBurn(address from, uint256 value)` public

See {IERC7802-crosschainBurn}. Emits a [`crosschainBurn`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC20Bridgeable-crosschainBurn-address-uint256-) event.

#### `_checkTokenBridge(address caller)` internal

Checks if the caller is a trusted token bridge. MUST revert otherwise.

Developers should implement this function using an access control mechanism that allows
customizing the list of allowed senders. Consider using {AccessControl} or {AccessManaged}.

### `ERC4626Fees`

```solidity hljs
import "@openzeppelin/community-contracts/token/ERC20/extensions/ERC4626Fees.sol";
```

ERC-4626 vault with entry/exit fees expressed in [basis point (bp)](https://en.wikipedia.org/wiki/Basis_point).

Functions

- `previewDeposit(assets)`

- `previewMint(shares)`

- `previewWithdraw(assets)`

- `previewRedeem(shares)`

- `_deposit(caller, receiver, assets, shares)`

- `_withdraw(caller, receiver, owner, assets, shares)`

- `_entryFeeBasisPoints()`

- `_exitFeeBasisPoints()`

- `_entryFeeRecipient()`

- `_exitFeeRecipient()`


ERC4626

- `decimals()`

- `asset()`

- `totalAssets()`

- `convertToShares(assets)`

- `convertToAssets(shares)`

- `maxDeposit()`

- `maxMint()`

- `maxWithdraw(owner)`

- `maxRedeem(owner)`

- `deposit(assets, receiver)`

- `mint(shares, receiver)`

- `withdraw(assets, receiver, owner)`

- `redeem(shares, receiver, owner)`

- `_convertToShares(assets, rounding)`

- `_convertToAssets(shares, rounding)`

- `_decimalsOffset()`


ERC20

- `name()`

- `symbol()`

- `totalSupply()`

- `balanceOf(account)`

- `transfer(to, value)`

- `allowance(owner, spender)`

- `approve(spender, value)`

- `transferFrom(from, to, value)`

- `_transfer(from, to, value)`

- `_update(from, to, value)`

- `_mint(account, value)`

- `_burn(account, value)`

- `_approve(owner, spender, value)`

- `_approve(owner, spender, value, emitEvent)`

- `_spendAllowance(owner, spender, value)`


Events

IERC4626

- `Deposit(sender, owner, assets, shares)`

- `Withdraw(sender, receiver, owner, assets, shares)`


IERC20

- `Transfer(from, to, value)`

- `Approval(owner, spender, value)`


Errors

ERC4626

- `ERC4626ExceededMaxDeposit(receiver, assets, max)`

- `ERC4626ExceededMaxMint(receiver, shares, max)`

- `ERC4626ExceededMaxWithdraw(owner, assets, max)`

- `ERC4626ExceededMaxRedeem(owner, shares, max)`


IERC20Errors

- `ERC20InsufficientBalance(sender, balance, needed)`

- `ERC20InvalidSender(sender)`

- `ERC20InvalidReceiver(receiver)`

- `ERC20InsufficientAllowance(spender, allowance, needed)`

- `ERC20InvalidApprover(approver)`

- `ERC20InvalidSpender(spender)`


#### `previewDeposit(uint256 assets) → uint256` public

Preview taking an entry fee on deposit. See {IERC4626-previewDeposit}.

#### `previewMint(uint256 shares) → uint256` public

Preview adding an entry fee on mint. See {IERC4626-previewMint}.

#### `previewWithdraw(uint256 assets) → uint256` public

Preview adding an exit fee on withdraw. See {IERC4626-previewWithdraw}.

#### `previewRedeem(uint256 shares) → uint256` public

Preview taking an exit fee on redeem. See {IERC4626-previewRedeem}.

#### `_deposit(address caller, address receiver, uint256 assets, uint256 shares)` internal

Send entry fee to [`_entryFeeRecipient`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC4626Fees-_entryFeeRecipient--). See {IERC4626-\_deposit}.

#### `_withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares)` internal

Send exit fee to [`_exitFeeRecipient`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token#ERC4626Fees-_exitFeeRecipient--). See {IERC4626-\_deposit}.

#### `_entryFeeBasisPoints() → uint256` internal

#### `_exitFeeBasisPoints() → uint256` internal

#### `_entryFeeRecipient() → address` internal

#### `_exitFeeRecipient() → address` internal

[← Proxy](https://docs.openzeppelin.com/community-contracts/0.0.1/api/proxy)

[Utils →](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils)ERC-721 Metadata - OpenZeppelin Docs

# ERC-721 Metadata

Extension of [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) that adds the optional metadata functions from the ERC721 standard.

## Usage

In order to make [`ERC-721 Metadata`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/metadata/index.html) methods “external” so that other contracts can call them, you need to add the following code to your contract:

```rust hljs
use openzeppelin_stylus::{
    token::erc721::{
        extensions::Erc721Metadata,
        Erc721,
    },
};

sol_storage! {
    #[entrypoint]
    struct Erc721Example {
        #[borrow]
        Erc721 erc721;
        #[borrow]
        Erc721Metadata metadata;
    }
}

#[public]
#[inherit(Erc721, Erc721Metadata)]
impl Erc721Example {
    // ...

    #[selector(name = "tokenURI")]
    pub fn token_uri(&self, token_id: U256) -> Result<String, Vec<u8>> {
        Ok(self.metadata.token_uri(token_id, &self.erc721)?)
    }
}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy).
Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc721Example {
    // ...

    string private _name;
    string private _symbol;
    string private _baseUri;

    constructor(string memory name_, string memory symbol_, string memory baseUri_) {
        // ...
        _name = name_;
        _symbol = symbol_;
        _baseUri = baseUri_;
        // ...
    }
}
```Using Dependencies - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Using Dependencies

In [Getting Started](https://docs.openzeppelin.com/cli/2.7/getting-started), we learned how to set up a new OpenZeppelin project, deploy a simple contract, and upgrade it. Now, we will build a more interesting project with multiple contracts, leveraging the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package). We will learn about **linking Ethereum Packages**, and **writing upgradeable contracts**.

## What We Will Build

We will write a `TokenExchange` contract, that will allow any user to purchase an ERC20 token in exchange for ETH, at a fixed exchange rate. We will write `TokenExchange` ourselves, but leverage the [ERC20 implementation](https://docs.openzeppelin.com/contracts/5.x/erc20) from [**OpenZeppelin Contracts**](https://docs.openzeppelin.com/contracts/5.x/)

Before we get started, make sure to [initialize a new project](https://docs.openzeppelin.com/cli/2.7/getting-started#setting-up-your-project):

```console hljs language-shell
$ mkdir token-exchange && cd token-exchange
$ npm init -y
$ npm install @openzeppelin/cli
$ npx openzeppelin init
```

|     |     |
| --- | --- |
|  | The full code for this project is available in our [Github repo](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.4.0/examples/linking-contracts). |

## Linking the Contracts Ethereum Package

We will first get ourselves an ERC20 token. Instead of coding one from scratch, we will use the one provided by the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package). An Ethereum Package is a set of contracts set up to be easily included in an OpenZeppelin project, with the added bonus that the contracts' code _is already deployed in the Ethereum network_. This is a more secure code distribution mechanism, and also helps you save gas upon deployment.

|     |     |
| --- | --- |
|  | Check out [this article](https://blog.openzeppelin.com/open-source-collaboration-in-the-blockchain-era-evm-packages/) to learn more about Ethereum Packages. |

To link the OpenZeppelin Contracts Ethereum Package into your project, simply run the following:

```console hljs language-shell
$ npx oz link @openzeppelin/contracts-ethereum-package
```

This command will download the Ethereum Package (bundled as a regular npm package), and connect it to your OpenZeppelin project. We now have all of OpenZeppelin contracts at our disposal, so let’s create an ERC20 token!

|     |     |
| --- | --- |
|  | Make sure you install `@openzeppelin/contracts-ethereum-package` and not the vanilla `@openzeppelin/contracts`. The latter is set up for general usage, while `@openzeppelin/contracts-ethereum-package` is tailored for being used with [OpenZeppelin Upgrades](https://docs.openzeppelin.com/upgrades/2.8/). This means that its contracts are [already set up to be upgradeable](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#use-upgradeable-packages). |

## Creating an ERC20 Token

Let’s deploy an ERC20 token contract to our development network. Make sure to [have a Ganache instance running](https://docs.openzeppelin.com/learn/deploying-and-interacting#local-blockchain), or start one by running:

```console hljs language-shell
$ npx ganache-cli --deterministic
```

For setting up the token, we will be using the [StandaloneERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/token/ERC20/StandaloneERC20.sol) provided by the OpenZeppelin package. We will _initialize_ the instance with the token metadata (name, symbol, and decimals), and mint a large initial supply for one of our accounts.

|     |     |
| --- | --- |
|  | The unlocked accounts and transaction hashes may differ from the ones shown here. Run a brand-new Ganache in `--deterministic` mode to get the same ones. |

```console hljs language-shell
$ npx oz create
? Pick a contract to instantiate: @openzeppelin/contracts-ethereum-package/StandaloneERC20
? Pick a network: development
✓ Deploying @openzeppelin/contracts-ethereum-package dependency to network
? Call a function to initialize the instance after creating it?: Yes
? Select which function: * initialize(name: string, symbol: string, decimals: uint8, initialSupply: uint256, initialHolder: address, minters: address[], pausers: address[])
? name (string): MyToken
? symbol (string): MYT
? decimals (uint8): 18
? initialSupply (uint256): 100e18
? initialHolder (address): 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
? minters (address[]):
? pausers (address[]):
✓ Setting everything up to create contract instances
✓ Instance created at 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
```

Let’s break down what we did in the command above. We first chose to create an instance of the `StandaloneERC20` contract from the `@openzeppelin/contracts-ethereum-package` package we had linked before, and to create it in the local `development` network. We are then instructing the CLI to _initialize_ it with the initial values needed to set up our token. This requires us to choose the appropriate `initialize` function, and input all the required arguments. The OpenZeppelin CLI will then atomically create and initialize the new instance in a single transaction.

We now have a working ERC20 token contract in our development network. We can check that the initial supply was properly allocated by using the `balance` command. Make sure to use the address where your ERC20 token instance was created.

```console hljs language-shell
$ npx oz balance --erc20 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
? Enter an address to query its balance: 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
? Pick a network: development
Balance: 100 MYT
```

Great! We can now write an exchange contract and connect it to this token when we deploy it.

## Writing the Exchange Contract

In order to transfer an amount of tokens every time it receives ETH, our exchange contract will need to store the token contract address and the exchange rate in its state. We will set these two values during initialization, when we create the instance with `oz create`.

Because we’re writing upgradeable contracts [we cannot use Solidity `constructor` s](https://docs.openzeppelin.com/upgrades/2.8/proxies#the-constructor-caveat). Instead, we need to use _initializers_. An initializer is just a regular Solidity function, with an additional check to ensure that it can be called only once.

To make coding initializers easy, [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/) provides a base `Initializable` contract, that includes an `initializer` modifier that takes care of this. You will first need to install it:

```console hljs language-shell
$ npm install @openzeppelin/upgrades
```

Now, let’s write our exchange contract in `contracts/TokenExchange.sol`, using an _initializer_ to set its initial state:

```solidity hljs
// contracts/TokenExchange.sol
pragma solidity ^0.5.0;

// Import base Initializable contract
import "@openzeppelin/upgrades/contracts/Initializable.sol";

// Import the IERC20 interface and and SafeMath library
import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";

contract TokenExchange is Initializable {
    using SafeMath for uint256;

    // Contract state: exchange rate and token
    uint256 public rate;
    IERC20 public token;

    // Initializer function (replaces constructor)
    function initialize(uint256 _rate, IERC20 _token) public initializer {
        rate = _rate;
        token = _token;
    }

    // Send tokens back to the sender using predefined exchange rate
    function() external payable {
        uint256 tokens = msg.value.mul(rate);
        token.transfer(msg.sender, tokens);
    }
}
```

Note the usage of the `initializer` modifier in the `initialize` method. This guarantees that once we have deployed our contract, no one can call into that function again to alter the token or the rate.

Let’s now create and initialize our new `TokenExchange` contract:

```console hljs language-shell
$ npx oz create
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
? Pick a contract to instantiate: TokenExchange
? Pick a network: development
✓ Contract TokenExchange deployed
? Call a function to initialize the instance after creating it?: Yes
? Select which function: initialize(_rate: uint256, _token: address)
? _rate (uint256): 10
? _token (address): 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
Instance created at 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec
```

Our exchange is almost ready! We only need to fund it, so it can send tokens to purchasers. Let’s do that using the `oz send-tx` command, to transfer the full token balance from our own account to the exchange contract. Make sure to replace the recipient of the transfer with the `TokenExchange` address you got from the previous command.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Choose an instance: StandaloneERC20 at 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
? Select which function: transfer(to: address, value: uint256)
? to (address): 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec
? value (uint256): 10e18
Transaction successful: 0x5863c8a8e122fcda7c6234abc6e60fad3f5a8108a3f88e2d8a956b63dbc222c2
Events emitted:
 - Transfer
    from: 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1,
    to: 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec,
    value: 10000000000000000000
```

All set! We can start playing with our brand new token exchange.

## Using Our Exchange

Now that we have initialized our exchange contract and seeded it with funds, we can test it out by purchasing tokens. Our exchange contract will send tokens back automatically when we send ETH to it, so let’s test it by using the `oz transfer` command. This command allows us to send funds to any address; in this case, we will use it to send ETH to our `TokenExchange` instance:

```console hljs language-shell
$ npx oz transfer
? Pick a network: development
? Choose the account to send transactions from: (1) 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
? Enter the receiver account: 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec
? Enter an amount to transfer 0.1 ether
✓ Funds sent. Transaction hash: 0xc85a8caa161110ba7f08134f4496a995968a5aff7ae60ad9b6ce1c824e13cacb
```

|     |     |
| --- | --- |
|  | Make sure you replace the receiver account with the corresponding address where your `TokenExchange` was created. |

We can now use `oz balance` again, to check the token balance of the address that made the purchase. Since we sent 0.1 ETH, and we used a 1:10 exchange rate, we should see a balance of 1 MYT (MyToken).

```console hljs language-shell
$ npx oz balance --erc20 0x5f8e26fAcC23FA4cbd87b8d9Dbbd33D5047abDE1
? Enter an address to query its balance: 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
? Pick a network: development
Balance: 1 MYT
```

Success! We have our exchange up and running, gathering ETH in exchange for our tokens. But how can we collect the funds we earned…​?

## Upgrading the Exchange

We forgot to add a method to withdraw the funds from the token exchange contract! While this would typically mean that the funds are locked in there forever, we can upgrade the contract with the OpenZeppelin CLI to add a way to collect those funds.

|     |     |
| --- | --- |
|  | While upgrading a contract is certainly useful in situations like this, where you need to fix a bug or add a missing feature, it could still be used to change the rules of the game. For instance, you could upgrade the token exchange contract to alter the rate at any time. Because of this, it is important to have a proper [Project Governance](https://docs.openzeppelin.com/learn/preparing-for-mainnet#project-governance) in place. |

Let’s modify the `TokenExchange` contract to add a `withdraw` method, only callable by an `owner`.

```solidity hljs
// contracts/TokenExchange.sol
contract TokenExchange is Initializable {
    uint256 public rate;
    IERC20 public token;
    address public owner;

    function withdraw() public {
        require(msg.sender == owner, "Address not allowed to call this function");
        msg.sender.transfer(address(this).balance);
    }

    // (existing functions not shown here for brevity)
}
```

When modifying your contract, you will have to place the `owner` variable **after** the other variables ( [learn more](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) about this restriction). Don’t worry if you forget about it, the CLI will check this for you when you try to upgrade.

|     |     |
| --- | --- |
|  | If you are familiar with [**OpenZeppelin Contracts**](https://docs.openzeppelin.com/contracts/5.x/), you may be wondering why we didn’t simply extend from `Ownable` and used the `onlyOwner` modifier. The issue is OpenZeppelin Upgrades does not support extending from now contracts in an upgrade (if they declare their own state variables). Again, the CLI will alert you if you attempt to do this. Refer to the [Upgrades documentation](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) for more info. |

The only thing missing is actually _setting_ the `owner` of the contract. To do this, we can add another function that we will call when upgrading, making sure it can only be called once:

```solidity hljs
// contracts/TokenExchange.sol
contract TokenExchange is Initializable {
  uint256 public rate;
  IERC20 public token;
  address public owner;

  function withdraw() public {
    require(msg.sender == owner, "Address not allowed to call this function");
    msg.sender.transfer(address(this).balance);
  }

  // To be run during upgrade, ensuring it can never be called again
  function setOwner(address _owner) public {
    require(owner == address(0), "Owner already set, cannot modify!");
    owner = _owner;
  }

  // (existing functions not shown here for brevity)
}
```

We can now upgrade our token exchange contract to this new version, and call `setOwner` during the upgrade process. The OpenZeppelin CLI will take care of making the upgrade and the call atomically in a single transaction.

```console hljs language-shell
$ npx oz upgrade
? Pick a network: development
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
- New variable 'address owner' was added in contract TokenExchange in contracts/TokenExchange.sol:1 at the end of the contract.
✓ Contract TokenExchange deployed
? Which proxies would you like to upgrade?: Choose by name
? Pick a contract to upgrade: TokenExchange
? Call a function on the instance after upgrading it?: Yes
? Select which function: setOwner(_owner: address)
? _owner (address): 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
✓ Instance upgraded at 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec.
```

There! We can now call `withdraw` from our default address to extract all ETH sent to the exchange.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: TokenExchange at 0xD86C8F0327494034F60e25074420BcCF560D5610
? Select which function: withdraw()
✓ Transaction successful. Transaction hash: 0xc9fb0d3ada96ec4c67c1c8f1569f9cfaf0ff0f7b241e172b32a023b1763ab7ab
```

|     |     |
| --- | --- |
|  | You can also upgrade dependencies from an Ethereum Package. Upon a new release of `@openzeppelin/contracts-ethereum-package`, if you want to update your ERC20 to include the latest fixes, you can just `oz link` the new version and use `oz upgrade` to get your instance to the newest code. |

## Wrapping Up

We have built a more complex setup in this tutorial, and learned several concepts along the way. We introduced [Ethereum Packages](https://blog.openzeppelin.com/open-source-collaboration-in-the-blockchain-era-evm-packages/) as dependencies for our projects, allowing us to spin up a new token with little effort.

We also presented some [limitations](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable) of [how Upgrades works](https://docs.openzeppelin.com/upgrades/2.8/proxies), such as [initializer methods](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#initializers) as a replacement for constructors, and [preserving the storage layout](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) when modifying our source code. We also learned how to run a function as a migration when upgrading a contract.

[← Getting Started](https://docs.openzeppelin.com/cli/2.7/getting-started)

[Compiling →](https://docs.openzeppelin.com/cli/2.7/compiling)Command Line Interface (CLI) - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Command Line Interface (CLI)

**Develop, deploy and operate upgradeable smart contract projects**. Support for Ethereum and every other EVM-powered blockchain.

- **Interactive commands**: Send transactions, query balances, and interact with your contracts directly from the command line, using commands like `oz send-tx`, `oz call`, `oz balance`, and `oz transfer`.

- **Deploy & upgrade your contracts**: You can develop your smart contracts iteratively, speeding up development locally, or squashing bugs in production. Run `oz create` to deploy your contracts, followed by `oz upgrade` any time you want to change their code.

- **Link Ethereum Packages**: Use code from contracts already deployed to the blockchain directly on your project, saving gas on deployments and managing your dependencies securely, just with an `oz link` command.

- **Bootstrap your dapp**: Jumpstart your dapp by unpacking one of our starter kits, pre-configured with OpenZeppelin Contracts, React, and Infura. Run `oz unpack` to start!


## Overview

### Installation

```console hljs language-shell
$ npm install @openzeppelin/cli
```

### Usage

All CLI commands are fully interactive: you can call them with no or incomplete arguments and they will prompt you for options as they proceed.

Below is a short list of the most used commands:

- [`oz init`](https://docs.openzeppelin.com/cli/2.6/commands#init): initialize your OpenZeppelin project

- [`oz compile`](https://docs.openzeppelin.com/cli/2.6/commands#compile): compile all Solidity smart contracts in your project

- [`oz create`](https://docs.openzeppelin.com/cli/2.6/commands#create): deploy an upgradeable smart contract

- [`oz send-tx`](https://docs.openzeppelin.com/cli/2.6/commands#send): send a transaction to a contract and execute a function

- [`oz call`](https://docs.openzeppelin.com/cli/2.6/commands#call): read data from the blockchain by calling `view` and `pure` functions

- [`oz upgrade`](https://docs.openzeppelin.com/cli/2.6/commands#upgrade): upgrade a deployed contract to a new version without changing the address or state

- [`oz unpack`](https://docs.openzeppelin.com/cli/2.6/commands#unpack): bootstrap a project with a [Starter Kit](https://docs.openzeppelin.com/starter-kits/)

- [`oz link`](https://docs.openzeppelin.com/cli/2.6/commands#link): reuse on-chain code by to a [linking to Ethereum Packages](https://docs.openzeppelin.com/cli/2.6/dependencies)


## Learn More

- Head to [Getting Started](https://docs.openzeppelin.com/cli/2.6/getting-started) to see the CLI in action by deploying and upgrading a smart contract!

- [Using Dependencies](https://docs.openzeppelin.com/cli/2.6/#using-dependencies.adoc) showcases a more complex project being built, including leveraging the [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/) library.

- If you are a Truffle user, go to [Using With Truffle](https://docs.openzeppelin.com/cli/2.6/truffle) for information on using both tools on the same project.

- Take a look at the API reference for all [CLI commands](https://docs.openzeppelin.com/cli/2.6/commands).

- For an overview of the internals of the CLI, you can read on the [Contracts Architecture](https://docs.openzeppelin.com/cli/2.6/contracts-architecture) and different [Configuration Files](https://docs.openzeppelin.com/cli/2.6/configuration).


|     |     |
| --- | --- |
|  | Looking for the documentation for version 2.4 or earlier? You can find it [here](https://docs.zeppelinos.org/versions). |

[Getting Started →](https://docs.openzeppelin.com/cli/2.6/getting-started)Votes - OpenZeppelin Docs

# Votes

The [VotesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent) provides a flexible system for tracking and delegating voting power. This system allows users to delegate their voting power to other addresses, enabling more active participation in governance.

|     |     |
| --- | --- |
|  | By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked. |

|     |     |
| --- | --- |
|  | The transferring of voting units must be handled by the implementing contract. In the case of `ERC20` and `ERC721` this is usually done via the hooks. You can check the [usage](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/votes#usage) section for examples of how to implement this. |

## Key features

1. **Delegation**: Users can delegate their voting power to any address, including themselves. Vote power can be delegated either by calling the [delegate](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegate) function directly, or by providing a signature to be used with [delegate\_by\_sig](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotesComponent-delegate_by_sig).

2. **Historical lookups**: The system keeps track of historical snapshots for each account, which allows the voting power of an account to be queried at a specific timestamp.


This can be used for example to determine the voting power of an account when a proposal was created, rather than using the current balance.


## Usage

When integrating the `VotesComponent`, the [VotingUnitsTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#VotingUnitsTrait) must be implemented to get the voting units for a given account as a function of the implementing contract.

For simplicity, this module already provides two implementations for `ERC20` and `ERC721` tokens, which will work out of the box if the respective components are integrated.

Additionally, you must implement the [NoncesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#NoncesComponent) and the [SNIP12Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#snip12) trait to enable delegation by signatures.

Here’s an example of how to structure a simple ERC20Votes contract:

```cairo hljs
#[starknet::contract]
mod ERC20VotesContract {
    use openzeppelin_governance::votes::VotesComponent;
    use openzeppelin_token::erc20::ERC20Component;
    use openzeppelin_utils::cryptography::nonces::NoncesComponent;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    component!(path: VotesComponent, storage: erc20_votes, event: ERC20VotesEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);

    // Votes
    #[abi(embed_v0)]
    impl VotesImpl = VotesComponent::VotesImpl<ContractState>;
    impl VotesInternalImpl = VotesComponent::InternalImpl<ContractState>;

    // ERC20
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Nonces
    #[abi(embed_v0)]
    impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;

    #[storage]
    pub struct Storage {
        #[substorage(v0)]
        pub erc20_votes: VotesComponent::Storage,
        #[substorage(v0)]
        pub erc20: ERC20Component::Storage,
        #[substorage(v0)]
        pub nonces: NoncesComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20VotesEvent: VotesComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event
    }

    // Required for hash computation.
    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }
        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    // We need to call the `transfer_voting_units` function after
    // every mint, burn and transfer.
    // For this, we use the `after_update` hook of the `ERC20Component::ERC20HooksTrait`.
    impl ERC20VotesHooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {
        fn after_update(
            ref self: ERC20Component::ComponentState<ContractState>,
            from: ContractAddress,
            recipient: ContractAddress,
            amount: u256
        ) {
            let mut contract_state = self.get_contract_mut();
            contract_state.erc20_votes.transfer_voting_units(from, recipient, amount);
        }
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc20.initializer("MyToken", "MTK");
    }
}
```

And here’s an example of how to structure a simple ERC721Votes contract:

```cairo hljs
#[starknet::contract]
pub mod ERC721VotesContract {
    use openzeppelin_governance::votes::VotesComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use openzeppelin_token::erc721::ERC721Component;
    use openzeppelin_utils::cryptography::nonces::NoncesComponent;
    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;
    use starknet::ContractAddress;

    component!(path: VotesComponent, storage: erc721_votes, event: ERC721VotesEvent);
    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);

    // Votes
    #[abi(embed_v0)]
    impl VotesImpl = VotesComponent::VotesImpl<ContractState>;
    impl VotesInternalImpl = VotesComponent::InternalImpl<ContractState>;

    // ERC721
    #[abi(embed_v0)]
    impl ERC721MixinImpl = ERC721Component::ERC721MixinImpl<ContractState>;
    impl ERC721InternalImpl = ERC721Component::InternalImpl<ContractState>;

    // Nonces
    #[abi(embed_v0)]
    impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;

    #[storage]
    pub struct Storage {
        #[substorage(v0)]
        pub erc721_votes: VotesComponent::Storage,
        #[substorage(v0)]
        pub erc721: ERC721Component::Storage,
        #[substorage(v0)]
        pub src5: SRC5Component::Storage,
        #[substorage(v0)]
        pub nonces: NoncesComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC721VotesEvent: VotesComponent::Event,
        #[flat]
        ERC721Event: ERC721Component::Event,
        #[flat]
        SRC5Event: SRC5Component::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event
    }

    /// Required for hash computation.
    pub impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'DAPP_NAME'
        }
        fn version() -> felt252 {
            'DAPP_VERSION'
        }
    }

    // We need to call the `transfer_voting_units` function after
    // every mint, burn and transfer.
    // For this, we use the `before_update` hook of the
    //`ERC721Component::ERC721HooksTrait`.
    // This hook is called before the transfer is executed.
    // This  gives us access to the previous owner.
    impl ERC721VotesHooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {
        fn before_update(
            ref self: ERC721Component::ComponentState<ContractState>,
            to: ContractAddress,
            token_id: u256,
            auth: ContractAddress
        ) {
            let mut contract_state = self.get_contract_mut();

            // We use the internal function here since it does not check if the token
            // id exists which is necessary for mints
            let previous_owner = self._owner_of(token_id);
            contract_state.erc721_votes.transfer_voting_units(previous_owner, to, 1);
        }
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.erc721.initializer("MyToken", "MTK", "");
    }
}
```

## Interface

This is the full interface of the `VotesImpl` implementation:

```cairo hljs
#[starknet::interface]
pub trait VotesABI<TState> {
    // IVotes
    fn get_votes(self: @TState, account: ContractAddress) -> u256;
    fn get_past_votes(self: @TState, account: ContractAddress, timepoint: u64) -> u256;
    fn get_past_total_supply(self: @TState, timepoint: u64) -> u256;
    fn delegates(self: @TState, account: ContractAddress) -> ContractAddress;
    fn delegate(ref self: TState, delegatee: ContractAddress);
    fn delegate_by_sig(ref self: TState, delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>);

    // INonces
    fn nonces(self: @TState, owner: ContractAddress) -> felt252;
}
```

[← Timelock Controller](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/timelock)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance)Compiling - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Compiling

The OpenZeppelin CLI integrates the Solidity compiler to seamlessly compile your Solidity contracts into Ethereum Virtual Machine (EVM) bytecode.

This guide covers how compiling works, its different options, and the output format.

## Running the Compiler

Most CLI commands, like `oz create` or `oz upgrade`, will automatically compile your projects smart contracts when required, so you don’t need to worry about doing this yourself.

However, you can also just run the compilation by itself, using the [`oz compile`](https://docs.openzeppelin.com/cli/2.6/commands#compile) command:

```console hljs language-shell
$ npx oz compile
```

When executed for the first time, all smart contracts in the `contracts` directory will be compiled at once. Further invocations of `compile` however will _only_ compile contracts that have changed (along with their dependents), speeding up the process.

## Settings

All compilation settings are passed directly to the Solidity compiler. Check out its [documentation](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html) for more info on how each setting affects compilation.

### Picking a Compiler Version

Each Solidity source files should be annotated with a [version pragma](https://solidity.readthedocs.io/en/v0.5.15/layout-of-source-files.html#version-pragma) that indicates which compiler versions can be used to compile it.

The CLI will parse all of these declarations and automatically select the latest compiler version that matches all your version pragmas. This single version will be the one used to compile _all_ of your contracts.

|     |     |
| --- | --- |
|  | It is often best to use permissive pragmas, such as `^0.5.0` or `^0.6.0` (which select the 0.5.x and 0.6.x lines of the compiler, respectively), and let the CLI do the rest. |

Alternatively, you can also specify a compiler version when calling `oz compile` by using the `--solc-version` option:

```console hljs language-shell
$ npx oz compile --solc-version 0.5.14
```

In all cases, the selected Solidity compiler version will be automatically downloaded and saved to cache from the [official distribution list](https://solc-bin.ethereum.org/bin/list.json). Once the version is set, subsequent compilations will [use that same version](https://docs.openzeppelin.com/cli/2.6/compiling#saving-your-settings).

|     |     |
| --- | --- |
|  | For enhanced performance, you can [install the native Solidity binaries](https://solidity.readthedocs.io/en/v0.5.15/installing-solidity.html#binary-packages) on your machine: the CLI will automatically pick it up when compiling if it matches the target version. Massive speedups can be achieved by doing this, specially on large projects. Just make sure it’s available on your [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable))!. |

### Picking an EVM Version

Each version of the Solidity compiler ships with a default [EVM version](https://solidity.readthedocs.io/en/v0.5.15/using-the-compiler.html#setting-the-evm-version-to-target), which corresponds to the mainnet EVM version at the time of release. The CLI will respect these defaults unless otherwise instructed.

In some occasions, it may be necessary to select a specific EVM version. This is achieved via the `--evm-version` flag:

```console hljs language-shell
$ npx oz compile --evm-version berlin
```

### Using the Optimizer

The Solidity compiler features an optional optimizer: it can produce smaller and more gas-efficient EVM bytecode, at the cost of making it harder to understand.

The optimizer is enabled or disabled with the `--optimizer` option:

```console hljs language-shell
$ npx oz compile --optimizer on
```

For fine tuning, you can also pass the `--optimizer-runs` option. This number should be an estimate of how many times you expect your smart contract to be called: pass 1 for one-offs, or a higher number for regularly used contracts. The default value is 200.

```console hljs language-shell
$ npx oz compile --optimizer on --optimizer-runs 100
```

|     |     |
| --- | --- |
|  | Don’t worry if you’re not sure what value to pass to `--optimizer-runs`: the gains achieved by using this parameter correctly are very limited. |

### Saving Your Settings

All compilation settings, including compiler version, EVM version and optimizer configuration are stored in your [project configuration file](https://docs.openzeppelin.com/cli/2.6/configuration#project.json), will be used in all successive compilations.

To modify these settings, run `oz compile` with the newly desired values, or simply edit the configuration file manually.

## Compilation Results

### Storing Compiled Artifacts

The output of the compiler is a number of `.json` files (one per compiled contract), which hold all relevant information: compiler settings, copies of the source, and most importantly, the resulting ABI and bytecode. These files are stored in the `build/contracts` directory, which the CLI will create for you automatically.

|     |     |
| --- | --- |
|  | These files can be large, and since compilation is a fast process it’s often a good idea to add this directory to your `.gitignore`:<br>```diff hljs<br> // .gitignore<br>+build/contracts<br>``` |

### Loading Your Contracts

The format of the `.json` artifacts is standard, and compatible with all major smart contract tools out there, such as Truffle, Buidler, and Etherlime.

If you want to load your compiled contracts and interact with them from JavaScript code, we recommend using the [**OpenZeppelin Contract Loader**](https://docs.openzeppelin.com/contract-loader/0.6/):

```javascript hljs
const { setupLoader } = require('@openzeppelin/contract-loader');

const loader = setupLoader({
  provider,        // either a web3 provider or a web3 instance
  defaultSender,   // optional
});

// Load build/contracts/ERC20.json
const ERC20 = loader.web3.fromArtifact('ERC20');

// Deploy contract
const token = await ERC20.deploy().send();

// Query state and send transaction
const balance = await token.methods.balanceOf(sender).call();
await token.methods.transfer(receiver, balance).send({ from: sender });
```

[← Using Dependencies](https://docs.openzeppelin.com/cli/2.6/dependencies)

[Deploying With `CREATE2` →](https://docs.openzeppelin.com/cli/2.6/deploying-with-create2)Using the OpenZeppelin CLI With Truffle - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Using the OpenZeppelin CLI With Truffle

Truffle is a framework for writing, compiling, deploying and testing smart contracts. You’ll notice we haven’t used it so far - this is because the OpenZeppelin tools are self-sufficient. It brings its own compiler along, its own habits and best practices, its own configuration files, and with some of the starter kits even its own UI elements and frameworks. But what if you’re used to Truffle and prefer it for the additional features it can offer? Do you need to pick between the OpenZeppelin CLI and Truffle now?

That’s a definitive _No_, captain. Let’s see how we can use them together.

This tutorial assumes you’ve gone through the [basic SDK guide](https://docs.openzeppelin.com/sdk/first) and have at least a passing familiarity with Truffle.

## Prerequisites

We’ll assume that you have:

- NodeJS and NPM installed, preferably via NVM

- Ganache installed and available on the command line via `ganache-cli`

- OpenZeppelin SDK installed and available on the command line, either globally or via NPX


All of these conditions should be met if you’ve gone through the [basic guide](https://docs.openzeppelin.com/sdk/first), so if you haven’t please do so now.

|     |     |
| --- | --- |
|  | If you have installed OpenZeppelin SDK globally, you will have to either install it again locally ( `npm install @openzeppelin/cli`) or link to it with `npm link @openzeppelin/cli` which creates a symlink from the globally installed module to your local folder (works on newer versions of Windows 10, too). This is because there’s no easier way to import globally installed Node modules into local scripts. |

## Configuration

When initializing a project with OpenZeppelin SDK, you’ll get a `network.js` file containing something like this:

```js hljs language-javascript
module.exports = {
  networks: {
    development: {
      protocol: 'http',
      host: 'localhost',
      port: 8545,
      gas: 5000000,
      gasPrice: 5e9,
      networkId: '*',
    },
  },
};
```

This configuration makes OpenZeppelin SDK default to a locally running instance of a blockchain, usually Ganache. With Truffle, the configuration is in `truffle-config.js` or `truffle.js`, so in most cases all you need to integrate the two is just make sure that file exists. If it does, OpenZeppelin SDK will default to reading that one for network settings and offer those network names to you when you invoke CLI commands. That said, let’s look at ways to integrate the two.

## Adding Truffle to an OpenZeppelin SDK project

In your example project (the one created by the [basic guide](https://docs.openzeppelin.com/sdk/first)), run `npm install truffle`. Alternatively, have Truffle installed globally so it’s accessible from everywhere ( `npm install -g truffle`) without having to run it with `npx`. We’ll use the `npx` approach in this guide - it makes it possible to use a specific Truffle version per project.

Once Truffle is installed, run `truffle init` in the project folder to initialize the project, or manually create the `truffle-config.js` file.

|     |     |
| --- | --- |
|  | if you say _yes_ when asked to overwrite an existing folder, e.g. if you already had a contracts folder, the contents of that folder will be deleted! The recommended approach is making a backup copy of the contracts folder, running `truffle init` with overwrites, and then merging the contents of the two folders later. |

If you used `init`, you should now have a very verbose `truffle-config.js` file in your project directory which, when the commented out examples are stripped out, comes down to this:

```js hljs language-javascript
module.exports = {
  networks: {
    development: {
     host: "127.0.0.1",
     port: 8545,
     network_id: "*",
    },
  },

  compilers: {
    solc: {
      version: "0.5.2",
      docker: false,
      settings: {
       optimizer: {
         enabled: true,
         runs: 200
       },
       evmVersion: "byzantium"
      }
    }
  }
}
```

If you created `truffle-config.js` from scratch, paste this in. If not, feel free to just uncomment the relevant lines or just paste this over everything. We can now delete OpenZeppelin’s `networks.js` file.

You should also have a file `contracts/Migrations.sol`. If you don’t, create it with the following content:

```sol hljs language-solidity
pragma solidity >=0.4.21 <0.6.0;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}
```

If you now run `openzeppelin deploy` or any other `openzeppelin` command that depends on compiling first, it will call `truffle compile` under the hood before proceeding with the other operations. The SDK will let you know about this:

```bash hljs
$ openzeppelin deploy
√ Compiling contracts with Truffle, using settings from truffle.js file
Truffle output:

Compiling your contracts...
===========================
> Compiling .\contracts\Counter.sol
> Artifacts written to ~\repos\openzeppelin-sdk-guide\build\contracts
> Compiled successfully using:
   - solc: 0.5.2+commit.1df8f40c.Emscripten.clang

? Pick a contract to instantiate ...
```

If you decide to instead recompile with OpenZeppelin, you can force this with `openzeppelin compile` which always compiles with OZ SDK.

Note that network settings are **always** read from Truffle’s configuration if present and will fall back to OpenZeppelin’s `network.js` if not.

## Adding OpenZeppelin SDK to a Truffle project

To add OZ SDK to a Truffle project, simply install OpenZeppelin locally or globally and `openzeppelin init` in the Truffle project’s folder. The `networks.js` file will not be created as OpenZeppelin will detect that it’s initializing in a Truffle folder. OpenZeppelin’s SDK is careful about overwriting essential files, so it won’t cause any conflicts like those that might occur when adding Truffle into an OZ project.

## Migrations

Now that the projects are merged, let’s see how we perform some Migrations - Truffle’s incremental, linked deployments to the blockchain. Migrations are useful when you want to bootstrap a project; like making sure that contracts link to each other properly, ensuring that values are initialized, and so on. By removing human errors and fat fingers from the process of a project’s launch, you make the whole thing much safer.

Our simple Counter contract gets deployed with a value of 0, so let’s write a migration which immediately sends a transaction increasing the value by 10.

OpenZeppelin’s SDK comes with a JavaScript interface which the CLI also uses to execute commands. We can invoke those if we import them in another project or script - like a Truffle migration.

Truffle comes with a default migration which makes subsequent migrations possible. Migrations are executed oredered by prefix - so if the name of a new migration file starts with 2, it will execute after `1_initial_migration.js`. Let’s create `2_deploy_counter.js` with the content:

```js hljs language-javascript
const { scripts, ConfigManager } = require('@openzeppelin/cli');
const { add, push, create } = scripts;

async function deploy(options) {
  add({ contractsData: [{ name: 'Counter', alias: 'Counter' }] });
  await push(options);
  await create(Object.assign({ contractAlias: 'Counter' }, options));
}

module.exports = function(deployer, networkName, accounts) {
  deployer.then(async () => {
    const { network, txParams } = await ConfigManager.initNetworkConfiguration({ network: networkName, from: accounts[0] })
    await deploy({ network, txParams })
  })
}
```

Let’s test it. Run:

```bash hljs
truffle migrate --network development
```

```bash hljs
λ npx truffle migrate --network development
Compiling .\contracts\Counter.sol...
Compiling .\contracts\Migrations.sol...
Writing artifacts to .\build\contracts
```

|     |     |
| --- | --- |
|  | If you’re using an HDWalletProvider, it must be Web3 1.0 enabled or your migration will hang. |

```
Starting migrations...
======================
> Network name:    'development'
> Network id:      1564927897006
> Block gas limit: 6721975

1_initial_migration.js
======================

   Deploying 'Migrations'
   ----------------------
   > transaction hash:    0x18fd35c7395f6dbc2ad39a6cef6bbb05af41f3c1b24a7abdef7066ff14e9d0b2
   > Blocks: 0            Seconds: 0
   > contract address:    0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab
   > account:             0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
   > balance:             99.99557658
   > gas used:            221171
   > gas price:           20 gwei
   > value sent:          0 ETH
   > total cost:          0.00442342 ETH

   > Saving artifacts
   -------------------------------------
   > Total cost:          0.00442342 ETH

2_deploy_counter.js
===================
0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B
   -------------------------------------
   > Total cost:                   0 ETH

Summary
=======
> Total deployments:   1
> Final cost:          0.00442342 ETH
```

It works! Let’s make sure and re-run migrations, it should tell us that we’re up to date.

```bash hljs
λ npx truffle migrate

Compiling your contracts...
===========================
> Everything is up to date, there is nothing to compile.

Network up to date.
```

Our counter is deployed but to make sure let’s check if we can interact with it. We’ll use OZ SDK.

```bash hljs
λ openzeppelin call
? Pick a network development
? Pick an instance Counter at 0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B
? Select which function value()
√ Method 'value()' returned: 0
0
```

Perfect. Now let’s make the second migration which increases the counter value by 10. Create `migrations/3_increment.js`.

```js hljs language-javascript
const Counter = artifacts.require("Counter");

module.exports = async function(deployer) {
    const counter = await Counter.deployed();
    await counter.increase(10);
};
```

You’ll notice we used Truffle’s default migration process instead of `sendTx` or `call`, like we would when interacting with OpenZeppelin’s SDK on the command line. This is because the JavaScript API does not have those helper functions exported for the moment (a pending change), so we have to interact with contracts _the old way_.

## Caveats

Once you start using Truffle in an OpenZeppelin SDK project, it’s recommended you keep using it and don’t mix and match other than in the context of migration scripts where you can use the OpenZeppelin SDK API as much as you wish. The reason is that OpenZeppelin will not respect the migrations deployed by Truffle as it is not aware of them, and will instead deploy its own copy of the contracts you’re creating, possibly causing conflicts.

* * *

Now that you know the fusion of Truffle and OpenZeppelin SDK is a possibility, go forth, #buidl and [let us know](https://twitter.com/openzeppelin) what you created!

[← Deploying With `CREATE2`](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2)

[Migrating CLI version →](https://docs.openzeppelin.com/cli/2.8/migrate-cli-versions)Deploying Contracts - OpenZeppelin Docs

# Deploying Contracts

To deploy a contract written in Rust using the Stylus SDK, the Arbitrum Stylus team created `cargo-stylus`. For now, this CLI tool doesn’t support deploying contracts with constructors.

We implemented [`koba`](https://github.com/OpenZeppelin/koba), a solution you can use today to write constructors in Solidity for your Rust smart contracts.

|     |     |
| --- | --- |
|  | Deploying `oppenzeppelin-stylus` contracts must be done using `koba`. Using `cargo-stylus` directly may initialize storage with unexpected values. |

This solution is meant to be temporary. In the near future, we expect support for constructors to be implemented in `cargo-stylus` or the Stylus VM itself.

## Constructors

Deployment transactions in Ethereum are composed of three sections:

- A `prelude` \- The bytecode prefix whose execution gets triggered by the deployment transaction.

- A `runtime` \- The bytecode of the smart contract stored on-chain.

- Constructor arguments - ABI-encoded arguments received by the constructor.


The prelude section is a [smart contract constructor](https://docs.soliditylang.org/en/latest/contracts.html#constructors) compiled to bytecode. The runtime is the rest of the smart contract. All three sections combined are called `binary`.

Deployment transactions with an input of only compressed wasm are not yet supported in Stylus. That is, only the `runtime` is actual webassembly.

Moreover, the prelude of deployment transactions using `cargo-stylus` is [hard-coded](https://github.com/OffchainLabs/cargo-stylus/blob/be9faca7720b534de7ec210fa5a071eae79824ec/check/src/deploy.rs#L102-L114).

`koba` solves this by putting together the Solidity constructor, the compiled webassembly and the abi-encoded constructor arguments. It can be used both as a CLI tool or as a library in Rust projects. For a complete example of using `koba` as a library, see the [basic token example](https://github.com/OpenZeppelin/rust-contracts-stylus/blob/main/examples/basic/README.md). For an example of deploying a contract using the command line see [koba’s README](https://github.com/OpenZeppelin/koba#koba-deploy).

## Usage

For a contract like this:

```rust hljs
sol_storage! {
    #[entrypoint]
    pub struct Counter {
        uint256 number;
    }
}

#[public]
impl Counter {
    pub fn number(&self) -> U256 {
        self.number.get()
    }

    pub fn increment(&mut self) {
        let number = self.number.get();
        self.set_number(number + U256::from(1));
    }
}
```

and a constructor like this:

```solidity hljs
contract Counter {
    uint256 private _number;

    constructor() {
        _number = 5;
    }
}
```

The following command will deploy your contract:

```bash hljs
$ koba deploy --sol <path-to-constructor> --wasm <path-to-wasm> --args <constructor-arguments> -e <rpc-url> --private-key <private-key>
```

[← Overview](https://docs.openzeppelin.com/contracts-stylus/0.1.0/)

[Tokens →](https://docs.openzeppelin.com/contracts-stylus/0.1.0/tokens)Using Dependencies - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Using Dependencies

In [Getting Started](https://docs.openzeppelin.com/cli/2.8/getting-started), we learned how to set up a new OpenZeppelin project, deploy a simple contract, and upgrade it. Now, we will build a more interesting project with multiple contracts, leveraging the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package). We will learn about **linking Ethereum Packages**, and **writing upgradeable contracts**.

## What We Will Build

We will write a `TokenExchange` contract, that will allow any user to purchase an ERC20 token in exchange for ETH, at a fixed exchange rate. We will write `TokenExchange` ourselves, but leverage the [ERC20 implementation](https://docs.openzeppelin.com/contracts/5.x/erc20) from [**OpenZeppelin Contracts**](https://docs.openzeppelin.com/contracts/5.x/)

Before we get started, make sure to [initialize a new project](https://docs.openzeppelin.com/cli/2.8/getting-started#setting-up-your-project):

```console hljs language-shell
$ mkdir token-exchange && cd token-exchange
$ npm init -y
$ npm install @openzeppelin/cli
$ npx openzeppelin init
```

|     |     |
| --- | --- |
|  | The full code for this project is available in our [Github repo](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/release/2.8/examples/linking-contracts). |

## Linking the Contracts Ethereum Package

We will first get ourselves an ERC20 token. Instead of coding one from scratch, we will use the one provided by the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package). An Ethereum Package is a set of contracts set up to be easily included in an OpenZeppelin project, with the added bonus that the contracts' code _is already deployed in the Ethereum network_. This is a more secure code distribution mechanism, and also helps you save gas upon deployment.

|     |     |
| --- | --- |
|  | Check out [this article](https://blog.openzeppelin.com/open-source-collaboration-in-the-blockchain-era-evm-packages/) to learn more about Ethereum Packages. |

To link the OpenZeppelin Contracts Ethereum Package into your project, simply run the following:

```console hljs language-shell
$ npx oz link @openzeppelin/contracts-ethereum-package
```

This command will download the Ethereum Package (bundled as a regular npm package), and connect it to your OpenZeppelin project. We now have all of OpenZeppelin contracts at our disposal, so let’s create an ERC20 token!

|     |     |
| --- | --- |
|  | Make sure you install `@openzeppelin/contracts-ethereum-package` and not the vanilla `@openzeppelin/contracts`. The latter is set up for general usage, while `@openzeppelin/contracts-ethereum-package` is tailored for being used with [OpenZeppelin Upgrades](https://docs.openzeppelin.com/upgrades/2.8/). This means that its contracts are [already set up to be upgradeable](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#use-upgradeable-packages). |

## Creating an ERC20 Token

Let’s deploy an ERC20 token contract to our development network. Make sure to [have a Ganache instance running](https://docs.openzeppelin.com/cli/2.8/dependencies#learn::deploy-and-interact.adoc#local-blockchain), or start one by running:

```console hljs language-shell
$ npx ganache-cli --deterministic
```

For setting up the token, we will be using the [ERC20PresetMinterPauser implementation](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/presets/ERC20PresetMinterPauser.sol) provided by the OpenZeppelin package. We will _initialize_ the instance with the token metadata (name, symbol), and then mint a large initial supply for one of our accounts.

|     |     |
| --- | --- |
|  | The unlocked accounts and transaction hashes may differ from the ones shown here. Run a brand-new Ganache in `--deterministic` mode to get the same ones. |

```console hljs language-shell
$ npx oz deploy
No contracts found to compile.
? Choose the kind of deployment upgradeable
? Pick a network development
? Pick a contract to deploy @openzeppelin/contracts-ethereum-package/ERC20PresetMinterPauserUpgradeSafe
✓ Deploying @openzeppelin/contracts-ethereum-package dependency to network dev-1589440867048
All implementations are up to date
? Call a function to initialize the instance after creating it? Yes
? Select which function initialize(name: string, symbol: string)
? name: string: MyToken
? symbol: string: MYT
✓ Setting everything up to create contract instances
✓ Instance created at 0x59d3631c86BbE35EF041872d502F218A39FBa150
To upgrade this instance run 'oz upgrade'
0x59d3631c86BbE35EF041872d502F218A39FBa150
```

Let’s break down what we did in the command above. We first chose to create an instance of the `ERC20PresetMinterPauserUpgradeSafe` contract from the `@openzeppelin/contracts-ethereum-package` package we had linked before, and to create it in the local `development` network. We are then instructing the CLI to _initialize_ it with the initial values needed to set up our token. This requires us to choose the appropriate `initialize` function, and input all the required arguments. The OpenZeppelin CLI will then atomically deploy and initialize the new instance in a single transaction.

We now have a working ERC20 token contract in our development network.

Next we get the accounts we have setup

```console hljs language-shell
$ npx oz accounts
? Pick a network development
Accounts for dev-1589440867048:
Default: 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
All:
- 0: 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
- 1: 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
...
```

Then we mint 100 MYT to our default account

```console hljs language-shell
$ npx oz send-tx
? Pick a network development
? Pick an instance ERC20PresetMinterPauserUpgradeSafe at 0x59d3631c86BbE35EF041872d502F218A39FBa150
? Select which function mint(to: address, amount: uint256)
? to: address: 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
? amount: uint256: 100000000000000000000
✓ Transaction successful. Transaction hash: 0xff24cce7801e424db6e5a7076d4a9c677ef76df320fe04e2c39e537d09029ec0
Events emitted:
 - Transfer(0x0000000000000000000000000000000000000000, 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1, 100000000000000000000)
```

We can check that the initial supply was properly allocated by using the `balance` command. Make sure to use the address where your ERC20 token instance was created.

```console hljs language-shell
$ npx oz balance --erc20 0x59d3631c86BbE35EF041872d502F218A39FBa150
? Enter an address to query its balance 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
? Pick a network development
Balance: 100 MYT
100000000000000000000
```

Great! We can now write an exchange contract and connect it to this token when we deploy it.

## Writing the Exchange Contract

In order to transfer an amount of tokens every time it receives ETH, our exchange contract will need to store the token contract address and the exchange rate in its state. We will set these two values during initialization, when we deploy the instance with `oz deploy`.

Because we’re writing upgradeable contracts [we cannot use Solidity `constructor` s](https://docs.openzeppelin.com/upgrades/2.8/proxies#the-constructor-caveat). Instead, we need to use _initializers_. An initializer is just a regular Solidity function, with an additional check to ensure that it can be called only once.

To make coding initializers easy, [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/) provides a base `Initializable` contract, that includes an `initializer` modifier that takes care of this. You will first need to install it:

```console hljs language-shell
$ npm install @openzeppelin/upgrades
```

Now, let’s write our exchange contract in `contracts/TokenExchange.sol`, using an _initializer_ to set its initial state:

```solidity hljs
// contracts/TokenExchange.sol
pragma solidity ^0.6.2;

// Import base Initializable contract
import "@openzeppelin/upgrades/contracts/Initializable.sol";

// Import the IERC20 interface and and SafeMath library
import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";

contract TokenExchange is Initializable {
    using SafeMath for uint256;

    // Contract state: exchange rate and token
    uint256 public rate;
    IERC20 public token;

    // Initializer function (replaces constructor)
    function initialize(uint256 _rate, IERC20 _token) public initializer {
        rate = _rate;
        token = _token;
    }

    // Send tokens back to the sender using predefined exchange rate
    receive() external payable {
        uint256 tokens = msg.value.mul(rate);
        token.transfer(msg.sender, tokens);
    }
}
```

Note the usage of the `initializer` modifier in the `initialize` method. This guarantees that once we have deployed our contract, no one can call into that function again to alter the token or the rate.

Let’s now create and initialize our new `TokenExchange` contract:

```console hljs language-shell
$ npx oz deploy
✓ Compiled contracts with solc 0.6.7 (commit.b8d736ae)
? Choose the kind of deployment upgradeable
? Pick a network development
? Pick a contract to deploy TokenExchange
✓ Added contract TokenExchange
✓ Contract TokenExchange deployed
All implementations have been deployed
? Call a function to initialize the instance after creating it? Yes
? Select which function initialize(_rate: uint256, _token: address)
? _rate: uint256: 10
? _token: address: 0x59d3631c86BbE35EF041872d502F218A39FBa150
✓ Instance created at 0x67B5656d60a809915323Bf2C40A8bEF15A152e3e
To upgrade this instance run 'oz upgrade'
0x67B5656d60a809915323Bf2C40A8bEF15A152e3e
```

Our exchange is almost ready! We only need to fund it, so it can send tokens to purchasers. Let’s do that using the `oz send-tx` command, to transfer the full token balance from our own account to the exchange contract. Make sure to replace the recipient of the transfer with the `TokenExchange` address you got from the previous command.

```console hljs language-shell
$ npx oz send-tx
? Pick a network development
? Pick an instance ERC20PresetMinterPauserUpgradeSafe at 0x59d3631c86BbE35EF041872d502F218A39FBa150
? Select which function transfer(recipient: address, amount: uint256)
? recipient: address: 0x67B5656d60a809915323Bf2C40A8bEF15A152e3e
? amount: uint256: 100e18
✓ Transaction successful. Transaction hash: 0xdfec4bb86d995ab6f48696bf09685e0bee9949f19eb0dc6c6425e2ea3a37ef49
Events emitted:
 - Transfer(0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1, 0x67B5656d60a809915323Bf2C40A8bEF15A152e3e, 100000000000000000000)
```

All set! We can start playing with our brand new token exchange.

## Using Our Exchange

Now that we have initialized our exchange contract and seeded it with funds, we can test it out by purchasing tokens. Our exchange contract will send tokens back automatically when we send ETH to it, so let’s test it by using the `oz transfer` command. This command allows us to send funds to any address; in this case, we will use it to send ETH to our `TokenExchange` instance:

```console hljs language-shell
$ npx oz transfer
? Pick a network development
? Choose the account to send transactions from (1) 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
? Enter the receiver account 0x67B5656d60a809915323Bf2C40A8bEF15A152e3e
? Enter an amount to transfer 0.1 ether
✓ Funds sent. Transaction hash: 0xfcd74514cd9629a26ec25f637f5dd958dbdfa151594c1a3a6671dcf1d889a50e
```

|     |     |
| --- | --- |
|  | Make sure you replace the receiver account with the corresponding address where your `TokenExchange` was created. |

We can now use `oz balance` again, to check the token balance of the address that made the purchase. Since we sent 0.1 ETH, and we used a 1:10 exchange rate, we should see a balance of 1 MYT (MyToken).

```console hljs language-shell
$ npx oz balance --erc20 0x59d3631c86BbE35EF041872d502F218A39FBa150
? Enter an address to query its balance 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
? Pick a network development
Balance: 1 MYT
1000000000000000000
```

Success! We have our exchange up and running, gathering ETH in exchange for our tokens. But how can we collect the funds we earned…​?

## Upgrading the Exchange

We forgot to add a method to withdraw the funds from the token exchange contract! While this would typically mean that the funds are locked in there forever, we can upgrade the contract with the OpenZeppelin CLI to add a way to collect those funds.

|     |     |
| --- | --- |
|  | While upgrading a contract is certainly useful in situations like this, where you need to fix a bug or add a missing feature, it could still be used to change the rules of the game. For instance, you could upgrade the token exchange contract to alter the rate at any time. Because of this, it is important to have appropriate Project Governance in place. |

Let’s modify the `TokenExchange` contract to add a `withdraw` method, only callable by an `owner`.

```solidity hljs
// contracts/TokenExchange.sol
contract TokenExchange is Initializable {
    uint256 public rate;
    IERC20 public token;
+    address public owner;

    // (existing functions not shown here for brevity)

+    function withdraw() public {
+        require(
+            msg.sender == owner,
+            "Address not allowed to call this function"
+        );
+        msg.sender.transfer(address(this).balance);
+    }
}
```

When modifying your contract, you will have to place the `owner` variable **after** the other variables ( [learn more](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) about this restriction). Don’t worry if you forget about it, the CLI will check this for you when you try to upgrade.

|     |     |
| --- | --- |
|  | If you are familiar with [**OpenZeppelin Contracts**](https://docs.openzeppelin.com/contracts/5.x/), you may be wondering why we didn’t simply extend from `Ownable` and used the `onlyOwner` modifier. The issue is OpenZeppelin Upgrades does not support extending from now contracts in an upgrade (if they declare their own state variables). Again, the CLI will alert you if you attempt to do this. Refer to the [Upgrades documentation](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) for more info. |

The only thing missing is actually _setting_ the `owner` of the contract. To do this, we can add another function that we will call when upgrading, making sure it can only be called once:

```solidity hljs
// contracts/TokenExchange.sol
contract TokenExchange is Initializable {
    uint256 public rate;
    IERC20 public token;
    address public owner;

    // (existing functions not shown here for brevity)

    function withdraw() public {
        require(
            msg.sender == owner,
            "Address not allowed to call this function"
        );
        msg.sender.transfer(address(this).balance);
    }

+    // To be run during upgrade, ensuring it can never be called again
+    function setOwner(address _owner) public {
+        require(owner == address(0), "Owner already set, cannot modify!");
+        owner = _owner;
+    }
}
```

First we compile the contract

```console hljs language-shell
$ npx oz compile
✓ Compiled contracts with solc 0.6.7 (commit.b8d736ae)
```

We can now upgrade our token exchange contract to this new version, and call `setOwner` during the upgrade process. The OpenZeppelin CLI will take care of making the upgrade and the call atomically in a single transaction.

```console hljs language-shell
$ npx oz upgrade
? Pick a network development
? Which instances would you like to upgrade? Choose by name
? Pick an instance to upgrade TokenExchange
? Call a function on the instance after upgrading it? Yes
? Select which function setOwner(_owner: address)
? _owner: address: 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
Nothing to compile, all contracts are up to date.
- New variable 'address owner' was added in contract TokenExchange in contracts/TokenExchange.sol:1 at the end of the contract.
See https://docs.openzeppelin.com/upgrades/2.6//writing-upgradeable#modifying-your-contracts for more info.
✓ Contract TokenExchange deployed
All implementations have been deployed
✓ Instance upgraded at 0x67B5656d60a809915323Bf2C40A8bEF15A152e3e. Transaction receipt: 0xb742c40f939daab145552880e7e07a696570684af1b6aef03d196d39ea61c019
✓ Instance at 0x67B5656d60a809915323Bf2C40A8bEF15A152e3e upgraded
```

There! We can now call `withdraw` from our default address to extract all ETH sent to the exchange.

```console hljs language-shell
$ npx oz send-tx
? Pick a network development
? Pick an instance TokenExchange at 0x67B5656d60a809915323Bf2C40A8bEF15A152e3e
? Select which function withdraw()
✓ Transaction successful. Transaction hash: 0x4797d95b1892c9a0cb264bb430fcb425b7cb220ef33cb759496d1dd1dc05a31a
```

|     |     |
| --- | --- |
|  | You can also upgrade dependencies from an Ethereum Package. Upon a new release of `@openzeppelin/contracts-ethereum-package`, if you want to update your ERC20 to include the latest fixes, you can just `oz link` the new version and use `oz upgrade` to get your instance to the newest code. |

## Wrapping Up

We have built a more complex setup in this tutorial, and learned several concepts along the way. We introduced [Ethereum Packages](https://blog.openzeppelin.com/open-source-collaboration-in-the-blockchain-era-evm-packages/) as dependencies for our projects, allowing us to spin up a new token with little effort.

We also presented some [limitations](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable) of [how Upgrades works](https://docs.openzeppelin.com/upgrades/2.8/proxies), such as [initializer methods](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#initializers) as a replacement for constructors, and [preserving the storage layout](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) when modifying our source code. We also learned how to run a function as a migration when upgrading a contract.

[← Getting Started](https://docs.openzeppelin.com/cli/2.8/getting-started)

[Compiling →](https://docs.openzeppelin.com/cli/2.8/compiling)Getting Started - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Getting Started

This tutorial will showcase usage of the OpenZeppelin CLI, giving you a taste of its capabilities and serving as a starting point for your own projects.

We will cover:
\\* Create a new OpenZeppelin project with a smart contract
\\* Deploying our contract to a local development network
\\* Interacting with our contract from the terminal
\\* Upgrading the deployed contract to a new version

## Prerequisites

The CLI is installed as a dependency to your Node project:

```console hljs language-shell
$ npm install @openzeppelin/cli
```

|     |     |
| --- | --- |
|  | If you’re unfamiliar with Node and npm, head to our guide on [Setting Up a Development Environment](https://docs.openzeppelin.com/cli/2.7/getting-started#learn::set-up-dev-environment). |

We are installing the CLI [locally](https://docs.npmjs.com/downloading-and-installing-packages-locally) instead of [globally](https://docs.npmjs.com/downloading-and-installing-packages-globally), which means usage of the CLI will be prefixed with `npx`. This will avoid issues that arise from having global dependencies, and will let you have different versions of the CLI in each of your projects, if you so desire.

## Setting up Your Project

Inside your Node project, use the CLI to initialize an OpenZeppelin project:

```console hljs language-shell
$ npx openzeppelin init
```

The CLI will prompt you for a project name and version, defaulting to the ones from the `package.json`, and then set up a few files and directories for running your OpenZeppelin project.

|     |     |
| --- | --- |
|  | If you’d rather type less, you can use the `oz` command alias, so `openzeppelin init` becomes just `oz init`. We’ll use this throughout the tutorial. |

We are now ready to begin working on our project.

|     |     |
| --- | --- |
|  | Should you get lost at any point during this tutorial, you can refer to the full code for this project in our [`Github repo`](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.4.0/examples/first-project). |

## Your First Contract

We will write a simple contract in [Solidity](https://solidity.readthedocs.io/), the most popular language for Ethereum smart contracts. Create a new file `contracts/Counter.sol` in your project with the following content:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
    uint256 public value;

    function increase() public {
      value++;
    }
}
```

This contract stores a numeric `value` that is increased by one every time we send a transaction to the `increase()` function.

You can run `oz compile` to compile the contract and check for any errors. Once that’s done, we’ll be ready to deploy it.

|     |     |
| --- | --- |
|  | You don’t have to worry if you forget to compile your contract. The CLI will automatically check if your contract changed when you run any command, and compile it if needed. |

## Deploying to a Development Network

We will use [Ganache](https://truffleframework.com/ganache) as a _development network_ to deploy our contract. If you don’t have Ganache installed, do so now by running `npm install ganache-cli`.

Development networks are mini blockchains that run just on your computer, and are much faster than the actual Ethereum network. We will use one for coding and testing.

|     |     |
| --- | --- |
|  | Head to [Setting up a Local Blockchain](https://docs.openzeppelin.com/learn/deploying-and-interacting#local-blockchain) to learn more about using Ganache. |

Open a separate terminal and start a new Ganache process:

```console hljs language-shell
$ npx ganache-cli --deterministic
```

This will start a new development network using a deterministic set of accounts, instead of random ones. We can now deploy our contract there, running `oz create`, and choosing to deploy the `Counter` contract to the `development` network.

```console hljs language-shell
$ npx oz create
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
? Pick a contract to instantiate: Counter
? Pick a network: development
✓ Added contract Counter
✓ Contract Counter deployed
? Call a function to initialize the instance after creating it?: No
✓ Setting everything up to create contract instances
✓ Instance created at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
```

|     |     |
| --- | --- |
|  | The addresses where your contracts are created and the transaction identifiers you see may differ from the ones listed here. |

Our `Counter` contract is deployed to the local development network and ready to go! We can test it out by interacting with it from the terminal. Let’s try incrementing the counter, by sending a transaction to call the `increase` function through `oz send-tx`.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase()
✓ Transaction successful. Transaction hash: 0x20bef6583ea32cc57fe179e34dd57a5494db3c403e441624e56a886898cb52bd
```

We can now use `oz call` to query the contract’s public `value`, and check that it was indeed increased from zero to one.

```console hljs language-shell
$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
✓ Method 'value()' returned: 1
```

## Upgrading Your Contract

We will now modify our `Counter` contract to make the `increase` function more interesting. Instead of increasing the counter by one, we will allow the caller to increase the counter by any value. Let’s modify the code in `contracts/Counter.sol` to the following:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
  uint256 public value;

  function increase(uint256 amount) public {
    value += amount;
  }
}
```

We can now upgrade the instance we created earlier to this new version:

```console hljs language-shell
$ npx oz upgrade
? Pick a network: development
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
✓ Contract Counter deployed
? Which proxies would you like to upgrade?: All proxies
Instance upgraded at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601.
```

Done! Our `Counter` instance has been upgraded to the latest version, and **neither its address nor its state have changed**. Let’s check it out by increasing the counter by ten, which should yield eleven, since we had already increased it by one:

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase(amount: uint256)
? amount (uint256): 10
Transaction successful: 0x9c84faf32a87a33f517b424518712f1dc5ba0bdac4eae3a67ca80a393c555ece

$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
Returned "11"
```

|     |     |
| --- | --- |
|  | That smart contracts are immutable, so you may be wondering how the OpenZeppelin CLI achieved this feat. To learn about this, head to the docomentation for [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/), in particular the guide about [Proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies).<br>You will note that there are some changes that are not supported during upgrades. For instance, you cannot [remove or change the type of a contract state variable](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts). Nevertheless, you can change, add, or remove all the functions you want. |

That’s it! You now know how to start a simple OpenZeppelin project, create a contract, deploy it to a local network, and even upgrade it as you develop. Head over to the next tutorial to learn how to interact with your contract from your code.

[← Overview](https://docs.openzeppelin.com/cli/2.7/)

[Using Dependencies →](https://docs.openzeppelin.com/cli/2.7/dependencies)ERC20Permit - OpenZeppelin Docs

# ERC20Permit

The [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612) standard, commonly referred to as ERC20Permit, is designed to support gasless token approvals. This is achieved with an off-chain
signature following the [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) standard, rather than with an on-chain transaction. The [permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-permit) function verifies the signature and sets
the spender’s allowance if the signature is valid. This approach improves user experience and reduces gas costs.

## Differences from Solidity

Although this extension is mostly similar to the [Solidity implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Permit.sol) of [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612), there are some notable differences in the parameters of the [permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-permit) function:

- The `deadline` parameter is represented by `u64` rather than `u256`.

- The `signature` parameter is represented by a span of felts rather than `v`, `r`, and `s` values.


|     |     |
| --- | --- |
|  | Unlike Solidity, there is no enforced format for signatures on Starknet. A signature is represented by an array or span of felts,<br>and there is no universal method for validating signatures of unknown formats. Consequently, a signature provided to the [permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-permit) function<br>is validated through an external `is_valid_signature` call to the contract at the `owner` address. |

## Usage

The functionality is provided as an embeddable [ERC20Permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Embeddable-Impls-ERC20PermitImpl) trait of the [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component).

```cairo hljs
#[abi(embed_v0)]
impl ERC20PermitImpl = ERC20Component::ERC20PermitImpl<ContractState>;
```

A contract must meet the following requirements to be able to use the [ERC20Permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Embeddable-Impls-ERC20PermitImpl) trait:

- Implement [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component).

- Implement [NoncesComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#NoncesComponent).

- Implement [SNIP12Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#snip12) trait (used in signature generation).


## Typed message

To safeguard against replay attacks and ensure the uniqueness of each approval via [permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-permit), the data signed includes:

- The address of the `owner`.

- The parameters specified in the [permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-approve) function ( `spender` and `amount`)

- The address of the `token` contract itself.

- A `nonce`, which must be unique for each operation.

- The `chain_id`, which protects against cross-chain replay attacks.


The format of the `Permit` structure in a signed permit message is as follows:

```cairo hljs
struct Permit {
    token: ContractAddress,
    spender: ContractAddress,
    amount: u256,
    nonce: felt252,
    deadline: u64,
}
```

|     |     |
| --- | --- |
|  | The owner of the tokens is also part of the signed message. It is used as the `signer` parameter in the `get_message_hash` call. |

Further details on preparing and signing a typed message can be found in the [SNIP12 guide](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/snip12).

[← Creating Supply](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/erc20-supply)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20)Contracts Architecture - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Contracts Architecture

Features such as contract upgrades and Ethereum Package linking involve interacting with a number of smart contracts. While regular usage of the CLI does not require awareness of these low-level details, it is still helpful to understand how everything works under the hood.

The following sections describe the contract achitecture behind both upgrades and Ethereum Packages.

|     |     |
| --- | --- |
|  | Most of these contracts are actually part of [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/), which the CLI uses. |

## Upgrades

The source code of the contracts involved with upgrades is located [here](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.6.0/packages/lib/contracts/upgradeability).

### `ProxyAdmin`

[`ProxyAdmin`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin) is a central admin for all [proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies) on your behalf, making their management as simple as possible.

As an admin of all proxy contracts it is in charge of upgrading them, as well as transferring their ownership to another admin. This contract is used to complement the [Transparent Proxy Pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes), which prevents an admin from accidentally triggering a proxy management function when interacting with their instances. `ProxyAdmin` is owned by its deployer (the project owner), and exposes its administrative interface to this account.

A `ProxyAdmin` is only deployed when you run an `oz deploy` (or `oz create2`) command for the first time. You can force the CLI to deploy one by running `oz push --deploy-proxy-admin`.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyAdmin.sol).

#### Ownership Transfer

The [`oz set-admin`](https://docs.openzeppelin.com/cli/2.8/commands#set-admin) CLI command is used to transfer ownership, both of any single contract or of the entire project (by transferring the ownership of the `ProxyAdmin` contract itself).

A contract’s ownership is transferred by providing its address and the new admin’s:

```console hljs language-shell
$ npx oz set-admin [MYCONTRACT_ADDRESS] [NEW_ADMIN_ADDRESS]
```

To instead transfer the whole project, just provide the new admin address:

```console hljs language-shell
$ npx oz set-admin [NEW_ADMIN_ADDRESS]
```

|     |     |
| --- | --- |
|  | `oz set-admin` is an interactive command: you can also run it with no arguments and it will prompt you for data as it proceeds. |

#### Contract Upgrades via `ProxyAdmin`

The `ProxyAdmin.sol` also responsible for upgrading our contracts. When you run the `oz upgrade` command, it goes through `ProxyAdmin’s` [`upgrade`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin-upgrade-contract-AdminUpgradeabilityProxy-address-) method. The `ProxyAdmin` contract also provides another method [`getProxyImplementation`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin-getProxyImplementation-contract-AdminUpgradeabilityProxy-) which returns the current implementation of a given proxy.

You can find your `ProxyAdmin` contract address in [`.openzeppelin/<network>.json`](https://docs.openzeppelin.com/cli/2.8/configuration#network.json) under the same name.

```json hljs
// .openzeppelin/<network.json>
"proxyAdmin": {
   "address": <proxyAdmin-address>
}
```

### `ProxyFactory`

[`ProxyFactory`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyFactory) is used when creating contracts via the `oz create2` command, as well as when creating minimal proxies. It contains all the necessary methods to deploy a proxy through the `CREATE2` opcode or a minimal non-upgradeable proxy.

This contract is only deployed when you run `openzeppelin create2` or `openzeppelin deploy --kind minimal` for the first time. You can force the CLI to deploy it by running `openzeppelin push --deploy-proxy-factory`.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyFactory.sol).

## Ethereum Packages

The source code of the contracts involved with a published Ethereum Package is located [here](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.6.0/packages/lib/contracts/application).

### `App`

[`App`](https://docs.openzeppelin.com/upgrades/2.8/api#App) is the project’s main entry point. Its most important function is to manage your project’s "providers". A provider is basically an Ethereum Package identified by a name at a specific version. For example, a project may track your application’s contracts in one provider named "my-application" at version "0.0.1", an OpenZeppelin Contracts provider named "@openzeppelin/contracts-ethereum-package" at version "2.0.0", and a few other providers. These providers are your project’s sources of on-chain logic.

The providers are mapped by name to `ProviderInfo` structs:

```solidity hljs
// App.sol
    ...

    mapping(string => ProviderInfo) internal providers;

    struct ProviderInfo {
        Package package;
        uint64[3] version;
    }

    ...
```

When you upgrade one of your application’s smart contracts, it is your application provider named "my-application" that is bumped to a new version, e.g. from "0.0.1" to "0.0.2". On the other hand, when you decide to use a new version of the OpenZeppelin Ethereum Package in your project, it is the "@openzeppelin/contracts-ethereum-package" provider which is now pointed at the "2.0.1" version of the package, instead of "2.0.0".

An Ethereum Package is defined by the `Package` contract, as we’ll see next.

|     |     |
| --- | --- |
|  | Additionally the `App` contract also facilitates the creation of proxies, by conveniently wrapping around the `AdminUpgradeabilityProxy` contract. |

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/App.sol).

### `Package`

A [`Package`](https://docs.openzeppelin.com/upgrades/2.8/api#Package) contract tracks all the versions of a given Ethereum Package. Following the example above, one package could be the "application package" associated to the name "my-application" containing all the contracts for version "0.0.1" of your application, and all the contracts for version "0.0.2" as well. Alternatively, another package could be an Ethereum Package associated to the name "@openzeppelin/contracts-ethereum-package" which contains a large number of versions "x.y.z" each of which contains a given set of contracts.

The versions are mapped by a semver hash to `Version` structs:

```solidity hljs
// Package.sol
    ...

    mapping (bytes32 => Version) internal versions;

    struct Version {
        uint64[3] semanticVersion;
        address contractAddress;
        bytes contentURI;
    }

    ...
```

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/Package.sol).

### `ImplementationDirectory`

A version’s `contractAddress` is an instance of the A [`ImplementationDirectory`](https://docs.openzeppelin.com/upgrades/2.8/api#ImplementationDirectory) contract, which is basically a mapping of contract aliases (or names) to deployed implementation instances. Continuing the example, your project’s "my-application" package for version "0.0.1" could contain a directory with the following contracts:

**Directory for version "0.0.1" of the "my-application" package**

- Alias: "MainContract", Implementation: "0x0B06339ad63A875D4874dB7B7C921012BbFfe943"

- Alias: "MyToken", Implementation: "0x1b9a62585255981c85Acec022cDaC701132884f7"


While version "0.0.2" of the "my-application" package could look like this:

**Directory for version "0.0.2" of the "my-application" package**

- Alias: "MainContract", Implementation: "0x0B06339ad63A875D4874dB7B7C921012BbFfe943"

- Alias: "MyToken", Implementation: "0x724a43099d375e36c07be60c967b8bbbec985dc8" ←-- this changed


Notice how version "0.0.2" uses a new implementation for the "MyToken" contract.

Likewise, different versions of the "@openzeppelin/contracts-ethereum-package" Ethereum Package could contain different implementations for persisting aliases such as "ERC20", "ERC721", etc.

An `ImplementationDirectory` is a contract that adopts the `ImplemetationProvider` interface, which simply requires that for a given contract alias or name, the deployed address of a contract is provided. In this particular implementation of the interface, an `ImplementationDirectory` can be frozen, indicating that it will no longer be able to set or unset additional contracts and aliases. This is helpful for making official releases of Ethereum Packages, where the immutability of the package is guaranteed.

Other implementations of the interface could provide contracts without such a limitation, which makes the architecture pretty flexible, yet secure.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/ImplementationDirectory.sol).

### Overview

The following diagram illustrates the interface of the contracts of published Ethereum Packages:

![OpenZeppelin 2.x UML](https://docs.openzeppelin.com/cli/2.8/_images/architecture.png)

[← Configuration Files](https://docs.openzeppelin.com/cli/2.8/configuration)Upgrades - OpenZeppelin Docs

# Upgrades

This crate provides interfaces and utilities related to upgradeability.

## Core

### `IUpgradeable`

```cairo hljs
use openzeppelin_upgrades::interface::IUpgradeable;
```

Interface of an upgradeable contract.

Functions

- [`upgrade(new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#IUpgradeable-upgrade)


#### Functions

#### `upgrade(new_class_hash: ClassHash)` external

Upgrades the contract code by updating its [class hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash/).

|     |     |
| --- | --- |
|  | This function is usually protected by an [Access Control](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access) mechanism. |

### `IUpgradeAndCall`

```cairo hljs
use openzeppelin::upgrades::interface::IUpgradeAndCall;
```

Interface for an upgradeable contract that couples an upgrade with a function call in the upgraded context.

Functions

- [`upgrade_and_call(new_class_hash, selector, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#IUpgradeAndCall-upgrade_and_call)


#### Functions

#### `upgrade_and_call(new_class_hash: ClassHash, selector: felt252, calldata: Span<felt252>) → Span<felt252>` external

Upgrades the contract code by updating its [class hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash/) and calls `selector` with the upgraded context.

|     |     |
| --- | --- |
|  | This function is usually protected by an [Access Control](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access) mechanism. |

### `UpgradeableComponent`

```cairo hljs
use openzeppelin_upgrades::upgradeable::UpgradeableComponent;
```

Upgradeable component.

Internal Implementations

InternalImpl

- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#UpgradeableComponent-upgrade)

- [`upgrade_and_call(self, new_class_hash, selector, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#UpgradeableComponent-upgrade_and_call)


Events

- [`Upgraded(class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#UpgradeableComponent-Upgraded)


#### Internal Functions

#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` internal

Upgrades the contract by updating the contract [class hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash/).

Requirements:

- `new_class_hash` must be different from zero.


Emits an [Upgraded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#UpgradeableComponent-Upgraded) event.

#### `upgrade_and_call(ref self: ContractState, new_class_hash: ClassHash, selector: felt252, calldata: Span<felt252>) → Span<felt252>` internal

Replaces the contract’s class hash with `new_class_hash` and then calls `selector`
from the upgraded context.
This function returns the unwrapped `call_contract_syscall` return value(s), if available, of the `selector` call.

Requirements:

- `new_class_hash` must be different from zero.


|     |     |
| --- | --- |
|  | The function call comes from the upgraded contract itself and not the account. |

|     |     |
| --- | --- |
|  | A similar behavior to `upgrade_and_call` can also be achieved with a list of calls from an account since the [SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md) account standard supports multicall.<br>An account can execute a list of calls with [upgrade](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#IUpgradeable-upgrade) being the first element in the list and the extra function call as the second.<br>With this approach, the calls will execute from the account’s context and can’t be front-ran. |

Emits an [Upgraded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#UpgradeableComponent-Upgraded) event.

#### Events

#### `Upgraded(class_hash: ClassHash)` event

Emitted when the [class hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash/) is upgraded.

[← Upgrades](https://docs.openzeppelin.com/contracts-cairo/0.20.0/upgrades)

[Utilities →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities)ERC20 - OpenZeppelin Docs

# ERC20

This module provides interfaces, presets, and utilities related to ERC20 contracts.

|     |     |
| --- | --- |
|  | For an overview of ERC20, read our [ERC20 guide](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20). |

## Core

### `IERC20`

```cairo hljs
use openzeppelin_token::erc20::interface::IERC20;
```

Interface of the IERC20 standard as defined in [EIP-20](https://eips.ethereum.org/EIPS/eip-20).

Functions

- [`total_supply()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-total_supply)

- [`balance_of()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-balance_of)

- [`allowance(owner, spender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-allowance)

- [`transfer(recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-transfer)

- [`transfer_from(sender, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-transfer_from)

- [`approve(spender, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-approve)


Events

- [`Transfer(from, to, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-Transfer)

- [`Approval(owner, spender, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-Approval)


#### Functions

#### `total_supply() → u256` external

Returns the amount of tokens in existence.

#### `balance_of(account: ContractAddress) → u256` external

Returns the amount of tokens owned by `account`.

#### `allowance(owner: ContractAddress, spender: ContractAddress) → u256` external

Returns the remaining number of tokens that `spender` is allowed to spend on behalf of `owner` through [transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#transfer_from). This is zero by default.

This value changes when [approve](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-approve) or [transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-transfer_from) are called.

#### `transfer(recipient: ContractAddress, amount: u256) → bool` external

Moves `amount` tokens from the caller’s token balance to `to`.
Returns `true` on success, reverts otherwise.

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-Transfer) event.

#### `transfer_from(sender: ContractAddress, recipient: ContractAddress, amount: u256) → bool` external

Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism.
`amount` is then deducted from the caller’s allowance.
Returns `true` on success, reverts otherwise.

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-Transfer) event.

#### `approve(spender: ContractAddress, amount: u256) → bool` external

Sets `amount` as the allowance of `spender` over the caller’s tokens.
Returns `true` on success, reverts otherwise.

Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20-Approval) event.

#### Events

#### `Transfer(from: ContractAddress, to: ContractAddress, value: u256)` event

Emitted when `value` tokens are moved from one address ( `from`) to another ( `to`).

Note that `value` may be zero.

#### `Approval(owner: ContractAddress, spender: ContractAddress, value: u256)` event

Emitted when the allowance of a `spender` for an `owner` is set.
`value` is the new allowance.

### `IERC20Metadata`

```cairo hljs
use openzeppelin_token::erc20::interface::IERC20Metadata;
```

Interface for the optional metadata functions in [EIP-20](https://eips.ethereum.org/EIPS/eip-20).

Functions

- [`name()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata-name)

- [`symbol()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata-symbol)

- [`decimals()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata-decimals)


#### Functions

#### `name() → ByteArray` external

Returns the name of the token.

#### `symbol() → ByteArray` external

Returns the ticker symbol of the token.

#### `decimals() → u8` external

Returns the number of decimals the token uses - e.g. `8` means to divide the token amount by `100000000` to get its user-readable representation.

For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` ( `505 / 10 ** 2`).

Tokens usually opt for a value of `18`, imitating the relationship between Ether and Wei.
This is the default value returned by this function.
To create a custom decimals implementation, see [Customizing decimals](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20#customizing_decimals).

|     |     |
| --- | --- |
|  | This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract. |

### `ERC20Component`

```cairo hljs
use openzeppelin_token::erc20::ERC20Component;
```

ERC20 component extending [IERC20](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20) and [IERC20Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata).

|     |     |
| --- | --- |
|  | See [Hooks](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Hooks) to understand how are hooks used. |

Hooks

ERC20HooksTrait

- [`before_update(self, from, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-before_update)

- [`after_update(self, from, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-after_update)


[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

ERC20MixinImpl

- [`ERC20Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Embeddable-Impls-ERC20Impl)

- [`ERC20MetadataImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Embeddable-Impls-ERC20MetadataImpl)

- [`ERC20CamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Embeddable-Impls-ERC20CamelOnlyImpl)


Embeddable Implementations

ERC20Impl

- [`total_supply(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-total_supply)

- [`balance_of(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-balance_of)

- [`allowance(self, owner, spender)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-allowance)

- [`transfer(self, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-transfer)

- [`transfer_from(self, sender, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-transfer_from)

- [`approve(self, spender, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-approve)


ERC20MetadataImpl

- [`name(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-name)

- [`symbol(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-symbol)

- [`decimals(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-decimals)


ERC20CamelOnlyImpl

- [`totalSupply(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-totalSupply)

- [`balanceOf(self, account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-balanceOf)

- [`transferFrom(self, sender, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-transferFrom)


ERC20PermitImpl

- [`permit(self, owner, spender, amount, deadline, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-permit)

- [`nonces(self, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-nonces)

- [`DOMAIN_SEPARATOR(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-DOMAIN_SEPARATOR)


SNIP12MetadataExternalImpl

- [`snip12_metadata(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-snip12_metadata)


Internal implementations

InternalImpl

- [`initializer(self, name, symbol)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-initializer)

- [`mint(self, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-mint)

- [`burn(self, account, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-burn)

- [`update(self, from, to, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-update)

- [`_transfer(self, sender, recipient, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-_transfer)

- [`_approve(self, owner, spender, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-_approve)

- [`_spend_allowance(self, owner, spender, amount)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-_spend_allowance)


Events

- [`Transfer(from, to, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Transfer)

- [`Approval(owner, spender, value)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Approval)


#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC20Component is expected to provide an implementation of the ERC20HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

|     |     |
| --- | --- |
|  | You can use `openzeppelin_token::erc20::ERC20HooksEmptyImpl` which is already available as part of the library<br>for this purpose. |

#### `before_update(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)` hook

Function executed at the beginning of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-update) function prior to any other logic.

#### `after_update(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)` hook

Function executed at the end of the [update](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-update) function.

#### Embeddable functions

#### `total_supply(@self: ContractState) → u256` external

See [IERC20::total\_supply](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-total_supply).

#### `balance_of(@self: ContractState, account: ContractAddress) → u256` external

See [IERC20::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-balance_of).

#### `allowance(@self: ContractState, owner: ContractAddress, spender: ContractAddress) → u256` external

See [IERC20::allowance](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-allowance).

#### `transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) → bool` external

See [IERC20::transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-transfer).

Requirements:

- `recipient` cannot be the zero address.

- The caller must have a balance of at least `amount`.


#### `transfer_from(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256) → bool` external

See [IERC20::transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-transfer_from).

Requirements:

- `sender` cannot be the zero address.

- `sender` must have a balance of at least `amount`.

- `recipient` cannot be the zero address.

- The caller must have allowance for `sender`'s tokens of at least `amount`.


#### `approve(ref self: ContractState, spender: ContractAddress, amount: u256) → bool` external

See [IERC20::approve](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-approve).

Requirements:

- `spender` cannot be the zero address.


#### `name() → ByteArray` external

See [IERC20Metadata::name](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata-name).

#### `symbol() → ByteArray` external

See [IERC20Metadata::symbol](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata-symbol).

#### `decimals() → u8` external

See [IERC20Metadata::decimals](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Metadata-decimals).

#### `totalSupply(self: @ContractState) → u256` external

See [IERC20::total\_supply](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-total_supply).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).

#### `balanceOf(self: @ContractState, account: ContractAddress) → u256` external

See [IERC20::balance\_of](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-balance_of).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).

#### `transferFrom(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress) → bool` external

See [IERC20::transfer\_from](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-transfer_from).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).

#### `permit(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>) → bool` external

Sets `amount` as the allowance of `spender` over `owner`'s tokens after validating the
signature.

Requirements:

- `owner` is a deployed account contract.

- `spender` is not the zero address.

- `deadline` is not a timestamp in the past.

- `signature` is a valid signature that can be validated with a call to `owner` account.

- `signature` must use the current nonce of the `owner`.


Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20-Approval) event.
Every successful call increases \`owner’s nonce by one.

#### `nonces(self: @ContractState, owner: ContractAddress) → felt252` external

Returns the current nonce of `owner`. A nonce value must be included
whenever a signature for `permit` call is generated.

#### `DOMAIN_SEPARATOR(self: @ContractState) → felt252` external

Returns the domain separator used in generating a message hash for `permit` signature.
The domain hashing logic follows the [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) standard.

#### `snip12_metadata(self: @ContractState) → (felt252, felt252)` external

Returns the domain name and version used to generate the message hash for permit signature.

The returned tuple contains:

- `t.0`: The name used in the [SNIP12Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#snip12) implementation.

- `t.1`: The version used in the [SNIP12Metadata](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#snip12) implementation.


#### Internal functions

#### `initializer(ref self: ContractState, name: ByteArray, symbol: ByteArray)` internal

Initializes the contract by setting the token name and symbol.
This should be used inside of the contract’s constructor.

#### `mint(ref self: ContractState, recipient: ContractAddress, amount: u256)` internal

Creates an `amount` number of tokens and assigns them to `recipient`.

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Transfer) event with `from` being the zero address.

Requirements:

- `recipient` cannot be the zero address.


#### `burn(ref self: ContractState, account: ContractAddress, amount: u256)` internal

Destroys `amount` number of tokens from `account`.

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Transfer) event with `to` set to the zero address.

Requirements:

- `account` cannot be the zero address.


#### `update(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)` internal

Transfers an `amount` of tokens from `from` to `to`, or alternatively mints (or burns) if `from` (or `to`) is
the zero address.

|     |     |
| --- | --- |
|  | This function can be extended using the [ERC20HooksTrait](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-ERC20HooksTrait), to add<br>functionality before and/or after the transfer, mint, or burn. |

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Transfer) event.

#### `_transfer(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256)` internal

Moves `amount` of tokens from `from` to `to`.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic token fees, slashing mechanisms, etc.

Emits a [Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Transfer) event.

Requirements:

- `from` cannot be the zero address.

- `to` cannot be the zero address.

- `from` must have a balance of at least `amount`.


#### `_approve(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)` internal

Sets `amount` as the allowance of `spender` over `owner`'s tokens.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic allowances on behalf of other addresses.

Emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Approval) event.

Requirements:

- `owner` cannot be the zero address.

- `spender` cannot be the zero address.


#### `_spend_allowance(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)` internal

Updates `owner`'s allowance for `spender` based on spent `amount`.

This internal function does not update the allowance value in the case of infinite allowance.

Possibly emits an [Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Approval) event.

#### Events

#### `Transfer(from: ContractAddress, to: ContractAddress, value: u256)` event

See [IERC20::Transfer](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-Transfer).

#### `Approval(owner: ContractAddress, spender: ContractAddress, value: u256)` event

See [IERC20::Approval](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20-Approval).

## Extensions

### `IERC20Permit`

```cairo hljs
use openzeppelin_token::erc20::interface::IERC20Permit;
```

Interface of the ERC20Permit standard to support gasless token approvals as defined in [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612).

Functions

- [`permit(owner, spender, amount, deadline, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Permit-permit)

- [`nonces(owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Permit-nonces)

- [`DOMAIN_SEPARATOR()`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#IERC20Permit-DOMAIN_SEPARATOR)


#### Functions

#### `permit(owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>)` external

Sets `amount` as the allowance of `spender` over `owner`'s tokens after validating the signature.

#### `nonces(owner: ContractAddress) → felt252` external

Returns the current nonce of `owner`. A nonce value must be included
whenever a signature for `permit` call is generated.

#### `DOMAIN_SEPARATOR() → felt252` external

Returns the domain separator used in generating a message hash for `permit` signature.
The domain hashing logic follows the [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) standard.

## Presets

### `ERC20Upgradeable`

```cairo hljs
use openzeppelin_presets::ERC20Upgradeable;
```

Upgradeable ERC20 contract leveraging [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component) with a fixed-supply mechanism for token distribution.

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x041385cd42de9877180b006fc01d613c70e2429fc2e660df6a791b4cc0e747de

Constructor

- [`constructor(self, name, symbol, fixed_supply, recipient, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Upgradeable-constructor)


Embedded Implementations

ERC20MixinImpl

- [`ERC20MixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component-Embeddable-Mixin-Impl)


OwnableMixinImpl

- [`OwnableMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent-Mixin-Impl)


External Functions

- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Upgradeable-upgrade)


#### Constructor

#### `constructor(ref self: ContractState, name: ByteArray, symbol: ByteArray, fixed_supply: u256, recipient: ContractAddress, owner: ContractAddress)` constructor

Sets the `name` and `symbol` and mints `fixed_supply` tokens to `recipient`.
Assigns `owner` as the contract owner with permissions to upgrade.

#### External functions

#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` external

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.

- `new_class_hash` cannot be zero.


[← ERC20Permit](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/erc20-permit)

[ERC721 →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc721)ERC-20 Capped - OpenZeppelin Docs

# ERC-20 Capped

Extension of [ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20) that adds a cap to the supply of tokens.

## Usage

In order to make [`ERC-20 Capped`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/extensions/capped/index.html) methods supervising the supply of tokens, you need to add them by yourself for your final contract as follows:

```rust hljs
use openzeppelin_stylus::{
    token::erc20::{
        extensions::{capped, Capped},
        Erc20, IErc20,
    }
};

sol_storage! {
    #[entrypoint]
    struct Erc20Example {
        #[borrow]
        Erc20 erc20;
        #[borrow]
        Capped capped;
    }
}

#[public]
#[inherit(Erc20, Capped)]
impl Erc20Example {
    // Add token minting feature.
    //
    // Make sure to handle `Capped` properly. You should not call
    // [`Erc20::_update`] to mint tokens -- it will the break `Capped`
    // mechanism.
    pub fn mint(
        &mut self,
        account: Address,
        value: U256,
    ) -> Result<(), Vec<u8>> {
        self.pausable.when_not_paused()?;
        let max_supply = self.capped.cap();

        // Overflow check required.
        let supply = self
            .erc20
            .total_supply()
            .checked_add(value)
            .expect("new supply should not exceed `U256::MAX`");

        if supply > max_supply {
            return Err(capped::Error::ExceededCap(
                capped::ERC20ExceededCap {
                    increased_supply: supply,
                    cap: max_supply,
                },
            ))?;
        }

        self.erc20._mint(account, value)?;
        Ok(())
    }
}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy). Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc20Example {
    // ...

    uint256 private _cap;

    error ERC20InvalidCap(uint256 cap);

    constructor(uint256 cap_) {
        // ...
        if (cap_ == 0) {
            revert ERC20InvalidCap(0);
        }

        _cap = cap_;

        // ...
    }
}
```ERC-721 - OpenZeppelin Docs

# ERC-721

We’ve discussed how you can make a _fungible_ token using [ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20), but what if not all tokens are alike?
This comes up in situations like **real estate**, **voting rights**, or **collectibles**, where some items are valued more than others, due to their usefulness, rarity, etc.
ERC-721 is a standard for representing ownership of [_non-fungible_ tokens](https://docs.openzeppelin.com/contracts-stylus/0.1.0/tokens#different-kinds-of-tokens), that is, where each token is unique.

ERC-721 is a more complex standard than ERC-20, with multiple optional extensions, and is split across a number of contracts.
The OpenZeppelin Contracts provide flexibility regarding how these are combined, along with custom useful extensions.
Check out the [`API reference`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/struct.Erc721.html) to learn more about these.

## Constructing an ERC-721 Token Contract

We’ll use ERC-721 to track items in our game, which will each have their own unique attributes.
Whenever one is to be awarded to a player, it will be minted and sent to them.
Players are free to keep their token or trade it with other people as they see fit, as they would any other asset on the blockchain!
Please note any account can call `awardItem` to mint items.
To restrict what accounts can be minted per item.
We can use an [Access Control](https://docs.openzeppelin.com/contracts-stylus/0.1.0/access-control) extension.

Here’s what a contract for tokenized items might look like:

```rust hljs
sol_storage! {
    #[entrypoint]
    struct GameItem {
        #[borrow]
        Erc721 erc721;
        #[borrow]
        Metadata metadata;
        uint256 _next_token_id;
    }
}

#[public]
#[inherit(Erc721, Metadata)]
impl GameItem {
    pub fn award_item(
        &mut self,
        player: Address,
    ) -> Result<U256, Vec<u8>> {
        let token_id = self._next_token_id.get() + uint!(1_U256);
        self._next_token_id.set(token_id);

        self.erc721._mint(player, token_id)?;

        Ok(token_id)
    }
}
```

The [`Erc721Metadata`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/metadata/struct.Erc721Metadata.html) contract is an extension contract of ERC-721.
It extends the contract itself with the name, symbol and base uri for the token.

Also note that, unlike ERC-20, ERC-721 lacks a `decimals` field, since each token is distinct and cannot be partitioned.

For more information about erc721 schema, check out the [ERC-721 specification](https://eips.ethereum.org/EIPS/eip-721).

|     |     |
| --- | --- |
|  | You’ll notice that the item’s information is included in the metadata, but that information isn’t on-chain!<br>So a game developer could change the underlying metadata, changing the rules of the game! |

## Extensions

Additionally, there are multiple custom extensions, including:

- [ERC-721 Burnable](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721-burnable): A way for token holders to burn their own tokens.

- [ERC-721 Consecutive](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721-consecutive): An implementation of [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) for minting batches of tokens during construction, in accordance with ERC721.

- [ERC-721 Enumerable](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721-enumerable): Optional extension that allows enumerating the tokens on chain, often not included since it requires large gas overhead.

- [ERC-721 Metadata](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721-metadata): Optional extension that adds name, symbol, and token URI, almost always included.

- [ERC-721 Pausable](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721-pausable): A primitive to pause contract operation.

- [ERC-721 Uri Storage](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721-uri-storage): A more flexible but more expensive way of storing metadata.


[← ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20)

[Access Control →](https://docs.openzeppelin.com/contracts-stylus/0.1.0/access-control)Creating ERC20 Supply - OpenZeppelin Docs

# Creating ERC20 Supply

The standard interface implemented by tokens built on Starknet comes from the popular token standard on Ethereum called ERC20.
[EIP20](https://eips.ethereum.org/EIPS/eip-20), from which ERC20 contracts are derived, does not specify how tokens are created.
This guide will go over strategies for creating both a fixed and dynamic token supply.

## Fixed Supply

Let’s say we want to create a token named `MyToken` with a fixed token supply.
We can achieve this by setting the token supply in the constructor which will execute upon deployment.

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        fixed_supply: u256,
        recipient: ContractAddress
    ) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }
}
```

In the constructor, we’re first calling the ERC20 initializer to set the token name and symbol.
Next, we’re calling the internal `mint` function which creates `fixed_supply` of tokens and allocates them to `recipient`.
Since the internal `mint` is not exposed in our contract, it will not be possible to create any more tokens.
In other words, we’ve implemented a fixed token supply!

## Dynamic Supply

ERC20 contracts with a dynamic supply include a mechanism for creating or destroying tokens.
Let’s make a few changes to the almighty `MyToken` contract and create a minting mechanism.

```cairo hljs
#[starknet::contract]
mod MyToken {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

   // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        let name = "MyToken";
        let symbol = "MTK";

        self.erc20.initializer(name, symbol);
    }

    #[external(v0)]
    fn mint(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256
    ) {
        // This function is NOT protected which means
        // ANYONE can mint tokens
        self.erc20.mint(recipient, amount);
    }
}
```

The exposed `mint` above will create `amount` tokens and allocate them to `recipient`.
We now have our minting mechanism!

There is, however, a big problem.
`mint` does not include any restrictions on who can call this function.
For the sake of good practices, let’s implement a simple permissioning mechanism with `Ownable`.

```cairo hljs
#[starknet::contract]
mod MyToken {

    (...)

    // Integrate Ownable

    #[external(v0)]
    fn mint(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256
    ) {
        // Set permissions with Ownable
        self.ownable.assert_only_owner();

        // Mint tokens if called by the contract owner
        self.erc20.mint(recipient, amount);
    }
}
```

In the constructor, we pass the owner address to set the owner of the `MyToken` contract.
The `mint` function includes `assert_only_owner` which will ensure that only the contract owner can call this function.
Now, we have a protected ERC20 minting mechanism to create a dynamic token supply.

|     |     |
| --- | --- |
|  | For a more thorough explanation of permission mechanisms, see [Access Control](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access). |

[← ERC20](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20)

[ERC20Permit →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/erc20-permit)Frequently Asked Questions - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Frequently Asked Questions

## Can I Specify Which Solidity Compiler Version to Use in the OpenZeppelin CLI?

Yes. You can run `openzeppelin compile --solc-version 0.5.14` to compile your contracts with a specific Solidity compiler version e.g. `0.5.14`. This choice will be saved to `.openzeppelin/project.json` for future runs.

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": "my-project",
  "version": "1.0.0",
  "compiler": {
    "manager": "openzeppelin",
    "solcVersion": "0.5.14"
  }
}
```

If you are using `truffle` for compiling your project, you can specify which compiler version to use in your `truffle.js` or `truffle-config.js` file, as you do normally in a truffle 5+ project:

```javascript hljs
// truffle.js
module.exports = {
  compilers: {
     solc: {
       version: "0.5.14"
     }
  }
}
```

## Can I Change Solidity Compiler Versions When Upgrading?

Yes. The Solidity team guarantess that the compiler will [preserve the storage layout accross versions](https://twitter.com/ethchris/status/1073692785176444928).

## Why Am I Getting the Error "Cannot Call Fallback Function From the Proxy Admin"?

This is due to the [Transparent Proxy Pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes). You shouldn’t get this error when using the OpenZeppelin CLI, since it relies on the `ProxyAdmin` contract for managing your proxies.

However, if you are using OpenZeppelin Upgrades programmatically you could potentially run into such error. The solution is to always interact with your proxies from an account that is not the admin of the proxy, unless you want to specifically call the functions of the proxy itself.

## How Can I Create an Upgradeable Instance From Solidity Code?

You can create upgradeable instances from Solidity code by using your project’s [`App`](https://docs.openzeppelin.com/cli/2.8/contracts-architecture#app.sol) contract, and then calling its `create` function from Solidity. Note that to be able to do this, your project needs to be published, that is, it needs to have the OpenZeppelin [Contracts Architecture](https://docs.openzeppelin.com/cli/2.8/contracts-architecture) enabled.

To see an example of how this is done, please refer to the example project [`creating-instances-from-solidity`](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/master/examples/creating-instances-from-solidity).

## Opt-In Usage Data Reporting

In order to better guide the development of our tools, we ask users if they would like to opt in to contributing anonymized logs of their usage of the OpenZeppelin CLI. In this document we explain exactly what data we collect and how we anonymize it. Please visit [https://openzeppelin.com/privacy](https://openzeppelin.com/privacy) for further information about our privacy practices.

When you run the OpenZeppelin CLI for the first time we ask if you would like to opt in to contributing usage logs. This is a setting that will be stored globally and will apply to future projects. You can opt-out at any time, and you can also choose to opt out on a per-project basis.

If you choose to you opt in, we generate a random user identifier and a random 32-byte salt.

Every `openzeppelin` subcommand you run will be first anonymized by hashing each argument together with the random salt. Note that this only applies to user-specific arguments (e.g. the name of a contract, or an address), and not to the flags themselves (e.g. `--force`). The anonymized commands will be logged on our servers together with the random user identifier, the network that they were run in, as well as general information about the environment (platform, architecture, and versions of node, the CLI, and web3 dependencies).

[← Migrating CLI version](https://docs.openzeppelin.com/cli/2.8/migrate-cli-versions)

[Upgrades Library →](https://docs.openzeppelin.com/upgrades/2.8/)Utilities - OpenZeppelin Docs

# Utilities

|     |     |
| --- | --- |
|  | This document is better viewed at [https://docs.openzeppelin.com/community-contracts/utils](https://docs.openzeppelin.com/community-contracts/utils) |

Miscellaneous contracts and libraries containing utility functions you can use to improve security, work with new data types, or safely use low-level primitives.

- [`AbstractSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner): Abstract contract for internal signature validation in smart contracts.

- [`ERC7739`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739): An abstract contract to validate signatures following the rehashing scheme from `ERC7739Utils`.

- [`ERC7739Utils`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739Utils): Utilities library that implements a defensive rehashing mechanism to prevent replayability of smart contract signatures based on ERC-7739.

- [`SignerECDSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA), [`SignerP256`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256), [`SignerRSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerRSA): Implementations of an [`AbstractSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner) with specific signature validation algorithms.

- [`Masks`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#Masks): Library to handle `bytes32` masks.


## Cryptography

### `AbstractSigner`

```solidity hljs
import "@openzeppelin/community-contracts/utils/cryptography/AbstractSigner.sol";
```

Abstract contract for signature validation.

Developers must implement [`_rawSignatureValidation`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner-_rawSignatureValidation-bytes32-bytes-) and use it as the lowest-level signature validation mechanism.

Functions

- `_rawSignatureValidation(hash, signature)`


#### `_rawSignatureValidation(bytes32 hash, bytes signature) → bool` internal

Signature validation algorithm.

|     |     |
| --- | --- |
|  | Implementing a signature validation algorithm is a security-sensitive operation as it involves<br>cryptographic verification. It is important to review and test thoroughly before deployment. Consider<br>using one of the signature verification libraries ( [ECDSA](https://docs.openzeppelin.com/contracts/api/utils#ECDSA),<br>[P256](https://docs.openzeppelin.com/contracts/api/utils#P256) or [RSA](https://docs.openzeppelin.com/contracts/api/utils#RSA)). |

### `ERC7739`

```solidity hljs
import "@openzeppelin/community-contracts/utils/cryptography/ERC7739.sol";
```

Validates signatures wrapping the message hash in a nested EIP712 type. See [`ERC7739Utils`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739Utils).

Linking the signature to the EIP-712 domain separator is a security measure to prevent signature replay across different
EIP-712 domains (e.g. a single offchain owner of multiple contracts).

This contract requires implementing the [`_rawSignatureValidation`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner-_rawSignatureValidation-bytes32-bytes-) function, which passes the wrapped message hash,
which may be either an typed data or a personal sign nested type.

|     |     |
| --- | --- |
|  | [EIP-712](https://docs.openzeppelin.com/contracts/api/utils#EIP712) uses<br>[ShortStrings](https://docs.openzeppelin.com/contracts/api/utils#ShortStrings) to optimize gas costs for<br>short strings (up to 31 characters). Consider that strings longer than that will use storage, which<br>may limit the ability of the signer to be used within the ERC-4337 validation phase (due to<br>[ERC-7562 storage access rules](https://eips.ethereum.org/EIPS/eip-7562#storage-rules)). |

Functions

- `isValidSignature(hash, signature)`


EIP712

- `_domainSeparatorV4()`

- `_hashTypedDataV4(structHash)`

- `eip712Domain()`

- `_EIP712Name()`

- `_EIP712Version()`


AbstractSigner

- `_rawSignatureValidation(hash, signature)`


Events

IERC5267

- `EIP712DomainChanged()`


#### `isValidSignature(bytes32 hash, bytes signature) → bytes4 result` public

Attempts validating the signature in a nested EIP-712 type.

A nested EIP-712 type might be presented in 2 different ways:

- As a nested EIP-712 typed data

- As a _personal_ signature (an EIP-712 mimic of the `eth_personalSign` for a smart contract)


### `ERC7739Utils`

```solidity hljs
import "@openzeppelin/community-contracts/utils/cryptography/ERC7739Utils.sol";
```

Utilities to process [ERC-7739](https://ercs.ethereum.org/ERCS/erc-7739) typed data signatures
that are specific to an EIP-712 domain.

This library provides methods to wrap, unwrap and operate over typed data signatures with a defensive
rehashing mechanism that includes the application’s
[EIP-712](https://docs.openzeppelin.com/contracts/api/utils#EIP712-_domainSeparatorV4)
and preserves readability of the signed content using an EIP-712 nested approach.

A smart contract domain can validate a signature for a typed data structure in two ways:

- As an application validating a typed data signature. See [`typedDataSignStructHash`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739Utils-typedDataSignStructHash-string-bytes32-bytes-).

- As a smart contract validating a raw message signature. See [`personalSignStructHash`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739Utils-personalSignStructHash-bytes32-).


|     |     |
| --- | --- |
|  | A provider for a smart contract wallet would need to return this signature as the<br>result of a call to `personal_sign` or `eth_signTypedData`, and this may be unsupported by<br>API clients that expect a return value of 129 bytes, or specifically the `r,s,v` parameters<br>of an [ECDSA](https://docs.openzeppelin.com/contracts/api/utils#ECDSA) signature, as is for<br>example specified for [EIP-712](https://docs.openzeppelin.com/contracts/api/utils#EIP712). |

Functions

- `encodeTypedDataSig(signature, appSeparator, contentsHash, contentsDescr)`

- `decodeTypedDataSig(encodedSignature)`

- `personalSignStructHash(contents)`

- `typedDataSignStructHash(contentsTypeName, contentsType, contentsHash, domainBytes)`

- `typedDataSignStructHash(contentsDescr, contentsHash, domainBytes)`

- `typedDataSignTypehash(contentsTypeName, contentsType)`

- `decodeContentsDescr(contentsDescr)`


Errors

- `InvalidContentsType()`


#### `encodeTypedDataSig(bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr) → bytes` internal

Nest a signature for a given EIP-712 type into a nested signature for the domain of the app.

Counterpart of [`decodeTypedDataSig`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739Utils-decodeTypedDataSig-bytes-) to extract the original signature and the nested components.

#### `decodeTypedDataSig(bytes encodedSignature) → bytes signature, bytes32 appSeparator, bytes32 contentsHash, string contentsDescr` internal

Parses a nested signature into its components.

Constructed as follows:

`signature ‖ DOMAIN_SEPARATOR ‖ contentsHash ‖ contentsDescr ‖ uint16(contentsDescr.length)`

- `signature` is the original signature for the nested struct hash that includes the "contents" hash

- `DOMAIN_SEPARATOR` is the EIP-712 {EIP712-\_domainSeparatorV4} of the smart contract verifying the signature

- `contentsHash` is the hash of the underlying data structure or message

- `contentsDescr` is a descriptor of the "contents" part of the the EIP-712 type of the nested signature


#### `personalSignStructHash(bytes32 contents) → bytes32` internal

Nests an `ERC-191` digest into a `PersonalSign` EIP-712 struct, and return the corresponding struct hash.
This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash} before
being verified/recovered.

This is used to simulates the `personal_sign` RPC method in the context of smart contracts.

#### `typedDataSignStructHash(string contentsTypeName, string contentsType, bytes32 contentsHash, bytes domainBytes) → bytes32 result` internal

Nests an `EIP-712` hash ( `contents`) into a `TypedDataSign` EIP-712 struct, and return the corresponding
struct hash. This struct hash must be combined with a domain separator, using {MessageHashUtils-toTypedDataHash}
before being verified/recovered.

#### `typedDataSignStructHash(string contentsDescr, bytes32 contentsHash, bytes domainBytes) → bytes32 result` internal

Variant of {typedDataSignStructHash-string-string-bytes32-string-bytes} that takes a content descriptor
and decodes the `contentsTypeName` and `contentsType` out of it.

#### `typedDataSignTypehash(string contentsTypeName, string contentsType) → bytes32` internal

Compute the EIP-712 typehash of the `TypedDataSign` structure for a given type (and typename).

#### `decodeContentsDescr(string contentsDescr) → string contentsTypeName, string contentsType` internal

Parse the type name out of the ERC-7739 contents type description. Supports both the implicit and explicit
modes.

Following ERC-7739 specifications, a `contentsTypeName` is considered invalid if it’s empty or it contains
any of the following bytes , )\\x00

If the `contentsType` is invalid, this returns an empty string. Otherwise, the return string has non-zero
length.

#### `InvalidContentsType()` error

Error when the contents type is invalid. See {tryValidateContentsType}.

### `SignerECDSA`

```solidity hljs
import "@openzeppelin/community-contracts/utils/cryptography/SignerECDSA.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner) using
[ECDSA](https://docs.openzeppelin.com/contracts/api/utils#ECDSA) signatures.

For [`Account`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#Account) usage, an [`_setSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA-_setSigner-address-) function is provided to set the [`signer`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA-signer--) address.
Doing so it’s easier for a factory, whose likely to use initializable clones of this contract.

Example of usage:

```solidity hljs
contract MyAccountECDSA is Account, SignerECDSA, Initializable {
    constructor() EIP712("MyAccountECDSA", "1") {}

    function initialize(address signerAddr) public initializer {
      _setSigner(signerAddr);
    }
}
```

|     |     |
| --- | --- |
|  | Avoiding to call [`_setSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA-_setSigner-address-) either during construction (if used standalone)<br>or during initialization (if used as a clone) may leave the signer either front-runnable or unusable. |

Functions

- `_setSigner(signerAddr)`

- `signer()`

- `_rawSignatureValidation(hash, signature)`


#### `_setSigner(address signerAddr)` internal

Sets the signer with the address of the native signer. This function should be called during construction
or through an initializater.

#### `signer() → address` public

Return the signer’s address.

#### `_rawSignatureValidation(bytes32 hash, bytes signature) → bool` internal

Signature validation algorithm.

|     |     |
| --- | --- |
|  | Implementing a signature validation algorithm is a security-sensitive operation as it involves<br>cryptographic verification. It is important to review and test thoroughly before deployment. Consider<br>using one of the signature verification libraries ( [ECDSA](https://docs.openzeppelin.com/contracts/api/utils#ECDSA),<br>[P256](https://docs.openzeppelin.com/contracts/api/utils#P256) or [RSA](https://docs.openzeppelin.com/contracts/api/utils#RSA)). |

### `SignerP256`

```solidity hljs
import "@openzeppelin/community-contracts/utils/cryptography/SignerP256.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner) using
[P256](https://docs.openzeppelin.com/contracts/api/utils#P256) signatures.

For [`Account`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#Account) usage, an [`_setSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256-_setSigner-bytes32-bytes32-) function is provided to set the [`signer`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256-signer--) public key.
Doing so it’s easier for a factory, whose likely to use initializable clones of this contract.

Example of usage:

```solidity hljs
contract MyAccountP256 is Account, SignerP256, Initializable {
    constructor() EIP712("MyAccountP256", "1") {}

    function initialize(bytes32 qx, bytes32 qy) public initializer {
      _setSigner(qx, qy);
    }
}
```

|     |     |
| --- | --- |
|  | Avoiding to call [`_setSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256-_setSigner-bytes32-bytes32-) either during construction (if used standalone)<br>or during initialization (if used as a clone) may leave the signer either front-runnable or unusable. |

Functions

- `_setSigner(qx, qy)`

- `signer()`

- `_rawSignatureValidation(hash, signature)`


Errors

- `SignerP256InvalidPublicKey(qx, qy)`


#### `_setSigner(bytes32 qx, bytes32 qy)` internal

Sets the signer with a P256 public key. This function should be called during construction
or through an initializater.

#### `signer() → bytes32 qx, bytes32 qy` public

Return the signer’s P256 public key.

#### `_rawSignatureValidation(bytes32 hash, bytes signature) → bool` internal

Signature validation algorithm.

|     |     |
| --- | --- |
|  | Implementing a signature validation algorithm is a security-sensitive operation as it involves<br>cryptographic verification. It is important to review and test thoroughly before deployment. Consider<br>using one of the signature verification libraries ( [ECDSA](https://docs.openzeppelin.com/contracts/api/utils#ECDSA),<br>[P256](https://docs.openzeppelin.com/contracts/api/utils#P256) or [RSA](https://docs.openzeppelin.com/contracts/api/utils#RSA)). |

#### `SignerP256InvalidPublicKey(bytes32 qx, bytes32 qy)` error

### `SignerRSA`

```solidity hljs
import "@openzeppelin/community-contracts/utils/cryptography/SignerRSA.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner) using
[RSA](https://docs.openzeppelin.com/contracts/api/utils#RSA) signatures.

For [`Account`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#Account) usage, an [`_setSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerRSA-_setSigner-bytes-bytes-) function is provided to set the [`signer`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerRSA-signer--) public key.
Doing so it’s easier for a factory, whose likely to use initializable clones of this contract.

Example of usage:

```solidity hljs
contract MyAccountRSA is Account, SignerRSA, Initializable {
    constructor() EIP712("MyAccountRSA", "1") {}

    function initialize(bytes memory e, bytes memory n) public initializer {
      _setSigner(e, n);
    }
}
```

|     |     |
| --- | --- |
|  | Avoiding to call [`_setSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerRSA-_setSigner-bytes-bytes-) either during construction (if used standalone)<br>or during initialization (if used as a clone) may leave the signer either front-runnable or unusable. |

Functions

- `_setSigner(e, n)`

- `signer()`

- `_rawSignatureValidation(hash, signature)`


#### `_setSigner(bytes e, bytes n)` internal

Sets the signer with a RSA public key. This function should be called during construction
or through an initializater.

#### `signer() → bytes e, bytes n` public

Return the signer’s RSA public key.

#### `_rawSignatureValidation(bytes32 hash, bytes signature) → bool` internal

Signature validation algorithm.

|     |     |
| --- | --- |
|  | Implementing a signature validation algorithm is a security-sensitive operation as it involves<br>cryptographic verification. It is important to review and test thoroughly before deployment. Consider<br>using one of the signature verification libraries ( [ECDSA](https://docs.openzeppelin.com/contracts/api/utils#ECDSA),<br>[P256](https://docs.openzeppelin.com/contracts/api/utils#P256) or [RSA](https://docs.openzeppelin.com/contracts/api/utils#RSA)). |

## Libraries

### `Masks`

```solidity hljs
import "@openzeppelin/community-contracts/utils/Masks.sol";
```

Library for handling bit masks

Functions

- `toMask(group)`

- `toMask(groups)`

- `get(self, group)`

- `isEmpty(self)`

- `complement(m1)`

- `union(m1, m2)`

- `intersection(m1, m2)`

- `difference(m1, m2)`

- `symmetricDifference(m1, m2)`


#### `toMask(uint8 group) → Masks.Mask` internal

Returns a new mask with the bit at `group` index set to 1.

#### `toMask(uint8[] groups) → Masks.Mask` internal

Returns a new mask with the bits at `groups` indices set to 1.

#### `get(Masks.Mask self, uint8 group) → bool` internal

Get value of the mask at `group` index

#### `isEmpty(Masks.Mask self) → bool` internal

Whether the mask is `bytes32(0)`

#### `complement(Masks.Mask m1) → Masks.Mask` internal

Invert the bits of a mask

#### `union(Masks.Mask m1, Masks.Mask m2) → Masks.Mask` internal

Perform a bitwise OR operation on two masks

#### `intersection(Masks.Mask m1, Masks.Mask m2) → Masks.Mask` internal

Perform a bitwise AND operation on two masks

#### `difference(Masks.Mask m1, Masks.Mask m2) → Masks.Mask` internal

Perform a bitwise difference operation on two masks (m1 - m2)

#### `symmetricDifference(Masks.Mask m1, Masks.Mask m2) → Masks.Mask` internal

Returns the symmetric difference (∆) of two masks, also known as disjunctive union or exclusive OR (XOR)

[← Token](https://docs.openzeppelin.com/community-contracts/0.0.1/api/token)Upgrades - OpenZeppelin Docs

# Upgrades

In different blockchains, multiple patterns have been developed for making a contract upgradeable including the widely adopted proxy patterns.

Starknet has native upgradeability through a syscall that updates the contract source code, removing [the need for proxies](https://docs.openzeppelin.com/contracts-cairo/0.20.0/upgrades#proxies_in_starknet).

|     |     |
| --- | --- |
|  | Make sure you follow [our security recommendations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/upgrades#security) before upgrading. |

## Replacing contract classes

To better comprehend how upgradeability works in Starknet, it’s important to understand the difference between a contract and its contract class.

[Contract Classes](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/contract-classes/) represent the source code of a program. All contracts are associated to a class, and many contracts can be instances of the same one. Classes are usually represented by a [class hash](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/class-hash/), and before a contract of a class can be deployed, the class hash needs to be declared.

### `replace_class_syscall`

The `replace_class` syscall allows a contract to update its source code by replacing its class hash once deployed.

```cairo hljs
/// Upgrades the contract source code to the new contract class.
fn upgrade(new_class_hash: ClassHash) {
    assert(!new_class_hash.is_zero(), 'Class hash cannot be zero');
    starknet::replace_class_syscall(new_class_hash).unwrap_syscall();
}
```

|     |     |
| --- | --- |
|  | If a contract is deployed without this mechanism, its class hash can still be replaced through [library calls](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#library_call). |

## `Upgradeable` component

OpenZeppelin Contracts for Cairo provides [Upgradeable](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.20.0/packages/upgrades/src/upgradeable.cairo) to add upgradeability support to your contracts.

### Usage

Upgrades are often very sensitive operations, and some form of access control is usually required to
avoid unauthorized upgrades. The [Ownable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access#ownership_and_ownable) module is used in this example.

|     |     |
| --- | --- |
|  | We will be using the following module to implement the [IUpgradeable](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades#IUpgradeable) interface described in the API Reference section. |

```cairo hljs
#[starknet::contract]
mod UpgradeableContract {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::ClassHash;
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, owner: ContractAddress) {
        self.ownable.initializer(owner);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            // This function can only be called by the owner
            self.ownable.assert_only_owner();

            // Replace the class hash upgrading the contract
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

## Security

Upgrades can be very sensitive operations, and security should always be top of mind while performing one. Please make sure you thoroughly review the changes and their consequences before upgrading. Some aspects to consider are:

- API changes that might affect integration. For example, changing an external function’s arguments might break existing contracts or offchain systems calling your contract.

- Storage changes that might result in lost data (e.g. changing a storage slot name, making existing storage inaccessible).

- Collisions (e.g. mistakenly reusing the same storage slot from another component) are also possible, although less likely if best practices are followed, for example prepending storage variables with the component’s name (e.g. `ERC20_balances`).

- Always check for [backwards compatibility](https://docs.openzeppelin.com/contracts-cairo/0.20.0/backwards-compatibility) before upgrading between versions of OpenZeppelin Contracts.


## Proxies in Starknet

Proxies enable different patterns such as upgrades and clones. But since Starknet achieves the same in different ways is that there’s no support to implement them.

In the case of contract upgrades, it is achieved by simply changing the contract’s class hash. As of clones, contracts already are like clones of the class they implement.

Implementing a proxy pattern in Starknet has an important limitation: there is no fallback mechanism to be used
for redirecting every potential function call to the implementation. This means that a generic proxy contract
can’t be implemented. Instead, a limited proxy contract can implement specific functions that forward
their execution to another contract class.
This can still be useful for example to upgrade the logic of some functions.

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades)Universal Deployer - OpenZeppelin Docs

# Universal Deployer

Reference of the Universal Deployer Contract (UDC) interface and preset.

## Core

### `IUniversalDeployer`

```cairo hljs
use openzeppelin_utils::interfaces::IUniversalDeployer;
```

Functions

- [`deploy_contract(class_hash, salt, from_zero, calldata)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#IUniversalDeployer-deploy_contract)


Events

- [`ContractDeployed(address, deployer, from_zero, class_hash, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#IUniversalDeployer-ContractDeployed)


#### Functions

#### `deploy_contract(class_hash: ClassHash, salt: felt252, from_zero: bool, calldata: Span<felt252>) → ContractAddress` external

Deploys a contract through the Universal Deployer Contract.

#### Events

#### `ContractDeployed(address: ContractAddress, deployer: ContractAddress, from_zero: bool, class_hash: ClassHash, calldata: Span<felt252>, salt: felt252)` event

Emitted when `deployer` deploys a contract through the Universal Deployer Contract.

## Presets

### `UniversalDeployer`

```cairo hljs
use openzeppelin_presets::UniversalDeployer;
```

The standard Universal Deployer Contract.

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x06b79a175c8be9fb2acf40a1b0289018c95d04092dd4f080a133d83f9e9c696b

Embedded Implementations

UniversalDeployerImpl

- [`deploy_contract(self, address, deployer, from_zero, class_hash, calldata, salt)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#UniversalDeployer-deploy_contract)


#### `deploy_contract(ref self: ContractState, address: ContractAddress, deployer: ContractAddress, from_zero: bool, class_hash: ClassHash, calldata: Span<felt252>, salt: felt252) -> ContractAddress` external

Deploys a contract through the Universal Deployer Contract.

When `from_zero` is `false`, `salt` is hashed with the caller address and the modified salt is passed to the inner `deploy_syscall`. This type of deployment is [origin-dependent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc#origin_dependent).

When `from_zero` is `true`, the deployment type is [origin-independent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc#origin_independent).

Emits an [ContractDeployed](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/udc#IUniversalDeployer-ContractDeployed) event.

[← Universal Deployer Contract](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc)

[Upgrades →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/upgrades)Using the OpenZeppelin CLI With Truffle - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Using the OpenZeppelin CLI With Truffle

Truffle is a framework for writing, compiling, deploying and testing smart contracts. You’ll notice we haven’t used it so far - this is because the OpenZeppelin tools are self-sufficient. It brings its own compiler along, its own habits and best practices, its own configuration files, and with some of the starter kits even its own UI elements and frameworks. But what if you’re used to Truffle and prefer it for the additional features it can offer? Do you need to pick between the OpenZeppelin CLI and Truffle now?

That’s a definitive _No_, captain. Let’s see how we can use them together.

This tutorial assumes you’ve gone through the [basic SDK guide](https://docs.openzeppelin.com/sdk/first) and have at least a passing familiarity with Truffle.

## Prerequisites

We’ll assume that you have:

- NodeJS and NPM installed, preferably via NVM

- Ganache installed and available on the command line via `ganache-cli`

- OpenZeppelin SDK installed and available on the command line, either globally or via NPX


All of these conditions should be met if you’ve gone through the [basic guide](https://docs.openzeppelin.com/sdk/first), so if you haven’t please do so now.

|     |     |
| --- | --- |
|  | If you have installed OpenZeppelin SDK globally, you will have to either install it again locally ( `npm install @openzeppelin/cli`) or link to it with `npm link @openzeppelin/cli` which creates a symlink from the globally installed module to your local folder (works on newer versions of Windows 10, too). This is because there’s no easier way to import globally installed Node modules into local scripts. |

## Configuration

When initializing a project with OpenZeppelin SDK, you’ll get a `network.js` file containing something like this:

```js hljs language-javascript
module.exports = {
  networks: {
    development: {
      protocol: 'http',
      host: 'localhost',
      port: 8545,
      gas: 5000000,
      gasPrice: 5e9,
      networkId: '*',
    },
  },
};
```

This configuration makes OpenZeppelin SDK default to a locally running instance of a blockchain, usually Ganache. With Truffle, the configuration is in `truffle-config.js` or `truffle.js`, so in most cases all you need to integrate the two is just make sure that file exists. If it does, OpenZeppelin SDK will default to reading that one for network settings and offer those network names to you when you invoke CLI commands. That said, let’s look at ways to integrate the two.

## Adding Truffle to an OpenZeppelin SDK project

In your example project (the one created by the [basic guide](https://docs.openzeppelin.com/sdk/first)), run `npm install truffle`. Alternatively, have Truffle installed globally so it’s accessible from everywhere ( `npm install -g truffle`) without having to run it with `npx`. We’ll use the `npx` approach in this guide - it makes it possible to use a specific Truffle version per project.

Once Truffle is installed, run `truffle init` in the project folder to initialize the project, or manually create the `truffle-config.js` file.

|     |     |
| --- | --- |
|  | if you say _yes_ when asked to overwrite an existing folder, e.g. if you already had a contracts folder, the contents of that folder will be deleted! The recommended approach is making a backup copy of the contracts folder, running `truffle init` with overwrites, and then merging the contents of the two folders later. |

If you used `init`, you should now have a very verbose `truffle-config.js` file in your project directory which, when the commented out examples are stripped out, comes down to this:

```js hljs language-javascript
module.exports = {
  networks: {
    development: {
     host: "127.0.0.1",
     port: 8545,
     network_id: "*",
    },
  },

  compilers: {
    solc: {
      version: "0.5.2",
      docker: false,
      settings: {
       optimizer: {
         enabled: true,
         runs: 200
       },
       evmVersion: "byzantium"
      }
    }
  }
}
```

If you created `truffle-config.js` from scratch, paste this in. If not, feel free to just uncomment the relevant lines or just paste this over everything. We can now delete OpenZeppelin’s `networks.js` file.

You should also have a file `contracts/Migrations.sol`. If you don’t, create it with the following content:

```sol hljs language-solidity
pragma solidity >=0.4.21 <0.6.0;

contract Migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}
```

If you now run `openzeppelin create` or any other `openzeppelin` command that depends on compiling first, it will call `truffle compile` under the hood before proceeding with the other operations. The SDK will let you know about this:

```bash hljs
λ openzeppelin create
√ Compiling contracts with Truffle, using settings from truffle.js file
Truffle output:

Compiling your contracts...
===========================
> Compiling .\contracts\Counter.sol
> Artifacts written to ~\repos\openzeppelin-sdk-guide\build\contracts
> Compiled successfully using:
   - solc: 0.5.2+commit.1df8f40c.Emscripten.clang

? Pick a contract to instantiate ...
```

If you decide to instead recompile with OpenZeppelin, you can force this with `openzeppelin compile` which always compiles with OZ SDK.

Note that network settings are **always** read from Truffle’s configuration if present and will fall back to OpenZeppelin’s `network.js` if not.

## Adding OpenZeppelin SDK to a Truffle project

To add OZ SDK to a Truffle project, simply install OpenZeppelin locally or globally and `openzeppelin init` in the Truffle project’s folder. The `networks.js` file will not be created as OpenZeppelin will detect that it’s initializing in a Truffle folder. OpenZeppelin’s SDK is careful about overwriting essential files, so it won’t cause any conflicts like those that might occur when adding Truffle into an OZ project.

## Migrations

Now that the projects are merged, let’s see how we perform some Migrations - Truffle’s incremental, linked deployments to the blockchain. Migrations are useful when you want to bootstrap a project; like making sure that contracts link to each other properly, ensuring that values are initialized, and so on. By removing human errors and fat fingers from the process of a project’s launch, you make the whole thing much safer.

Our simple Counter contract gets deployed with a value of 0, so let’s write a migration which immediately sends a transaction increasing the value by 10.

OpenZeppelin’s SDK comes with a JavaScript interface which the CLI also uses to execute commands. We can invoke those if we import them in another project or script - like a Truffle migration.

Truffle comes with a default migration which makes subsequent migrations possible. Migrations are executed oredered by prefix - so if the name of a new migration file starts with 2, it will execute after `1_initial_migration.js`. Let’s create `2_deploy_counter.js` with the content:

```js hljs language-javascript
const { scripts, ConfigManager } = require('@openzeppelin/cli');
const { add, push, create } = scripts;

async function deploy(options) {
  add({ contractsData: [{ name: 'Counter', alias: 'Counter' }] });
  await push(options);
  await create(Object.assign({ contractAlias: 'Counter' }, options));
}

module.exports = function(deployer, networkName, accounts) {
  deployer.then(async () => {
    const { network, txParams } = await ConfigManager.initNetworkConfiguration({ network: networkName, from: accounts[0] })
    await deploy({ network, txParams })
  })
}
```

Let’s test it. Run:

```bash hljs
truffle migrate --network development
```

```bash hljs
λ npx truffle migrate --network development
Compiling .\contracts\Counter.sol...
Compiling .\contracts\Migrations.sol...
Writing artifacts to .\build\contracts
```

|     |     |
| --- | --- |
|  | If you’re using an HDWalletProvider, it must be Web3 1.0 enabled or your migration will hang. |

```
Starting migrations...
======================
> Network name:    'development'
> Network id:      1564927897006
> Block gas limit: 6721975

1_initial_migration.js
======================

   Deploying 'Migrations'
   ----------------------
   > transaction hash:    0x18fd35c7395f6dbc2ad39a6cef6bbb05af41f3c1b24a7abdef7066ff14e9d0b2
   > Blocks: 0            Seconds: 0
   > contract address:    0xe78A0F7E598Cc8b0Bb87894B0F60dD2a88d6a8Ab
   > account:             0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1
   > balance:             99.99557658
   > gas used:            221171
   > gas price:           20 gwei
   > value sent:          0 ETH
   > total cost:          0.00442342 ETH

   > Saving artifacts
   -------------------------------------
   > Total cost:          0.00442342 ETH

2_deploy_counter.js
===================
0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B
   -------------------------------------
   > Total cost:                   0 ETH

Summary
=======
> Total deployments:   1
> Final cost:          0.00442342 ETH
```

It works! Let’s make sure and re-run migrations, it should tell us that we’re up to date.

```bash hljs
λ npx truffle migrate

Compiling your contracts...
===========================
> Everything is up to date, there is nothing to compile.

Network up to date.
```

Our counter is deployed but to make sure let’s check if we can interact with it. We’ll use OZ SDK.

```bash hljs
λ openzeppelin call
? Pick a network development
? Pick an instance Counter at 0x254dffcd3277C0b1660F6d42EFbB754edaBAbC2B
? Select which function value()
√ Method 'value()' returned: 0
0
```

Perfect. Now let’s make the second migration which increases the counter value by 10. Create `migrations/3_increment.js`.

```js hljs language-javascript
const Counter = artifacts.require("Counter");

module.exports = async function(deployer) {
    const counter = await Counter.deployed();
    await counter.increase(10);
};
```

You’ll notice we used Truffle’s default migration process instead of `sendTx` or `call`, like we would when interacting with OpenZeppelin’s SDK on the command line. This is because the JavaScript API does not have those helper functions exported for the moment (a pending change), so we have to interact with contracts _the old way_.

## Caveats

Once you start using Truffle in an OpenZeppelin SDK project, it’s recommended you keep using it and don’t mix and match other than in the context of migration scripts where you can use the OpenZeppelin SDK API as much as you wish. The reason is that OpenZeppelin will not respect the migrations deployed by Truffle as it is not aware of them, and will instead deploy its own copy of the contracts you’re creating, possibly causing conflicts.

* * *

Now that you know the fusion of Truffle and OpenZeppelin SDK is a possibility, go forth, #buidl and [let us know](https://twitter.com/openzeppelin) what you created!

[← Deploying With `CREATE2`](https://docs.openzeppelin.com/cli/2.6/deploying-with-create2)

[Frequently Asked Questions →](https://docs.openzeppelin.com/cli/2.6/faq)ERC-721 Burnable - OpenZeppelin Docs

# ERC-721 Burnable

[ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) Token that can be burned (destroyed).

## Usage

In order to make [`ERC-721 Burnable`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/burnable/index.html) methods “external” so that other contracts can call them, you need to implement them by yourself for your final contract as follows:

```rust hljs
use openzeppelin_stylus::{
    token::erc721::{
        extensions::IErc721Burnable,
        Erc721, IErc721,
    },
};

sol_storage! {
    #[entrypoint]
    struct Erc721Example {
        #[borrow]
        Erc721 erc721;
    }
}

#[public]
#[inherit(Erc721)]
impl Erc721Example {
    pub fn burn(&mut self, token_id: U256) -> Result<(), Vec<u8>> {
        // ...
        self.erc721.burn(token_id).map_err(|e| e.into())
    }
}
```ERC-20 Metadata - OpenZeppelin Docs

# ERC-20 Metadata

Extension of [ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20) that adds the optional metadata functions from the ERC20 standard.

## Usage

In order to make [`ERC-20 Metadata`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/extensions/metadata/index.html) methods “external” so that other contracts can call them, you need to add the following code to your contract:

```rust hljs
use openzeppelin_stylus::{
    token::erc20::{
        extensions::Erc20Metadata,
        Erc20,
    },
};

sol_storage! {
    #[entrypoint]
    struct Erc20Example {
        #[borrow]
        Erc20 erc20;
        #[borrow]
        Erc20Metadata metadata;
    }
}

#[public]
#[inherit(Erc20, Erc20Metadata, Capped, Pausable)]
impl Erc20Example {
    // ...
}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy). Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc20Example {
    // ...

    string private _name;
    string private _symbol;

    constructor(string memory name_, string memory symbol_) {
        // ...

        _name = name_;
        _symbol = symbol_;

        // ...
    }
}
```Getting Started - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Getting Started

This tutorial will showcase usage of the OpenZeppelin CLI, giving you a taste of its capabilities and serving as a starting point for your own projects.

We will cover:
\\* Create a new OpenZeppelin project with a smart contract
\\* Deploying our contract to a local development network
\\* Interacting with our contract from the terminal
\\* Upgrading the deployed contract to a new version

## Prerequisites

The CLI is installed as a dependency to your Node project:

```console hljs language-shell
$ npm install @openzeppelin/cli
```

|     |     |
| --- | --- |
|  | If you’re unfamiliar with Node and npm, head to our guide on [Setting Up a Node Project](https://docs.openzeppelin.com/learn/setting-up-a-node-project). |

We are installing the CLI [locally](https://docs.npmjs.com/downloading-and-installing-packages-locally) instead of [globally](https://docs.npmjs.com/downloading-and-installing-packages-globally), which means usage of the CLI will be prefixed with `npx`. This will avoid issues that arise from having global dependencies, and will let you have different versions of the CLI in each of your projects, if you so desire.

## Setting up Your Project

Inside your Node project, use the CLI to initialize an OpenZeppelin project:

```console hljs language-shell
$ npx openzeppelin init
```

The CLI will prompt you for a project name and version, defaulting to the ones from the `package.json`, and then set up a few files and directories for running your OpenZeppelin project.

|     |     |
| --- | --- |
|  | If you’d rather type less, you can use the `oz` command alias, so `openzeppelin init` becomes just `oz init`. We’ll use this throughout the tutorial. |

We are now ready to begin working on our project.

|     |     |
| --- | --- |
|  | Should you get lost at any point during this tutorial, you can refer to the full code for this project in our [`Github repo`](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.4.0/examples/first-project). |

## Your First Contract

We will write a simple contract in [Solidity](https://solidity.readthedocs.io/), the most popular language for Ethereum smart contracts. Create a new file `contracts/Counter.sol` in your project with the following content:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
    uint256 public value;

    function increase() public {
      value++;
    }
}
```

This contract stores a numeric `value` that is increased by one every time we send a transaction to the `increase()` function.

You can run `oz compile` to compile the contract and check for any errors. Once that’s done, we’ll be ready to deploy it.

|     |     |
| --- | --- |
|  | You don’t have to worry if you forget to compile your contract. The CLI will automatically check if your contract changed when you run any command, and compile it if needed. |

## Deploying to a Development Network

We will use [Ganache](https://truffleframework.com/ganache) as a _development network_ to deploy our contract. If you don’t have Ganache installed, do so now by running `npm install ganache-cli`.

Development networks are mini blockchains that run just on your computer, and are much faster than the actual Ethereum network. We will use one for coding and testing.

|     |     |
| --- | --- |
|  | Head to [Setting up a Local Blockchain](https://docs.openzeppelin.com/learn/deploying-and-interacting#local-blockchain) to learn more about using Ganache. |

Open a separate terminal and start a new Ganache process:

```console hljs language-shell
$ npx ganache-cli --deterministic
```

This will start a new development network using a deterministic set of accounts, instead of random ones. We can now deploy our contract there, running `oz deploy`, and choosing to deploy the `Counter` contract to the `development` network.

```console hljs language-shell
$ npx oz deploy
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
? Choose the kind of deployment: upgradeable
? Pick a network: development
? Pick a contract to instantiate: Counter
✓ Added contract Counter
✓ Contract Counter deployed
? Call a function to initialize the instance after creating it?: No
✓ Setting everything up to create contract instances
✓ Instance created at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
```

|     |     |
| --- | --- |
|  | The addresses where your contracts are created and the transaction identifiers you see may differ from the ones listed here. |

Our `Counter` contract is deployed to the local development network and ready to go! We can test it out by interacting with it from the terminal. Let’s try incrementing the counter, by sending a transaction to call the `increase` function through `oz send-tx`.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase()
✓ Transaction successful. Transaction hash: 0x20bef6583ea32cc57fe179e34dd57a5494db3c403e441624e56a886898cb52bd
```

We can now use `oz call` to query the contract’s public `value`, and check that it was indeed increased from zero to one.

```console hljs language-shell
$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
✓ Method 'value()' returned: 1
```

## Upgrading Your Contract

We will now modify our `Counter` contract to make the `increase` function more interesting. Instead of increasing the counter by one, we will allow the caller to increase the counter by any value. Let’s modify the code in `contracts/Counter.sol` to the following:

```solidity hljs
// contracts/Counter.sol
pragma solidity ^0.5.0;

contract Counter {
  uint256 public value;

  function increase(uint256 amount) public {
    value += amount;
  }
}
```

We can now upgrade the instance we created earlier to this new version:

```console hljs language-shell
$ npx oz upgrade
? Pick a network: development
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
✓ Contract Counter deployed
? Which proxies would you like to upgrade?: All proxies
Instance upgraded at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601.
```

Done! Our `Counter` instance has been upgraded to the latest version, and **neither its address nor its state have changed**. Let’s check it out by increasing the counter by ten, which should yield eleven, since we had already increased it by one:

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: increase(amount: uint256)
? amount (uint256): 10
Transaction successful: 0x9c84faf32a87a33f517b424518712f1dc5ba0bdac4eae3a67ca80a393c555ece

$ npx oz call
? Pick a network: development
? Pick an instance: Counter at 0xCfEB869F69431e42cdB54A4F4f105C19C080A601
? Select which function: value()
Returned "11"
```

|     |     |
| --- | --- |
|  | That smart contracts are immutable, so you may be wondering how the OpenZeppelin CLI achieved this feat. To learn about this, head to the docomentation for [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/), in particular the guide about [Proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies).<br>You will note that there are some changes that are not supported during upgrades. For instance, you cannot [remove or change the type of a contract state variable](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts). Nevertheless, you can change, add, or remove all the functions you want. |

That’s it! You now know how to start a simple OpenZeppelin project, create a contract, deploy it to a local network, and even upgrade it as you develop. Head over to the next tutorial to learn how to interact with your contract from your code.

[← Overview](https://docs.openzeppelin.com/cli/2.8/)

[Using Dependencies →](https://docs.openzeppelin.com/cli/2.8/dependencies)Finance - OpenZeppelin Docs

# Finance

This module includes primitives for financial systems.

## Vesting component

The [VestingComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent) manages the gradual release of ERC-20 tokens to a designated beneficiary based on a predefined vesting schedule.
The implementing contract must implement the [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent), where the contract owner is regarded as the vesting beneficiary.
This structure allows ownership rights of both the contract and the vested tokens to be assigned and transferred.

|     |     |
| --- | --- |
|  | Any assets transferred to this contract will follow the vesting schedule as if they were locked from the beginning of the vesting period.<br>As a result, if the vesting has already started, a portion of the newly transferred tokens may become immediately releasable. |

|     |     |
| --- | --- |
|  | By setting the duration to 0, it’s possible to configure this contract to behave like an asset timelock that holds tokens<br>for a beneficiary until a specified date. |

### Vesting schedule

The [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) trait defines the logic for calculating the vested amount based on a given timestamp. This
logic is not part of the [VestingComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent), so any contract implementing the [VestingComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent) must provide its own
implementation of the [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) trait.

|     |     |
| --- | --- |
|  | There’s a ready-made implementation of the [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) trait available named [LinearVestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#LinearVestingSchedule).<br>It incorporates a cliff period by returning 0 vested amount until the cliff ends. After the cliff, the vested amount<br>is calculated as directly proportional to the time elapsed since the beginning of the vesting schedule. |

### Usage

The contract must integrate [VestingComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent) and [OwnableComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#OwnableComponent) as dependencies. The contract’s constructor
should initialize both components. Core vesting parameters, such as `beneficiary`, `start`, `duration`
and `cliff_duration`, are passed as arguments to the constructor and set at the time of deployment.

The implementing contract must provide an implementation of the [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) trait. This can be achieved either by importing
a ready-made [LinearVestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#LinearVestingSchedule) implementation or by defining a custom one.

Here’s an example of a simple vesting wallet contract with a [LinearVestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#LinearVestingSchedule), where the vested amount
is calculated as being directly proportional to the time elapsed since the start of the vesting period.

```cairo hljs
#[starknet::contract]
mod LinearVestingWallet {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_finance::vesting::{VestingComponent, LinearVestingSchedule};
    use starknet::ContractAddress;

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: VestingComponent, storage: vesting, event: VestingEvent);

    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl VestingImpl = VestingComponent::VestingImpl<ContractState>;
    impl VestingInternalImpl = VestingComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        vesting: VestingComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        VestingEvent: VestingComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        beneficiary: ContractAddress,
        start: u64,
        duration: u64,
        cliff_duration: u64
    ) {
        self.ownable.initializer(beneficiary);
        self.vesting.initializer(start, duration, cliff_duration);
    }
}
```

A vesting schedule will often follow a custom formula. In such cases, the [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) trait is useful.
To support a custom vesting schedule, the contract must provide an implementation of the
[calculate\_vested\_amount](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-calculate_vested_amount) function based on the desired formula.

|     |     |
| --- | --- |
|  | When using a custom [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) implementation, the [LinearVestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#LinearVestingSchedule) must be excluded from the imports. |

|     |     |
| --- | --- |
|  | If there are additional parameters required for calculations, which are stored in the contract’s storage, you can access them using `self.get_contract()`. |

Here’s an example of a vesting wallet contract with a custom [VestingSchedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance#VestingComponent-Vesting-Schedule) implementation, where tokens
are vested in a number of steps.

```cairo hljs
#[starknet::contract]
mod StepsVestingWallet {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_finance::vesting::VestingComponent::VestingScheduleTrait;
    use openzeppelin_finance::vesting::VestingComponent;
    use starknet::ContractAddress;
    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: VestingComponent, storage: vesting, event: VestingEvent);

    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl VestingImpl = VestingComponent::VestingImpl<ContractState>;
    impl VestingInternalImpl = VestingComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        total_steps: u64,
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        vesting: VestingComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        VestingEvent: VestingComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        total_steps: u64,
        beneficiary: ContractAddress,
        start: u64,
        duration: u64,
        cliff: u64,
    ) {
        self.total_steps.write(total_steps);
        self.ownable.initializer(beneficiary);
        self.vesting.initializer(start, duration, cliff);
    }

    impl VestingSchedule of VestingScheduleTrait<ContractState> {
        fn calculate_vested_amount(
            self: @VestingComponent::ComponentState<ContractState>,
            token: ContractAddress,
            total_allocation: u256,
            timestamp: u64,
            start: u64,
            duration: u64,
            cliff: u64,
        ) -> u256 {
            if timestamp < cliff {
                0
            } else if timestamp >= start + duration {
                total_allocation
            } else {
                let total_steps = self.get_contract().total_steps.read();
                let vested_per_step = total_allocation / total_steps.into();
                let step_duration = duration / total_steps;
                let current_step = (timestamp - start) / step_duration;
                let vested_amount = vested_per_step * current_step.into();
                vested_amount
            }
        }
    }
}
```

### Interface

Here is the full interface of a standard contract implementing the vesting functionality:

```cairo hljs
#[starknet::interface]
pub trait VestingABI<TState> {
    // IVesting
    fn start(self: @TState) -> u64;
    fn cliff(self: @TState) -> u64;
    fn duration(self: @TState) -> u64;
    fn end(self: @TState) -> u64;
    fn released(self: @TState, token: ContractAddress) -> u256;
    fn releasable(self: @TState, token: ContractAddress) -> u256;
    fn vested_amount(self: @TState, token: ContractAddress, timestamp: u64) -> u256;
    fn release(ref self: TState, token: ContractAddress) -> u256;

    // IOwnable
    fn owner(self: @TState) -> ContractAddress;
    fn transfer_ownership(ref self: TState, new_owner: ContractAddress);
    fn renounce_ownership(ref self: TState);

    // IOwnableCamelOnly
    fn transferOwnership(ref self: TState, newOwner: ContractAddress);
    fn renounceOwnership(ref self: TState);
}
```

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account)

[API Reference →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/finance)Security - OpenZeppelin Docs

# Security

This crate provides components to handle common security-related tasks.

## Initializable

### `InitializableComponent`

```cairo hljs
use openzeppelin_security::InitializableComponent;
```

Component enabling one-time initialization for contracts.

Embeddable Implementations

InitializableImpl

- [`is_initialized(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#InitializableComponent-is_initialized)


Internal Implementations

InternalImpl

- [`initialize(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#InitializableComponent-initialize)


#### Embeddable functions

#### `is_initialized(self: @ComponentState) → bool` external

Returns whether the contract has been initialized.

#### Internal functions

#### `initialize(ref self: ComponentState)` internal

Initializes the contract. Can only be called once.

Requirements:

- the contract must not have been initialized before.


## Pausable

### `PausableComponent`

```cairo hljs
use openzeppelin_security::PausableComponent;
```

Component to implement an emergency stop mechanism.

Embeddable Implementations

PausableImpl

- [`is_paused(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-is_paused)


Internal Implementations

InternalImpl

- [`assert_not_paused(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-assert_not_paused)

- [`assert_paused(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-assert_paused)

- [`pause(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-pause)

- [`unpause(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-unpause)


Events

- [`Paused(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-Paused)

- [`Unpaused(account)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-Unpaused)


#### Embeddable functions

#### `is_paused(self: @ComponentState) → bool` external

Returns whether the contract is currently paused.

#### Internal functions

#### `assert_not_paused(self: @ComponentState)` internal

Panics if the contract is paused.

#### `assert_paused(self: @ComponentState)` internal

Panics if the contract is not paused.

#### `pause(ref self: ComponentState)` internal

Pauses the contract.

Requirements:

- the contract must not be paused.


Emits a [Paused](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-Paused) event.

#### `unpause(ref self: ComponentState)` internal

Unpauses the contract.

Requirements:

- the contract must be paused.


Emits an [Unpaused](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#PausableComponent-Unpaused) event.

#### Events

#### `Paused(account: ContractAddress)` event

Emitted when the contract is paused by `account`.

#### `Unpaused(account: ContractAddress)` event

Emitted when the contract is unpaused by `account`.

## ReentrancyGuard

### `ReentrancyGuardComponent`

```cairo hljs
use openzeppelin_security::ReentrancyGuardComponent;
```

Component to help prevent reentrant calls.

Internal Implementations

InternalImpl

- [`start(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#ReentrancyGuardComponent-start)

- [`end(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/security#ReentrancyGuardComponent-end)


#### Internal functions

#### `start(ref self: ComponentState)` internal

Prevents a contract’s function from calling itself or another protected function, directly or indirectly.

Requirements:

- the guard must not be currently enabled.


#### `end(ref self: ComponentState)` internal

Removes the reentrant guard.

[← Security](https://docs.openzeppelin.com/contracts-cairo/0.20.0/security)

[ERC20 →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/erc20)Contracts Architecture - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Contracts Architecture

Features such as contract upgrades and Ethereum Package linking involve interacting with a number of smart contracts. While regular usage of the CLI does not require awareness of these low-level details, it is still helpful to understand how everything works under the hood.

The following sections describe the contract achitecture behind both upgrades and Ethereum Packages.

|     |     |
| --- | --- |
|  | Most of these contracts are actually part of [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/), which the CLI uses. |

## Upgrades

The source code of the contracts involved with upgrades is located [here](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.6.0/packages/lib/contracts/upgradeability).

### `ProxyAdmin`

[`ProxyAdmin`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin) is a central admin for all [proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies) on your behalf, making their management as simple as possible.

As an admin of all proxy contracts it is in charge of upgrading them, as well as transferring their ownership to another admin. This contract is used to complement the [Transparent Proxy Pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes), which prevents an admin from accidentally triggering a proxy management function when interacting with their instances. `ProxyAdmin` is owned by its deployer (the project owner), and exposes its administrative interface to this account.

A `ProxyAdmin` is only deployed when you run an `oz create` (or `oz create2`) command for the first time. You can force the CLI to deploy one by running `oz push --deploy-proxy-admin`.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyAdmin.sol).

#### Ownership Transfer

The [`oz set-admin`](https://docs.openzeppelin.com/cli/2.6/commands#set-admin) CLI command is used to transfer ownership, both of any single contract or of the entire project (by transferring the ownership of the `ProxyAdmin` contract itself).

A contract’s ownership is transferred by providing its address and the new admin’s:

```console hljs language-shell
$ npx oz set-admin [MYCONTRACT_ADDRESS] [NEW_ADMIN_ADDRESS]
```

To instead transfer the whole project, just provide the new admin address:

```console hljs language-shell
$ npx oz set-admin [NEW_ADMIN_ADDRESS]
```

|     |     |
| --- | --- |
|  | `oz set-admin` is an interactive command: you can also run it with no arguments and it will prompt you for data as it proceeds. |

#### Contract Upgrades via `ProxyAdmin`

The `ProxyAdmin.sol` also responsible for upgrading our contracts. When you run the `oz upgrade` command, it goes through `ProxyAdmin’s` [`upgrade`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin-upgrade-contract-AdminUpgradeabilityProxy-address-) method. The `ProxyAdmin` contract also provides another method [`getProxyImplementation`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyAdmin-getProxyImplementation-contract-AdminUpgradeabilityProxy-) which returns the current implementation of a given proxy.

You can find your `ProxyAdmin` contract address in [`.openzeppelin/<network>.json`](https://docs.openzeppelin.com/cli/2.6/configuration#network.json) under the same name.

```json hljs
// .openzeppelin/<network.json>
"proxyAdmin": {
   "address": <proxyAdmin-address>
}
```

### `ProxyFactory`

[`ProxyFactory`](https://docs.openzeppelin.com/upgrades/2.8/api#ProxyFactory) is used when creating contracts via the `oz create2` command, as well as when creating minimal proxies. It contains all the necessary methods to deploy a proxy through the `CREATE2` opcode or a minimal non-upgradeable proxy.

This contract is only deployed when you run `openzeppelin create2` or `openzeppelin create --minimal` for the first time. You can force the CLI to deploy it by running `openzeppelin push --deploy-proxy-factory`.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/upgradeability/ProxyFactory.sol).

## Ethereum Packages

The source code of the contracts involved with a published Ethereum Package is located [here](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.6.0/packages/lib/contracts/application).

### `App`

[`App`](https://docs.openzeppelin.com/upgrades/2.8/api#App) is the project’s main entry point. Its most important function is to manage your project’s "providers". A provider is basically an Ethereum Package identified by a name at a specific version. For example, a project may track your application’s contracts in one provider named "my-application" at version "0.0.1", an OpenZeppelin Contracts provider named "@openzeppelin/contracts-ethereum-package" at version "2.0.0", and a few other providers. These providers are your project’s sources of on-chain logic.

The providers are mapped by name to `ProviderInfo` structs:

```solidity hljs
// App.sol
    ...

    mapping(string => ProviderInfo) internal providers;

    struct ProviderInfo {
        Package package;
        uint64[3] version;
    }

    ...
```

When you upgrade one of your application’s smart contracts, it is your application provider named "my-application" that is bumped to a new version, e.g. from "0.0.1" to "0.0.2". On the other hand, when you decide to use a new version of the OpenZeppelin Ethereum Package in your project, it is the "@openzeppelin/contracts-ethereum-package" provider which is now pointed at the "2.0.1" version of the package, instead of "2.0.0".

An Ethereum Package is defined by the `Package` contract, as we’ll see next.

|     |     |
| --- | --- |
|  | Additionally the `App` contract also facilitates the creation of proxies, by conveniently wrapping around the `AdminUpgradeabilityProxy` contract. |

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/App.sol).

### `Package`

A [`Package`](https://docs.openzeppelin.com/upgrades/2.8/api#Package) contract tracks all the versions of a given Ethereum Package. Following the example above, one package could be the "application package" associated to the name "my-application" containing all the contracts for version "0.0.1" of your application, and all the contracts for version "0.0.2" as well. Alternatively, another package could be an Ethereum Package associated to the name "@openzeppelin/contracts-ethereum-package" which contains a large number of versions "x.y.z" each of which contains a given set of contracts.

The versions are mapped by a semver hash to `Version` structs:

```solidity hljs
// Package.sol
    ...

    mapping (bytes32 => Version) internal versions;

    struct Version {
        uint64[3] semanticVersion;
        address contractAddress;
        bytes contentURI;
    }

    ...
```

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/Package.sol).

### `ImplementationDirectory`

A version’s `contractAddress` is an instance of the A [`ImplementationDirectory`](https://docs.openzeppelin.com/upgrades/2.8/api#ImplementationDirectory) contract, which is basically a mapping of contract aliases (or names) to deployed implementation instances. Continuing the example, your project’s "my-application" package for version "0.0.1" could contain a directory with the following contracts:

**Directory for version "0.0.1" of the "my-application" package**

- Alias: "MainContract", Implementation: "0x0B06339ad63A875D4874dB7B7C921012BbFfe943"

- Alias: "MyToken", Implementation: "0x1b9a62585255981c85Acec022cDaC701132884f7"


While version "0.0.2" of the "my-application" package could look like this:

**Directory for version "0.0.2" of the "my-application" package**

- Alias: "MainContract", Implementation: "0x0B06339ad63A875D4874dB7B7C921012BbFfe943"

- Alias: "MyToken", Implementation: "0x724a43099d375e36c07be60c967b8bbbec985dc8" ←-- this changed


Notice how version "0.0.2" uses a new implementation for the "MyToken" contract.

Likewise, different versions of the "@openzeppelin/contracts-ethereum-package" Ethereum Package could contain different implementations for persisting aliases such as "ERC20", "ERC721", etc.

An `ImplementationDirectory` is a contract that adopts the `ImplemetationProvider` interface, which simply requires that for a given contract alias or name, the deployed address of a contract is provided. In this particular implementation of the interface, an `ImplementationDirectory` can be frozen, indicating that it will no longer be able to set or unset additional contracts and aliases. This is helpful for making official releases of Ethereum Packages, where the immutability of the package is guaranteed.

Other implementations of the interface could provide contracts without such a limitation, which makes the architecture pretty flexible, yet secure.

You can read its source code [here](https://github.com/OpenZeppelin/openzeppelin-sdk/blob/v2.6.0/packages/lib/contracts/application/ImplementationDirectory.sol).

### Overview

The following diagram illustrates the interface of the contracts of published Ethereum Packages:

![OpenZeppelin 2.x UML](https://docs.openzeppelin.com/cli/2.6/_images/architecture.png)

[← Configuration Files](https://docs.openzeppelin.com/cli/2.6/configuration)Merkle Tree - OpenZeppelin Docs

# Merkle Tree

This crate provides a set of utilities for verifying Merkle Tree proofs on-chain. The tree and the proofs can be
generated using this [JavaScript library](https://github.com/ericnordelo/strk-merkle-tree).

This module provides:

- `verify` \- can prove that some value is part of a Merkle tree.

- `verify_multi_proof` \- can prove multiple values are part of a Merkle tree.


|     |     |
| --- | --- |
|  | `openzeppelin_merkle_tree` doesn’t have dependencies outside of `corelib`, and can be used in projects that are not Starknet-related. |

|     |     |
| --- | --- |
|  | To use it as a standalone package, you can add it in your `Scarb.toml` as follows:<br>`openzeppelin_merkle_tree = "0.20.0"` |

## Modules

### `merkle_proof`

```cairo hljs
use openzeppelin_merkle_tree::merkle_proof;
```

These functions deal with verification of Merkle Tree proofs.

The tree and the proofs can be generated using this [JavaScript library](https://github.com/ericnordelo/strk-merkle-tree). You will find a quickstart guide in the readme.

|     |     |
| --- | --- |
|  | You should avoid using leaf values that are two felt252 values long prior to hashing, or use a hash function<br>other than the one used to hash internal nodes for hashing leaves. This is because the concatenation of a sorted pair<br>of internal nodes in the Merkle tree could be reinterpreted as a leaf value. The JavaScript library generates Merkle<br>trees that are safe against this attack out of the box. |

Functions

- [`verify<Hasher>(proof, root, leaf)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#merkle_proof-verify)

- [`verify_pedersen(proof, root, leaf)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#merkle_proof-verify_pedersen)

- [`verify_poseidon(proof, root, leaf)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#merkle_proof-verify_poseidon)

- [`process_proof<Hasher>(proof, leaf)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#merkle_proof-process_proof)

- [`verify_multi_proof<Hasher>(proof, proof_flags, root, leaves)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#merkle_proof-verify_multi_proof)

- [`process_multi_proof<Hasher>(proof, proof_flags, leaf)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#merkle_proof-process_multi_proof)


#### Functions

#### `verify<+CommutativeHasher>(proof: Span<felt252>, root: felt252, leaf: felt252) → bool` public

Returns true if a `leaf` can be proved to be a part of a Merkle tree defined by `root`.

For this, a `proof` must be provided, containing sibling hashes on the branch from the leaf to the root of the tree.

Each pair of leaves and each pair of pre-images are assumed to be sorted.

|     |     |
| --- | --- |
|  | This function expects a `CommutativeHasher` implementation. See [hashes::CommutativeHasher](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#hashes-CommutativeHasher) for more information.<br>`verify_pedersen` and `verify_poseidon` already include the corresponding `Hasher` implementations. |

#### `verify_pedersen(proof: Span<felt252>, root: felt252, leaf: felt252) → bool` public

Version of `verify` using Pedersen as the hashing function.

#### `verify_poseidon(proof: Span<felt252>, root: felt252, leaf: felt252) → bool` public

Version of `verify` using Poseidon as the hashing function.

#### `process_proof<+CommutativeHasher>(proof: Span<felt252>, leaf: felt252) → felt252` public

Returns the rebuilt hash obtained by traversing a Merkle tree up from `leaf` using `proof`.

A `proof` is valid if and only if the rebuilt hash matches the root of the tree.

When processing the proof, the pairs of leaves & pre-images are assumed to be sorted.

|     |     |
| --- | --- |
|  | This function expects a `CommutativeHasher` implementation. See [hashes::CommutativeHasher](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#hashes-CommutativeHasher) for more information. |

#### `verify_multi_proof<+CommutativeHasher>(proof: Span<felt252>, proof_flags: Span<bool>, root: felt252, leaves: Span<felt252>) → bool` public

Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined
by `root`, according to `proof` and `proof_flags` as described in `process_multi_proof`.

The `leaves` must be validated independently.

|     |     |
| --- | --- |
|  | Not all Merkle trees admit multiproofs. See `process_multi_proof` for details. |

|     |     |
| --- | --- |
|  | Consider the case where `root == proof.at(0) && leaves.len() == 0` as it will return `true`. |

|     |     |
| --- | --- |
|  | This function expects a `CommutativeHasher` implementation. See [hashes::CommutativeHasher](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#hashes-CommutativeHasher) for more information. |

#### `process_multi_proof<+CommutativeHasher>(proof: Span<felt252>, proof_flags: Span<bool>, leaves: Span<felt252>) → felt252` public

Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`.

The reconstruction proceeds by incrementally reconstructing all inner nodes by combining a
leaf/inner node with either another leaf/inner node or a proof sibling node, depending on
whether each `proof_flags` item is true or false respectively.

|     |     |
| --- | --- |
|  | Not all Merkle trees admit multiproofs.<br>To use multiproofs, it is sufficient to ensure that:<br>1. The tree is complete (but not necessarily perfect).<br>   <br>2. The leaves to be proven are in the opposite order than they are in the tree.<br>(i.e., as seen from right to left starting at the deepest layer and continuing at the next layer). |

|     |     |
| --- | --- |
|  | The _empty set_ (i.e. the case where `proof.len() == 1 && leaves.len() == 0`) is<br>considered a no-op, and therefore a valid multiproof (i.e. it returns `proof.at(0)`). Consider<br>disallowing this case if you’re not validating the leaves elsewhere. |

|     |     |
| --- | --- |
|  | This function expects a `CommutativeHasher` implementation. See [hashes::CommutativeHasher](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#hashes-CommutativeHasher) for more information. |

### `hashes`

```cairo hljs
use openzeppelin_merkle_tree::hashes;
```

Module providing the trait and default implementations for the commutative hash functions used in
[`merkle_proof`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#merkle_proof).

|     |     |
| --- | --- |
|  | The `PedersenCHasher` implementation matches the default node hashing function used in the [JavaScript library](https://github.com/ericnordelo/strk-merkle-tree). |

Traits

- [`CommutativeHasher`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#hashes-CommutativeHasher)


Impls

- [`PedersenCHasher`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#hashes-PedersenCHasher)

- [`PoseidonCHasher`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/merkle-tree#hashes-PoseidonCHasher)


#### Traits

#### `CommutativeHasher` trait

Declares a commutative hash function with the following signature:

`commutative_hash(a: felt252, b: felt252) → felt252;`

which computes a commutative hash of a sorted pair of felt252 values.

This is usually implemented as an extension of a non-commutative hash function, like
Pedersen or Poseidon, returning the hash of the concatenation of the two values by first
sorting them.

Frequently used when working with merkle proofs.

|     |     |
| --- | --- |
|  | The `commutative_hash` function MUST follow the invariant that `commutative_hash(a, b) == commutative_hash(b, a)`. |

#### Impls

#### `PedersenCHasher` impl

Implementation of the `CommutativeHasher` trait which computes the Pedersen hash of chaining the two input values
with the len (2), sorting the pair first.

#### `PoseidonCHasher` impl

Implementation of the `CommutativeHasher` trait which computes the Poseidon hash of the concatenation of two values, sorting the pair first.

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection)

[Security →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/security)Crypto - OpenZeppelin Docs

# Crypto

The OpenZeppelin Rust Contracts provide a crate for common cryptographic procedures in a blockchain environment. The following documents the available functionality.

## Verifying Merkle Proofs

Developers can build a Merkle Tree off-chain, which allows for verifying that an element (leaf) is part of a set by using a Merkle Proof. This technique is widely used for creating whitelists (e.g. for airdrops) and other advanced use cases.

|     |     |
| --- | --- |
|  | OpenZeppelin Contracts provides a [JavaScript library](https://github.com/OpenZeppelin/merkle-tree) for building trees off-chain and generating proofs. |

[`MerkleProof`](https://docs.rs/openzeppelin-crypto/0.1.0/openzeppelin_crypto/merkle/struct.Verifier.html) provides:

- [`verify`](https://docs.rs/openzeppelin-crypto/0.1.0/openzeppelin_crypto/merkle/struct.Verifier.html#method.verify) \- can prove that some value is part of a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree).

- [`verify_multi_proof`](https://docs.rs/openzeppelin-crypto/0.1.0/openzeppelin_crypto/merkle/struct.Verifier.html#method.verify_multi_proof) \- can prove multiple values are part of a Merkle tree.


```rust hljs
pub fn verify(&self, proof: Vec<B256>, root: B256, leaf: B256) -> bool {
    let proof: Vec<[u8; 32]> = proof.into_iter().map(|m| *m).collect();
    Verifier::<KeccakBuilder>::verify(&proof, *root, *leaf)
}
```

Note that these functions use `keccak256` as the hashing algorithm, but our library also provides generic counterparts: [`verify_with_builder`](https://docs.rs/openzeppelin-crypto/0.1.0/openzeppelin_crypto/merkle/struct.Verifier.html#method.verify_with_builder) and [`verify_multi_proof_with_builder`](https://docs.rs/openzeppelin-crypto/0.1.0/openzeppelin_crypto/merkle/struct.Verifier.html#method.verify_multi_proof_with_builder).

We also provide an adapter [`hash`](https://docs.rs/openzeppelin-crypto/0.1.0/openzeppelin_crypto/hash/index.html) module to use your own hashers in conjunction with them that resembles Rust’s standard library’s API.

[← Access Control](https://docs.openzeppelin.com/contracts-stylus/0.1.0/access-control)Multisig - OpenZeppelin Docs

# Multisig

The Multisig component implements a multi-signature mechanism to enhance the security and
governance of smart contract transactions. It ensures that no single signer can unilaterally
execute critical actions, requiring multiple registered signers to approve and collectively
execute transactions.

This component is designed to secure operations such as fund management or protocol governance,
where collective decision-making is essential. The Multisig Component is self-administered,
meaning that changes to signers or quorum must be approved through the multisig process itself.

## Key features

- **Multi-Signature Security**: transactions must be approved by multiple signers, ensuring
distributed governance.

- **Quorum Enforcement**: defines the minimum number of approvals required for transaction execution.

- **Self-Administration**: all modifications to the component (e.g., adding or removing signers)
must pass through the multisig process.

- **Event Logging**: provides comprehensive event logging for transparency and auditability.


## Signer management

The Multisig component introduces the concept of signers and quorum:

- **Signers**: only registered signers can submit, confirm, revoke, or execute transactions. The Multisig
Component supports adding, removing, or replacing signers.

- **Quorum**: the quorum defines the minimum number of confirmations required to approve a transaction.


|     |     |
| --- | --- |
|  | To prevent unauthorized modifications, only the contract itself can add, remove, or replace signers or change the quorum.<br>This ensures that all modifications pass through the multisig approval process. |

## Transaction lifecycle

The state of a transaction is represented by the `TransactionState` enum and can be retrieved
by calling the `get_transaction_state` function with the transaction’s identifier.

The identifier of a multisig transaction is a `felt252` value, computed as the Pedersen hash
of the transaction’s calls and salt. It can be computed by invoking the implementing contract’s
`hash_transaction` method for single-call transactions or `hash_transaction_batch` for multi-call
transactions. Submitting a transaction with identical calls and the same salt value a second time
will fail, as transaction identifiers must be unique. To resolve this, use a different salt value
to generate a unique identifier.

A transaction in the Multisig component follows a specific lifecycle:

`NotFound` → `Pending` → `Confirmed` → `Executed`

- **NotFound**: the transaction does not exist.

- **Pending**: the transaction exists but has not reached the required confirmations.

- **Confirmed**: the transaction has reached the quorum but has not yet been executed.

- **Executed**: the transaction has been successfully executed.


## Usage

Integrating the Multisig functionality into a contract requires implementing [MultisigComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent).
The contract’s constructor should initialize the component with a quorum value and a list of initial signers.

Here’s an example of a simple wallet contract featuring the Multisig functionality:

```cairo hljs
#[starknet::contract]
mod MultisigWallet {
    use openzeppelin_governance::multisig::MultisigComponent;
    use starknet::ContractAddress;

    component!(path: MultisigComponent, storage: multisig, event: MultisigEvent);

    #[abi(embed_v0)]
    impl MultisigImpl = MultisigComponent::MultisigImpl<ContractState>;
    impl MultisigInternalImpl = MultisigComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        multisig: MultisigComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        MultisigEvent: MultisigComponent::Event,
    }

    #[constructor]
    fn constructor(ref self: ContractState, quorum: u32, signers: Span<ContractAddress>) {
        self.multisig.initializer(quorum, signers);
    }
}
```

## Interface

This is the interface of a contract implementing the [MultisigComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#MultisigComponent):

```cairo hljs
#[starknet::interface]
pub trait MultisigABI<TState> {
    // Read functions
    fn get_quorum(self: @TState) -> u32;
    fn is_signer(self: @TState, signer: ContractAddress) -> bool;
    fn get_signers(self: @TState) -> Span<ContractAddress>;
    fn is_confirmed(self: @TState, id: TransactionID) -> bool;
    fn is_confirmed_by(self: @TState, id: TransactionID, signer: ContractAddress) -> bool;
    fn is_executed(self: @TState, id: TransactionID) -> bool;
    fn get_submitted_block(self: @TState, id: TransactionID) -> u64;
    fn get_transaction_state(self: @TState, id: TransactionID) -> TransactionState;
    fn get_transaction_confirmations(self: @TState, id: TransactionID) -> u32;
    fn hash_transaction(
        self: @TState,
        to: ContractAddress,
        selector: felt252,
        calldata: Span<felt252>,
        salt: felt252,
    ) -> TransactionID;
    fn hash_transaction_batch(self: @TState, calls: Span<Call>, salt: felt252) -> TransactionID;

    // Write functions
    fn add_signers(ref self: TState, new_quorum: u32, signers_to_add: Span<ContractAddress>);
    fn remove_signers(ref self: TState, new_quorum: u32, signers_to_remove: Span<ContractAddress>);
    fn replace_signer(
        ref self: TState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress,
    );
    fn change_quorum(ref self: TState, new_quorum: u32);
    fn submit_transaction(
        ref self: TState,
        to: ContractAddress,
        selector: felt252,
        calldata: Span<felt252>,
        salt: felt252,
    ) -> TransactionID;
    fn submit_transaction_batch(
        ref self: TState, calls: Span<Call>, salt: felt252,
    ) -> TransactionID;
    fn confirm_transaction(ref self: TState, id: TransactionID);
    fn revoke_confirmation(ref self: TState, id: TransactionID);
    fn execute_transaction(
        ref self: TState,
        to: ContractAddress,
        selector: felt252,
        calldata: Span<felt252>,
        salt: felt252,
    );
    fn execute_transaction_batch(ref self: TState, calls: Span<Call>, salt: felt252);
}
```

[← Governor](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/governor)

[Timelock Controller →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/timelock)OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


## openzeppelin\|oz

Usage: `openzeppelin|oz <command> [options]`

where <command> is one of: accounts, add, balance, bump, call, check, compile, create, create2, freeze, init, link, publish, push, remove, send-tx, session, set-admin, transfer, unlink, unpack, upgrade, verify

`--version`

output the version number

`-v, --verbose`

verbose mode on: output errors stacktrace and detailed log.

`-s, --silent`

silent mode: no output sent to stderr.

## accounts

Usage: `accounts [options]`

list the accounts of the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## add

Usage: `add [contractName1[:contractAlias1] …​ contractNameN[:contractAliasN]] [options]`

add contract to your project. Provide a list of whitespace-separated contract names

`--all`

add all contracts in your build directory

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## balance

Usage: `balance --network <network> [options]`

query the balance of the specified account

`--erc20 <contractAddress>`

query the balance of an ERC20 token instead of ETH

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## bump

Usage: `bump <version> [options]`

bump your project to a new <version>

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## call

Usage: `call --to <to> --method <method> [options]`

call a method of the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the call

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## check

Usage: `check [contract] [options]`

checks your contracts for potential issues

`--skip-compile`

skips contract compilation

## compile

Usage: `compile [options]`

compiles all contracts in the current project

`--solc-version [version]`

version of the solc compiler to use (value is written to configuration file for future runs, defaults to most recent release that satisfies contract pragmas)

`--optimizer [on|off]`

enables compiler optimizer (value is written to configuration file for future runs, defaults to off)

`--optimizer-runs [runs]`

specify number of runs if optimizer enabled (value is written to configuration file for future runs, defaults to 200)

`--evm-version [evm]`

choose target evm version (value is written to configuration file for future runs, defaults depends on compiler: byzantium prior to 0.5.5, petersburg from 0.5.5)

`--typechain [web3-v1|truffle|ethers]`

enables typechain generation of typescript wrappers for contracts using the chosen target

`--typechain-outdir [path]`

path where typechain artifacts are written (defaults to ./types/contracts/)

`--no-interactive`

force to run the command in non-interactive mode

## create

Usage: `create [alias] --network <network> [options]`

deploys a new upgradeable contract instance. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package.

`--init [function]`

call function after creating contract. If none is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--force`

ignore contracts validation errors

`--minimal`

creates a cheaper but non-upgradeable instance instead, using a minimal proxy

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## create2

Usage: `create2 [alias] --network <network> --salt <salt> [options]`

deploys a new upgradeable contract instance using CREATE2 at a predetermined address given a numeric <salt> and a <from> address. Provide the <alias> you added your contract with, or <package>/<alias> to create a contract from a linked package. A <signature> can be provided to derive the deployment address from a signer different to the <from> address. Warning: support for this feature is experimental.

`--salt <salt>`

salt used to determine the deployment address (required)

`--query [sender]`

do not create the contract and just return the deployment address, optionally specifying the sender used to derive the deployment address (defaults to 'from')

`--init [function]`

initialization function to call after creating contract (defaults to 'initialize', skips initialization if not set)

`--args <arg1, arg2, …​>`

arguments to the initialization function

`--admin <admin>`

admin of the proxy (uses the project’s proxy admin if not set)

`--signature <signature>`

signature of the request, uses the signer to derive the deployment address (uses the sender to derive deployment address if not set)

`--force`

force creation even if contracts have local modifications

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## freeze

Usage: `freeze --network <network> [options]`

freeze current release version of your published project

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

## init

Usage: `init <project-name> [version]`

initialize your OpenZeppelin project. Provide a <project-name> and optionally an initial \[version\] name

`--publish`

automatically publish your project upon pushing it to a network

`--force`

overwrite existing project if there is one

`--typechain <target>`

enable typechain support with specified target (web3-v1, ethers, or truffle)

`--typechain-outdir <path>`

set output directory for typechain compilation (defaults to types/contracts)

`--link <dependency>`

link to a dependency

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## link

Usage: `link [dependencyName1 …​ dependencyNameN] [options]`

links project with a list of dependencies each located in its npm package

`--no-install`

skip installing packages dependencies locally

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## publish

Usage: `publish --network <network> [options]`

publishes your project to the selected network

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## push

Usage: `push --network <network> [options]`

deploys your project to the specified <network>

`--skip-compile`

skips contract compilation

`-d, --deploy-dependencies`

deploys dependencies to the network if there is no existing deployment

`--reset`

redeploys all contracts (not only the ones that changed)

`--force`

ignores validation errors and deploys contracts

`--deploy-proxy-admin`

eagerly deploys the project’s proxy admin (if not deployed yet on the provided network)

`--deploy-proxy-factory`

eagerly deploys the project’s proxy factory (if not deployed yet on the provided network)

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## remove

Usage: `remove [contract1 …​ contractN] [options]`

removes one or more contracts from your project. Provide a list of whitespace-separated contract names.

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## send-tx

Usage: `send-tx --to <to> --method <method> [options]`

send a transaction to the specified contract instance. Provide the \[address\], method to call and its arguments if needed

`--to <to>`

address of the contract that will receive the transaction

`--method <method>`

name of the method to execute in the contract

`--args <arg1, arg2, …​>`

arguments to the method to execute

`--value <value>`

optional value in wei to send with the transaction

`--gas <gas>`

gas limit of the transaction, will default to the limit specified in the configuration file, or use gas estimation if not set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## session

Usage: `session [options]`

by providing network options, commands like create, freeze, push, and update will use them unless overridden. Use --close to undo.

`--expires <expires>`

expiration of the session in seconds (defaults to 900, 15 minutes)

`--close`

closes the current session, removing all network options set

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## set-admin

Usage: `set-admin [alias-or-address] [new-admin-address] --network <network> [options]`

change upgradeability admin of a contract instance, all instances or proxy admin. Provide the \[alias\] or \[package\]/\[alias\] of the contract to change the ownership of all its instances, or its \[address\] to change a single one, or none to change all contract instances to a new admin. Note that if you transfer to an incorrect address, you may irreversibly lose control over upgrading your contract.

`--force`

bypass a manual check

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## transfer

Usage: `transfer --network <network> [options]`

send funds to a given address

`--to <to>`

specify recipient address

`--value <value>`

the amount of ether units to be transferred

`--unit <unit>`

unit name. Wei, kwei, gwei, milli and ether are supported among others. If none is given, 'ether' will be used.

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## unlink

Usage: `unlink [dependencyName1…​ dependencyNameN]`

unlinks dependencies from the project. Provide a list of whitespace-separated dependency names

`--push [network]`

push all changes to the specified network

`-f, --from <from>`

specify the transaction sender address for --push

`--skip-compile`

skips contract compilation

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--no-interactive`

force to run the command in non-interactive mode

## unpack

Usage: `unpack [kit]`

download and install an OpenZeppelin Starter Kit to the current directory

`--no-interactive`

force to run the command in non-interactive mode

## upgrade

Usage: `upgrade [alias-or-address] --network <network> [options]`

upgrade contract to a new logic. Provide the \[alias\] or \[package\]/\[alias\] you added your contract with, its \[address\], or use --all flag to upgrade all contracts in your project.

`--init [function]`

call function after upgrading contract. If no name is given, 'initialize' will be used

`--args <arg1, arg2, …​>`

provide initialization arguments for your contract if required

`--all`

upgrade all contracts in the application

`--force`

ignore contracts validation errors

`-n, --network <network>`

network to be used

`-f, --from <from>`

specify transaction sender address

`--timeout <timeout>`

timeout in seconds for each transaction when using an http connection (defaults to 750 seconds)

`--blockTimeout <timeout>`

timeout in blocks for each transaction when using a websocket connection (defaults to 50 blocks)

`--skip-compile`

skips contract compilation

`--no-interactive`

force to run the command in non-interactive mode

## verify

Usage: `verify [options] [contract-alias]`

verify a contract with etherscan or etherchain. Provide a contract name.

`-n, --network [network]`

network where to verify the contract

`-o, --optimizer`

enables optimizer option

`--optimizer-runs [runs]`

specify number of runs if optimizer enabled.

`--remote <remote>`

specify remote endpoint to use for verification

`--api-key <key>`

specify etherscan API key. To get one, go to: [https://etherscan.io/myapikey](https://etherscan.io/myapikey)

`--no-interactive`

force to run the command in non-interactive mode

[← Frequently Asked Questions](https://docs.openzeppelin.com/cli/2.7/faq)

[Configuration Files →](https://docs.openzeppelin.com/cli/2.7/configuration)ERC-20 Burnable - OpenZeppelin Docs

# ERC-20 Burnable

Extension of [ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20) that allows token holders to destroy both their own tokens and those that they have an allowance for, in a way that can be recognized off-chain (via event analysis).

## Usage

In order to make [`ERC-20 Burnable`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/extensions/burnable/index.html) methods “external” so that other contracts can call them, you need to implement them by yourself for your final contract as follows:

```rust hljs
use openzeppelin_stylus::{
    token::erc20::{
        extensions::IErc20Burnable,
        Erc20, IErc20,
    },
};

sol_storage! {
    #[entrypoint]
    struct Erc20Example {
        #[borrow]
        Erc20 erc20;
    }
}

#[public]
#[inherit(Erc20)]
impl Erc20Example {
    pub fn burn(&mut self, value: U256) -> Result<(), Vec<u8>> {
        // ...
        self.erc20.burn(value).map_err(|e| e.into())
    }

    pub fn burn_from(
        &mut self,
        account: Address,
        value: U256,
    ) -> Result<(), Vec<u8>> {
        // ...
        self.erc20.burn_from(account, value).map_err(|e| e.into())
    }
}
```Configuration Files - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Configuration Files

The OpenZeppelin CLI stores your project’s configuration in the `.openzeppelin` directory, inside a number of JSON files. Those are described here.

|     |     |
| --- | --- |
|  | You can skip ahead to see which files you should [track using version control](https://docs.openzeppelin.com/cli/2.6/configuration#configuration-files-in-version-control). |

## `project.json`

This stores the project’s general configuration, and is created by the `oz init` command. It has the following structure:

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": <projectName>,
  "version": <version>,
  "publish": <publishFlag>,
  "contracts": {
    <contract-1-alias>: <contract-1-name>,
    <contract-2-alias>: <contract-2-name>,
    ...
    <contract-N-alias>: <contract-N-name>
  },
  "dependencies": {
    <dependency-1-name>: <dependency-1-version>,
    <dependency-2-name>: <dependency-2-version>,
    ...
    <dependency-N-name>: <dependency-N-version>
  }
}
```

Here, `<projectName>` is the name of the project, and `<version>` is the current semver number. The boolean value `<publish>` indicates whether the project should be automatically published to the network upon being pushed, allowing it to be reused as an Ethereum Package by other projects. The field `manifestVersion` indicates the version of the configuration file.

Once you start adding your contracts via `oz add`, they will be recorded under the `"contracts"` field, with the contract aliases as the keys (which default to the contract names), and the contract names as the values. Finally, if you link a dependency with `oz link`, this will be reflected in the `"dependencies"` field, where `<dependency-name>` is the name of the linked Ethereum Package, and `<dependency-version>` is its semver required version.

## `<network_name>.json`

The OpenZeppelin CLI will also generate a file for each of the networks you work on ( `local`, `ropsten`, `mainnet`, etc). These should be configured in your `networks.js` file, but note that `oz init` already configures a `local` network for `localhost:8545`. These files share the same structure:

```json hljs
// .openzeppelin/<network_name>.json
{
  "manifestVersion": "2.2",
  "version": <app-version>,
  "contracts": {
    <contract-N-name>: {
      "address": <contract-N-address>,
      "constructorCode": <contract-N-constructor>,
      "bodyBytecodeHash": <contract-N-body>,
      "localBytecodeHash": <contract-N-local>,
      "deployedBytecodeHash": <contract-N-deployed>,
      "types": { ... },
      "storage": [ ... ],
      "warnings": { ... }
    },
    ...
  },
  "solidityLibs": {
    ...
  },
  "proxies": {
    <package-name>/<contract-name>: [\
      {\
        "address": <proxy-1-address>,\
        "version": <proxy-1-version>,\
        "implementation": <implementation-1-address>\
      },\
      ...\
    ],
    ...
  },
  "proxyAdmin": {
    "address": <proxyAdmin-address>
  },
  "app": {
    "address": <app-address>
  },
  "package": {
    "address": <package-address>
  },
  "provider": {
    "address": <provider-address>
  },
  "dependencies": {
    <dependency-name>: {
      "package": <dependency-address>,
      "version": <dependency-version>,
      "customDeploy": <dependency-custom-deploy>
    },
    ...
  }
}
```

The most important things to see here are the proxies and contracts' addresses, `<proxy-i-address>` and `<contract-i-address>` respectively. What will happen is that each time you upload new versions of your logic contracts, `<contract-i-address>` will change. The proxy addresses, however, will stay the same, so you can interact seamlessly with the same addresses as if no change has taken place. Note that `<implementation-i-address>` will always point to the current contract address `<contract-i-address>` if the proxies are `update`-ed. Proxies are grouped by the name of the package and contract they are backed by.

For every logic contract, besides the deployment address, the following info is also tracked:

- `constructorCode` is the SHA256 hash of the bytecode used to `CREATE` the logic contract

- `bodyBytecodeHash` is the SHA256 hash of the same bytecode as above, stripped of its constructor

- `localBytecodeHash` is the SHA256 hash of the bytecode, including any Solidity library placeholders

- `deployedBytecodeHash` is the SHA256 hash of the bytecode, with all Solidity library placeholders replaced by their corresponding addresses

- `types` keeps track of all the types used in the contract or its ancestors, from basic types like `uint256` to custom `struct` types

- `storage` tracks the storage layout of the linearized contract, referencing the types defined in the `types` section, and is used for verifying that any storage layout changes between subsequent versions are compatible

- `warnings` tracks any existing warnings for the contract, such as whether it has a constructor or `selfdestruct` operations


Any Solidity libraries used by the project’s contracts are tracked in the `solidityLibs` node, which has the same structure as the `contracts` item.

Another thing to notice in these files are the version numbers. The `<app-version>` keeps track of the latest app version, and matches `<version>` from `project.json`. The `<proxy-i-version>`, on the other hand, keeps track of which version of the contracts the proxies are pointing to. Say you deploy a contract in your app version 1.0.0, and then bump the version to 1.1.0 and push some upgraded code for that same contract. This will be reflected in the `<contract-i-address>`, but not yet in the proxy, which will display 1.0.0 in `<proxy-i-version>` and the old logic contract address in `<implementation-i-address>`. Once you run `oz update` to your contract, `<proxy-i-version>` will show the new 1.1.0 version, and `<implementation-i-address>` will point to the new `<contract-i-address>`. Note that this version identifier will refer to the version of the dependency (and not the app) if the proxy points to a dependent Ethereum Package.

The field `<proxyAdmin>` contains the address of the ProxyAdmin contract, used to manage the [transparent proxy pattern](https://docs.openzeppelin.com/cli/2.6/configuration#pattern.adoc#transparent-proxies-and-function-clashes) in the project’s proxies.

Also, notice the fields `<app>`, `<package>`, and `<provider>`. These contain the addresses of contracts the OpenZeppelin CLI uses to facilitate the creation of proxies and the management of different versions of your contracts. These contracts will only be deployed once you `publish` your project to a desired network. That is, your project will not have an `app`, `package`, or `provider` unless explicitly running the `publish` command, or if the project was created with the `--publish` flag. Note that this step is required for projects that produce an Ethereum Package. To read more about the architecture of contracts we are using to publish your project on-chain please refer to the [Contract Architecture](https://docs.openzeppelin.com/cli/2.6/configuration#architecture.adoc) section.

Finally, the `dependencies` field stores information about linked Ethereum Packages. For each dependency, the `<dependency-address>` tracks the address of the deployed `package` in the network, and `<dependency-version>` is the exact semver identifier being used for the dependency. The `custom-deploy` field will be present only when a version of the Ethereum Package is deployed using the `--deploy-dependencies` flag of the `push` command, in which case `<custom-deploy>` will be `true`.

The naming of the file will be `<network_name>.json`, but note that `<network_name>` is not taken from the name of the network’s entry in the network file, but is instead inferred from the canonical network id associated to the entry. For example, given the following network configuration:

```json hljs
// networks.js
module.exports = {
  networks: {
     geth_ropsten: {
      host: 'localhost',
      port: 8555,
      network_id: 3
    },
     parity_ropsten: {
      host: 'localhost',
      port: 8565,
      network_id: 3
    },
     local: {
      host: 'localhost',
      port: 8545,
      network_id: *
    }
  }
};
```

Using `oz push --network geth_ropsten` or `oz push --network parity_ropsten` will both produce a file named `ropsten.json` no matter which method was used to connect to the ropsten network. The OpenZeppelin CLI will automatically detect which public network is being referred to (using web3.network.getVersion()) and use this information for determining the file name. When dealing with local networks, the OpenZeppelin CLI will generate files with `dev-<network_id>`, given that these networks are not public and don’t have a canonical name. Using `oz push --network local` will produce a file named `dev-1540303312049.json` (or some other number representing the network id of the local network).

## Configuration Files in Version Control

The `project.json` file should be tracked in version control. This file represents an OpenZeppelin project’s configuration; the contracts and Ethereum Packages that compose it, its name and version, the version of the OpenZeppelin CLI it uses, etc. The file should be identical for all the contributors of a project.

Public network files like `mainnet.json` or `ropsten.json` should also be tracked in version control. These contain valuable information about your project’s status in the corresponding network; the addresses of the contract implementations that have been deployed, the addresses of the proxies that have been deployed, etc. Such files should also be identical for all the contributors of a project.

However, local network files like `dev-<network_id>.json` only represent a project’s deployment in a temporary local network such as `ganache-cli` that are only relevant to a single contributor of the project and should not be tracked in version control.

An example `.gitignore` file could contain the following entries:

```json hljs
// .gitignore
# OpenZeppelin
.openzeppelin/dev-*.json
.openzeppelin/.session
```

[← Commands](https://docs.openzeppelin.com/cli/2.6/commands)

[Contracts Architecture →](https://docs.openzeppelin.com/cli/2.6/contracts-architecture)Using Dependencies - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Using Dependencies

In [Getting Started](https://docs.openzeppelin.com/cli/2.6/getting-started), we learned how to set up a new OpenZeppelin project, deploy a simple contract, and upgrade it. Now, we will build a more interesting project with multiple contracts, leveraging the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package). We will learn about **linking Ethereum Packages**, and **writing upgradeable contracts**.

## What We Will Build

We will write a `TokenExchange` contract, that will allow any user to purchase an ERC20 token in exchange for ETH, at a fixed exchange rate. We will write `TokenExchange` ourselves, but leverage the [ERC20 implementation](https://docs.openzeppelin.com/contracts/5.x/erc20) from [**OpenZeppelin Contracts**](https://docs.openzeppelin.com/contracts/5.x/)

Before we get started, make sure to [initialize a new project](https://docs.openzeppelin.com/cli/2.6/getting-started#setting-up-your-project):

```console hljs language-shell
$ mkdir token-exchange && cd token-exchange
$ npm init -y
$ npm install @openzeppelin/cli
$ npx openzeppelin init
```

|     |     |
| --- | --- |
|  | The full code for this project is available in our [Github repo](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/v2.4.0/examples/linking-contracts). |

## Linking the Contracts Ethereum Package

We will first get ourselves an ERC20 token. Instead of coding one from scratch, we will use the one provided by the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package). An Ethereum Package is a set of contracts set up to be easily included in an OpenZeppelin project, with the added bonus that the contracts' code _is already deployed in the Ethereum network_. This is a more secure code distribution mechanism, and also helps you save gas upon deployment.

|     |     |
| --- | --- |
|  | Check out [this article](https://blog.openzeppelin.com/open-source-collaboration-in-the-blockchain-era-evm-packages/) to learn more about Ethereum Packages. |

To link the OpenZeppelin Contracts Ethereum Package into your project, simply run the following:

```console hljs language-shell
$ npx oz link @openzeppelin/contracts-ethereum-package
```

This command will download the Ethereum Package (bundled as a regular npm package), and connect it to your OpenZeppelin project. We now have all of OpenZeppelin contracts at our disposal, so let’s create an ERC20 token!

|     |     |
| --- | --- |
|  | Make sure you install `@openzeppelin/contracts-ethereum-package` and not the vanilla `@openzeppelin/contracts`. The latter is set up for general usage, while `@openzeppelin/contracts-ethereum-package` is tailored for being used with [OpenZeppelin Upgrades](https://docs.openzeppelin.com/upgrades/2.8/). This means that its contracts are [already set up to be upgradeable](https://docs.openzeppelin.com/cli/2.6/dependencies#upgrades::writing-contracts.adoc#use-upgradeable-packages). |

## Creating an ERC20 Token

Let’s deploy an ERC20 token contract to our development network. Make sure to [have a Ganache instance running](https://docs.openzeppelin.com/cli/2.6/dependencies#learn::deploy-and-interact.adoc#local-blockchain), or start one by running:

```console hljs language-shell
$ npx ganache-cli --deterministic
```

For setting up the token, we will be using the [StandaloneERC20 implementation](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/token/ERC20/StandaloneERC20.sol) provided by the OpenZeppelin package. We will _initialize_ the instance with the token metadata (name, symbol, and decimals), and mint a large initial supply for one of our accounts.

|     |     |
| --- | --- |
|  | The unlocked accounts and transaction hashes may differ from the ones shown here. Run a brand-new Ganache in `--deterministic` mode to get the same ones. |

```console hljs language-shell
$ npx oz create
? Pick a contract to instantiate: @openzeppelin/contracts-ethereum-package/StandaloneERC20
? Pick a network: development
✓ Deploying @openzeppelin/contracts-ethereum-package dependency to network
? Call a function to initialize the instance after creating it?: Yes
? Select which function: * initialize(name: string, symbol: string, decimals: uint8, initialSupply: uint256, initialHolder: address, minters: address[], pausers: address[])
? name (string): MyToken
? symbol (string): MYT
? decimals (uint8): 18
? initialSupply (uint256): 100e18
? initialHolder (address): 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
? minters (address[]):
? pausers (address[]):
✓ Setting everything up to create contract instances
✓ Instance created at 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
```

Let’s break down what we did in the command above. We first chose to create an instance of the `StandaloneERC20` contract from the `@openzeppelin/contracts-ethereum-package` package we had linked before, and to create it in the local `development` network. We are then instructing the CLI to _initialize_ it with the initial values needed to set up our token. This requires us to choose the appropriate `initialize` function, and input all the required arguments. The OpenZeppelin CLI will then atomically create and initialize the new instance in a single transaction.

We now have a working ERC20 token contract in our development network. We can check that the initial supply was properly allocated by using the `balance` command. Make sure to use the address where your ERC20 token instance was created.

```console hljs language-shell
$ npx oz balance --erc20 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
? Enter an address to query its balance: 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
? Pick a network: development
Balance: 100 MYT
```

Great! We can now write an exchange contract and connect it to this token when we deploy it.

## Writing the Exchange Contract

In order to transfer an amount of tokens every time it receives ETH, our exchange contract will need to store the token contract address and the exchange rate in its state. We will set these two values during initialization, when we create the instance with `oz create`.

Because we’re writing upgradeable contracts [we cannot use Solidity `constructor` s](https://docs.openzeppelin.com/upgrades/2.8/proxies#the-constructor-caveat). Instead, we need to use _initializers_. An initializer is just a regular Solidity function, with an additional check to ensure that it can be called only once.

To make coding initializers easy, [**OpenZeppelin Upgrades**](https://docs.openzeppelin.com/upgrades/2.8/) provides a base `Initializable` contract, that includes an `initializer` modifier that takes care of this. You will first need to install it:

```console hljs language-shell
$ npm install @openzeppelin/upgrades
```

Now, let’s write our exchange contract in `contracts/TokenExchange.sol`, using an _initializer_ to set its initial state:

```solidity hljs
// contracts/TokenExchange.sol
pragma solidity ^0.5.0;

// Import base Initializable contract
import "@openzeppelin/upgrades/contracts/Initializable.sol";

// Import the IERC20 interface and and SafeMath library
import "@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";

contract TokenExchange is Initializable {
    using SafeMath for uint256;

    // Contract state: exchange rate and token
    uint256 public rate;
    IERC20 public token;

    // Initializer function (replaces constructor)
    function initialize(uint256 _rate, IERC20 _token) public initializer {
        rate = _rate;
        token = _token;
    }

    // Send tokens back to the sender using predefined exchange rate
    function() external payable {
        uint256 tokens = msg.value.mul(rate);
        token.transfer(msg.sender, tokens);
    }
}
```

Note the usage of the `initializer` modifier in the `initialize` method. This guarantees that once we have deployed our contract, no one can call into that function again to alter the token or the rate.

Let’s now create and initialize our new `TokenExchange` contract:

```console hljs language-shell
$ npx oz create
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
? Pick a contract to instantiate: TokenExchange
? Pick a network: development
✓ Contract TokenExchange deployed
? Call a function to initialize the instance after creating it?: Yes
? Select which function: initialize(_rate: uint256, _token: address)
? _rate (uint256): 10
? _token (address): 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
Instance created at 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec
```

Our exchange is almost ready! We only need to fund it, so it can send tokens to purchasers. Let’s do that using the `oz send-tx` command, to transfer the full token balance from our own account to the exchange contract. Make sure to replace the recipient of the transfer with the `TokenExchange` address you got from the previous command.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Choose an instance: StandaloneERC20 at 0x2612Af3A521c2df9EAF28422Ca335b04AdF3ac66
? Select which function: transfer(to: address, value: uint256)
? to (address): 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec
? value (uint256): 10e18
Transaction successful: 0x5863c8a8e122fcda7c6234abc6e60fad3f5a8108a3f88e2d8a956b63dbc222c2
Events emitted:
 - Transfer
    from: 0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1,
    to: 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec,
    value: 10000000000000000000
```

All set! We can start playing with our brand new token exchange.

## Using Our Exchange

Now that we have initialized our exchange contract and seeded it with funds, we can test it out by purchasing tokens. Our exchange contract will send tokens back automatically when we send ETH to it, so let’s test it by using the `oz transfer` command. This command allows us to send funds to any address; in this case, we will use it to send ETH to our `TokenExchange` instance:

```console hljs language-shell
$ npx oz transfer
? Pick a network: development
? Choose the account to send transactions from: (1) 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
? Enter the receiver account: 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec
? Enter an amount to transfer 0.1 ether
✓ Funds sent. Transaction hash: 0xc85a8caa161110ba7f08134f4496a995968a5aff7ae60ad9b6ce1c824e13cacb
```

|     |     |
| --- | --- |
|  | Make sure you replace the receiver account with the corresponding address where your `TokenExchange` was created. |

We can now use `oz balance` again, to check the token balance of the address that made the purchase. Since we sent 0.1 ETH, and we used a 1:10 exchange rate, we should see a balance of 1 MYT (MyToken).

```console hljs language-shell
$ npx oz balance --erc20 0x5f8e26fAcC23FA4cbd87b8d9Dbbd33D5047abDE1
? Enter an address to query its balance: 0xFFcf8FDEE72ac11b5c542428B35EEF5769C409f0
? Pick a network: development
Balance: 1 MYT
```

Success! We have our exchange up and running, gathering ETH in exchange for our tokens. But how can we collect the funds we earned…​?

## Upgrading the Exchange

We forgot to add a method to withdraw the funds from the token exchange contract! While this would typically mean that the funds are locked in there forever, we can upgrade the contract with the OpenZeppelin CLI to add a way to collect those funds.

|     |     |
| --- | --- |
|  | While upgrading a contract is certainly useful in situations like this, where you need to fix a bug or add a missing feature, it could still be used to change the rules of the game. For instance, you could upgrade the token exchange contract to alter the rate at any time. Because of this, it is important to have a proper [Project Governance](https://docs.openzeppelin.com/cli/2.6/dependencies#learn::mainnet.adoc#project-governance) in place. |

Let’s modify the `TokenExchange` contract to add a `withdraw` method, only callable by an `owner`.

```solidity hljs
// contracts/TokenExchange.sol
contract TokenExchange is Initializable {
    uint256 public rate;
    IERC20 public token;
    address public owner;

    function withdraw() public {
        require(msg.sender == owner, "Address not allowed to call this function");
        msg.sender.transfer(address(this).balance);
    }

    // (existing functions not shown here for brevity)
}
```

When modifying your contract, you will have to place the `owner` variable **after** the other variables ( [learn more](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) about this restriction). Don’t worry if you forget about it, the CLI will check this for you when you try to upgrade.

|     |     |
| --- | --- |
|  | If you are familiar with [**OpenZeppelin Contracts**](https://docs.openzeppelin.com/contracts/5.x/), you may be wondering why we didn’t simply extend from `Ownable` and used the `onlyOwner` modifier. The issue is OpenZeppelin Upgrades does not support extending from now contracts in an upgrade (if they declare their own state variables). Again, the CLI will alert you if you attempt to do this. Refer to the [Upgrades documentation](https://docs.openzeppelin.com/cli/2.6/dependencies#writing-contracts.adoc#modifying-your-contracts) for more info. |

The only thing missing is actually _setting_ the `owner` of the contract. To do this, we can add another function that we will call when upgrading, making sure it can only be called once:

```solidity hljs
// contracts/TokenExchange.sol
contract TokenExchange is Initializable {
  uint256 public rate;
  IERC20 public token;
  address public owner;

  function withdraw() public {
    require(msg.sender == owner, "Address not allowed to call this function");
    msg.sender.transfer(address(this).balance);
  }

  // To be run during upgrade, ensuring it can never be called again
  function setOwner(address _owner) public {
    require(owner == address(0), "Owner already set, cannot modify!");
    owner = _owner;
  }

  // (existing functions not shown here for brevity)
}
```

We can now upgrade our token exchange contract to this new version, and call `setOwner` during the upgrade process. The OpenZeppelin CLI will take care of making the upgrade and the call atomically in a single transaction.

```console hljs language-shell
$ npx oz upgrade
? Pick a network: development
✓ Compiled contracts with solc 0.5.9 (commit.e560f70d)
- New variable 'address owner' was added in contract TokenExchange in contracts/TokenExchange.sol:1 at the end of the contract.
✓ Contract TokenExchange deployed
? Which proxies would you like to upgrade?: Choose by name
? Pick a contract to upgrade: TokenExchange
? Call a function on the instance after upgrading it?: Yes
? Select which function: setOwner(_owner: address)
? _owner (address): 0x90f8bf6a479f320ead074411a4b0e7944ea8c9c1
✓ Instance upgraded at 0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec.
```

There! We can now call `withdraw` from our default address to extract all ETH sent to the exchange.

```console hljs language-shell
$ npx oz send-tx
? Pick a network: development
? Pick an instance: TokenExchange at 0xD86C8F0327494034F60e25074420BcCF560D5610
? Select which function: withdraw()
✓ Transaction successful. Transaction hash: 0xc9fb0d3ada96ec4c67c1c8f1569f9cfaf0ff0f7b241e172b32a023b1763ab7ab
```

|     |     |
| --- | --- |
|  | You can also upgrade dependencies from an Ethereum Package. Upon a new release of `@openzeppelin/contracts-ethereum-package`, if you want to update your ERC20 to include the latest fixes, you can just `oz link` the new version and use `oz upgrade` to get your instance to the newest code. |

## Wrapping Up

We have built a more complex setup in this tutorial, and learned several concepts along the way. We introduced [Ethereum Packages](https://blog.openzeppelin.com/open-source-collaboration-in-the-blockchain-era-evm-packages/) as dependencies for our projects, allowing us to spin up a new token with little effort.

We also presented some [limitations](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable) of [how Upgrades works](https://docs.openzeppelin.com/upgrades/2.8/proxies), such as [initializer methods](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#initializers) as a replacement for constructors, and [preserving the storage layout](https://docs.openzeppelin.com/upgrades/2.8/writing-upgradeable#modifying-your-contracts) when modifying our source code. We also learned how to run a function as a migration when upgrading a contract.

[← Getting Started](https://docs.openzeppelin.com/cli/2.6/getting-started)

[Compiling →](https://docs.openzeppelin.com/cli/2.6/compiling)Deploying Smart Contracts Using <code>CREATE2</code> - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Deploying Smart Contracts Using `CREATE2`

The [`CREATE2`](https://eips.ethereum.org/EIPS/eip-1014) opcode gives us the ability predict the address where a contract will be deployed, without ever having to do so. This opens up lots of possibilities to improve [user onboarding and scalability](https://blog.openzeppelin.com/getting-the-most-out-of-create2/).

In this guide we will precompute the address where a contract will be deployed and send Ether to it. Then, we’ll deploy an upgradeable contract to that same address, and use it to retrieve the funds previously sent there.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with Solidity, development blockchains and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying and Interacting With Smart Contracts](https://docs.openzeppelin.com/cli/2.6/deploying-with-create2#learn::deploy-and-interact.adoc). |

## Creating a Smart Contract

There are two major ways in which a smart contract can be deployed: with the `CREATE` and `CREATE2` flows. We’ll go through a short overview of how they work and their core difference.

|     |     |
| --- | --- |
|  | If you are already familiar with the goals behind `CREATE2`, feel free to [skip ahead](https://docs.openzeppelin.com/cli/2.6/deploying-with-create2#create2-from-the-cli). |

### `CREATE`

Smart contracts can be created both by other contracts (using [Solidity’s `new` keyword](https://solidity.readthedocs.io/en/v0.5.15/control-structures.html#creating-contracts-via-new)) and by regular accounts (such as when running [`oz create`](https://docs.openzeppelin.com/cli/2.6/commands#create)). In both cases, the address for the new contract is computed the same way: as a function of the sender’s own address and a nonce.

```console hljs language-shell
new_address = hash(sender, nonce)
```

Every account has an associated nonce: for regular accounts it is increased on every transaction, while for contract accounts it is increased on every contract creation. Nonces cannot be reused, and they must be sequential.

This means it is possible to predict the address where the _next_ created contract will be deployed, but _only_ if no other transactions happen before then - an undesirable property for counterfactual systems.

### `CREATE2`

The whole idea behind this opcode is to make the resulting address _independent of future events_. Regardless of what may happen on the blockchain, it will always be possible to deploy the contract at the precomputed address.

New addresses are a function of:

- `0xFF`, a constant that prevents collisions with `CREATE`

- The sender’s own address

- A salt (an arbitrary value provided by the sender)

- The to-be-deployed contract’s bytecode


```console hljs language-shell
new_address = hash(0xFF, sender, salt, bytecode)
```

`CREATE2` guarantees that if `sender` ever deploys `bytecode` using `CREATE2` and the provided `salt`, it will be stored in `new_address`.

Because `bytecode` is included in this computation other agents can _rely_ on the fact that, if a contract is ever deployed to `new_address`, it will be one they know about. This is the key concept behind counterfactual deployments.

## Using `CREATE2` From the CLI

Because `CREATE2` is an EVM opcode, it is normally only usable by smart contracts and not external accounts. However, the OpenZeppelin CLI provides a handy way of running `CREATE2`-like deployments directly from the terminal.

We’ll begin by [initializing a new OpenZeppelin project](https://docs.openzeppelin.com/cli/2.6/getting-started#setting-up-your-project) with a `Vault` contract:

```solidity hljs
// contracts/Vault.sol
pragma solidity ^0.5.0;

import "@openzeppelin/upgrades/contracts/Initializable.sol";

contract Vault is Initializable {
    address payable owner;

    function initialize(address payable _owner) initializer public {
        owner = _owner;
    }

    function withdraw() public {
        require(owner == msg.sender);
        owner.transfer(address(this).balance);
    }
}
```

We will compute the address where `Vault` will be deployed, and send Ether there. Then, we will deploy `Vault` using `CREATE2` and call the `withdraw` method, retrieving the funds that were sent to it before deployment.

|     |     |
| --- | --- |
|  | While this simple example may sound silly, being able to interact with contracts that don’t yet exist is an extremely powerful tool, and is the key building block behind state channels, onboarding solutions and front-running prevention schemes. |

## Computing the Deployment Address

Recall that only smart contracts can use `CREATE2`: for the OpenZeppelin CLI to be able to provide equivalent behavior, we’ll need to do some setup first.

Under the hood, the CLI will use a contract factory to [deploy upgradeable contracts from Solidity](https://docs.openzeppelin.com/upgrades/2.8/creating-upgradeable-from-solidity). This means we’ll need to use two low-level CLI commands that don’t come into play often: [`oz add`](https://docs.openzeppelin.com/cli/2.6/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.6/commands#push):

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add Vault
✓ Added contract Vault
$ npx oz push
✓ Contract Vault deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | You can safely use `CREATE2` without understanding what is going on behind the scenes, but if you want to get down to the gory details, start by learning about [OpenZeppelin Upgrades proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies). |

With this setup out of the way, we can _query_ the CLI for the address where our contracts will be deployed using an arbitrary `salt` by calling [`oz create2`](https://docs.openzeppelin.com/cli/2.6/commands#create2):

```console hljs language-shell
$ npx oz create2 --query --salt 12345 --network development
✓ Deployed ProxyFactory at 0x4e08589Cd399474157f24f591B9fB100D1adD5d9

Any contract created with salt 12345 will be deployed to the following address
0x4e08589Cd399474157f24f591B9fB100D1adD5d9
```

Neat! We can now interact with the computed address, knowing we’ll later be able to deploy a contract there.

## Interacting With the Counterfactual Contract

Under normal circumstances, sending funds to a random Ethereum address is a bad idea. Here however, we know we’ll be able to deploy `Vault` at the computed address and retrieve our funds. So let’s do it!

The easiest way to send Ether is by using [`oz transfer`](https://docs.openzeppelin.com/cli/2.6/commands#transfer):

```console hljs language-shell
$ $ npx oz transfer
? Pick a network development
? Choose the account to send transactions from (0) 0xA84577357099567A750f542C2C002B0aA680d477
? Enter the receiver account 0x98329e006610472e6B372C080833f6D79ED833cf
? Enter an amount to transfer 10 ether
✓ Funds sent. Transaction hash: 0x9cff31198a80cefb9541e5cf406433f985490a4d786b72bb7e07139ae293657d
```

Because the address has no bytecode and we don’t have its private keys, we cannot do much with it other than checking the funds are indeed there:

```console hljs language-shell
$ npx oz balance
? Enter an address to query its balance 0x98329e006610472e6B372C080833f6D79ED833cf
Balance: 10 ETH
```

Let’s get them back.

## Withdrawing From Our `Vault`

`CREATE2` dpeloyments are performed using the same [`oz create2`](https://docs.openzeppelin.com/cli/2.6/commands#create2) command, this time without the `--query` option.

Recall that `Vault` has an `initialize` method for its owner: we’ll call it with one of the accounts we control.

```console hljs language-shell
$ npx oz create2 Vault --salt 12345 --init --args 0xA84577357099567A750f542C2C002B0aA680d477 --network development
✓ Instance created at 0x98329e006610472e6B372C080833f6D79ED833cf
```

If all went well, we should now be able to `withdraw` from our `Vault`:

```console hljs language-shell
$ npx oz send-tx
? Pick a network development
? Pick an instance Vault at 0x272F769068bDB8740e44E6e0E852b97c8C4865b0
? Select which function withdraw()

✓ Transaction successful. Transaction hash: 0xb0a67ba8a198a0d86814519ed12de8fbeaaaab151ae3b70f67a608236627ec4b
```

Success! Just to be sure, let’s verify the `Vault` is indeed empty:

```console hljs language-shell
$ npx oz balance
? Enter an address to query its balance 0x98329e006610472e6B372C080833f6D79ED833cf
Balance: 0 ETH
```

We’ve sent funds to an address we preocumputed, knowing we’d be later able to deploy a contract there and retrieve them. As as a bonus, our `Vault` contract can be upgraded via [`oz upgrade`](https://docs.openzeppelin.com/cli/2.6/commands#upgrade)!

[← Compiling](https://docs.openzeppelin.com/cli/2.6/compiling)

[Using With Truffle →](https://docs.openzeppelin.com/cli/2.6/truffle)Deploying Smart Contracts Using <code>CREATE2</code> - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Deploying Smart Contracts Using `CREATE2`

The [`CREATE2`](https://eips.ethereum.org/EIPS/eip-1014) opcode gives us the ability predict the address where a contract will be deployed, without ever having to do so. This opens up lots of possibilities to improve [user onboarding and scalability](https://blog.openzeppelin.com/getting-the-most-out-of-create2/).

In this guide we will precompute the address where a contract will be deployed and send Ether to it. Then, we’ll deploy an upgradeable contract to that same address, and use it to retrieve the funds previously sent there.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with Solidity, development blockchains and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying and Interacting With Smart Contracts](https://docs.openzeppelin.com/learn/deploying-and-interacting). |

## Creating a Smart Contract

There are two major ways in which a smart contract can be deployed: with the `CREATE` and `CREATE2` flows. We’ll go through a short overview of how they work and their core difference.

|     |     |
| --- | --- |
|  | If you are already familiar with the goals behind `CREATE2`, feel free to [skip ahead](https://docs.openzeppelin.com/cli/2.8/deploying-with-create2#create2-from-the-cli). |

### `CREATE`

Smart contracts can be created both by other contracts (using [Solidity’s `new` keyword](https://solidity.readthedocs.io/en/v0.5.15/control-structures.html#creating-contracts-via-new)) and by regular accounts (such as when running [`oz deploy`](https://docs.openzeppelin.com/cli/2.8/commands#create)). In both cases, the address for the new contract is computed the same way: as a function of the sender’s own address and a nonce.

```console hljs language-shell
new_address = hash(sender, nonce)
```

Every account has an associated nonce: for regular accounts it is increased on every transaction, while for contract accounts it is increased on every contract creation. Nonces cannot be reused, and they must be sequential.

This means it is possible to predict the address where the _next_ created contract will be deployed, but _only_ if no other transactions happen before then - an undesirable property for counterfactual systems.

### `CREATE2`

The whole idea behind this opcode is to make the resulting address _independent of future events_. Regardless of what may happen on the blockchain, it will always be possible to deploy the contract at the precomputed address.

New addresses are a function of:

- `0xFF`, a constant that prevents collisions with `CREATE`

- The sender’s own address

- A salt (an arbitrary value provided by the sender)

- The to-be-deployed contract’s bytecode


```console hljs language-shell
new_address = hash(0xFF, sender, salt, bytecode)
```

`CREATE2` guarantees that if `sender` ever deploys `bytecode` using `CREATE2` and the provided `salt`, it will be stored in `new_address`.

Because `bytecode` is included in this computation other agents can _rely_ on the fact that, if a contract is ever deployed to `new_address`, it will be one they know about. This is the key concept behind counterfactual deployments.

## Using `CREATE2` From the CLI

Because `CREATE2` is an EVM opcode, it is normally only usable by smart contracts and not external accounts. However, the OpenZeppelin CLI provides a handy way of running `CREATE2`-like deployments directly from the terminal.

We’ll begin by [initializing a new OpenZeppelin project](https://docs.openzeppelin.com/cli/2.8/getting-started#setting-up-your-project) with a `Vault` contract:

```solidity hljs
// contracts/Vault.sol
pragma solidity ^0.5.0;

import "@openzeppelin/upgrades/contracts/Initializable.sol";

contract Vault is Initializable {
    address payable owner;

    function initialize(address payable _owner) initializer public {
        owner = _owner;
    }

    function withdraw() public {
        require(owner == msg.sender);
        owner.transfer(address(this).balance);
    }
}
```

We will compute the address where `Vault` will be deployed, and send Ether there. Then, we will deploy `Vault` using `CREATE2` and call the `withdraw` method, retrieving the funds that were sent to it before deployment.

|     |     |
| --- | --- |
|  | While this simple example may sound silly, being able to interact with contracts that don’t yet exist is an extremely powerful tool, and is the key building block behind state channels, onboarding solutions and front-running prevention schemes. |

## Computing the Deployment Address

Recall that only smart contracts can use `CREATE2`: for the OpenZeppelin CLI to be able to provide equivalent behavior, we’ll need to do some setup first.

Under the hood, the CLI will use a contract factory to [deploy upgradeable contracts from Solidity](https://docs.openzeppelin.com/upgrades/2.8/creating-upgradeable-from-solidity). This means we’ll need to use two low-level CLI commands that don’t come into play often: [`oz add`](https://docs.openzeppelin.com/cli/2.8/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.8/commands#push):

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add Vault
✓ Added contract Vault
$ npx oz push
✓ Contract Vault deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | You can safely use `CREATE2` without understanding what is going on behind the scenes, but if you want to get down to the gory details, start by learning about [OpenZeppelin Upgrades proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies). |

With this setup out of the way, we can _query_ the CLI for the address where our contracts will be deployed using an arbitrary `salt` by calling [`oz create2`](https://docs.openzeppelin.com/cli/2.8/commands#create2):

```console hljs language-shell
$ npx oz create2 --query --salt 12345 --network development
✓ Deployed ProxyFactory at 0x4e08589Cd399474157f24f591B9fB100D1adD5d9

Any contract created with salt 12345 will be deployed to the following address
0x4e08589Cd399474157f24f591B9fB100D1adD5d9
```

Neat! We can now interact with the computed address, knowing we’ll later be able to deploy a contract there.

## Interacting With the Counterfactual Contract

Under normal circumstances, sending funds to a random Ethereum address is a bad idea. Here however, we know we’ll be able to deploy `Vault` at the computed address and retrieve our funds. So let’s do it!

The easiest way to send Ether is by using [`oz transfer`](https://docs.openzeppelin.com/cli/2.8/commands#transfer):

```console hljs language-shell
$ $ npx oz transfer
? Pick a network development
? Choose the account to send transactions from (0) 0xA84577357099567A750f542C2C002B0aA680d477
? Enter the receiver account 0x98329e006610472e6B372C080833f6D79ED833cf
? Enter an amount to transfer 10 ether
✓ Funds sent. Transaction hash: 0x9cff31198a80cefb9541e5cf406433f985490a4d786b72bb7e07139ae293657d
```

Because the address has no bytecode and we don’t have its private keys, we cannot do much with it other than checking the funds are indeed there:

```console hljs language-shell
$ npx oz balance
? Enter an address to query its balance 0x98329e006610472e6B372C080833f6D79ED833cf
Balance: 10 ETH
```

Let’s get them back.

## Withdrawing From Our `Vault`

`CREATE2` dpeloyments are performed using the same [`oz create2`](https://docs.openzeppelin.com/cli/2.8/commands#create2) command, this time without the `--query` option.

Recall that `Vault` has an `initialize` method for its owner: we’ll call it with one of the accounts we control.

```console hljs language-shell
$ npx oz create2 Vault --salt 12345 --init --args 0xA84577357099567A750f542C2C002B0aA680d477 --network development
✓ Instance created at 0x98329e006610472e6B372C080833f6D79ED833cf
```

If all went well, we should now be able to `withdraw` from our `Vault`:

```console hljs language-shell
$ npx oz send-tx
? Pick a network development
? Pick an instance Vault at 0x272F769068bDB8740e44E6e0E852b97c8C4865b0
? Select which function withdraw()

✓ Transaction successful. Transaction hash: 0xb0a67ba8a198a0d86814519ed12de8fbeaaaab151ae3b70f67a608236627ec4b
```

Success! Just to be sure, let’s verify the `Vault` is indeed empty:

```console hljs language-shell
$ npx oz balance
? Enter an address to query its balance 0x98329e006610472e6B372C080833f6D79ED833cf
Balance: 0 ETH
```

We’ve sent funds to an address we preocumputed, knowing we’d be later able to deploy a contract there and retrieve them. As as a bonus, our `Vault` contract can be upgraded via [`oz upgrade`](https://docs.openzeppelin.com/cli/2.8/commands#upgrade)!

[← Compiling](https://docs.openzeppelin.com/cli/2.8/compiling)

[Using With Truffle →](https://docs.openzeppelin.com/cli/2.8/truffle)Publishing an Ethereum Package - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Publishing an Ethereum Package

In [Using Dependencies](https://docs.openzeppelin.com/cli/2.7/dependencies), we showed how to use the [`oz link`](https://docs.openzeppelin.com/cli/2.7/commands#link) command to use the [OpenZeppelin Contracts Ethereum Package](https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package) as a dependency, taking advantage of its contracts being _already deployed on the blockchain_.

In this guide we’ll describe how you can create your own Ethereum Package, and make it available to everyone via the OpenZeppelin CLI.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with using public networks, upgradeable contracts, and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying to a Public Test Network](https://docs.openzeppelin.com/learn/connecting-to-public-test-networks) and [Upgrades](https://docs.openzeppelin.com/learn/upgrading-smart-contracts). |

## Storing Your Project On-chain

So far, we’ve mostly limited ourselves to depoying contracts using [`oz deploy`](https://docs.openzeppelin.com/cli/2.7/commands#create), which creates _upgradeable instances_ by deploying _proxies_ to an existing implementation contract (refer to [How Upgrades Work](https://docs.openzeppelin.com/learn/upgrading-smart-contracts#how-upgrades-work) to brush up on this). Here, we will instead deploy just the implementations, so that other people can create new proxies pointing to them.

To achieve this, we’ll use two low-level CLI commands: [`oz add`](https://docs.openzeppelin.com/cli/2.7/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.7/commands#push). These work simmilarly to `git add` and `git push`: they will register contracts in your project and deploy them to a network.

In your [OpenZeppelin project](https://docs.openzeppelin.com/cli/2.7/getting-started#setting-up-your-project), run:

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add <contract-1>, <contract-2>
✓ Added contract <contract-1>
✓ Added contract <contract-2>
All the selected contracts have been added to the project
$ npx oz push
? Pick a network mainnet
✓ Contract <contract-1> deployed
✓ Contract <contract-2> deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | For your Ethereum Pacakge to be used by others, it needs to be deployed on a real network instead of a local one. Take a look at [Deploying to a Public Test Network](https://docs.openzeppelin.com/learn/connecting-to-public-test-networks) for detailed instructions for this process. |

Ethereum Packages are upgradeable, which means they track the different implementation contracts that correspond to each version of the package. We’ll use the [`oz publish`](https://docs.openzeppelin.com/cli/2.7/commands#publish) command for this, which will deploy an [`App`](https://docs.openzeppelin.com/cli/2.7/contracts-architecture#app.sol) contract and register the implementations there:

```console hljs language-shell
$ npx oz publish
? Pick a network mainnet
✓ Project structure deployed
✓ Registering <contract-1> at 0x2c2eB5B599C2C4Bb2cA7e43179585aFec0D97D51 in directory
✓ Registering <contract-2> at 0x6389e6409Ad106aF5e7e6bE8D95Fca637980fB63 in directory
✓ Published to mainnet!
```

The Ethereum Package is complete! But we’re still lacking something: a convenient way to tell people about its existence.

## Distributing With `npm`

For your Ethereum Package to [usable from other projects](https://docs.openzeppelin.com/cli/2.7/dependencies), it needs to be published on the [npm registry](https://www.npmjs.com/). If you havent’t published an npm package before, go ahead and [sign up for a free npm account](https://www.npmjs.com/signup).

First, add your contract sources, compiled artifacts and OpenZeppelin project files to your package by including the following entries in your project’s `package.json`:

```diff hljs
 // package.json
 {
   ...,
   "files": [\
+    "build",\
+    "contracts",\
+    ".openzeppelin/*.json"\
   ]
 }
```

|     |     |
| --- | --- |
|  | The files in your `.openzeppelin` directory that [should not be tracked in version control](https://docs.openzeppelin.com/cli/2.7/configuration#configuration-files-in-version-control) are not required to be part of your published npm package: remove them before publishing to the registry. |

Almost done! Log into npm and upload your package with:

```console hljs language-shell
$ npm login
$ npm publish
```

Success! The Ethereum Package is now live on the blockchain, and accessible to everyone via the npm registry.

Any OpenZeppelin project can now [link](https://docs.openzeppelin.com/cli/2.7/commands#link) to your package:

```console hljs language-shell
$ npx oz link <your-project-name>
```

|     |     |
| --- | --- |
|  | Your Ethereum Package’s name is the same one you provided [during initialization](https://docs.openzeppelin.com/cli/2.7/getting-started#setting-up-your-project). |Deploying Smart Contracts Using <code>CREATE2</code> - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Deploying Smart Contracts Using `CREATE2`

The [`CREATE2`](https://eips.ethereum.org/EIPS/eip-1014) opcode gives us the ability predict the address where a contract will be deployed, without ever having to do so. This opens up lots of possibilities to improve [user onboarding and scalability](https://blog.openzeppelin.com/getting-the-most-out-of-create2/).

In this guide we will precompute the address where a contract will be deployed and send Ether to it. Then, we’ll deploy an upgradeable contract to that same address, and use it to retrieve the funds previously sent there.

|     |     |
| --- | --- |
|  | This guide features advanced usage of OpenZeppelin tools, and requires familiarity with Solidity, development blockchains and the OpenZeppelin CLI.<br>For a refresher on the topics, head to [Deploying and Interacting With Smart Contracts](https://docs.openzeppelin.com/learn/deploying-and-interacting). |

## Creating a Smart Contract

There are two major ways in which a smart contract can be deployed: with the `CREATE` and `CREATE2` flows. We’ll go through a short overview of how they work and their core difference.

|     |     |
| --- | --- |
|  | If you are already familiar with the goals behind `CREATE2`, feel free to [skip ahead](https://docs.openzeppelin.com/cli/2.7/deploying-with-create2#create2-from-the-cli). |

### `CREATE`

Smart contracts can be created both by other contracts (using [Solidity’s `new` keyword](https://solidity.readthedocs.io/en/v0.5.15/control-structures.html#creating-contracts-via-new)) and by regular accounts (such as when running [`oz create`](https://docs.openzeppelin.com/cli/2.7/commands#create)). In both cases, the address for the new contract is computed the same way: as a function of the sender’s own address and a nonce.

```console hljs language-shell
new_address = hash(sender, nonce)
```

Every account has an associated nonce: for regular accounts it is increased on every transaction, while for contract accounts it is increased on every contract creation. Nonces cannot be reused, and they must be sequential.

This means it is possible to predict the address where the _next_ created contract will be deployed, but _only_ if no other transactions happen before then - an undesirable property for counterfactual systems.

### `CREATE2`

The whole idea behind this opcode is to make the resulting address _independent of future events_. Regardless of what may happen on the blockchain, it will always be possible to deploy the contract at the precomputed address.

New addresses are a function of:

- `0xFF`, a constant that prevents collisions with `CREATE`

- The sender’s own address

- A salt (an arbitrary value provided by the sender)

- The to-be-deployed contract’s bytecode


```console hljs language-shell
new_address = hash(0xFF, sender, salt, bytecode)
```

`CREATE2` guarantees that if `sender` ever deploys `bytecode` using `CREATE2` and the provided `salt`, it will be stored in `new_address`.

Because `bytecode` is included in this computation other agents can _rely_ on the fact that, if a contract is ever deployed to `new_address`, it will be one they know about. This is the key concept behind counterfactual deployments.

## Using `CREATE2` From the CLI

Because `CREATE2` is an EVM opcode, it is normally only usable by smart contracts and not external accounts. However, the OpenZeppelin CLI provides a handy way of running `CREATE2`-like deployments directly from the terminal.

We’ll begin by [initializing a new OpenZeppelin project](https://docs.openzeppelin.com/cli/2.7/getting-started#setting-up-your-project) with a `Vault` contract:

```solidity hljs
// contracts/Vault.sol
pragma solidity ^0.5.0;

import "@openzeppelin/upgrades/contracts/Initializable.sol";

contract Vault is Initializable {
    address payable owner;

    function initialize(address payable _owner) initializer public {
        owner = _owner;
    }

    function withdraw() public {
        require(owner == msg.sender);
        owner.transfer(address(this).balance);
    }
}
```

We will compute the address where `Vault` will be deployed, and send Ether there. Then, we will deploy `Vault` using `CREATE2` and call the `withdraw` method, retrieving the funds that were sent to it before deployment.

|     |     |
| --- | --- |
|  | While this simple example may sound silly, being able to interact with contracts that don’t yet exist is an extremely powerful tool, and is the key building block behind state channels, onboarding solutions and front-running prevention schemes. |

## Computing the Deployment Address

Recall that only smart contracts can use `CREATE2`: for the OpenZeppelin CLI to be able to provide equivalent behavior, we’ll need to do some setup first.

Under the hood, the CLI will use a contract factory to [deploy upgradeable contracts from Solidity](https://docs.openzeppelin.com/upgrades/2.8/creating-upgradeable-from-solidity). This means we’ll need to use two low-level CLI commands that don’t come into play often: [`oz add`](https://docs.openzeppelin.com/cli/2.7/commands#add) and [`oz push`](https://docs.openzeppelin.com/cli/2.7/commands#push):

```console hljs language-shell
$ npx oz add
? Pick which contracts you want to add Vault
✓ Added contract Vault
$ npx oz push
✓ Contract Vault deployed
All contracts have been deployed
```

|     |     |
| --- | --- |
|  | You can safely use `CREATE2` without understanding what is going on behind the scenes, but if you want to get down to the gory details, start by learning about [OpenZeppelin Upgrades proxies](https://docs.openzeppelin.com/upgrades/2.8/proxies). |

With this setup out of the way, we can _query_ the CLI for the address where our contracts will be deployed using an arbitrary `salt` by calling [`oz create2`](https://docs.openzeppelin.com/cli/2.7/commands#create2):

```console hljs language-shell
$ npx oz create2 --query --salt 12345 --network development
✓ Deployed ProxyFactory at 0x4e08589Cd399474157f24f591B9fB100D1adD5d9

Any contract created with salt 12345 will be deployed to the following address
0x4e08589Cd399474157f24f591B9fB100D1adD5d9
```

Neat! We can now interact with the computed address, knowing we’ll later be able to deploy a contract there.

## Interacting With the Counterfactual Contract

Under normal circumstances, sending funds to a random Ethereum address is a bad idea. Here however, we know we’ll be able to deploy `Vault` at the computed address and retrieve our funds. So let’s do it!

The easiest way to send Ether is by using [`oz transfer`](https://docs.openzeppelin.com/cli/2.7/commands#transfer):

```console hljs language-shell
$ $ npx oz transfer
? Pick a network development
? Choose the account to send transactions from (0) 0xA84577357099567A750f542C2C002B0aA680d477
? Enter the receiver account 0x98329e006610472e6B372C080833f6D79ED833cf
? Enter an amount to transfer 10 ether
✓ Funds sent. Transaction hash: 0x9cff31198a80cefb9541e5cf406433f985490a4d786b72bb7e07139ae293657d
```

Because the address has no bytecode and we don’t have its private keys, we cannot do much with it other than checking the funds are indeed there:

```console hljs language-shell
$ npx oz balance
? Enter an address to query its balance 0x98329e006610472e6B372C080833f6D79ED833cf
Balance: 10 ETH
```

Let’s get them back.

## Withdrawing From Our `Vault`

`CREATE2` dpeloyments are performed using the same [`oz create2`](https://docs.openzeppelin.com/cli/2.7/commands#create2) command, this time without the `--query` option.

Recall that `Vault` has an `initialize` method for its owner: we’ll call it with one of the accounts we control.

```console hljs language-shell
$ npx oz create2 Vault --salt 12345 --init --args 0xA84577357099567A750f542C2C002B0aA680d477 --network development
✓ Instance created at 0x98329e006610472e6B372C080833f6D79ED833cf
```

If all went well, we should now be able to `withdraw` from our `Vault`:

```console hljs language-shell
$ npx oz send-tx
? Pick a network development
? Pick an instance Vault at 0x272F769068bDB8740e44E6e0E852b97c8C4865b0
? Select which function withdraw()

✓ Transaction successful. Transaction hash: 0xb0a67ba8a198a0d86814519ed12de8fbeaaaab151ae3b70f67a608236627ec4b
```

Success! Just to be sure, let’s verify the `Vault` is indeed empty:

```console hljs language-shell
$ npx oz balance
? Enter an address to query its balance 0x98329e006610472e6B372C080833f6D79ED833cf
Balance: 0 ETH
```

We’ve sent funds to an address we preocumputed, knowing we’d be later able to deploy a contract there and retrieve them. As as a bonus, our `Vault` contract can be upgraded via [`oz upgrade`](https://docs.openzeppelin.com/cli/2.7/commands#upgrade)!

[← Compiling](https://docs.openzeppelin.com/cli/2.7/compiling)

[Using With Truffle →](https://docs.openzeppelin.com/cli/2.7/truffle)Account - OpenZeppelin Docs

# Account

This crate provides components to implement account contracts that can be used for interacting with the network.

## Core

### `ISRC6`

```cairo hljs
use openzeppelin_account::interface::ISRC6;
```

Interface of the SRC6 Standard Account as defined in the [SNIP-6](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-6.md).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x2ceccef7f994940b3962a6c67e0ba4fcd37df7d131417c604f91e03caecc1cd

Functions

- [`__execute__(calls)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-__execute__)

- [`__validate__(calls)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-__validate__)

- [`is_valid_signature(hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-is_valid_signature)


#### Functions

#### `__execute__(calls: Array<Call>) → Array<Span<felt252>>` external

Executes the list of calls as a transaction after validation.

Returns an array with each call’s output.

|     |     |
| --- | --- |
|  | The `Call` struct is defined in [corelib](https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/account.cairo#L3). |

#### `__validate__(calls: Array<Call>) → felt252` external

Validates a transaction before execution.

Returns the short string `'VALID'` if valid, otherwise it reverts.

#### `is_valid_signature(hash: felt252, signature: Array<felt252>) → felt252` external

Validates whether a signature is valid or not for the given message hash.

Returns the short string `'VALID'` if valid, otherwise it reverts.

### `AccountComponent`

```cairo hljs
use openzeppelin_account::AccountComponent;
```

Account component implementing [`ISRC6`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6) for signatures over the [Starknet curve](https://docs.starknet.io/documentation/architecture_and_concepts/Cryptography/stark-curve/).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

AccountMixinImpl

- [`SRC6Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-Embeddable-Impls-SRC6Impl)

- [`DeclarerImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-Embeddable-Impls-DeclarerImpl)

- [`DeployableImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-Embeddable-Impls-DeployableImpl)

- [`PublicKeyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-Embeddable-Impls-PublicKeyImpl)

- [`SRC6CamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-Embeddable-Impls-SRC6CamelOnlyImpl)

- [`PublicKeyCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-Embeddable-Impls-PublicKeyCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

SRC6Impl

- [`__execute__(self, calls)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-__execute__)

- [`__validate__(self, calls)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-__validate__)

- [`is_valid_signature(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-is_valid_signature)


DeclarerImpl

- [`__validate_declare__(self, class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-__validate_declare__)


DeployableImpl

- [`__validate_deploy__(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-__validate_deploy__)


PublicKeyImpl

- [`get_public_key(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-get_public_key)

- [`set_public_key(self, new_public_key, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-set_public_key)


SRC6CamelOnlyImpl

- [`isValidSignature(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-isValidSignature)


PublicKeyCamelImpl

- [`getPublicKey(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-getPublicKey)

- [`setPublicKey(self, newPublicKey, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-setPublicKey)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


Internal Implementations

InternalImpl

- [`initializer(self, public_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-initializer)

- [`assert_only_self(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-assert_only_self)

- [`assert_valid_new_owner(self, current_owner, new_owner, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-assert_valid_new_owner)

- [`validate_transaction(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-validate_transaction)

- [`_set_public_key(self, new_public_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-_set_public_key)

- [`_is_valid_signature(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-_is_valid_signature)


Events

- [`OwnerAdded(new_owner_guid)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-OwnerAdded)

- [`OwnerRemoved(removed_owner_guid)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-OwnerRemoved)


#### Embeddable functions

#### `__execute__(self: @ContractState, calls: Array<Call>) → Array<Span<felt252>>` external

See [ISRC6::\_\_execute\_\_](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-__execute__).

#### `__validate__(self: @ContractState, calls: Array<Call>) → felt252` external

See [ISRC6::\_\_validate\_\_](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-__validate__).

#### `is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252` external

See [ISRC6::is\_valid\_signature](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-is_valid_signature).

#### `__validate_declare__(self: @ContractState, class_hash: felt252) → felt252` external

Validates a [`Declare` transaction](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/transactions/#declare-transaction).

Returns the short string `'VALID'` if valid, otherwise it reverts.

#### `__validate_deploy__(self: @ContractState, class_hash: felt252, contract_address_salt: felt252, public_key: felt252) → felt252` external

Validates a [`DeployAccount` transaction](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/transactions/#deploy_account_transaction).
See [Counterfactual Deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment).

Returns the short string `'VALID'` if valid, otherwise it reverts.

#### `get_public_key(self: @ContractState) → felt252` external

Returns the current public key of the account.

#### `set_public_key(ref self: ContractState, new_public_key: felt252, signature: Span<felt252>)` external

Sets a new public key for the account. Only accessible by the account calling itself through `__execute__`.

Requirements:

- The caller must be the contract itself.

- The signature must be valid for the new owner.


Emits both an [OwnerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-OwnerRemoved) and an [OwnerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-OwnerAdded) event.

|     |     |
| --- | --- |
|  | The message to be signed is computed in Cairo as follows:<br>```javascript hljs<br>let message_hash = PoseidonTrait::new()<br>        .update_with('StarkNet Message')<br>        .update_with('accept_ownership')<br>        .update_with(get_contract_address())<br>        .update_with(current_owner)<br>        .finalize();<br>``` |

#### `isValidSignature(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252` external

See [ISRC6::is\_valid\_signature](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-is_valid_signature).

#### `getPublicKey(self: @ContractState) → felt252` external

See [get\_public\_key](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-get_public_key).

#### `setPublicKey(ref self: ContractState, newPublicKey: felt252, signature: Span<felt252>)` external

See [set\_public\_key](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-set_public_key).

#### Internal functions

#### `initializer(ref self: ComponentState, public_key: felt252)` internal

Initializes the account with the given public key, and registers the `ISRC6` interface ID.

Emits an [OwnerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-OwnerAdded) event.

#### `assert_only_self(self: @ComponentState)` internal

Validates that the caller is the account itself. Otherwise it reverts.

#### `assert_valid_new_owner(self: @ComponentState, current_owner: felt252, new_owner: felt252, signature: Span<felt252>)` internal

Validates that `new_owner` accepted the ownership of the contract through a signature.

Requirements:

- `signature` must be valid for the new owner.


|     |     |
| --- | --- |
|  | This function assumes that `current_owner` is the current owner of the contract, and<br>does not validate this assumption. |

#### `validate_transaction(self: @ComponentState) → felt252` internal

Validates a transaction signature from the
[global context](https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L61).

Returns the short string `'VALID'` if valid, otherwise it reverts.

#### `_set_public_key(ref self: ComponentState, new_public_key: felt252)` internal

Set the public key without validating the caller.

Emits an [OwnerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-OwnerAdded) event.

|     |     |
| --- | --- |
|  | The usage of this method outside the `set_public_key` function is discouraged. |

#### `_is_valid_signature(self: @ComponentState, hash: felt252, signature: Span<felt252>) → bool` internal

Validates the provided `signature` for the `hash`, using the account’s current public key.

#### Events

#### `OwnerAdded(new_owner_guid: felt252)` event

Emitted when a `public_key` is added.

#### `OwnerRemoved(removed_owner_guid: felt252)` event

Emitted when a `public_key` is removed.

### `EthAccountComponent`

```cairo hljs
use openzeppelin_account::eth_account::EthAccountComponent;
```

Account component implementing [`ISRC6`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6) for signatures over the [Secp256k1 curve](https://en.bitcoin.it/wiki/Secp256k1).

|     |     |
| --- | --- |
|  | Implementing [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) is a requirement for this component to be implemented. |

|     |     |
| --- | --- |
|  | The `EthPublicKey` type is an alias for `starknet::secp256k1::Secp256k1Point`. |

[Embeddable Mixin Implementations](https://docs.openzeppelin.com/contracts-cairo/0.20.0/components#mixins)

EthAccountMixinImpl

- [`SRC6Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-Embeddable-Impls-SRC6Impl)

- [`DeclarerImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-Embeddable-Impls-DeclarerImpl)

- [`DeployableImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-Embeddable-Impls-DeployableImpl)

- [`PublicKeyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-Embeddable-Impls-PublicKeyImpl)

- [`SRC6CamelOnlyImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-Embeddable-Impls-SRC6CamelOnlyImpl)

- [`PublicKeyCamelImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-Embeddable-Impls-PublicKeyCamelImpl)

- [`SRC5Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component-Embeddable-Impls)


Embeddable Implementations

SRC6Impl

- [`__execute__(self, calls)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-__execute__)

- [`__validate__(self, calls)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-__validate__)

- [`is_valid_signature(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-is_valid_signature)


DeclarerImpl

- [`__validate_declare__(self, class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-__validate_declare__)


DeployableImpl

- [`__validate_deploy__(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-__validate_deploy__)


PublicKeyImpl

- [`get_public_key(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-get_public_key)

- [`set_public_key(self, new_public_key, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-set_public_key)


SRC6CamelOnlyImpl

- [`isValidSignature(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-isValidSignature)


PublicKeyCamelImpl

- [`getPublicKey(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-getPublicKey)

- [`setPublicKey(self, newPublicKey, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-setPublicKey)


SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5-supports_interface)


Internal Implementations

InternalImpl

- [`initializer(self, public_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-initializer)

- [`assert_only_self(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-assert_only_self)

- [`assert_valid_new_owner(self, current_owner, new_owner, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-assert_valid_new_owner)

- [`validate_transaction(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-validate_transaction)

- [`_set_public_key(self, new_public_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-_set_public_key)

- [`_is_valid_signature(self, hash, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-_is_valid_signature)


Events

- [`OwnerAdded(new_owner_guid)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-OwnerAdded)

- [`OwnerRemoved(removed_owner_guid)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-OwnerRemoved)


#### Embeddable functions

#### `__execute__(self: @ContractState, calls: Array<Call>) → Array<Span<felt252>>` external

See [ISRC6::\_\_execute\_\_](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-__execute__).

#### `__validate__(self: @ContractState, calls: Array<Call>) → felt252` external

See [ISRC6::\_\_validate\_\_](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-__validate__).

#### `is_valid_signature(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252` external

See [ISRC6::is\_valid\_signature](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-is_valid_signature).

#### `__validate_declare__(self: @ContractState, class_hash: felt252) → felt252` external

Validates a [`Declare` transaction](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/Blocks/transactions/#declare-transaction).

Returns the short string `'VALID'` if valid, otherwise it reverts.

#### `__validate_deploy__(self: @ContractState, class_hash: felt252, contract_address_salt: felt252, public_key: EthPublicKey) → felt252` external

Validates a [`DeployAccount` transaction](https://docs.starknet.io/documentation/architecture_and_concepts/Network_Architecture/Blocks/transactions/#deploy_account_transaction).
See [Counterfactual Deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment).

Returns the short string `'VALID'` if valid, otherwise it reverts.

#### `get_public_key(self: @ContractState) → EthPublicKey` external

Returns the current public key of the account.

#### `set_public_key(ref self: ContractState, new_public_key: EthPublicKey, signature: Span<felt252>)` external

Sets a new public key for the account. Only accessible by the account calling itself through `__execute__`.

Requirements:

- The caller must be the contract itself.

- The signature must be valid for the new owner.


Emits both an [OwnerRemoved](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-OwnerRemoved) and an [OwnerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-OwnerAdded) event.

|     |     |
| --- | --- |
|  | The message to be signed is computed in Cairo as follows:<br>```javascript hljs<br>let message_hash = PoseidonTrait::new()<br>        .update_with('StarkNet Message')<br>        .update_with('accept_ownership')<br>        .update_with(get_contract_address())<br>        .update_with(current_owner.get_coordinates().unwrap_syscall())<br>        .finalize();<br>``` |

#### `isValidSignature(self: @ContractState, hash: felt252, signature: Array<felt252>) → felt252` external

See [ISRC6::is\_valid\_signature](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6-is_valid_signature).

#### `getPublicKey(self: @ContractState) → EthPublicKey` external

See [get\_public\_key](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-get_public_key).

#### `setPublicKey(ref self: ContractState, newPublicKey: EthPublicKey, signature: Span<felt252>)` external

See [set\_public\_key](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-set_public_key).

#### Internal functions

#### `initializer(ref self: ComponentState, public_key: EthPublicKey)` internal

Initializes the account with the given public key, and registers the `ISRC6` interface ID.

Emits an [OwnerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-OwnerAdded) event.

#### `assert_only_self(self: @ComponentState)` internal

Validates that the caller is the account itself. Otherwise it reverts.

#### `assert_valid_new_owner(self: @ComponentState, current_owner: EthPublicKey, new_owner: EthPublicKey, signature: Span<felt252>)` internal

Validates that `new_owner` accepted the ownership of the contract through a signature.

Requirements:

- The signature must be valid for the `new_owner`.


|     |     |
| --- | --- |
|  | This function assumes that `current_owner` is the current owner of the contract, and<br>does not validate this assumption. |

#### `validate_transaction(self: @ComponentState) → felt252` internal

Validates a transaction signature from the
[global context](https://github.com/starkware-libs/cairo/blob/main/corelib/src/starknet/info.cairo#L61).

Returns the short string `'VALID'` if valid, otherwise it reverts.

#### `_set_public_key(ref self: ComponentState, new_public_key: EthPublicKey)` internal

Set the public key without validating the caller.

Emits an [OwnerAdded](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-OwnerAdded) event.

|     |     |
| --- | --- |
|  | The usage of this method outside the `set_public_key` function is discouraged. |

#### `_is_valid_signature(self: @ComponentState, hash: felt252, signature: Span<felt252>) → bool` internal

Validates the provided `signature` for the `hash`, using the account’s current public key.

#### Events

|     |     |
| --- | --- |
|  | The `guid` is computed as the hash of the public key, using the poseidon hash function. |

#### `OwnerAdded(new_owner_guid: felt252)` event

Emitted when a `public_key` is added.

#### `OwnerRemoved(removed_owner_guid: felt252)` event

Emitted when a `public_key` is removed.

## Extensions

### `ISRC9_V2`

```cairo hljs
use openzeppelin_account::extensions::src9::ISRC9_V2;
```

Interface of the SRC9 Standard as defined in the [SNIP-9](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-9.md).

[SRC5 ID](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#ISRC5)

0x1d1144bb2138366ff28d8e9ab57456b1d332ac42196230c3a602003c89872

Functions

- [`execute_from_outside_v2(outside_execution, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC9_V2-execute_from_outside_v2)

- [`is_valid_outside_execution_nonce(nonce)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC9_V2-is_valid_outside_execution_nonce)


#### Functions

#### `execute_from_outside_v2(outside_execution: OutsideExecution, signature: Span<felt252>,) → Array<Span<felt252>>` external

Allows anyone to submit a transaction on behalf of the account as long as they have the relevant signatures.

This method allows reentrancy. A call to `__execute__` or `execute_from_outside_v2` can trigger
another nested transaction to `execute_from_outside_v2` thus the implementation MUST verify
that the provided `signature` matches the hash of `outside_execution` and that `nonce` was
not already used.

The implementation should expect version to be set to 2 in the domain separator.

Arguments:

- `outside_execution` \- The parameters of the transaction to execute.

- `signature` \- A valid signature on the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message encoding of `outside_execution`.


#### `is_valid_outside_execution_nonce(nonce: felt252) → bool` external

Get the status of a given nonce. `true` if the nonce is available to use.

### `SRC9Component`

```cairo hljs
use openzeppelin_account::extensions::SRC9Component;
```

OutsideExecution component implementing [`ISRC9_V2`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC9_V2).

|     |     |
| --- | --- |
|  | This component is signature-agnostic, meaning it can be integrated into any account contract, as long as the<br>account implements the ISRC6 interface. |

Embeddable Implementations

OutsideExecutionV2Impl

- [`execute_from_outside_v2(self, outside_execution, signature)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#SRC9Component-execute_from_outside_v2)

- [`is_valid_outside_execution_nonce(self, nonce)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#SRC9Component-is_valid_outside_execution_nonce)


Internal Implementations

InternalImpl

- [`initializer(self)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#SRC9Component-initializer)


#### Embeddable functions

#### `execute_from_outside_v2(ref self: ContractState, outside_execution: OutsideExecution, signature: Span<felt252>) → Array<Span<felt252>>` external

Allows anyone to submit a transaction on behalf of the account as long as they
have the relevant signatures.

This method allows reentrancy. A call to `__execute__` or `execute_from_outside_v2` can
trigger another nested transaction to `execute_from_outside_v2`. This implementation
verifies that the provided `signature` matches the hash of `outside_execution` and that
`nonce` was not already used.

Arguments:

- `outside_execution` \- The parameters of the transaction to execute.

- `signature` \- A valid signature on the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message encoding of
`outside_execution`.


Requirements:

- The caller must be the `outside_execution.caller` unless 'ANY\_CALLER' is used.

- The current time must be within the `outside_execution.execute_after` and `outside_execution.execute_before` span.

- The `outside_execution.nonce` must not be used before.

- The `signature` must be valid.


#### `is_valid_outside_execution_nonce(self: @ContractState, nonce: felt252) → bool` external

Returns the status of a given nonce. `true` if the nonce is available to use.

#### Internal functions

#### `initializer(ref self: ComponentState)` internal

Initializes the account by registering the `ISRC9_V2` interface ID.

## Presets

### `AccountUpgradeable`

```cairo hljs
use openzeppelin_presets::AccountUpgradeable;
```

Upgradeable account which can change its public key and declare, deploy, or call
contracts. Supports outside execution by implementing [SRC9](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#SRC9Component).

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x02b31e19e45c06f29234e06e2ee98a9966479ba3067f8785ed972794fdb0065c

Constructor

- [`constructor(self, public_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountUpgradeable-constructor)


Embedded Implementations

AccountComponent

- [`AccountMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountComponent-Embeddable-Mixin-Impl)


SRC9Component

- [`OutsideExecutionV2Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#SRC9Component-Embeddable-Impls-OutsideExecutionV2Impl)


External Functions

- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#AccountUpgradeable-upgrade)


#### Constructor

#### `constructor(ref self: ContractState, public_key: felt252)` constructor

Sets the account `public_key` and registers the interfaces the contract supports.

#### External functions

#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` external

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the account contract itself.

- `new_class_hash` cannot be zero.


### `EthAccountUpgradeable`

```cairo hljs
use openzeppelin_presets::EthAccountUpgradeable;
```

Upgradeable account which can change its public key and declare, deploy, or call contracts, using Ethereum
signing keys. Supports outside execution by implementing [SRC9](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#SRC9Component).

|     |     |
| --- | --- |
|  | The `EthPublicKey` type is an alias for `starknet::secp256k1::Secp256k1Point`. |

[Sierra class hash](https://docs.openzeppelin.com/contracts-cairo/0.20.0/presets)

0x02ba7c42372cf971c8ee60166544e7ff72c2e38bc2835d7edd89b327b1000d8b

Constructor

- [`constructor(self, public_key)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountUpgradeable-constructor)


Embedded Implementations

EthAccountComponent

- [`EthAccountMixinImpl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountComponent-Embeddable-Mixin-Impl)


SRC9Component

- [`OutsideExecutionV2Impl`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#SRC9Component-Embeddable-Impls-OutsideExecutionV2Impl)


External Functions

- [`upgrade(self, new_class_hash)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#EthAccountUpgradeable-upgrade)


#### Constructor

#### `constructor(ref self: ContractState, public_key: EthPublicKey)` constructor

Sets the account `public_key` and registers the interfaces the contract supports.

#### External functions

#### `upgrade(ref self: ContractState, new_class_hash: ClassHash)` external

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the account contract itself.

- `new_class_hash` cannot be zero.


[← Accounts](https://docs.openzeppelin.com/contracts-cairo/0.20.0/accounts)

[Finance →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/finance)Utilities - OpenZeppelin Docs

# Utilities

This crate provides miscellaneous components and libraries containing utility functions to handle common tasks.

## Core

### `utils`

```cairo hljs
use openzeppelin_utils;
```

Module containing core utilities of the library.

Members

Inner modules

- [`cryptography`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#utils-cryptography)

- [`deployments`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#utils-deployments)

- [`math`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#utils-math)

- [`serde`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#utils-serde)


#### Inner modules

#### `cryptography` module

See [`openzeppelin_utils::cryptography`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#cryptography).

#### `deployments` module

See [`openzeppelin_utils::deployments`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments).

#### `math` module

See [`openzeppelin_utils::math`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#math).

#### `serde` module

See [`openzeppelin_utils::serde`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#serde).

### `cryptography`

```cairo hljs
use openzeppelin_utils::cryptography;
```

Module containing utilities related to cryptography.

Members

Inner modules

- [`nonces`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#cryptography-nonces)

- [`snip12`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#cryptography-snip12)


#### Inner modules

#### `nonces` module

See [`openzeppelin_utils::cryptography::nonces::NoncesComponent`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#NoncesComponent).

#### `snip12` module

See [`openzeppelin_utils::cryptography::snip12`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#snip12).

### `deployments`

```cairo hljs
use openzeppelin_utils::deployments;
```

Module containing utility functions for calculating contract addresses through [deploy\_syscall](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#deploy) and the [Universal Deployer Contract](https://docs.openzeppelin.com/contracts-cairo/0.20.0/udc) (UDC).

Members

Structs

- [`DeployerInfo(caller_address, udc_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-DeployerInfo)


Functions

- [`calculate_contract_address_from_deploy_syscall(salt, class_hash, constructor_calldata, deployer_address)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-calculate_contract_address_from_deploy_syscall)

- [`compute_hash_on_elements(data)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-compute_hash_on_elements)

- [`calculate_contract_address_from_udc(salt, class_hash, constructor_calldata, deployer_info)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-calculate_contract_address_from_udc)


#### Structs

#### `DeployerInfo(caller_address: ContractAddress, udc_address: ContractAddress)` struct

Struct containing arguments necessary in [utils::calculate\_contract\_address\_from\_udc](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-calculate_contract_address_from_udc) for origin-dependent deployment calculations.

#### Functions

#### `calculate_contract_address_from_deploy_syscall(salt: felt252, class_hash: ClassHash, constructor_calldata: Span<felt252>, deployer_address: ContractAddress) → ContractAddress` function

Returns the contract address when passing the given arguments to [deploy\_syscall](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#deploy).

#### `compute_hash_on_elements(data: Span<felt252>) → felt252` function

Creates a Pedersen hash chain with the elements of `data` and returns the finalized hash.

#### `calculate_contract_address_from_udc(salt: felt252, class_hash: ClassHash, constructor_calldata: Span<felt252>, deployer_info: Option<DeployerInfo>) → ContractAddress` function

Returns the calculated contract address for UDC deployments.

Origin-independent deployments (deployed from zero) should pass `Option::None` as `deployer_info`.

Origin-dependent deployments hash `salt` with `caller_address` (member of [DeployerInfo](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#deployments-DeployerInfo)) and pass the hashed salt to the inner [deploy\_syscall](https://docs.starknet.io/documentation/architecture_and_concepts/Smart_Contracts/system-calls-cairo1/#deploy) as the `contract_address_salt` argument.

### `math`

```cairo hljs
use openzeppelin_utils::math;
```

Module containing math utilities.

Members

Functions

- [`average(a, b)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#math-average)


#### Functions

#### `average(a: T, b: T) → T` function

Returns the average of two values. The result is rounded down.

|     |     |
| --- | --- |
|  | `T` is a generic value matching different numeric implementations. |

### `serde`

```cairo hljs
use openzeppelin_utils::serde;
```

Module containing utilities related to serialization and deserialization of Cairo data structures.

Members

Traits

- [`SerializedAppend`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#serde-SerializedAppend)


#### Traits

#### `SerializedAppend` trait

Importing this trait allows the ability to append a serialized representation of a Cairo data structure already
implementing the `Serde` trait to a `felt252` buffer.

Usage example:

```cairo hljs
use openzeppelin_utils::serde::SerializedAppend;
use starknet::ContractAddress;

fn to_calldata(recipient: ContractAddress, amount: u256) -> Array<felt252> {
    let mut calldata = array![];
    calldata.append_serde(recipient);
    calldata.append_serde(amount);
    calldata
}
```

Note that the `append_serde` method is automatically available for arrays of felts, and it accepts any data structure
that implements the `Serde` trait.

## Cryptography

### `NoncesComponent`

```cairo hljs
use openzeppelin_utils::cryptography::nonces::NoncesComponent;
```

This component provides a simple mechanism for handling incremental
nonces for a set of addresses. It is commonly used to prevent replay attacks
when contracts accept signatures as input.

Embeddable Implementations

NoncesImpl

- [`nonces(self, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#NoncesComponent-nonces)


Internal Implementations

InternalImpl

- [`use_nonce(self, owner)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#NoncesComponent-use_nonce)

- [`use_checked_nonce(self, owner, nonce)`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#NoncesComponent-use_checked_nonce)


#### Embeddable functions

#### `nonces(self: @ContractState, owner: ContractAddress) → felt252` external

Returns the next unused nonce for an `owner`.

#### Internal functions

#### `use_nonce(ref self: ComponentState, owner: ContractAddress) → felt252` internal

Consumes a nonce, returns the current value, and increments nonce.

For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be
decremented or reset. This guarantees that the nonce never overflows.

#### `use_checked_nonce(ref self: ComponentState, owner: ContractAddress, nonce: felt252) → felt252` internal

Same as `use_nonce` but checking that `nonce` is the next valid one for `owner`.

### `snip12`

```cairo hljs
use openzeppelin_utils::snip12;
```

Supports on-chain generation of message hashes compliant with [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md).

|     |     |
| --- | --- |
|  | For a full walkthrough on how to use this module, see the<br>[SNIP12 and Typed Messages](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/snip12) guide. |

[← API Reference](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/upgrades)

[Test Utilities →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/testing)Account - OpenZeppelin Docs

# Account

This directory includes contracts to build accounts for ERC-4337. These include:

- [`AccountCore`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore): An ERC-4337 smart account implementation that includes the core logic to process user operations.

- [`Account`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#Account): An extension of `AccountCore` that implements the recommended features for ERC-4337 smart accounts.

- {AccountSignerERC7702}: An account implementation with low-level signature validation performed by an EOA.

- [`ERC7821`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#ERC7821): Minimal batch executor implementation contracts. Useful to enable easy batch execution for smart contracts.


## Core

### `AccountCore`

```solidity hljs
import "@openzeppelin/community-contracts/account/AccountCore.sol";
```

A simple ERC4337 account implementation. This base implementation only includes the minimal logic to process
user operations.

Developers must implement the [`AccountCore._signableUserOpHash`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-_signableUserOpHash-struct-PackedUserOperation-bytes32-) and [`AbstractSigner._rawSignatureValidation`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner-_rawSignatureValidation-bytes32-bytes-)
functions to define the account’s validation logic.

|     |     |
| --- | --- |
|  | This core account doesn’t include any mechanism for performing arbitrary external calls. This is an essential<br>feature that all Account should have. We leave it up to the developers to implement the mechanism of their choice.<br>Common choices include ERC-6900, ERC-7579 and ERC-7821 (among others). |

|     |     |
| --- | --- |
|  | Implementing a mechanism to validate signatures is a security-sensitive operation as it may allow an<br>attacker to bypass the account’s security measures. Check out [`SignerECDSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA), [`SignerP256`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256), or [`SignerRSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerRSA) for<br>digital signature validation implementations. |

Modifiers

- `onlyEntryPointOrSelf()`

- `onlyEntryPoint()`


Functions

- `entryPoint()`

- `getNonce()`

- `getNonce(key)`

- `validateUserOp(userOp, userOpHash, missingAccountFunds)`

- `_validateUserOp(userOp, userOpHash)`

- `_signableUserOpHash(userOp, userOpHash)`

- `_payPrefund(missingAccountFunds)`

- `_checkEntryPoint()`

- `_checkEntryPointOrSelf()`

- `receive()`


AbstractSigner

- `_rawSignatureValidation(hash, signature)`


Errors

- `AccountUnauthorized(sender)`


#### `onlyEntryPointOrSelf()` modifier

Revert if the caller is not the entry point or the account itself.

#### `onlyEntryPoint()` modifier

Revert if the caller is not the entry point.

#### `entryPoint() → contract IEntryPoint` public

Canonical entry point for the account that forwards and validates user operations.

#### `getNonce() → uint256` public

Return the account nonce for the canonical sequence.

#### `getNonce(uint192 key) → uint256` public

Return the account nonce for a given sequence (key).

#### `validateUserOp(struct PackedUserOperation userOp, bytes32 userOpHash, uint256 missingAccountFunds) → uint256` public

Validates a user operation.

- MUST validate the caller is a trusted EntryPoint

- MUST validate that the signature is a valid signature of the userOpHash, and SHOULD
return SIG\_VALIDATION\_FAILED (and not revert) on signature mismatch. Any other error MUST revert.

- MUST pay the entryPoint (caller) at least the “missingAccountFunds” (which might
be zero, in case the current account’s deposit is high enough)


Returns an encoded packed validation data that is composed of the following elements:

- `authorizer` ( `address`): 0 for success, 1 for failure, otherwise the address of an authorizer contract

- `validUntil` ( `uint48`): The UserOp is valid only up to this time. Zero for “infinite”.

- `validAfter` ( `uint48`): The UserOp is valid only after this time.


#### `_validateUserOp(struct PackedUserOperation userOp, bytes32 userOpHash) → uint256` internal

Returns the validationData for a given user operation. By default, this checks the signature of the
signable hash (produced by [`_signableUserOpHash`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-_signableUserOpHash-struct-PackedUserOperation-bytes32-)) using the abstract signer ({\_rawSignatureValidation}).

|     |     |
| --- | --- |
|  | The userOpHash is assumed to be correct. Calling this function with a userOpHash that does not match the<br>userOp will result in undefined behavior. |

#### `_signableUserOpHash(struct PackedUserOperation userOp, bytes32 userOpHash) → bytes32` internal

Virtual function that returns the signable hash for a user operations. Some implementation may return
`userOpHash` while other may prefer a signer-friendly value such as an EIP-712 hash describing the `userOp`
details.

#### `_payPrefund(uint256 missingAccountFunds)` internal

Sends the missing funds for executing the user operation to the [`entryPoint`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-entryPoint--).
The `missingAccountFunds` must be defined by the entrypoint when calling [`validateUserOp`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-validateUserOp-struct-PackedUserOperation-bytes32-uint256-).

#### `_checkEntryPoint()` internal

Ensures the caller is the [`entryPoint`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-entryPoint--).

#### `_checkEntryPointOrSelf()` internal

Ensures the caller is the [`entryPoint`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-entryPoint--) or the account itself.

#### `receive()` external

Receive Ether.

#### `AccountUnauthorized(address sender)` error

Unauthorized call to the account.

### `Account`

```solidity hljs
import "@openzeppelin/community-contracts/account/Account.sol";
```

Extension of [`AccountCore`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore) with recommended feature that most account abstraction implementation will want:

- {ERC721Holder} and {ERC1155Holder} to accept ERC-712 and ERC-1155 token transfers transfers.

- [`ERC7739`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739) for ERC-1271 signature support with ERC-7739 replay protection

- [`ERC7821`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#ERC7821) for performing external calls in batches.


|     |     |
| --- | --- |
|  | Use [`ERC7821`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#ERC7821) to enable external calls in batches. |

|     |     |
| --- | --- |
|  | To use this contract, the {ERC7739-\_rawSignatureValidation} function must be<br>implemented using a specific signature verification algorithm. See [`SignerECDSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA), [`SignerP256`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256) or [`SignerRSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerRSA). |

Functions

- `_signableUserOpHash(userOp, )`


ERC7739

- `isValidSignature(hash, signature)`


ERC1155Holder

- `supportsInterface(interfaceId)`

- `onERC1155Received(, , , , )`

- `onERC1155BatchReceived(, , , , )`


ERC721Holder

- `onERC721Received(, , , )`


EIP712

- `_domainSeparatorV4()`

- `_hashTypedDataV4(structHash)`

- `eip712Domain()`

- `_EIP712Name()`

- `_EIP712Version()`


AccountCore

- `entryPoint()`

- `getNonce()`

- `getNonce(key)`

- `validateUserOp(userOp, userOpHash, missingAccountFunds)`

- `_validateUserOp(userOp, userOpHash)`

- `_payPrefund(missingAccountFunds)`

- `_checkEntryPoint()`

- `_checkEntryPointOrSelf()`

- `receive()`


AbstractSigner

- `_rawSignatureValidation(hash, signature)`


Events

IERC5267

- `EIP712DomainChanged()`


Errors

AccountCore

- `AccountUnauthorized(sender)`


Internal Variables

- `bytes32 constant _PACKED_USER_OPERATION`


#### `_signableUserOpHash(struct PackedUserOperation userOp, bytes32) → bytes32` internal

Specialization of [`AccountCore._signableUserOpHash`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-_signableUserOpHash-struct-PackedUserOperation-bytes32-) that returns a typehash following EIP-712 typed data
hashing for readability. This assumes the underlying signature scheme implements `signTypedData`, which will be
the case when combined with [`SignerECDSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA) or [`SignerERC7702`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerERC7702).

#### `bytes32 _PACKED_USER_OPERATION` internal constant

## Extensions

### `ERC7821`

```solidity hljs
import "@openzeppelin/community-contracts/account/extensions/ERC7821.sol";
```

Minimal batch executor following ERC-7821. Only supports basic mode (no optional "opData").

Functions

- `execute(mode, executionData)`

- `supportsExecutionMode(mode)`

- `_erc7821AuthorizedExecutor(caller, , )`


Errors

- `UnsupportedExecutionMode()`


#### `execute(bytes32 mode, bytes executionData)` public

Executes the calls in `executionData` with no optional `opData` support.

|     |     |
| --- | --- |
|  | Access to this function is controlled by [`_erc7821AuthorizedExecutor`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#ERC7821-_erc7821AuthorizedExecutor-address-bytes32-bytes-). Changing access permissions, for<br>example to approve calls by the ERC-4337 entrypoint, should be implement by overriding it. |

Reverts and bubbles up error if any call fails.

#### `supportsExecutionMode(bytes32 mode) → bool result` public

This function is provided for frontends to detect support.
Only returns true for:
\- `bytes32(0x01000000000000000000…​)`: does not support optional `opData`.
\- `bytes32(0x01000000000078210001…​)`: supports optional `opData`.

#### `_erc7821AuthorizedExecutor(address caller, bytes32, bytes) → bool` internal

Access control mechanism for the [`execute`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#ERC7821-execute-bytes32-bytes-) function.
By default, only the contract itself is allowed to execute.

Override this function to implement custom access control, for example to allow the
ERC-4337 entrypoint to execute.

```solidity hljs
function _erc7821AuthorizedExecutor(
  address caller,
  bytes32 mode,
  bytes calldata executionData
) internal view virtual override returns (bool) {
  return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);
}
```

#### `UnsupportedExecutionMode()` error

[← Access](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access)

[Proxy →](https://docs.openzeppelin.com/community-contracts/0.0.1/api/proxy)Access - OpenZeppelin Docs

# Access

|     |     |
| --- | --- |
|  | This document is better viewed at [https://docs.openzeppelin.com/community-contracts/proxy](https://docs.openzeppelin.com/community-contracts/proxy) |

This directory contains utility contracts to restrict access control in smart contracts. These include:

- [`AccessManagerLight`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight): A simpler version of an AccessManager that uses `bytes8` roles to allow function calls identified by their 4-bytes selector.


## AccessManager

### `AccessManagerLight`

```solidity hljs
import "@openzeppelin/community-contracts/access/manager/AccessManagerLight.sol";
```

Light version of an AccessManager contract that defines `bytes8` roles
that are stored as requirements (see [`getRequirements`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-getRequirements-address-bytes4-)) for each function.

Each requirement is a bitmask of roles that are allowed to call a function
identified by its `bytes4` selector. Users have their permissioned stored
as a bitmask of roles they belong to.

The admin role is a special role that has access to all functions and can
manage the roles of other users.

Modifiers

- `onlyRole(requirement)`


Functions

- `constructor(admin)`

- `canCall(caller, target, selector)`

- `getGroups(user)`

- `getGroupAdmins(group)`

- `getRequirements(target, selector)`

- `addGroup(user, group)`

- `remGroup(user, group)`

- `_addGroup(user, group)`

- `_remGroup(user, group)`

- `setGroupAdmins(group, admins)`

- `_setGroupAdmins(group, admins)`

- `setRequirements(target, selectors, groups)`

- `_setRequirements(target, selector, groups)`

- `ADMIN_ROLE()`

- `PUBLIC_ROLE()`

- `ADMIN_MASK()`

- `PUBLIC_MASK()`


Events

- `GroupAdded(user, group)`

- `GroupRemoved(user, group)`

- `GroupAdmins(group, admins)`

- `RequirementsSet(target, selector, groups)`


Errors

- `MissingPermissions(user, permissions, requirement)`


#### `onlyRole(Masks.Mask requirement)` modifier

Throws if the specified requirement is not met by the caller’s permissions (see [`getGroups`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-getGroups-address-)).

#### `constructor(address admin)` public

Initializes the contract with the `admin` as the first member of the admin group.

#### `canCall(address caller, address target, bytes4 selector) → bool` public

Returns whether the `caller` has the required permissions to call the `target` with the `selector`.

#### `getGroups(address user) → Masks.Mask` public

Returns the groups that the `user` belongs to.

#### `getGroupAdmins(uint8 group) → Masks.Mask` public

Returns the admins of the `group`.

#### `getRequirements(address target, bytes4 selector) → Masks.Mask` public

Returns the requirements for the `target` and `selector`.

#### `addGroup(address user, uint8 group)` public

Adds the `user` to the `group`. Emits [`GroupAdded`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-GroupAdded-address-uint8-) event.

#### `remGroup(address user, uint8 group)` public

Removes the `user` from the `group`. Emits [`GroupRemoved`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-GroupRemoved-address-uint8-) event.

#### `_addGroup(address user, uint8 group)` internal

Internal version of [`addGroup`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-addGroup-address-uint8-) without access control.

#### `_remGroup(address user, uint8 group)` internal

Internal version of [`remGroup`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-remGroup-address-uint8-) without access control.

#### `setGroupAdmins(uint8 group, uint8[] admins)` public

Sets the `admins` of the `group`. Emits [`GroupAdmins`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-GroupAdmins-uint8-Masks-Mask-) event.

#### `_setGroupAdmins(uint8 group, Masks.Mask admins)` internal

Internal version of [`_setGroupAdmins`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-_setGroupAdmins-uint8-Masks-Mask-) without access control.

#### `setRequirements(address target, bytes4[] selectors, uint8[] groups)` public

Sets the `groups` requirements for the `selectors` of the `target`.

#### `_setRequirements(address target, bytes4 selector, Masks.Mask groups)` internal

Internal version of [`_setRequirements`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access#AccessManagerLight-_setRequirements-address-bytes4-Masks-Mask-) without access control.

#### `ADMIN_ROLE() → uint8` public

#### `PUBLIC_ROLE() → uint8` public

#### `ADMIN_MASK() → Masks.Mask` public

#### `PUBLIC_MASK() → Masks.Mask` public

#### `GroupAdded(address indexed user, uint8 indexed group)` event

#### `GroupRemoved(address indexed user, uint8 indexed group)` event

#### `GroupAdmins(uint8 indexed group, Masks.Mask admins)` event

#### `RequirementsSet(address indexed target, bytes4 indexed selector, Masks.Mask groups)` event

#### `MissingPermissions(address user, Masks.Mask permissions, Masks.Mask requirement)` error

[← Utilities](https://docs.openzeppelin.com/community-contracts/0.0.1/utilities)

[Account →](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account)Timelock Controller - OpenZeppelin Docs

# Timelock Controller

The Timelock Controller provides a means of enforcing time delays on the execution of transactions. This is considered good practice regarding governance systems because it allows users the opportunity to exit the system if they disagree with a decision before it is executed.

|     |     |
| --- | --- |
|  | The Timelock contract itself executes transactions, not the user. The Timelock should, therefore, hold associated funds, ownership, and access control roles. |

## Operation lifecycle

The state of an operation is represented by the `OperationState` enum and can be retrieved
by calling the `get_operation_state` function with the operation’s identifier.

The identifier of an operation is a `felt252` value, computed as the Pedersen hash of the
operation’s call or calls, its predecessor, and salt. It can be computed by invoking the
implementing contract’s `hash_operation` function for single-call operations or
`hash_operation_batch` for multi-call operations. Submitting an operation with identical calls,
predecessor, and the same salt value a second time will fail, as operation identifiers must be
unique. To resolve this, use a different salt value to generate a unique identifier.

Timelocked operations follow a specific lifecycle:

`Unset` → `Waiting` → `Ready` → `Done`

- `Unset`: the operation has not been scheduled or has been canceled.

- `Waiting`: the operation has been scheduled and is pending the scheduled delay.

- `Ready`: the timer has expired, and the operation is eligible for execution.

- `Done`: the operation has been executed.


## Timelock flow

### Schedule

When a proposer calls [schedule](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-schedule), the `OperationState` moves from `Unset` to `Waiting`.
This starts a timer that must be greater than or equal to the minimum delay.
The timer expires at a timestamp accessible through [get\_timestamp](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_timestamp).
Once the timer expires, the `OperationState` automatically moves to the `Ready` state.
At this point, it can be executed.

### Execute

By calling [execute](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-execute), an executor triggers the operation’s underlying transactions and moves it to the `Done` state. If the operation has a predecessor, the predecessor’s operation must be in the `Done` state for this transaction to succeed.

### Cancel

The [cancel](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-cancel) function allows cancellers to cancel any pending operations.
This resets the operation to the `Unset` state.
It is therefore possible for a proposer to re-schedule an operation that has been cancelled.
In this case, the timer restarts when the operation is re-scheduled.

### Roles

[TimelockControllerComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent) leverages an [AccessControlComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) setup that we need to understand in order to set up roles.

- `PROPOSER_ROLE` \- in charge of queueing operations.

- `CANCELLER_ROLE` \- may cancel scheduled operations.
During initialization, accounts granted with `PROPOSER_ROLE` will also be granted `CANCELLER_ROLE`.
Therefore, the initial proposers may also cancel operations after they are scheduled.

- `EXECUTOR_ROLE` \- in charge of executing already available operations.

- `DEFAULT_ADMIN_ROLE` \- can grant and revoke the three previous roles.


|     |     |
| --- | --- |
|  | The `DEFAULT_ADMIN_ROLE` is a sensitive role that will be granted automatically to the timelock itself and optionally to a second account.<br>The latter case may be required to ease a contract’s initial configuration; however, this role should promptly be renounced. |

Furthermore, the timelock component supports the concept of open roles for the `EXECUTOR_ROLE`.
This allows anyone to execute an operation once it’s in the `Ready` OperationState.
To enable the `EXECUTOR_ROLE` to be open, grant the zero address with the `EXECUTOR_ROLE`.

|     |     |
| --- | --- |
|  | Be very careful with enabling open roles as _anyone_ can call the function. |

### Minimum delay

The minimum delay of the timelock acts as a buffer from when a proposer schedules an operation to the earliest point at which an executor may execute that operation.
The idea is for users, should they disagree with a scheduled proposal, to have options such as exiting the system or making their case for cancellers to cancel the operation.

After initialization, the only way to change the timelock’s minimum delay is to schedule it and execute it with the same flow as any other operation.

The minimum delay of a contract is accessible through [get\_min\_delay](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#ITimelock-get_min_delay).

### Usage

Integrating the timelock into a contract requires integrating [TimelockControllerComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/governance#TimelockControllerComponent) as well as [SRC5Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/introspection#SRC5Component) and [AccessControlComponent](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/access#AccessControlComponent) as dependencies.
The contract’s constructor should initialize the timelock which consists of setting the:

- Proposers and executors.

- Minimum delay between scheduling and executing an operation.

- Optional admin if additional configuration is required.


|     |     |
| --- | --- |
|  | The optional admin should renounce their role once configuration is complete. |

Here’s an example of a simple timelock contract:

```cairo hljs
#[starknet::contract]
mod TimelockControllerContract {
    use openzeppelin_access::accesscontrol::AccessControlComponent;
    use openzeppelin_governance::timelock::TimelockControllerComponent;
    use openzeppelin_introspection::src5::SRC5Component;
    use starknet::ContractAddress;

    component!(path: AccessControlComponent, storage: access_control, event: AccessControlEvent);
    component!(path: TimelockControllerComponent, storage: timelock, event: TimelockEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    // Timelock Mixin
    #[abi(embed_v0)]
    impl TimelockMixinImpl =
        TimelockControllerComponent::TimelockMixinImpl<ContractState>;
    impl TimelockInternalImpl = TimelockControllerComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        access_control: AccessControlComponent::Storage,
        #[substorage(v0)]
        timelock: TimelockControllerComponent::Storage,
        #[substorage(v0)]
        src5: SRC5Component::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        AccessControlEvent: AccessControlComponent::Event,
        #[flat]
        TimelockEvent: TimelockControllerComponent::Event,
        #[flat]
        SRC5Event: SRC5Component::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        min_delay: u64,
        proposers: Span<ContractAddress>,
        executors: Span<ContractAddress>,
        admin: ContractAddress
    ) {
        self.timelock.initializer(min_delay, proposers, executors, admin);
    }
}
```

### Interface

This is the full interface of the TimelockMixinImpl implementation:

```cairo hljs
#[starknet::interface]
pub trait TimelockABI<TState> {
    // ITimelock
    fn is_operation(self: @TState, id: felt252) -> bool;
    fn is_operation_pending(self: @TState, id: felt252) -> bool;
    fn is_operation_ready(self: @TState, id: felt252) -> bool;
    fn is_operation_done(self: @TState, id: felt252) -> bool;
    fn get_timestamp(self: @TState, id: felt252) -> u64;
    fn get_operation_state(self: @TState, id: felt252) -> OperationState;
    fn get_min_delay(self: @TState) -> u64;
    fn hash_operation(self: @TState, call: Call, predecessor: felt252, salt: felt252) -> felt252;
    fn hash_operation_batch(
        self: @TState, calls: Span<Call>, predecessor: felt252, salt: felt252
    ) -> felt252;
    fn schedule(ref self: TState, call: Call, predecessor: felt252, salt: felt252, delay: u64);
    fn schedule_batch(
        ref self: TState, calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64
    );
    fn cancel(ref self: TState, id: felt252);
    fn execute(ref self: TState, call: Call, predecessor: felt252, salt: felt252);
    fn execute_batch(ref self: TState, calls: Span<Call>, predecessor: felt252, salt: felt252);
    fn update_delay(ref self: TState, new_delay: u64);

    // ISRC5
    fn supports_interface(self: @TState, interface_id: felt252) -> bool;

    // IAccessControl
    fn has_role(self: @TState, role: felt252, account: ContractAddress) -> bool;
    fn get_role_admin(self: @TState, role: felt252) -> felt252;
    fn grant_role(ref self: TState, role: felt252, account: ContractAddress);
    fn revoke_role(ref self: TState, role: felt252, account: ContractAddress);
    fn renounce_role(ref self: TState, role: felt252, account: ContractAddress);

    // IAccessControlCamel
    fn hasRole(self: @TState, role: felt252, account: ContractAddress) -> bool;
    fn getRoleAdmin(self: @TState, role: felt252) -> felt252;
    fn grantRole(ref self: TState, role: felt252, account: ContractAddress);
    fn revokeRole(ref self: TState, role: felt252, account: ContractAddress);
    fn renounceRole(ref self: TState, role: felt252, account: ContractAddress);
}
```

[← Multisig](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/multisig)

[Votes →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/governance/votes)Frequently Asked Questions - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Frequently Asked Questions

## Can I Specify Which Solidity Compiler Version to Use in the OpenZeppelin CLI?

Yes. You can run `openzeppelin compile --solc-version 0.5.14` to compile your contracts with a specific Solidity compiler version e.g. `0.5.14`. This choice will be saved to `.openzeppelin/project.json` for future runs.

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": "my-project",
  "version": "1.0.0",
  "compiler": {
    "manager": "openzeppelin",
    "solcVersion": "0.5.14"
  }
}
```

If you are using `truffle` for compiling your project, you can specify which compiler version to use in your `truffle.js` or `truffle-config.js` file, as you do normally in a truffle 5+ project:

```javascript hljs
// truffle.js
module.exports = {
  compilers: {
     solc: {
       version: "0.5.14"
     }
  }
}
```

## Can I Change Solidity Compiler Versions When Upgrading?

Yes. The Solidity team guarantess that the compiler will [preserve the storage layout accross versions](https://twitter.com/ethchris/status/1073692785176444928).

## Why Am I Getting the Error "Cannot Call Fallback Function From the Proxy Admin"?

This is due to the [Transparent Proxy Pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes). You shouldn’t get this error when using the OpenZeppelin CLI, since it relies on the `ProxyAdmin` contract for managing your proxies.

However, if you are using OpenZeppelin Upgrades programmatically you could potentially run into such error. The solution is to always interact with your proxies from an account that is not the admin of the proxy, unless you want to specifically call the functions of the proxy itself.

## How Can I Create an Upgradeable Instance From Solidity Code?

You can create upgradeable instances from Solidity code by using your project’s [`App`](https://docs.openzeppelin.com/cli/2.7/contracts-architecture#app.sol) contract, and then calling its `create` function from Solidity. Note that to be able to do this, your project needs to be published, that is, it needs to have the OpenZeppelin [Contracts Architecture](https://docs.openzeppelin.com/cli/2.7/contracts-architecture) enabled.

To see an example of how this is done, please refer to the example project [`creating-instances-from-solidity`](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/master/examples/creating-instances-from-solidity).

## Opt-In Usage Data Reporting

In order to better guide the development of our tools, we ask users if they would like to opt in to contributing anonymized logs of their usage of the OpenZeppelin CLI. In this document we explain exactly what data we collect and how we anonymize it. Please visit [https://openzeppelin.com/privacy](https://openzeppelin.com/privacy) for further information about our privacy practices.

When you run the OpenZeppelin CLI for the first time we ask if you would like to opt in to contributing usage logs. This is a setting that will be stored globally and will apply to future projects. You can opt-out at any time, and you can also choose to opt out on a per-project basis.

If you choose to you opt in, we generate a random user identifier and a random 32-byte salt.

Every `openzeppelin` subcommand you run will be first anonymized by hashing each argument together with the random salt. Note that this only applies to user-specific arguments (e.g. the name of a contract, or an address), and not to the flags themselves (e.g. `--force`). The anonymized commands will be logged on our servers together with the random user identifier, the network that they were run in, as well as general information about the environment (platform, architecture, and versions of node, the CLI, and web3 dependencies).

[← Using With Truffle](https://docs.openzeppelin.com/cli/2.7/truffle)

[Commands →](https://docs.openzeppelin.com/cli/2.7/commands)Access Control - OpenZeppelin Docs

# Access Control

Access control—that is, "who is allowed to do this thing"—is incredibly important in the world of smart contracts. The access control of your contract may govern who can mint tokens, vote on proposals, freeze transfers, and many other things. It is therefore **critical** to understand how you implement it, lest someone else [steals your whole system](https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7).

## Ownership and `Ownable`

The most common and basic form of access control is the concept of _ownership_: there’s an account that is the `owner` of a contract and can do administrative tasks on it. This approach is perfectly reasonable for contracts that have a single administrative user.

OpenZeppelin Contracts for Stylus provides [`Ownable`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/access/ownable/struct.Ownable.html) for implementing ownership in your contracts.

```rust hljs
use openzeppelin_stylus::access::ownable::Ownable;

sol_storage! {
    #[entrypoint]
    struct OwnableExample {
        #[borrow]
        Ownable ownable;
    }
}

#[public]
#[inherit(Ownable)]
impl MyContract {
    fn normal_thing(&self) {
        // anyone can call this normal_thing()
    }

    pub fn special_thing(
        &mut self,
    ) -> Result<(), Vec<u8>> {
        self.ownable.only_owner()?;

        // only the owner can call special_thing()!

        Ok(())
    }
}
```

At deployment, the [`owner`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/access/ownable/struct.Ownable.html#method.owner) of an `Ownable` contract is set to the provided `initial_owner` parameter.

Ownable also lets you:

- [`transfer_ownership`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/access/ownable/struct.Ownable.html#method.transfer_ownership) from the owner account to a new one, and

- [`renounce_ownership`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/access/ownable/struct.Ownable.html#method.renounce_ownership) for the owner to relinquish this administrative privilege, a common pattern after an initial stage with centralized administration is over.


|     |     |
| --- | --- |
|  | Removing the owner altogether will mean that administrative tasks that are protected by `only_owner` will no longer be callable! |

Note that **a contract can also be the owner of another one**! This opens the door to using, for example, a [Gnosis Safe](https://gnosis-safe.io/), an [Aragon DAO](https://aragon.org/), or a totally custom contract that _you_ create.

In this way, you can use _composability_ to add additional layers of access control complexity to your contracts. Instead of having a single regular Ethereum account (Externally Owned Account, or EOA) as the owner, you could use a 2-of-3 multisig run by your project leads, for example. Prominent projects in the space, such as [MakerDAO](https://makerdao.com/), use systems similar to this one.

## Role-Based Access Control

While the simplicity of _ownership_ can be useful for simple systems or quick prototyping, different levels of authorization are often needed. You may want for an account to have permission to ban users from a system, but not create new tokens. [_Role-Based Access Control (RBAC)_](https://en.wikipedia.org/wiki/Role-based_access_control) offers flexibility in this regard.

In essence, we will be defining multiple _roles_, each allowed to perform different sets of actions. An account may have, for example, 'moderator', 'minter' or 'admin' roles, which you will then check for instead of simply using `only_owner`. This check can be enforced through the `only_role` modifier. Separately, you will be able to define rules for how accounts can be granted a role, have it revoked, and more.

Most software uses access control systems that are role-based: some users are regular users, some may be supervisors or managers, and a few will often have administrative privileges.

### Using `AccessControl`

OpenZeppelin Contracts provides [`AccessControl`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/access/control/struct.AccessControl.html) for implementing role-based access control. Its usage is straightforward: for each role that you want to define,
you will create a new _role identifier_ that is used to grant, revoke, and check if an account has that role.

Here’s a simple example of using `AccessControl` in an [ERC-20 token](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20) to define a 'minter' role, which allows accounts that have it create new tokens. Note that the example is unassuming of the way you construct your contract.

```rust hljs
sol_storage! {
    #[entrypoint]
    struct Example {
        #[borrow]
        Erc20 erc20;
        #[borrow]
        AccessControl access;
    }
}

// `keccak256("MINTER_ROLE")`
pub const MINTER_ROLE: [u8; 32] = [\
    159, 45, 240, 254, 210, 199, 118, 72, 222, 88, 96, 164, 204, 80, 140, 208,\
    129, 140, 133, 184, 184, 161, 171, 76, 238, 239, 141, 152, 28, 137, 86,\
    166,\
];

#[public]
#[inherit(Erc20, AccessControl)]
impl Example {
    pub const MINTER_ROLE: [u8; 32] = MINTER_ROLE;

    pub fn mint(&mut self, to: Address, amount: U256) -> Result<(), Vec<u8>> {
        if self.access.has_role(Example::MINTER_ROLE, msg::sender()) {
            return Err(Vec::new());
        }
        self.erc20._mint(to, amount)?;
        Ok(())
    }
}
```

|     |     |
| --- | --- |
|  | Make sure you fully understand how [`AccessControl`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/access/control/struct.AccessControl.html) works before using it on your system, or copy-pasting the examples from this guide. |

While clear and explicit, this isn’t anything we wouldn’t have been able to achieve with `Ownable`. Indeed, where `AccessControl` shines is in scenarios where granular permissions are required, which can be implemented by defining _multiple_ roles.

Let’s augment our ERC-20 token example by also defining a 'burner' role, which lets accounts destroy tokens, and by using the `only_role` modifier:

```rust hljs
sol_storage! {
    #[entrypoint]
    struct Example {
        #[borrow]
        Erc20 erc20;
        #[borrow]
        AccessControl access;
    }
}

// `keccak256("MINTER_ROLE")`
pub const MINTER_ROLE: [u8; 32] = [\
    159, 45, 240, 254, 210, 199, 118, 72, 222, 88, 96, 164, 204, 80, 140, 208,\
    129, 140, 133, 184, 184, 161, 171, 76, 238, 239, 141, 152, 28, 137, 86,\
    166,\
];

// `keccak256("BURNER_ROLE")`
pub const BURNER_ROLE: [u8; 32] = [\
    60, 17, 209, 108, 186, 255, 208, 29, 246, 156, 225, 196, 4, 246, 52, 14,\
    224, 87, 73, 143, 95, 0, 36, 97, 144, 234, 84, 34, 5, 118, 168, 72,\
];

#[public]
#[inherit(Erc20, AccessControl)]
impl Example {
    pub const MINTER_ROLE: [u8; 32] = MINTER_ROLE;
    pub const BURNER_ROLE: [u8; 32] = BURNER_ROLE;

    pub fn mint(&mut self, to: Address, amount: U256) -> Result<(), Vec<u8>> {
        self.access.only_role(Example::MINTER_ROLE.into())?;
        self.erc20._mint(to, amount)?;
        Ok(())
    }

    pub fn mint(&mut self, from: Address, amount: U256) -> Result<(), Vec<u8>> {
        self.access.only_role(Example::BURNER_ROLE.into())?;
        self.erc20._burn(to, amount)?;
        Ok(())
    }
}
```

So clean! By splitting concerns this way, more granular levels of permission may be implemented than were possible with the simpler _ownership_ approach to access control. Limiting what each component of a system is able to do is known as the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), and is a good security practice. Note that each account may still have more than one role, if so desired.

### Granting and Revoking Roles

The ERC-20 token example above uses `_grant_role`, an `internal` function that is useful when programmatically assigning roles (such as during construction). But what if we later want to grant the 'minter' role to additional accounts?

By default, **accounts with a role cannot grant it or revoke it from other accounts**: all having a role does is making the `has_role` check pass. To grant and revoke roles dynamically, you will need help from the _role’s admin_.

Every role has an associated admin role, which grants permission to call the `grant_role` and `revoke_role` functions. A role can be granted or revoked by using these if the calling account has the corresponding admin role. Multiple roles may have the same admin role to make management easier. A role’s admin can even be the same role itself, which would cause accounts with that role to be able to also grant and revoke it.

This mechanism can be used to create complex permissioning structures resembling organizational charts, but it also provides an easy way to manage simpler applications. `AccessControl` includes a special role, called `DEFAULT_ADMIN_ROLE`, which acts as the **default admin role for all roles**. An account with this role will be able to manage any other role, unless `_set_role_admin` is used to select a new admin role.

Note that, by default, no accounts are granted the 'minter' or 'burner' roles. We assume you use a constructor to set the default admin role as the role of the deployer, or have a different mechanism where you make sure that you are able to grant roles. However, because those roles' admin role is the default admin role, and _that_ role was granted to `msg::sender()`, that same account can call `grant_role` to give minting or burning permission, and `revoke_role` to remove it.

Dynamic role allocation is often a desirable property, for example in systems where trust in a participant may vary over time. It can also be used to support use cases such as [KYC](https://en.wikipedia.org/wiki/Know_your_customer), where the list of role-bearers may not be known up-front, or may be prohibitively expensive to include in a single transaction.

[← ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721)

[Cryptography →](https://docs.openzeppelin.com/contracts-stylus/0.1.0/crypto)ERC-20 Permit - OpenZeppelin Docs

# ERC-20 Permit

Adds the permit method, which can be used to change an account’s ERC20 allowance (see [`IErc20::allowance`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/trait.IErc20.html#tymethod.allowance)) by presenting a message signed by the account. By not relying on [`IErc20::approve`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/trait.IErc20.html#tymethod.approve), the token holder account doesn’t need to send a transaction, and thus is not required to hold Ether at all.

## Usage

In order to have [`ERC-20 Permit`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/extensions/permit/index.html) token, you need to use only this contract without [ERC-20](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20) as follows:

```rust hljs
use openzeppelin_stylus::{
    token::erc20::extensions::Erc20Permit, utils::cryptography::eip712::IEip712,
};

sol_storage! {
    #[entrypoint]
    struct Erc20PermitExample {
        #[borrow]
        Erc20Permit<Eip712> erc20_permit;
    }

    struct Eip712 {}
}

// Define `NAME` and `VERSION` for your contract.
impl IEip712 for Eip712 {
    const NAME: &'static str = "ERC-20 Permit Example";
    const VERSION: &'static str = "1";
}

#[public]
#[inherit(Erc20Permit<Eip712>)]
impl Erc20PermitExample {
    // ...
}
```ERC-20 - OpenZeppelin Docs

# ERC-20

An ERC-20 token contract keeps track of [_fungible_ tokens](https://docs.openzeppelin.com/contracts-stylus/0.1.0/tokens#different-kinds-of-tokens): any token is exactly equal to any other token; no token has a special right or behavior associated with them.
This makes ERC-20 tokens useful for things like a **medium of exchange currency**, **voting rights**, **staking**, and more.

OpenZeppelin Contracts provide many ERC20-related contracts for Arbitrum Stylus.
On the [`API reference`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/struct.Erc20.html) you’ll find detailed information on their properties and usage.

## Constructing an ERC-20 Token Contract

Using Contracts, we can easily create our own ERC-20 token contract, which will be used to track _Gold_ (GLD), an internal currency in a hypothetical game.

Here’s what our GLD token might look like.

```rust hljs
sol_storage! {
    #[entrypoint]
    struct GLDToken {
        #[borrow]
        Erc20 erc20;
        #[borrow]
        Erc20Metadata metadata;
    }
}

#[public]
#[inherit(Erc20, Erc20Metadata)]
impl GLDToken {}
```

Our contracts are often used via stylus-sdk [inheritance](https://docs.arbitrum.io/stylus/reference/rust-sdk-guide#inheritance-inherit-and-borrow), and here we’re reusing [`ERC20`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/struct.Erc20.html) for both the basic standard implementation and with optional extensions.

## A Note on `decimals`

Often, you’ll want to be able to divide your tokens into arbitrary amounts: say, if you own `5 GLD`, you may want to send `1.5 GLD` to a friend, and keep `3.5 GLD` to yourself.
Unfortunately, Solidity and the EVM do not support this behavior: only integer (whole) numbers can be used, which poses an issue.
You may send `1` or `2` tokens, but not `1.5`.

To work around this, ERC20 provides a [`decimals`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc20/extensions/metadata/trait.IErc20Metadata.html#tymethod.decimals) field, which is used to specify how many decimal places a token has.
To be able to transfer `1.5 GLD`, `decimals` must be at least `1`, since that number has a single decimal place.

How can this be achieved?
It’s actually very simple: a token contract can use larger integer values, so that a balance of `50` will represent `5 GLD`, a transfer of `15` will correspond to `1.5 GLD` being sent, and so on.

It is important to understand that `decimals` is _only used for display purposes_.
All arithmetic inside the contract is still performed on integers, and it is the different user interfaces (wallets, exchanges, etc.) that must adjust the displayed values according to `decimals`.
The total token supply and balance of each account are not specified in `GLD`: you need to divide by `10 ** decimals` to get the actual `GLD` amount.

You’ll probably want to use a `decimals` value of `18`, just like Ether and most ERC-20 token contracts in use, unless you have an exceptional reason not to.
When minting tokens or transferring them around, you will be actually sending the number `GLD * (10 ** decimals)`.

|     |     |
| --- | --- |
|  | By default, `ERC20` uses a value of `18` for `decimals`. |

To use a different value, you will need to override the `decimals()` function in your contract. For example, to use `16` decimals, you would do:

```rust hljs
pub fn decimals(&self) -> u8 {
    16
}
```

So if you want to send `5` tokens using a token contract with `18` decimals, the method to call will actually be:

```rust hljs
token.transfer(recipient, 5 * uint!(10_U256).pow(uint!(18_U256)));
```

## Extensions

Additionally, there are multiple custom extensions, including:

- [ERC-20 Burnable](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20-burnable): destruction of own tokens.

- [ERC-20 Capped](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20-capped): enforcement of a cap to the total supply when minting tokens.

- [ERC-20 Metadata](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20-metadata): the extended ERC20 interface including the name, symbol, and decimals functions.

- [ERC-20 Pausable](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20-pausable): ability to pause token transfers.

- [ERC-20 Permit](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc20-permit): gasless approval of tokens (standardized as [`EIP-2612`](https://eips.ethereum.org/EIPS/eip-2612)).


[← Tokens](https://docs.openzeppelin.com/contracts-stylus/0.1.0/tokens)

[ERC-721 →](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721)Contracts for Stylus - OpenZeppelin Docs

# Contracts for Stylus

**A library for secure smart contract development** written in Rust for [Stylus](https://docs.arbitrum.io/stylus/stylus-gentle-introduction).

|     |     |
| --- | --- |
|  | You can track our roadmap in our [Github Project](https://github.com/orgs/OpenZeppelin/projects/35). |

[Deploying Contracts →](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy)Utilities - OpenZeppelin Docs

# Utilities

Multiple libraries and general purpose utilities included in the community version of OpenZeppelin Contracts. These are only a set of utility contracts. For the full list, check out the [API Reference](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils).

## Cryptography

### Validating Typed Data Signatures

_For prior knowledge on how to validate signatures on-chain, check out the [OpenZeppelin Contracts documentation](https://docs.openzeppelin.com/contracts/5.x/utilities#checking_signatures_on_chain)_

As opposed to validating plain-text messages, it is possible to let your users sign structured data (i.e. typed values) in a way that is still readable on their wallets. This is possible by implementing [`EIP712`](https://docs.openzeppelin.com/contracts/api/utils#EIP712), a standard way to encode structured data into a typed data hash.

To start validating signed typed structures, just validate the [typed data hash](https://docs.openzeppelin.com/contracts/api/utils#EIP712-_hashTypedDataV4-bytes32-):

```solidity hljs
// contracts/MyContractDomain.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";

/// @dev Unsafe contract to demonstrate the use of EIP712 and ECDSA.
abstract contract MyContractDomain is EIP712 {
    function validateSignature(
        address mailTo,
        string memory mailContents,
        bytes memory signature
    ) internal view returns (address) {
        bytes32 digest = _hashTypedDataV4(
            keccak256(abi.encode(keccak256("Mail(address to,string contents)"), mailTo, keccak256(bytes(mailContents))))
        );
        return ECDSA.recover(digest, signature);
    }
}
```

As part of the message, EIP-712 requires implementers to include a domain separator, which is a hash that includes the current smart contract address and the chain id where it’s deployed. This way, the smart contract can be sure that the structured message was signed for its specific domain, avoiding replayability of signatures in smart contracts.

#### Validating Nested EIP-712 Signatures

Accounts (i.e. Smart Contract Wallets or Smart Accounts) are particularly likely to be controlled by multiple signers. As such, it’s important to make sure that signatures are:

1. Only valid for the intended domain and account.

2. Validated in a way that’s readable for the end signer.


On one hand, making sure that the Account signature is only valid for an specific smart contract (i.e. an application) is difficult since it requires to validate a signature whose domain is the application but also the Account itself. For these reason, the community developed [ERC-7739](https://eips.ethereum.org/EIPS/eip-7739); a defensive rehashing mechanism that binds a signature to a single domain using a nested EIP-712 approach (i.e. an EIP-712 typed structure wrapping another).

In case your smart contract validates signatures, using [`ERC7739Signer`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739Signer) will implement the [`IERC1271`](https://docs.openzeppelin.com/contracts/api/interfaces#IERC1271) interface for validating smart contract signatures following the approach suggested by ERC-7739:

```solidity hljs
// contracts/ERC7739ECDSA.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";

import {ERC7739} from "@openzeppelin/community-contracts/utils/cryptography/ERC7739.sol";

contract ERC7739ECDSA is ERC7739 {
    address private immutable _signer;

    constructor(address signerAddr) EIP712("ERC7739ECDSA", "1") {
        _signer = signerAddr;
    }

    function _rawSignatureValidation(
        bytes32 hash,
        bytes calldata signature
    ) internal view virtual override returns (bool) {
        (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
        return _signer == recovered && err == ECDSA.RecoverError.NoError;
    }
}
```

[← Account Abstraction](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction)

[Access →](https://docs.openzeppelin.com/community-contracts/0.0.1/api/access)SNIP12 and Typed Messages - OpenZeppelin Docs

# SNIP12 and Typed Messages

Similar to [EIP712](https://eips.ethereum.org/EIPS/eip-712), [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) is a standard for secure off-chain signature verification on Starknet.
It provides a way to hash and sign generic typed structs rather than just strings. When building decentralized
applications, usually you might need to sign a message with complex data. The purpose of signature verification
is then to ensure that the received message was indeed signed by the expected signer, and it hasn’t been tampered with.

OpenZeppelin Contracts for Cairo provides a set of utilities to make the implementation of this standard
as easy as possible, and in this guide we will walk you through the process of generating the hashes of typed messages
using these utilities for on-chain signature verification. For that, let’s build an example with a custom [ERC20](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20) contract
adding an extra `transfer_with_signature` method.

|     |     |
| --- | --- |
|  | This is an educational example, and it is not intended to be used in production environments. |

## CustomERC20

Let’s start with a basic ERC20 contract leveraging the [ERC20Component](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/erc20#ERC20Component), and let’s add the new function.
Note that some declarations are omitted for brevity. The full example will be available at the end of the guide.

```cairo hljs
#[starknet::contract]
mod CustomERC20 {
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);

    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    (...)

    #[constructor]
    fn constructor(
        ref self: ContractState,
        initial_supply: u256,
        recipient: ContractAddress
    ) {
        self.erc20.initializer("MyToken", "MTK");
        self.erc20.mint(recipient, initial_supply);
    }

    #[external(v0)]
    fn transfer_with_signature(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256,
        nonce: felt252,
        expiry: u64,
        signature: Array<felt252>
    ) {
        (...)
    }
}
```

The `transfer_with_signature` function will allow a user to transfer tokens to another account by providing a signature.
The signature will be generated off-chain, and it will be used to verify the message on-chain. Note that the message
we need to verify is a struct with the following fields:

- `recipient`: The address of the recipient.

- `amount`: The amount of tokens to transfer.

- `nonce`: A unique number to prevent replay attacks.

- `expiry`: The timestamp when the signature expires.


Note that generating the hash of this message on-chain is a requirement to verify the signature, because if we accept
the message as a parameter, it could be easily tampered with.

## Generating the Typed Message Hash

To generate the hash of the message, we need to follow these steps:

### 1\. Define the message struct.

In this particular example, the message struct looks like this:

```cairo hljs
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}
```

### 2\. Get the message type hash.

This is the `starknet_keccak(encode_type(message))` as defined in the [SNIP](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md#how-to-work-with-each-type).

In this case it can be computed as follows:

```cairo hljs
let message_type_hash = selector!(
    "\"Message\"(\"recipient\":\"ContractAddress\",\"amount\":\"u256\",\"nonce\":\"felt\",\"expiry\":\"u64\")\"u256\"(\"low\":\"felt\",\"high\":\"felt\")"
);
```

which is the same as:

```cairo hljs
let message_type_hash = 0x120ae1bdaf7c1e48349da94bb8dad27351ca115d6605ce345aee02d68d99ec1;
```

|     |     |
| --- | --- |
|  | In practice it’s better to compute the type hash off-chain and hardcode it in the contract, since it is a constant value. |

### 3\. Implement the `StructHash` trait for the struct.

You can import the trait from: `openzeppelin_utils::snip12::StructHash`. And this implementation
is nothing more than the encoding of the message as defined in the [SNIP](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md#how-to-work-with-each-type).

```cairo hljs
use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;
use openzeppelin_utils::snip12::StructHash;
use starknet::ContractAddress;

const MESSAGE_TYPE_HASH: felt252 =
    0x120ae1bdaf7c1e48349da94bb8dad27351ca115d6605ce345aee02d68d99ec1;

#[derive(Copy, Drop, Hash)]
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}

impl StructHashImpl of StructHash<Message> {
    fn hash_struct(self: @Message) -> felt252 {
        let hash_state = PoseidonTrait::new();
        hash_state.update_with(MESSAGE_TYPE_HASH).update_with(*self).finalize()
    }
}
```

### 4\. Implement the `SNIP12Metadata` trait.

This implementation determines the values of the domain separator. Only the `name` and `version` fields are required
because the `chain_id` is obtained on-chain, and the `revision` is hardcoded to `1`.

```cairo hljs
use openzeppelin_utils::snip12::SNIP12Metadata;

impl SNIP12MetadataImpl of SNIP12Metadata {
    fn name() -> felt252 { 'DAPP_NAME' }
    fn version() -> felt252 { 'v1' }
}
```

In the above example, no storage reads are required which avoids unnecessary extra gas costs, but in
some cases we may need to read from storage to get the domain separator values. This can be accomplished even when
the trait is not bounded to the ContractState, like this:

```cairo hljs
use openzeppelin_utils::snip12::SNIP12Metadata;

impl SNIP12MetadataImpl of SNIP12Metadata {
    fn name() -> felt252 {
        let state = unsafe_new_contract_state();

        // Some logic to get the name from storage
        state.erc20.name().at(0).unwrap().into()
    }

    fn version() -> felt252 { 'v1' }
}
```

### 5\. Generate the hash.

The final step is to use the `OffchainMessageHashImpl` implementation to generate the hash of the message
using the `get_message_hash` function. The implementation is already available as a utility.

```cairo hljs
use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;
use openzeppelin_utils::snip12::{SNIP12Metadata, StructHash, OffchainMessageHash};
use starknet::ContractAddress;

const MESSAGE_TYPE_HASH: felt252 =
    0x120ae1bdaf7c1e48349da94bb8dad27351ca115d6605ce345aee02d68d99ec1;

#[derive(Copy, Drop, Hash)]
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}

impl StructHashImpl of StructHash<Message> {
    fn hash_struct(self: @Message) -> felt252 {
        let hash_state = PoseidonTrait::new();
        hash_state.update_with(MESSAGE_TYPE_HASH).update_with(*self).finalize()
    }
}

impl SNIP12MetadataImpl of SNIP12Metadata {
    fn name() -> felt252 {
        'DAPP_NAME'
    }
    fn version() -> felt252 {
        'v1'
    }
}

fn get_hash(
    account: ContractAddress, recipient: ContractAddress, amount: u256, nonce: felt252, expiry: u64
) -> felt252 {
    let message = Message { recipient, amount, nonce, expiry };
    message.get_message_hash(account)
}
```

|     |     |
| --- | --- |
|  | The expected parameter for the `get_message_hash` function is the address of account that signed the message. |

## Full Implementation

Finally, the full implementation of the `CustomERC20` contract looks like this:

|     |     |
| --- | --- |
|  | We are using the [`ISRC6Dispatcher`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/account#ISRC6) to verify the signature,<br>and the [`NoncesComponent`](https://docs.openzeppelin.com/contracts-cairo/0.20.0/api/utilities#NoncesComponent) to handle nonces to prevent replay attacks. |

```cairo hljs
use core::hash::{HashStateExTrait, HashStateTrait};
use core::poseidon::PoseidonTrait;
use openzeppelin_utils::snip12::{SNIP12Metadata, StructHash, OffchainMessageHash};
use starknet::ContractAddress;

const MESSAGE_TYPE_HASH: felt252 =
    0x120ae1bdaf7c1e48349da94bb8dad27351ca115d6605ce345aee02d68d99ec1;

#[derive(Copy, Drop, Hash)]
struct Message {
    recipient: ContractAddress,
    amount: u256,
    nonce: felt252,
    expiry: u64
}

impl StructHashImpl of StructHash<Message> {
    fn hash_struct(self: @Message) -> felt252 {
        let hash_state = PoseidonTrait::new();
        hash_state.update_with(MESSAGE_TYPE_HASH).update_with(*self).finalize()
    }
}

#[starknet::contract]
mod CustomERC20 {
    use openzeppelin_account::interface::{ISRC6Dispatcher, ISRC6DispatcherTrait};
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_utils::cryptography::nonces::NoncesComponent;
    use starknet::ContractAddress;

    use super::{Message, OffchainMessageHash, SNIP12Metadata};

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);

    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;
    impl NoncesInternalImpl = NoncesComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        nonces: NoncesComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_supply: u256, recipient: ContractAddress) {
        self.erc20.initializer("MyToken", "MTK");
        self.erc20.mint(recipient, initial_supply);
    }

    /// Required for hash computation.
    impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'CustomERC20'
        }
        fn version() -> felt252 {
            'v1'
        }
    }

    #[external(v0)]
    fn transfer_with_signature(
        ref self: ContractState,
        recipient: ContractAddress,
        amount: u256,
        nonce: felt252,
        expiry: u64,
        signature: Array<felt252>
    ) {
        assert(starknet::get_block_timestamp() <= expiry, 'Expired signature');
        let owner = starknet::get_caller_address();

        // Check and increase nonce
        self.nonces.use_checked_nonce(owner, nonce);

        // Build hash for calling `is_valid_signature`
        let message = Message { recipient, amount, nonce, expiry };
        let hash = message.get_message_hash(owner);

        let is_valid_signature_felt = ISRC6Dispatcher { contract_address: owner }
            .is_valid_signature(hash, signature);

        // Check either 'VALID' or true for backwards compatibility
        let is_valid_signature = is_valid_signature_felt == starknet::VALIDATED
            || is_valid_signature_felt == 1;
        assert(is_valid_signature, 'Invalid signature');

        // Transfer tokens
        self.erc20._transfer(owner, recipient, amount);
    }
}
```

[← Counterfactual Deployments](https://docs.openzeppelin.com/contracts-cairo/0.20.0/guides/deployment)

[Access →](https://docs.openzeppelin.com/contracts-cairo/0.20.0/access)Frequently Asked Questions - OpenZeppelin Docs

OpenZeppelin SDK is not being actively developed. We recommend using [Upgrades Plugins](https://docs.openzeppelin.com/upgrades-plugins) instead. For more information, see [Building for interoperability: why we’re focusing on Upgrades Plugins](https://forum.openzeppelin.com/t/building-for-interoperability-why-we-re-focusing-on-upgrades-plugins/4088).


# Frequently Asked Questions

## Can I Specify Which Solidity Compiler Version to Use in the OpenZeppelin CLI?

Yes. You can run `openzeppelin compile --solc-version 0.5.14` to compile your contracts with a specific Solidity compiler version e.g. `0.5.14`. This choice will be saved to `.openzeppelin/project.json` for future runs.

```json hljs
// .openzeppelin/project.json
{
  "manifestVersion": "2.2",
  "name": "my-project",
  "version": "1.0.0",
  "compiler": {
    "manager": "openzeppelin",
    "solcVersion": "0.5.14"
  }
}
```

If you are using `truffle` for compiling your project, you can specify which compiler version to use in your `truffle.js` or `truffle-config.js` file, as you do normally in a truffle 5+ project:

```javascript hljs
// truffle.js
module.exports = {
  compilers: {
     solc: {
       version: "0.5.14"
     }
  }
}
```

## Can I Change Solidity Compiler Versions When Upgrading?

Yes. The Solidity team guarantess that the compiler will [preserve the storage layout accross versions](https://twitter.com/ethchris/status/1073692785176444928).

## Why Am I Getting the Error "Cannot Call Fallback Function From the Proxy Admin"?

This is due to the [Transparent Proxy Pattern](https://docs.openzeppelin.com/upgrades/2.8/proxies#transparent-proxies-and-function-clashes). You shouldn’t get this error when using the OpenZeppelin CLI, since it relies on the `ProxyAdmin` contract for managing your proxies.

However, if you are using OpenZeppelin Upgrades programmatically you could potentially run into such error. The solution is to always interact with your proxies from an account that is not the admin of the proxy, unless you want to specifically call the functions of the proxy itself.

## How Can I Create an Upgradeable Instance From Solidity Code?

You can create upgradeable instances from Solidity code by using your project’s [`App`](https://docs.openzeppelin.com/cli/2.6/contracts-architecture#app.sol) contract, and then calling its `create` function from Solidity. Note that to be able to do this, your project needs to be published, that is, it needs to have the OpenZeppelin [Contracts Architecture](https://docs.openzeppelin.com/cli/2.6/faq#architecture.adoc) enabled.

To see an example of how this is done, please refer to the example project [`creating-instances-from-solidity`](https://github.com/OpenZeppelin/openzeppelin-sdk/tree/master/examples/creating-instances-from-solidity).

## Opt-In Usage Data Reporting

In order to better guide the development of our tools, we ask users if they would like to opt in to contributing anonymized logs of their usage of the OpenZeppelin CLI. In this document we explain exactly what data we collect and how we anonymize it. Please visit [https://openzeppelin.com/privacy](https://openzeppelin.com/privacy) for further information about our privacy practices.

When you run the OpenZeppelin CLI for the first time we ask if you would like to opt in to contributing usage logs. This is a setting that will be stored globally and will apply to future projects. You can opt-out at any time, and you can also choose to opt out on a per-project basis.

If you choose to you opt in, we generate a random user identifier and a random 32-byte salt.

Every `openzeppelin` subcommand you run will be first anonymized by hashing each argument together with the random salt. Note that this only applies to user-specific arguments (e.g. the name of a contract, or an address), and not to the flags themselves (e.g. `--force`). The anonymized commands will be logged on our servers together with the random user identifier, the network that they were run in, as well as general information about the environment (platform, architecture, and versions of node, the CLI, and web3 dependencies).

[← Using With Truffle](https://docs.openzeppelin.com/cli/2.6/truffle)

[Commands →](https://docs.openzeppelin.com/cli/2.6/commands)ERC-721 Uri Storage - OpenZeppelin Docs

# ERC-721 Uri Storage

The OpenZeppelin [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) URI Storage extension is needed to manage and store URIs for individual tokens. This extension allows each token to have its own unique URI,
which can point to metadata about the token, such as images, descriptions, and other attributes.
This is particularly useful for non-fungible tokens (NFTs) where each token is unique and may have different metadata.

## Usage

In order to make an [ERC-721](https://docs.openzeppelin.com/contracts-stylus/0.1.0/erc721) token with [URI Storage](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/uri_storage/index.html) flavour,
your token should also use [`ERC-721 Metadata`](https://docs.rs/openzeppelin-stylus/0.1.0/openzeppelin_stylus/token/erc721/extensions/metadata/index.html) extension to provide additional metadata for each token.
You need to create a specified contract as follows:

```rust hljs
use openzeppelin_stylus::token::erc721::{
    extensions::{
        Erc721Metadata, Erc721UriStorage,
        IErc721Burnable, IErc721Metadata,
    },
    Erc721, IErc721,
};

sol_storage! {
    #[entrypoint]
    struct Erc721MetadataExample {
        #[borrow]
        Erc721 erc721;
        #[borrow]
        Erc721Metadata metadata;
        Erc721UriStorage uri_storage;
    }
}

#[public]
#[inherit(Erc721, Erc721Metadata, Erc721UriStorage)]
impl Erc721MetadataExample {
    pub fn mint(&mut self, to: Address, token_id: U256) -> Result<(), Vec<u8>> {
        Ok(self.erc721._mint(to, token_id)?)
    }

    pub fn burn(&mut self, token_id: U256) -> Result<(), Vec<u8>> {
        Ok(self.erc721.burn(token_id)?)
    }

    #[selector(name = "tokenURI")]
    pub fn token_uri(&self, token_id: U256) -> Result<String, Vec<u8>> {
        Ok(self.uri_storage.token_uri(
            token_id,
            &self.erc721,
            &self.metadata,
        )?)
    }

    #[selector(name = "setTokenURI")]
    pub fn set_token_uri(&mut self, token_id: U256, token_uri: String) {
        self.uri_storage._set_token_uri(token_id, token_uri)
    }
}
```

Additionally, you need to ensure proper initialization during [contract deployment](https://docs.openzeppelin.com/contracts-stylus/0.1.0/deploy).
Make sure to include the following code in your Solidity Constructor:

```solidity hljs
contract Erc721Example {
    // ...

    string private _name;
    string private _symbol;
    string private _baseUri;

    mapping(uint256 => string) _tokenUris;

    constructor(string memory name_, string memory symbol_, string memory baseUri_) {
        // ...
        _name = name_;
        _symbol = symbol_;
        _baseUri = baseUri_;
        // ...
    }
}
```Account Abstraction - OpenZeppelin Docs

# Account Abstraction

Unlike Externally Owned Accounts (EOAs), smart contracts may contain arbitrary verification logic based on authentication mechanisms different to Ethereum’s native [ECDSA](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ECDSA) and have execution advantages such as batching or gas sponsorship. To leverage these properties of smart contracts, the community has widely adopted [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337), a standard to process user operations through an alternative mempool.

The library provides multiple contracts for Account Abstraction following this standard as it enables more flexible and user-friendly interactions with applications. Account Abstraction use cases include wallets in novel contexts (e.g. embedded wallets), more granular configuration of accounts, and recovery mechanisms.

These capabilities can be supercharged with a modularity approach following standards such as [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) or [ERC-6909](https://eips.ethereum.org/EIPS/eip-6909).

## Smart Accounts

OpenZeppelin provides an abstract [`AccountCore`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore) contract that implements the basic logic to handle user operations in compliance with ERC-4337. Developers who want to build their own account can use this to bootstrap.

User operations are validated using an [`AbstractSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner), which requires to implement the internal [`_rawSignatureValidation`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner-_rawSignatureValidation) function. This is the lowest-level signature validation layer and is used to wrap other validation methods like the Account’s [`validateUserOp`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-validateUserOp-struct-PackedUserOperation-bytes32-uint256-).

A more opinionated version is the [`Account`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#Account) contract, which also inherits from:

- [ERC7739Signer](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#ERC7739Signer): An implementation of the [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) interface for smart contract signatures. This layer adds a defensive rehashing mechanism that prevents signatures for this account to be replayed in another account controlled by the same signer. See [ERC-7739 signatures](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction#erc7739_signatures).

- [ERC721Holder](https://docs.openzeppelin.com/contracts/api/token/erc721#ERC721Holder), [ERC1155Holder](https://docs.openzeppelin.com/contracts/api/token/erc1155#ERC1155Holder): Allows the account to hold [ERC-721](https://eips.ethereum.org/EIPS/eip-721) and [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155) tokens.


|     |     |
| --- | --- |
|  | The Account doesn’t include an execution mechanism. Using [`ERC7821`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#ERC7821) is a recommended solution with the minimal logic to batch multiple calls in a single execution. This is useful to execute multiple calls within a single user operation (e.g. approve and transfer). |

```solidity hljs
// contracts/MyAccount.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {Account} from "@openzeppelin/community-contracts/account/Account.sol"; // or AccountCore
import {ERC7821} from "@openzeppelin/community-contracts/account/extensions/ERC7821.sol";

contract MyAccount is Account, ERC7821, Initializable {
    /**
     * NOTE: EIP-712 domain is set at construction because each account clone
     * will recalculate its domain separator based on their own address.
     */
    constructor() EIP712("MyAccount", "1") {}

    /// @dev Signature validation logic.
    function _rawSignatureValidation(
        bytes32 hash,
        bytes calldata signature
    ) internal view virtual override returns (bool) {
        // Custom validation logic
    }

    function initializeSigner() public initializer {
        // Most accounts will require some form of signer initialization logic
    }

    /// @dev Allows the entry point as an authorized executor.
    function _erc7821AuthorizedExecutor(
        address caller,
        bytes32 mode,
        bytes calldata executionData
    ) internal view virtual override returns (bool) {
        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);
    }
}
```

### Setting up an account

To setup an account, you can either bring your own validation logic and start with [`Account`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#Account) or [`AccountCore`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore), or import any of the predefined signers that can be used to control an account.

### Selecting a signer

The library includes specializations of the `AbstractSigner` contract that use custom digital signature verification algorithms. These are [`SignerECDSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerECDSA), [`SignerP256`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256) and [`SignerRSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerRSA).

Since smart accounts are deployed by a factory, the best practice is to create [minimal clones](https://docs.openzeppelin.com/contracts/5.x/api/proxy#minimal_clones) of initializable contracts. These signer implementations provide an initializable design by default so that the factory can interact with the account to set it up after deployment in a single transaction.

|     |     |
| --- | --- |
|  | Leaving an account uninitialized may leave it unusable since no public key was associated with it. |

```solidity hljs
// contracts/MyAccount.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import {Account} from "@openzeppelin/community-contracts/account/Account.sol";
import {ERC7821} from "@openzeppelin/community-contracts/account/extensions/ERC7821.sol";
import {SignerECDSA} from "@openzeppelin/community-contracts/utils/cryptography/SignerECDSA.sol";

contract MyAccountECDSA is Initializable, Account, SignerECDSA, ERC7821 {
    constructor() EIP712("MyAccountECDSA", "1") {}

    function initialize(address signerAddr) public initializer {
        _setSigner(signerAddr);
    }

    /// @dev Allows the entry point as an authorized executor.
    function _erc7821AuthorizedExecutor(
        address caller,
        bytes32 mode,
        bytes calldata executionData
    ) internal view virtual override returns (bool) {
        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);
    }
}
```

|     |     |
| --- | --- |
|  | [`Account`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#Account) initializes [`EIP712`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#EIP712) to generate a domain separator that prevents replayability in other accounts controlled by the same key. See [ERC-7739 signatures](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction#erc7739_signatures) |

Along with the regular EOA signature verification, the library also provides the [`SignerP256`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#SignerP256) for P256 signatures, a widely used _elliptic curve_ verification algorithm that’s present in mobile device security enclaves, FIDO keys, and corporate environments (i.e. public key infrastructures).

```solidity hljs
// contracts/MyAccount.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import {Account} from "@openzeppelin/community-contracts/account/Account.sol";
import {ERC7821} from "@openzeppelin/community-contracts/account/extensions/ERC7821.sol";
import {SignerP256} from "@openzeppelin/community-contracts/utils/cryptography/SignerP256.sol";

contract MyAccountP256 is Initializable, Account, SignerP256, ERC7821 {
    constructor() EIP712("MyAccountP256", "1") {}

    function initialize(bytes32 qx, bytes32 qy) public initializer {
        _setSigner(qx, qy);
    }

    /// @dev Allows the entry point as an authorized executor.
    function _erc7821AuthorizedExecutor(
        address caller,
        bytes32 mode,
        bytes calldata executionData
    ) internal view virtual override returns (bool) {
        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);
    }
}
```

Similarly, some government and corporate public key infrastructures use RSA for signature verification. For those cases, the [`AccountRSA`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountRSA) may be a good fit.

```solidity hljs
// contracts/MyAccount.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import {Account} from "@openzeppelin/community-contracts/account/Account.sol";
import {ERC7821} from "@openzeppelin/community-contracts/account/extensions/ERC7821.sol";
import {SignerRSA} from "@openzeppelin/community-contracts/utils/cryptography/SignerRSA.sol";

contract MyAccountRSA is Initializable, Account, SignerRSA, ERC7821 {
    constructor() EIP712("MyAccountRSA", "1") {}

    function initialize(bytes memory e, bytes memory n) public initializer {
        _setSigner(e, n);
    }

    /// @dev Allows the entry point as an authorized executor.
    function _erc7821AuthorizedExecutor(
        address caller,
        bytes32 mode,
        bytes calldata executionData
    ) internal view virtual override returns (bool) {
        return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);
    }
}
```

## Account Factory

The first time a user sends an user operation, the account will be created deterministically (i.e. its code and address can be predicted) using the the `initCode` field in the UserOperation. This field contains both the address of a smart contract (the factory) and the data required to call it and deploy the smart account.

For this purpose, developers can create an account factory using the [Clones library from OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/5.x/api/proxy#Clones). It exposes methods to calculate the address of an account before deployment.

```solidity hljs
// contracts/MyFactoryAccount.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";
import {MyAccountECDSA} from "./MyAccountECDSA.sol";

/**
 * @dev A factory contract to create ECDSA accounts on demand.
 */
contract MyFactoryAccount {
    using Clones for address;

    address private immutable _impl = address(new MyAccountECDSA());

    /// @dev Predict the address of the account
    function predictAddress(bytes32 salt) public view returns (address) {
        return _impl.predictDeterministicAddress(salt, address(this));
    }

    /// @dev Create clone accounts on demand
    function cloneAndInitialize(bytes32 salt, address signer) public returns (address) {
        return _cloneAndInitialize(salt, signer);
    }

    /// @dev Create clone accounts on demand and return the address. Uses `signer` to initialize the clone.
    function _cloneAndInitialize(bytes32 salt, address signer) internal returns (address) {
        // Scope salt to the signer to avoid front-running the salt with a different signer
        bytes32 _signerSalt = keccak256(abi.encodePacked(salt, signer));

        address predicted = predictAddress(_signerSalt);
        if (predicted.code.length == 0) {
            _impl.cloneDeterministic(_signerSalt);
            MyAccountECDSA(payable(predicted)).initialize(signer);
        }
        return predicted;
    }
}
```

You’ve setup your own account and its corresponding factory. Both are ready to be used with ERC-4337 infrastructure. Customizing the factory to other validation mechanisms must be straightforward.

## Paymaster

In case you want to sponsor user operation for your users, the ERC-4337 defines a special type of contract called Paymaster, whose purpose is to pay the gas fees consumed by the user operation. Developers can bootstrap their own paymaster with [`PaymasterCore`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#PaymasterCore) and implement a signature-based paymaster authorization with [`PaymasterSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#PaymasterSigner) that they can combine with any [`AbstractSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#AbstractSigner) quite easily.

To enable operation sponsorship, users sign their user operation including a special field called `paymasterAndData` resulting from the concatenation of the paymaster they’re using and the calldata that’s going to be passed into [`validatePaymasterUserOp`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#PaymasterCore-validatePaymasterUserOp). This function will use the passed bytes buffer to determine whether it will pay for the user operation or not.

### Setting up a paymaster

To start your paymaster from scratch, the library provides [`PaymasterCore`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#PaymasterCore) with the basic logic you can extend to implement your own validation logic.

```solidity hljs
// contracts/MyPaymaster.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {PaymasterCore} from "@openzeppelin/community-contracts/account/paymaster/PaymasterCore.sol";
import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";

contract MyPaymaster is PaymasterCore, Ownable {
    constructor(address withdrawer) Ownable(withdrawer) {}

    /// @dev Paymaster user op validation logic
    function _validatePaymasterUserOp(
        PackedUserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 requiredPreFund
    ) internal override returns (bytes memory context, uint256 validationData) {
        // Custom validation logic
    }

    function _authorizeWithdraw() internal override onlyOwner {}
}
```

|     |     |
| --- | --- |
|  | Use [`ERC4337Utils`](https://docs.openzeppelin.com/contracts/5.x/api/account#ERC4337Utils) to access paymaster-related fields of the userOp (e.g. `paymasterData`, `paymasterVerificationGasLimit`) |

The library also includes the [`PaymasterSigner`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/utils#PaymasterSigner) that allows developers to setup a signature-based authorization paymaster. This is the easiest setup to start sponsoring user operations with an ECDSA signature (i.e. a regular ethereum signature).

```solidity hljs
// contracts/MyPaymasterECDSA.sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {PaymasterSigner, EIP712} from "@openzeppelin/community-contracts/account/paymaster/PaymasterSigner.sol";
import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";
import {SignerECDSA} from "@openzeppelin/community-contracts/utils/cryptography/SignerECDSA.sol";

contract MyPaymasterECDSA is PaymasterSigner, SignerECDSA, Ownable {
    constructor(address paymasterSignerAddr, address withdrawer) EIP712("MyPaymasterECDSA", "1") Ownable(withdrawer) {
        _setSigner(paymasterSignerAddr);
    }

    function _authorizeWithdraw() internal override onlyOwner {}
}
```

## ERC-4337 Overview

The ERC-4337 is a detailed specification of how to implement the necessary logic to handle operations without making changes to the protocol level (i.e. the rules of the blockchain itself). This specification defines the following components:

### UserOperation

A `UserOperation` is a higher-layer pseudo-transaction object that represents the intent of the account. This shares some similarities with regular EVM transactions like the concept of `gasFees` or `callData` but includes fields that enable new capabilities.

```solidity hljs
struct PackedUserOperation {
    address sender;
    uint256 nonce;
    bytes initCode; // concatenation of factory address and factoryData (or empty)
    bytes callData;
    bytes32 accountGasLimits; // concatenation of verificationGas (16 bytes) and callGas (16 bytes)
    uint256 preVerificationGas;
    bytes32 gasFees; // concatenation of maxPriorityFee (16 bytes) and maxFeePerGas (16 bytes)
    bytes paymasterAndData; // concatenation of paymaster fields (or empty)
    bytes signature;
}
```

### Entrypoint

Each `UserOperation` is executed through a contract known as the [`EntryPoint`](https://etherscan.io/address/0x0000000071727de22e5e9d8baf0edac6f37da032#code). This contract is a singleton deployed across multiple networks at the same address although other custom implementations may be used.

The Entrypoint contracts is considered a trusted entity by the account.

### Bundlers

The bundler is a piece of _offchain_ infrastructure that is in charge of processing an alternative mempool of user operations. Bundlers themselves call the Entrypoint contract’s `handleOps` function with an array of UserOperations that are executed and included in a block.

During the process, the bundler pays for the gas of executing the transaction and gets refunded during the execution phase of the Entrypoint contract.

### Account Contract

The Account Contract is a smart contract that implements the logic required to validate a `UserOperation` in the context of ERC-4337. Any smart contract account should conform with the `IAccount` interface to validate operations.

```solidity hljs
interface IAccount {
    function validateUserOp(PackedUserOperation calldata, bytes32, uint256) external returns (uint256 validationData);
}
```

Similarly, an Account should have a way to execute these operations by either handling arbitrary calldata on its `fallback` or implementing the `IAccountExecute` interface:

```solidity hljs
interface IAccountExecute {
    function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external;
}
```

|     |     |
| --- | --- |
|  | The `IAccountExecute` interface is optional. Developers might want to use [`AccountERC7821`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountERC7821) for a minimal batched execution interface or rely on ERC-7579, ERC-6909 or any other execution logic. |

To build your own account, see [Smart Accounts](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction#smart_accounts).

### Factory Contract

The smart contract accounts are created by a Factory contract defined by the Account developer. This factory receives arbitrary bytes as `initData` and returns an `address` where the logic of the account is deployed.

To build your own factory, see [Account Factory](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction#account_factory)

### Paymaster Contract

A Paymaster is an optional entity that can sponsor gas fees for Accounts, or allow them to pay for those fees in ERC-20 instead of native currency. This abstracts gas away of the user experience in the same way that computational costs of cloud servers are abstracted away from end-users.

To build your own paymaster, see [Paymaster](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction#paymaster)

## Further notes

### ERC-7739 Signatures

A common security practice to prevent user operation [replayability across smart contract accounts controlled by the same private key](https://mirror.xyz/curiousapple.eth/pFqAdW2LiJ-6S4sg_u1z08k4vK6BCJ33LcyXpnNb8yU) (i.e. multiple accounts for the same signer) is to link the signature to the `address` and `chainId` of the account. This can be done by asking the user to sign a hash that includes these values.

The problem with this approach is that the user might be prompted by the wallet provider to sign an [obfuscated message](https://x.com/howydev/status/1780353754333634738), which is a phishing vector that may lead to a user losing its assets.

To prevent this, developers may use [`ERC7739Signer`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#ERC7739Signer), a utility that implements [`IERC1271`](https://docs.openzeppelin.com/community-contracts/0.0.1/account-abstraction#api:interfaces.adoc#IERC1271) for smart contract signatures with a defensive rehashing mechanism based on a [nested EIP-712 approach](https://github.com/frangio/eip712-wrapper-for-eip1271) to wrap the signature request in a context where there’s clearer information for the end user.

### ERC-7562 Validation Rules

To process a bundle of `UserOperations`, bundlers call [`validateUserOp`](https://docs.openzeppelin.com/community-contracts/0.0.1/api/account#AccountCore-validateUserOp-struct-PackedUserOperation-bytes32-uint256-) on each operation sender to check whether the operation can be executed. However, the bundler has no guarantee that the state of the blockchain will remain the same after the validation phase. To overcome this problem, [ERC-7562](https://eips.ethereum.org/EIPS/eip-7562) proposes a set of limitations to EVM code so that bundlers (or node operators) are protected from unexpected state changes.

These rules outline the requirements for operations to be processed by the canonical mempool.

Accounts can access its own storage during the validation phase, they might easily violate ERC-7562 storage access rules in undirect ways. For example, most accounts access their public keys from storage when validating a signature, limiting the ability of having accounts that validate operations for other accounts (e.g. via ERC-1271)

|     |     |
| --- | --- |
|  | Although any Account that breaks such rules may still be processed by a private bundler, developers should keep in mind the centralization tradeoffs of relying on private infrastructure instead of _permissionless_ execution. |

[← Overview](https://docs.openzeppelin.com/community-contracts/0.0.1/)

[Utilities →](https://docs.openzeppelin.com/community-contracts/0.0.1/utilities)
